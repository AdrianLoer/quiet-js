((function(global) {
 if (typeof global.SIMD === "undefined") {
  global.SIMD = {};
 }
 if (typeof module !== "undefined") {
  module.exports = global.SIMD;
 }
 var SIMD = global.SIMD;
 var _f32x4 = new Float32Array(4);
 var _f64x2 = new Float64Array(_f32x4.buffer);
 var _i32x4 = new Int32Array(_f32x4.buffer);
 var _i16x8 = new Int16Array(_f32x4.buffer);
 var _i8x16 = new Int8Array(_f32x4.buffer);
 var _ui32x4 = new Uint32Array(_f32x4.buffer);
 var _ui16x8 = new Uint16Array(_f32x4.buffer);
 var _ui8x16 = new Uint8Array(_f32x4.buffer);
 function convertValue(buffer, value) {
  buffer[0] = value;
  return buffer[0];
 }
 function convertArray(buffer, array) {
  for (var i = 0; i < array.length; i++) array[i] = convertValue(buffer, array[i]);
  return array;
 }
 function isInt32(o) {
  return (o | 0) === o;
 }
 function isTypedArray(o) {
  return o instanceof Int8Array || o instanceof Uint8Array || o instanceof Uint8ClampedArray || o instanceof Int16Array || o instanceof Uint16Array || o instanceof Int32Array || o instanceof Uint32Array || o instanceof Float32Array || o instanceof Float64Array;
 }
 function minNum(x, y) {
  return x != x ? y : y != y ? x : Math.min(x, y);
 }
 function maxNum(x, y) {
  return x != x ? y : y != y ? x : Math.max(x, y);
 }
 function clamp(a, min, max) {
  if (a < min) return min;
  if (a > max) return max;
  return a;
 }
 function simdCheckLaneIndex(index, lanes) {
  if (!isInt32(index)) throw new TypeError("Lane index must be an int32");
  if (index < 0 || index >= lanes) throw new RangeError("Lane index must be in bounds");
 }
 var lanes = [];
 function simdCreate(type) {
  return type.fn.apply(type.fn, lanes);
 }
 function simdToString(type, a) {
  a = type.fn.check(a);
  var str = "SIMD." + type.name + "(";
  str += type.fn.extractLane(a, 0);
  for (var i = 1; i < type.lanes; i++) {
   str += ", " + type.fn.extractLane(a, i);
  }
  return str + ")";
 }
 function simdToLocaleString(type, a) {
  a = type.fn.check(a);
  var str = "SIMD." + type.name + "(";
  str += type.fn.extractLane(a, 0).toLocaleString();
  for (var i = 1; i < type.lanes; i++) {
   str += ", " + type.fn.extractLane(a, i).toLocaleString();
  }
  return str + ")";
 }
 function simdSplat(type, s) {
  for (var i = 0; i < type.lanes; i++) lanes[i] = s;
  return simdCreate(type);
 }
 function simdReplaceLane(type, a, i, s) {
  a = type.fn.check(a);
  simdCheckLaneIndex(i, type.lanes);
  for (var j = 0; j < type.lanes; j++) lanes[j] = type.fn.extractLane(a, j);
  lanes[i] = s;
  return simdCreate(type);
 }
 function simdFrom(toType, fromType, a) {
  a = fromType.fn.check(a);
  for (var i = 0; i < fromType.lanes; i++) {
   var v = fromType.fn.extractLane(a, i);
   if (toType.minVal !== undefined && (v < toType.minVal || v > toType.maxVal)) {
    throw new RangeError("Can't convert value");
   }
   lanes[i] = v;
  }
  return simdCreate(toType);
 }
 function simdFromBits(toType, fromType, a) {
  a = fromType.fn.check(a);
  var newValue = new toType.fn;
  newValue.s_ = new toType.view(a.s_.buffer);
  return newValue;
 }
 function simdSelect(type, selector, a, b) {
  selector = type.boolType.fn.check(selector);
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) {
   lanes[i] = type.boolType.fn.extractLane(selector, i) ? type.fn.extractLane(a, i) : type.fn.extractLane(b, i);
  }
  return simdCreate(type);
 }
 function simdSwizzle(type, a, indices) {
  a = type.fn.check(a);
  for (var i = 0; i < indices.length; i++) {
   simdCheckLaneIndex(indices[i], type.lanes);
   lanes[i] = type.fn.extractLane(a, indices[i]);
  }
  return simdCreate(type);
 }
 function simdShuffle(type, a, b, indices) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < indices.length; i++) {
   simdCheckLaneIndex(indices[i], 2 * type.lanes);
   lanes[i] = indices[i] < type.lanes ? type.fn.extractLane(a, indices[i]) : type.fn.extractLane(b, indices[i] - type.lanes);
  }
  return simdCreate(type);
 }
 function unaryNeg(a) {
  return -a;
 }
 function unaryBitwiseNot(a) {
  return ~a;
 }
 function unaryLogicalNot(a) {
  return !a;
 }
 function simdUnaryOp(type, op, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i));
  return simdCreate(type);
 }
 function binaryAnd(a, b) {
  return a & b;
 }
 function binaryOr(a, b) {
  return a | b;
 }
 function binaryXor(a, b) {
  return a ^ b;
 }
 function binaryAdd(a, b) {
  return a + b;
 }
 function binarySub(a, b) {
  return a - b;
 }
 function binaryMul(a, b) {
  return a * b;
 }
 function binaryDiv(a, b) {
  return a / b;
 }
 var binaryImul;
 if (typeof Math.imul !== "undefined") {
  binaryImul = Math.imul;
 } else {
  binaryImul = (function(a, b) {
   var ah = a >>> 16 & 65535;
   var al = a & 65535;
   var bh = b >>> 16 & 65535;
   var bl = b & 65535;
   return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  });
 }
 function simdBinaryOp(type, op, a, b) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i), type.fn.extractLane(b, i));
  return simdCreate(type);
 }
 function binaryEqual(a, b) {
  return a == b;
 }
 function binaryNotEqual(a, b) {
  return a != b;
 }
 function binaryLess(a, b) {
  return a < b;
 }
 function binaryLessEqual(a, b) {
  return a <= b;
 }
 function binaryGreater(a, b) {
  return a > b;
 }
 function binaryGreaterEqual(a, b) {
  return a >= b;
 }
 function simdRelationalOp(type, op, a, b) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i), type.fn.extractLane(b, i));
  return simdCreate(type.boolType);
 }
 function simdAnyTrue(type, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) if (type.fn.extractLane(a, i)) return true;
  return false;
 }
 function simdAllTrue(type, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) if (!type.fn.extractLane(a, i)) return false;
  return true;
 }
 function binaryShiftLeft(a, bits) {
  return a << bits;
 }
 function binaryShiftRightArithmetic(a, bits) {
  return a >> bits;
 }
 function binaryShiftRightLogical(a, bits) {
  return a >>> bits;
 }
 function simdShiftOp(type, op, a, bits) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i), bits);
  return simdCreate(type);
 }
 function simdLoad(type, tarray, index, count) {
  if (!isTypedArray(tarray)) throw new TypeError("The 1st argument must be a typed array.");
  if (!isInt32(index)) throw new TypeError("The 2nd argument must be an Int32.");
  var bpe = tarray.BYTES_PER_ELEMENT;
  var bytes = count * type.laneSize;
  if (index < 0 || index * bpe + bytes > tarray.byteLength) throw new RangeError("The value of index is invalid.");
  var newValue = type.fn();
  var dst = new Uint8Array(newValue.s_.buffer);
  var src = new Uint8Array(tarray.buffer, tarray.byteOffset + index * bpe, bytes);
  for (var i = 0; i < bytes; i++) {
   dst[i] = src[i];
  }
  for (var i = bytes; i < 16; ++i) {
   dst[i] = 0;
  }
  return newValue;
 }
 function simdStore(type, tarray, index, a, count) {
  if (!isTypedArray(tarray)) throw new TypeError("The 1st argument must be a typed array.");
  if (!isInt32(index)) throw new TypeError("The 2nd argument must be an Int32.");
  var bpe = tarray.BYTES_PER_ELEMENT;
  var bytes = count * type.laneSize;
  if (index < 0 || index * bpe + bytes > tarray.byteLength) throw new RangeError("The value of index is invalid.");
  a = type.fn.check(a);
  var src = new Uint8Array(a.s_.buffer);
  var dst = new Uint8Array(tarray.buffer, tarray.byteOffset + index * bpe, bytes);
  for (var i = 0; i < bytes; i++) {
   dst[i] = src[i];
  }
  return a;
 }
 if (typeof SIMD.Float32x4 === "undefined" || typeof SIMD.Float32x4.extractLane === "undefined") {
  SIMD.Float32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Float32x4)) {
    return new SIMD.Float32x4(s0, s1, s2, s3);
   }
   this.s_ = convertArray(_f32x4, new Float32Array([ s0, s1, s2, s3 ]));
  });
  SIMD.Float32x4.extractLane = (function(v, i) {
   v = SIMD.Float32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Float32x4.swizzle === "undefined") {
  SIMD.Float32x4.swizzle = (function(a, s0, s1, s2, s3) {
   return simdSwizzle(float32x4, a, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Float32x4.shuffle === "undefined") {
  SIMD.Float32x4.shuffle = (function(a, b, s0, s1, s2, s3) {
   return simdShuffle(float32x4, a, b, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Int32x4 === "undefined" || typeof SIMD.Int32x4.extractLane === "undefined") {
  SIMD.Int32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Int32x4)) {
    return new SIMD.Int32x4(s0, s1, s2, s3);
   }
   this.s_ = convertArray(_i32x4, new Int32Array([ s0, s1, s2, s3 ]));
  });
  SIMD.Int32x4.extractLane = (function(v, i) {
   v = SIMD.Int32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Int32x4.swizzle === "undefined") {
  SIMD.Int32x4.swizzle = (function(a, s0, s1, s2, s3) {
   return simdSwizzle(int32x4, a, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Int32x4.shuffle === "undefined") {
  SIMD.Int32x4.shuffle = (function(a, b, s0, s1, s2, s3) {
   return simdShuffle(int32x4, a, b, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Int16x8 === "undefined" || typeof SIMD.Int16x8.extractLane === "undefined") {
  SIMD.Int16x8 = (function(s0, s1, s2, s3, s4, s5, s6, s7) {
   if (!(this instanceof SIMD.Int16x8)) {
    return new SIMD.Int16x8(s0, s1, s2, s3, s4, s5, s6, s7);
   }
   this.s_ = convertArray(_i16x8, new Int16Array([ s0, s1, s2, s3, s4, s5, s6, s7 ]));
  });
  SIMD.Int16x8.extractLane = (function(v, i) {
   v = SIMD.Int16x8.check(v);
   simdCheckLaneIndex(i, 8);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Int16x8.swizzle === "undefined") {
  SIMD.Int16x8.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdSwizzle(int16x8, a, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Int16x8.shuffle === "undefined") {
  SIMD.Int16x8.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdShuffle(int16x8, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Int8x16 === "undefined" || typeof SIMD.Int8x16.extractLane === "undefined") {
  SIMD.Int8x16 = (function(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   if (!(this instanceof SIMD.Int8x16)) {
    return new SIMD.Int8x16(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15);
   }
   this.s_ = convertArray(_i8x16, new Int8Array([ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]));
  });
  SIMD.Int8x16.extractLane = (function(v, i) {
   v = SIMD.Int8x16.check(v);
   simdCheckLaneIndex(i, 16);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Int8x16.swizzle === "undefined") {
  SIMD.Int8x16.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdSwizzle(int8x16, a, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Int8x16.shuffle === "undefined") {
  SIMD.Int8x16.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdShuffle(int8x16, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Uint32x4 === "undefined" || typeof SIMD.Uint32x4.extractLane === "undefined") {
  SIMD.Uint32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Uint32x4)) {
    return new SIMD.Uint32x4(s0, s1, s2, s3);
   }
   this.s_ = convertArray(_ui32x4, new Uint32Array([ s0, s1, s2, s3 ]));
  });
  SIMD.Uint32x4.extractLane = (function(v, i) {
   v = SIMD.Uint32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Uint32x4.swizzle === "undefined") {
  SIMD.Uint32x4.swizzle = (function(a, s0, s1, s2, s3) {
   return simdSwizzle(uint32x4, a, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Uint32x4.shuffle === "undefined") {
  SIMD.Uint32x4.shuffle = (function(a, b, s0, s1, s2, s3) {
   return simdShuffle(uint32x4, a, b, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Uint16x8 === "undefined" || typeof SIMD.Uint16x8.extractLane === "undefined") {
  SIMD.Uint16x8 = (function(s0, s1, s2, s3, s4, s5, s6, s7) {
   if (!(this instanceof SIMD.Uint16x8)) {
    return new SIMD.Uint16x8(s0, s1, s2, s3, s4, s5, s6, s7);
   }
   this.s_ = convertArray(_ui16x8, new Uint16Array([ s0, s1, s2, s3, s4, s5, s6, s7 ]));
  });
  SIMD.Uint16x8.extractLane = (function(v, i) {
   v = SIMD.Uint16x8.check(v);
   simdCheckLaneIndex(i, 8);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Uint16x8.swizzle === "undefined") {
  SIMD.Uint16x8.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdSwizzle(uint16x8, a, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Uint16x8.shuffle === "undefined") {
  SIMD.Uint16x8.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdShuffle(uint16x8, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Uint8x16 === "undefined" || typeof SIMD.Uint8x16.extractLane === "undefined") {
  SIMD.Uint8x16 = (function(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   if (!(this instanceof SIMD.Uint8x16)) {
    return new SIMD.Uint8x16(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15);
   }
   this.s_ = convertArray(_ui8x16, new Uint8Array([ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]));
  });
  SIMD.Uint8x16.extractLane = (function(v, i) {
   v = SIMD.Uint8x16.check(v);
   simdCheckLaneIndex(i, 16);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Uint8x16.swizzle === "undefined") {
  SIMD.Uint8x16.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdSwizzle(uint8x16, a, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Uint8x16.shuffle === "undefined") {
  SIMD.Uint8x16.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdShuffle(uint8x16, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Bool32x4 === "undefined" || typeof SIMD.Bool32x4.extractLane === "undefined") {
  SIMD.Bool32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Bool32x4)) {
    return new SIMD.Bool32x4(s0, s1, s2, s3);
   }
   this.s_ = [ !!s0, !!s1, !!s2, !!s3 ];
  });
  SIMD.Bool32x4.extractLane = (function(v, i) {
   v = SIMD.Bool32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Bool16x8 === "undefined" || typeof SIMD.Bool16x8.extractLane === "undefined") {
  SIMD.Bool16x8 = (function(s0, s1, s2, s3, s4, s5, s6, s7) {
   if (!(this instanceof SIMD.Bool16x8)) {
    return new SIMD.Bool16x8(s0, s1, s2, s3, s4, s5, s6, s7);
   }
   this.s_ = [ !!s0, !!s1, !!s2, !!s3, !!s4, !!s5, !!s6, !!s7 ];
  });
  SIMD.Bool16x8.extractLane = (function(v, i) {
   v = SIMD.Bool16x8.check(v);
   simdCheckLaneIndex(i, 8);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Bool8x16 === "undefined" || typeof SIMD.Bool8x16.extractLane === "undefined") {
  SIMD.Bool8x16 = (function(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   if (!(this instanceof SIMD.Bool8x16)) {
    return new SIMD.Bool8x16(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15);
   }
   this.s_ = [ !!s0, !!s1, !!s2, !!s3, !!s4, !!s5, !!s6, !!s7, !!s8, !!s9, !!s10, !!s11, !!s12, !!s13, !!s14, !!s15 ];
  });
  SIMD.Bool8x16.extractLane = (function(v, i) {
   v = SIMD.Bool8x16.check(v);
   simdCheckLaneIndex(i, 16);
   return v.s_[i];
  });
 }
 var float32x4 = {
  name: "Float32x4",
  fn: SIMD.Float32x4,
  lanes: 4,
  laneSize: 4,
  buffer: _f32x4,
  view: Float32Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "add", "sub", "mul", "div", "neg", "abs", "min", "max", "minNum", "maxNum", "reciprocalApproximation", "reciprocalSqrtApproximation", "sqrt", "load", "load1", "load2", "load3", "store", "store1", "store2", "store3" ]
 };
 var int32x4 = {
  name: "Int32x4",
  fn: SIMD.Int32x4,
  lanes: 4,
  laneSize: 4,
  minVal: -2147483648,
  maxVal: 2147483647,
  buffer: _i32x4,
  notFn: unaryBitwiseNot,
  view: Int32Array,
  mulFn: binaryImul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "neg", "shiftLeftByScalar", "shiftRightByScalar", "load", "load1", "load2", "load3", "store", "store1", "store2", "store3" ]
 };
 var int16x8 = {
  name: "Int16x8",
  fn: SIMD.Int16x8,
  lanes: 8,
  laneSize: 2,
  minVal: -32768,
  maxVal: 32767,
  buffer: _i16x8,
  notFn: unaryBitwiseNot,
  view: Int16Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "neg", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var int8x16 = {
  name: "Int8x16",
  fn: SIMD.Int8x16,
  lanes: 16,
  laneSize: 1,
  minVal: -128,
  maxVal: 127,
  buffer: _i8x16,
  notFn: unaryBitwiseNot,
  view: Int8Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "neg", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var uint32x4 = {
  name: "Uint32x4",
  fn: SIMD.Uint32x4,
  lanes: 4,
  laneSize: 4,
  minVal: 0,
  maxVal: 4294967295,
  unsigned: true,
  buffer: _ui32x4,
  notFn: unaryBitwiseNot,
  view: Uint32Array,
  mulFn: binaryImul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "shiftLeftByScalar", "shiftRightByScalar", "load", "load1", "load2", "load3", "store", "store1", "store2", "store3" ]
 };
 var uint16x8 = {
  name: "Uint16x8",
  fn: SIMD.Uint16x8,
  lanes: 8,
  laneSize: 2,
  unsigned: true,
  minVal: 0,
  maxVal: 65535,
  buffer: _ui16x8,
  notFn: unaryBitwiseNot,
  view: Uint16Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var uint8x16 = {
  name: "Uint8x16",
  fn: SIMD.Uint8x16,
  lanes: 16,
  laneSize: 1,
  unsigned: true,
  minVal: 0,
  maxVal: 255,
  buffer: _ui8x16,
  notFn: unaryBitwiseNot,
  view: Uint8Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var bool32x4 = {
  name: "Bool32x4",
  fn: SIMD.Bool32x4,
  lanes: 4,
  laneSize: 4,
  notFn: unaryLogicalNot,
  fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
 };
 var bool16x8 = {
  name: "Bool16x8",
  fn: SIMD.Bool16x8,
  lanes: 8,
  laneSize: 2,
  notFn: unaryLogicalNot,
  fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
 };
 var bool8x16 = {
  name: "Bool8x16",
  fn: SIMD.Bool8x16,
  lanes: 16,
  laneSize: 1,
  notFn: unaryLogicalNot,
  fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
 };
 float32x4.boolType = int32x4.boolType = uint32x4.boolType = bool32x4;
 int16x8.boolType = uint16x8.boolType = bool16x8;
 int8x16.boolType = uint8x16.boolType = bool8x16;
 float32x4.from = [ int32x4, uint32x4 ];
 int32x4.from = [ float32x4, uint32x4 ];
 int16x8.from = [ uint16x8 ];
 int8x16.from = [ uint8x16 ];
 uint32x4.from = [ float32x4, int32x4 ];
 uint16x8.from = [ int16x8 ];
 uint8x16.from = [ int8x16 ];
 float32x4.fromBits = [ int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16 ];
 int32x4.fromBits = [ float32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16 ];
 int16x8.fromBits = [ float32x4, int32x4, int8x16, uint32x4, uint16x8, uint8x16 ];
 int8x16.fromBits = [ float32x4, int32x4, int16x8, uint32x4, uint16x8, uint8x16 ];
 uint32x4.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint16x8, uint8x16 ];
 uint16x8.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint8x16 ];
 uint8x16.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8 ];
 var simdTypes = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16, bool32x4, bool16x8, bool8x16 ];
 simdPhase2 = true;
 if (typeof simdPhase2 !== "undefined") {
  if (typeof SIMD.Float64x2 === "undefined" || typeof SIMD.Float64x2.extractLane === "undefined") {
   SIMD.Float64x2 = (function(s0, s1) {
    if (!(this instanceof SIMD.Float64x2)) {
     return new SIMD.Float64x2(s0, s1);
    }
    this.s_ = convertArray(_f64x2, new Float64Array([ s0, s1 ]));
   });
   SIMD.Float64x2.extractLane = (function(v, i) {
    v = SIMD.Float64x2.check(v);
    simdCheckLaneIndex(i, 2);
    return v.s_[i];
   });
  }
  if (typeof SIMD.Float64x2.swizzle === "undefined") {
   SIMD.Float64x2.swizzle = (function(a, s0, s1) {
    return simdSwizzle(float64x2, a, [ s0, s1 ]);
   });
  }
  if (typeof SIMD.Float64x2.shuffle === "undefined") {
   SIMD.Float64x2.shuffle = (function(a, b, s0, s1) {
    return simdShuffle(float64x2, a, b, [ s0, s1 ]);
   });
  }
  if (typeof SIMD.Bool64x2 === "undefined" || typeof SIMD.Bool64x2.extractLane === "undefined") {
   SIMD.Bool64x2 = (function(s0, s1) {
    if (!(this instanceof SIMD.Bool64x2)) {
     return new SIMD.Bool64x2(s0, s1);
    }
    this.s_ = [ !!s0, !!s1 ];
   });
   SIMD.Bool64x2.extractLane = (function(v, i) {
    v = SIMD.Bool64x2.check(v);
    simdCheckLaneIndex(i, 2);
    return v.s_[i];
   });
  }
  var float64x2 = {
   name: "Float64x2",
   fn: SIMD.Float64x2,
   lanes: 2,
   laneSize: 8,
   buffer: _f64x2,
   view: Float64Array,
   mulFn: binaryMul,
   fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "add", "sub", "mul", "div", "neg", "abs", "min", "max", "minNum", "maxNum", "reciprocalApproximation", "reciprocalSqrtApproximation", "sqrt", "load", "store" ]
  };
  float64x2.fns.push("load1");
  float64x2.fns.push("store1");
  var bool64x2 = {
   name: "Bool64x2",
   fn: SIMD.Bool64x2,
   lanes: 2,
   laneSize: 8,
   notFn: unaryLogicalNot,
   fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
  };
  float64x2.boolType = bool64x2;
  float32x4.fromBits.push(float64x2);
  int32x4.fromBits.push(float64x2);
  int16x8.fromBits.push(float64x2);
  int8x16.fromBits.push(float64x2);
  uint32x4.fromBits.push(float64x2);
  uint16x8.fromBits.push(float64x2);
  uint8x16.fromBits.push(float64x2);
  float64x2.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16 ];
  simdTypes.push(float64x2);
  simdTypes.push(bool64x2);
 }
 var prototypeFns = {
  valueOf: (function(type) {
   return (function() {
    throw new TypeError(type.name + " cannot be converted to a number");
   });
  }),
  toString: (function(type) {
   return (function() {
    return simdToString(type, this);
   });
  }),
  toLocaleString: (function(type) {
   return (function() {
    return simdToLocaleString(type, this);
   });
  })
 };
 var simdFns = {
  check: (function(type) {
   return (function(a) {
    if (!(a instanceof type.fn)) {
     throw new TypeError("Argument is not a " + type.name + ".");
    }
    return a;
   });
  }),
  splat: (function(type) {
   return (function(s) {
    return simdSplat(type, s);
   });
  }),
  replaceLane: (function(type) {
   return (function(a, i, s) {
    return simdReplaceLane(type, a, i, s);
   });
  }),
  allTrue: (function(type) {
   return (function(a) {
    return simdAllTrue(type, a);
   });
  }),
  anyTrue: (function(type) {
   return (function(a) {
    return simdAnyTrue(type, a);
   });
  }),
  and: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryAnd, a, b);
   });
  }),
  or: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryOr, a, b);
   });
  }),
  xor: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryXor, a, b);
   });
  }),
  not: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, type.notFn, a);
   });
  }),
  equal: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryEqual, a, b);
   });
  }),
  notEqual: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryNotEqual, a, b);
   });
  }),
  lessThan: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryLess, a, b);
   });
  }),
  lessThanOrEqual: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryLessEqual, a, b);
   });
  }),
  greaterThan: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryGreater, a, b);
   });
  }),
  greaterThanOrEqual: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryGreaterEqual, a, b);
   });
  }),
  add: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryAdd, a, b);
   });
  }),
  sub: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binarySub, a, b);
   });
  }),
  mul: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, type.mulFn, a, b);
   });
  }),
  div: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryDiv, a, b);
   });
  }),
  neg: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, unaryNeg, a);
   });
  }),
  abs: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, Math.abs, a);
   });
  }),
  min: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, Math.min, a, b);
   });
  }),
  max: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, Math.max, a, b);
   });
  }),
  minNum: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, minNum, a, b);
   });
  }),
  maxNum: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, maxNum, a, b);
   });
  }),
  load: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, type.lanes);
   });
  }),
  load1: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, 1);
   });
  }),
  load2: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, 2);
   });
  }),
  load3: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, 3);
   });
  }),
  store: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, type.lanes);
   });
  }),
  store1: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, 1);
   });
  }),
  store2: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, 2);
   });
  }),
  store3: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, 3);
   });
  }),
  select: (function(type) {
   return (function(selector, a, b) {
    return simdSelect(type, selector, a, b);
   });
  }),
  reciprocalApproximation: (function(type) {
   return (function(a) {
    a = type.fn.check(a);
    return type.fn.div(type.fn.splat(1), a);
   });
  }),
  reciprocalSqrtApproximation: (function(type) {
   return (function(a) {
    a = type.fn.check(a);
    return type.fn.reciprocalApproximation(type.fn.sqrt(a));
   });
  }),
  sqrt: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, Math.sqrt, a);
   });
  }),
  shiftLeftByScalar: (function(type) {
   return (function(a, bits) {
    if (bits >>> 0 >= type.laneSize * 8) return type.fn.splat(0);
    return simdShiftOp(type, binaryShiftLeft, a, bits);
   });
  }),
  shiftRightByScalar: (function(type) {
   if (type.unsigned) {
    return (function(a, bits) {
     if (bits >>> 0 >= type.laneSize * 8) return type.fn.splat(0);
     return simdShiftOp(type, binaryShiftRightLogical, a, bits);
    });
   } else {
    return (function(a, bits) {
     if (bits >>> 0 >= type.laneSize * 8) bits = type.laneSize * 8 - 1;
     return simdShiftOp(type, binaryShiftRightArithmetic, a, bits);
    });
   }
  }),
  addSaturate: (function(type) {
   function addSaturate(a, b) {
    return clamp(a + b, type.minVal, type.maxVal);
   }
   return (function(a, b) {
    return simdBinaryOp(type, addSaturate, a, b);
   });
  }),
  subSaturate: (function(type) {
   function subSaturate(a, b) {
    return clamp(a - b, type.minVal, type.maxVal);
   }
   return (function(a, b) {
    return simdBinaryOp(type, subSaturate, a, b);
   });
  })
 };
 simdTypes.forEach((function(type) {
  var simdFn = type.fn;
  var proto = simdFn.prototype;
  for (var name in prototypeFns) {
   if (!proto.hasOwnProperty(name)) proto[name] = prototypeFns[name](type);
  }
  type.fns.forEach((function(name) {
   if (typeof simdFn[name] === "undefined") simdFn[name] = simdFns[name](type);
  }));
  if (type.from) {
   type.from.forEach((function(fromType) {
    var name = "from" + fromType.name;
    var toType = type;
    if (typeof type.fn[name] === "undefined") {
     type.fn[name] = (function(a) {
      return simdFrom(toType, fromType, a);
     });
    }
   }));
  }
  if (type.fromBits) {
   type.fromBits.forEach((function(fromType) {
    var name = "from" + fromType.name + "Bits";
    var toType = type;
    if (typeof type.fn[name] === "undefined") {
     type.fn[name] = (function(a) {
      return simdFromBits(toType, fromType, a);
     });
    }
   }));
  }
 }));
}))(typeof window !== "undefined" ? window : typeof process === "object" && typeof require === "function" && typeof global === "object" ? global : typeof self === "object" ? self : this);
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.equal(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevEqual = SIMD.Float64x2.equal;
  SIMD.Float64x2.equal = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.equal to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.notEqual(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevNotEqual = SIMD.Float64x2.notEqual;
  SIMD.Float64x2.notEqual = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevNotEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.notEqual to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.greaterThan(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevGreaterThan = SIMD.Float64x2.greaterThan;
  SIMD.Float64x2.greaterThan = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevGreaterThan(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.greaterThan to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.greaterThanOrEqual(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevGreaterThanOrEqual = SIMD.Float64x2.greaterThanOrEqual;
  SIMD.Float64x2.greaterThanOrEqual = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevGreaterThanOrEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.greaterThanOrEqual to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.lessThan(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevLessThan = SIMD.Float64x2.lessThan;
  SIMD.Float64x2.lessThan = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevLessThan(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.lessThan to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.lessThanOrEqual(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevLessThanOrEqual = SIMD.Float64x2.lessThanOrEqual;
  SIMD.Float64x2.lessThanOrEqual = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevLessThanOrEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.lessThanOrEqual to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
if (!SIMD.Int32x4.fromBool64x2Bits) {
 SIMD.Int32x4.fromBool64x2Bits = (function(bool64x2) {
  var lane0 = SIMD.Bool64x2.extractLane(bool64x2, 0) ? -1 : 0;
  var lane1 = SIMD.Bool64x2.extractLane(bool64x2, 1) ? -1 : 0;
  return SIMD.Int32x4(lane0, lane0, lane1, lane1);
 });
}
var Module;
if (!Module) Module = (typeof Module !== "undefined" ? Module : null) || {};
var moduleOverrides = {};
for (var key in Module) {
 if (Module.hasOwnProperty(key)) {
  moduleOverrides[key] = Module[key];
 }
}
var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
if (Module["ENVIRONMENT"]) {
 if (Module["ENVIRONMENT"] === "WEB") {
  ENVIRONMENT_IS_WEB = true;
 } else if (Module["ENVIRONMENT"] === "WORKER") {
  ENVIRONMENT_IS_WORKER = true;
 } else if (Module["ENVIRONMENT"] === "NODE") {
  ENVIRONMENT_IS_NODE = true;
 } else if (Module["ENVIRONMENT"] === "SHELL") {
  ENVIRONMENT_IS_SHELL = true;
 } else {
  throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");
 }
} else {
 ENVIRONMENT_IS_WEB = typeof window === "object";
 ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
 ENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
 ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
}
if (ENVIRONMENT_IS_NODE) {
 if (!Module["print"]) Module["print"] = console.log;
 if (!Module["printErr"]) Module["printErr"] = console.warn;
 var nodeFS;
 var nodePath;
 Module["read"] = function read(filename, binary) {
  if (!nodeFS) nodeFS = require("fs");
  if (!nodePath) nodePath = require("path");
  filename = nodePath["normalize"](filename);
  var ret = nodeFS["readFileSync"](filename);
  if (!ret && filename != nodePath["resolve"](filename)) {
   filename = path.join(__dirname, "..", "src", filename);
   ret = nodeFS["readFileSync"](filename);
  }
  if (ret && !binary) ret = ret.toString();
  return ret;
 };
 Module["readBinary"] = function readBinary(filename) {
  var ret = Module["read"](filename, true);
  if (!ret.buffer) {
   ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
 };
 Module["load"] = function load(f) {
  globalEval(read(f));
 };
 if (!Module["thisProgram"]) {
  if (process["argv"].length > 1) {
   Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/");
  } else {
   Module["thisProgram"] = "unknown-program";
  }
 }
 Module["arguments"] = process["argv"].slice(2);
 if (typeof module !== "undefined") {
  module["exports"] = Module;
 }
 process["on"]("uncaughtException", (function(ex) {
  if (!(ex instanceof ExitStatus)) {
   throw ex;
  }
 }));
 Module["inspect"] = (function() {
  return "[Emscripten Module object]";
 });
} else if (ENVIRONMENT_IS_SHELL) {
 if (!Module["print"]) Module["print"] = print;
 if (typeof printErr != "undefined") Module["printErr"] = printErr;
 if (typeof read != "undefined") {
  Module["read"] = read;
 } else {
  Module["read"] = function read() {
   throw "no read() available (jsc?)";
  };
 }
 Module["readBinary"] = function readBinary(f) {
  if (typeof readbuffer === "function") {
   return new Uint8Array(readbuffer(f));
  }
  var data = read(f, "binary");
  assert(typeof data === "object");
  return data;
 };
 if (typeof scriptArgs != "undefined") {
  Module["arguments"] = scriptArgs;
 } else if (typeof arguments != "undefined") {
  Module["arguments"] = arguments;
 }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 Module["read"] = function read(url) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", url, false);
  xhr.send(null);
  return xhr.responseText;
 };
 Module["readAsync"] = function readAsync(url, onload, onerror) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", url, true);
  xhr.responseType = "arraybuffer";
  xhr.onload = function xhr_onload() {
   if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
    onload(xhr.response);
   } else {
    onerror();
   }
  };
  xhr.onerror = onerror;
  xhr.send(null);
 };
 if (typeof arguments != "undefined") {
  Module["arguments"] = arguments;
 }
 if (typeof console !== "undefined") {
  if (!Module["print"]) Module["print"] = function print(x) {
   console.log(x);
  };
  if (!Module["printErr"]) Module["printErr"] = function printErr(x) {
   console.warn(x);
  };
 } else {
  var TRY_USE_DUMP = false;
  if (!Module["print"]) Module["print"] = TRY_USE_DUMP && typeof dump !== "undefined" ? (function(x) {
   dump(x);
  }) : (function(x) {});
 }
 if (ENVIRONMENT_IS_WORKER) {
  Module["load"] = importScripts;
 }
 if (typeof Module["setWindowTitle"] === "undefined") {
  Module["setWindowTitle"] = (function(title) {
   document.title = title;
  });
 }
} else {
 throw "Unknown runtime environment. Where are we?";
}
function globalEval(x) {
 eval.call(null, x);
}
if (!Module["load"] && Module["read"]) {
 Module["load"] = function load(f) {
  globalEval(Module["read"](f));
 };
}
if (!Module["print"]) {
 Module["print"] = (function() {});
}
if (!Module["printErr"]) {
 Module["printErr"] = Module["print"];
}
if (!Module["arguments"]) {
 Module["arguments"] = [];
}
if (!Module["thisProgram"]) {
 Module["thisProgram"] = "./this.program";
}
Module.print = Module["print"];
Module.printErr = Module["printErr"];
Module["preRun"] = [];
Module["postRun"] = [];
for (var key in moduleOverrides) {
 if (moduleOverrides.hasOwnProperty(key)) {
  Module[key] = moduleOverrides[key];
 }
}
moduleOverrides = undefined;
var Runtime = {
 setTempRet0: (function(x) {
  Runtime.tempRet0 = x;
 }),
 getTempRet0: (function() {
  return Runtime.tempRet0;
 }),
 stackSave: (function() {
  return STACKTOP;
 }),
 stackRestore: (function(stackTop) {
  STACKTOP = stackTop;
 }),
 getNativeTypeSize: (function(type) {
  switch (type) {
  case "i1":
  case "i8":
   return 1;
  case "i16":
   return 2;
  case "i32":
   return 4;
  case "i64":
   return 8;
  case "float":
   return 4;
  case "double":
   return 8;
  default:
   {
    if (type[type.length - 1] === "*") {
     return Runtime.QUANTUM_SIZE;
    } else if (type[0] === "i") {
     var bits = parseInt(type.substr(1));
     assert(bits % 8 === 0);
     return bits / 8;
    } else {
     return 0;
    }
   }
  }
 }),
 getNativeFieldSize: (function(type) {
  return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
 }),
 STACK_ALIGN: 16,
 prepVararg: (function(ptr, type) {
  if (type === "double" || type === "i64") {
   if (ptr & 7) {
    assert((ptr & 7) === 4);
    ptr += 4;
   }
  } else {
   assert((ptr & 3) === 0);
  }
  return ptr;
 }),
 getAlignSize: (function(type, size, vararg) {
  if (!vararg && (type == "i64" || type == "double")) return 8;
  if (!type) return Math.min(size, 8);
  return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
 }),
 dynCall: (function(sig, ptr, args) {
  if (args && args.length) {
   if (!args.splice) args = Array.prototype.slice.call(args);
   args.splice(0, 0, ptr);
   return Module["dynCall_" + sig].apply(null, args);
  } else {
   return Module["dynCall_" + sig].call(null, ptr);
  }
 }),
 getFunctionTables: (function(module) {
  if (!module) module = Module;
  var tables = {};
  for (var t in module) {
   if (/^FUNCTION_TABLE_.*/.test(t)) {
    var table = module[t];
    if (typeof table === "object") tables[t.substr("FUNCTION_TABLE_".length)] = table;
   }
  }
  return tables;
 }),
 alignFunctionTables: (function(module) {
  var tables = Runtime.getFunctionTables(module);
  var maxx = 0;
  for (var sig in tables) {
   maxx = Math.max(maxx, tables[sig].length);
  }
  assert(maxx >= 0);
  for (var sig in tables) {
   var table = tables[sig];
   while (table.length < maxx) table.push(0);
  }
  return maxx;
 }),
 registerFunctions: (function(sigs, newModule) {
  sigs.forEach((function(sig) {
   if (!Module["FUNCTION_TABLE_" + sig]) {
    Module["FUNCTION_TABLE_" + sig] = [];
   }
  }));
  var oldMaxx = Runtime.alignFunctionTables();
  var newMaxx = Runtime.alignFunctionTables(newModule);
  var maxx = oldMaxx + newMaxx;
  sigs.forEach((function(sig) {
   var newTable = newModule["FUNCTION_TABLE_" + sig];
   var oldTable = Module["FUNCTION_TABLE_" + sig];
   assert(newTable !== oldTable);
   assert(oldTable.length === oldMaxx);
   for (var i = 0; i < newTable.length; i++) {
    oldTable.push(newTable[i]);
   }
   assert(oldTable.length === maxx);
  }));
  assert(maxx === Runtime.alignFunctionTables());
 }),
 functionPointers: [],
 addFunction: (function(func) {
  Runtime.alignFunctionTables();
  var tables = Runtime.getFunctionTables();
  var ret = -1;
  for (var sig in tables) {
   var table = tables[sig];
   if (ret < 0) ret = table.length; else assert(ret === table.length);
   table.push(func);
  }
  return ret;
 }),
 removeFunction: (function(index) {
  Runtime.alignFunctionTables();
  var tables = Runtime.getFunctionTables();
  for (var sig in tables) {
   tables[sig][index] = null;
  }
 }),
 loadedDynamicLibraries: [],
 loadDynamicLibrary: (function(lib) {
  var src = Module["read"](lib);
  var libModule = eval(src)(Runtime.alignFunctionTables(), Module);
  for (var sym in libModule) {
   if (!Module.hasOwnProperty(sym)) {
    Module[sym] = libModule[sym];
   }
  }
  Runtime.loadedDynamicLibraries.push(libModule);
 }),
 warnOnce: (function(text) {
  if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
  if (!Runtime.warnOnce.shown[text]) {
   Runtime.warnOnce.shown[text] = 1;
   Module.printErr(text);
  }
 }),
 funcWrappers: {},
 getFuncWrapper: (function(func, sig) {
  assert(sig);
  if (!Runtime.funcWrappers[sig]) {
   Runtime.funcWrappers[sig] = {};
  }
  var sigCache = Runtime.funcWrappers[sig];
  if (!sigCache[func]) {
   sigCache[func] = function dynCall_wrapper() {
    return Runtime.dynCall(sig, func, arguments);
   };
  }
  return sigCache[func];
 }),
 getCompilerSetting: (function(name) {
  throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";
 }),
 stackAlloc: (function(size) {
  var ret = STACKTOP;
  STACKTOP = STACKTOP + size | 0;
  STACKTOP = STACKTOP + 15 & -16;
  return ret;
 }),
 staticAlloc: (function(size) {
  var ret = STATICTOP;
  STATICTOP = STATICTOP + size | 0;
  STATICTOP = STATICTOP + 15 & -16;
  return ret;
 }),
 dynamicAlloc: (function(size) {
  var ret = DYNAMICTOP;
  DYNAMICTOP = DYNAMICTOP + size | 0;
  DYNAMICTOP = DYNAMICTOP + 15 & -16;
  if (DYNAMICTOP >= TOTAL_MEMORY) {
   var success = enlargeMemory();
   if (!success) {
    DYNAMICTOP = ret;
    return 0;
   }
  }
  return ret;
 }),
 alignMemory: (function(size, quantum) {
  var ret = size = Math.ceil(size / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
  return ret;
 }),
 makeBigInt: (function(low, high, unsigned) {
  var ret = unsigned ? +(low >>> 0) + +(high >>> 0) * +4294967296 : +(low >>> 0) + +(high | 0) * +4294967296;
  return ret;
 }),
 tempRet0: 0,
 GLOBAL_BASE: 8,
 QUANTUM_SIZE: 4,
 __dummy__: 0
};
Runtime.GLOBAL_BASE = Runtime.alignMemory(Runtime.GLOBAL_BASE, 8);
Module["Runtime"] = Runtime;
var ABORT = false;
var EXITSTATUS = 0;
function assert(condition, text) {
 if (!condition) {
  abort("Assertion failed: " + text);
 }
}
function getCFunc(ident) {
 var func = Module["_" + ident];
 if (!func) {
  try {
   func = eval("_" + ident);
  } catch (e) {}
 }
 assert(func, "Cannot call unknown function " + ident + " (perhaps LLVM optimizations or closure removed it?)");
 return func;
}
var cwrap, ccall;
((function() {
 var JSfuncs = {
  "stackSave": (function() {
   Runtime.stackSave();
  }),
  "stackRestore": (function() {
   Runtime.stackRestore();
  }),
  "arrayToC": (function(arr) {
   var ret = Runtime.stackAlloc(arr.length);
   writeArrayToMemory(arr, ret);
   return ret;
  }),
  "stringToC": (function(str) {
   var ret = 0;
   if (str !== null && str !== undefined && str !== 0) {
    ret = Runtime.stackAlloc((str.length << 2) + 1);
    writeStringToMemory(str, ret);
   }
   return ret;
  })
 };
 var toC = {
  "string": JSfuncs["stringToC"],
  "array": JSfuncs["arrayToC"]
 };
 ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {
  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
   for (var i = 0; i < args.length; i++) {
    var converter = toC[argTypes[i]];
    if (converter) {
     if (stack === 0) stack = Runtime.stackSave();
     cArgs[i] = converter(args[i]);
    } else {
     cArgs[i] = args[i];
    }
   }
  }
  var ret = func.apply(null, cArgs);
  if (returnType === "string") ret = Pointer_stringify(ret);
  if (stack !== 0) {
   if (opts && opts.async) {
    EmterpreterAsync.asyncFinalizers.push((function() {
     Runtime.stackRestore(stack);
    }));
    return;
   }
   Runtime.stackRestore(stack);
  }
  return ret;
 };
 var sourceRegex = /^function\s*[a-zA-Z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
 function parseJSFunc(jsfunc) {
  var parsed = jsfunc.toString().match(sourceRegex).slice(1);
  return {
   arguments: parsed[0],
   body: parsed[1],
   returnValue: parsed[2]
  };
 }
 var JSsource = null;
 function ensureJSsource() {
  if (!JSsource) {
   JSsource = {};
   for (var fun in JSfuncs) {
    if (JSfuncs.hasOwnProperty(fun)) {
     JSsource[fun] = parseJSFunc(JSfuncs[fun]);
    }
   }
  }
 }
 cwrap = function cwrap(ident, returnType, argTypes) {
  argTypes = argTypes || [];
  var cfunc = getCFunc(ident);
  var numericArgs = argTypes.every((function(type) {
   return type === "number";
  }));
  var numericRet = returnType !== "string";
  if (numericRet && numericArgs) {
   return cfunc;
  }
  var argNames = argTypes.map((function(x, i) {
   return "$" + i;
  }));
  var funcstr = "(function(" + argNames.join(",") + ") {";
  var nargs = argTypes.length;
  if (!numericArgs) {
   ensureJSsource();
   funcstr += "var stack = " + JSsource["stackSave"].body + ";";
   for (var i = 0; i < nargs; i++) {
    var arg = argNames[i], type = argTypes[i];
    if (type === "number") continue;
    var convertCode = JSsource[type + "ToC"];
    funcstr += "var " + convertCode.arguments + " = " + arg + ";";
    funcstr += convertCode.body + ";";
    funcstr += arg + "=(" + convertCode.returnValue + ");";
   }
  }
  var cfuncname = parseJSFunc((function() {
   return cfunc;
  })).returnValue;
  funcstr += "var ret = " + cfuncname + "(" + argNames.join(",") + ");";
  if (!numericRet) {
   var strgfy = parseJSFunc((function() {
    return Pointer_stringify;
   })).returnValue;
   funcstr += "ret = " + strgfy + "(ret);";
  }
  if (!numericArgs) {
   ensureJSsource();
   funcstr += JSsource["stackRestore"].body.replace("()", "(stack)") + ";";
  }
  funcstr += "return ret})";
  return eval(funcstr);
 };
}))();
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;
function setValue(ptr, value, type, noSafe) {
 type = type || "i8";
 if (type.charAt(type.length - 1) === "*") type = "i32";
 switch (type) {
 case "i1":
  HEAP8[ptr >> 0] = value;
  break;
 case "i8":
  HEAP8[ptr >> 0] = value;
  break;
 case "i16":
  HEAP16[ptr >> 1] = value;
  break;
 case "i32":
  HEAP32[ptr >> 2] = value;
  break;
 case "i64":
  tempI64 = [ value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= +1 ? tempDouble > +0 ? (Math_min(+Math_floor(tempDouble / +4294967296), +4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / +4294967296) >>> 0 : 0) ], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
  break;
 case "float":
  HEAPF32[ptr >> 2] = value;
  break;
 case "double":
  HEAPF64[ptr >> 3] = value;
  break;
 default:
  abort("invalid type for setValue: " + type);
 }
}
Module["setValue"] = setValue;
function getValue(ptr, type, noSafe) {
 type = type || "i8";
 if (type.charAt(type.length - 1) === "*") type = "i32";
 switch (type) {
 case "i1":
  return HEAP8[ptr >> 0];
 case "i8":
  return HEAP8[ptr >> 0];
 case "i16":
  return HEAP16[ptr >> 1];
 case "i32":
  return HEAP32[ptr >> 2];
 case "i64":
  return HEAP32[ptr >> 2];
 case "float":
  return HEAPF32[ptr >> 2];
 case "double":
  return HEAPF64[ptr >> 3];
 default:
  abort("invalid type for setValue: " + type);
 }
 return null;
}
Module["getValue"] = getValue;
var ALLOC_NORMAL = 0;
var ALLOC_STACK = 1;
var ALLOC_STATIC = 2;
var ALLOC_DYNAMIC = 3;
var ALLOC_NONE = 4;
Module["ALLOC_NORMAL"] = ALLOC_NORMAL;
Module["ALLOC_STACK"] = ALLOC_STACK;
Module["ALLOC_STATIC"] = ALLOC_STATIC;
Module["ALLOC_DYNAMIC"] = ALLOC_DYNAMIC;
Module["ALLOC_NONE"] = ALLOC_NONE;
function allocate(slab, types, allocator, ptr) {
 var zeroinit, size;
 if (typeof slab === "number") {
  zeroinit = true;
  size = slab;
 } else {
  zeroinit = false;
  size = slab.length;
 }
 var singleType = typeof types === "string" ? types : null;
 var ret;
 if (allocator == ALLOC_NONE) {
  ret = ptr;
 } else {
  ret = [ typeof _malloc === "function" ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc ][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
 }
 if (zeroinit) {
  var ptr = ret, stop;
  assert((ret & 3) == 0);
  stop = ret + (size & ~3);
  for (; ptr < stop; ptr += 4) {
   HEAP32[ptr >> 2] = 0;
  }
  stop = ret + size;
  while (ptr < stop) {
   HEAP8[ptr++ >> 0] = 0;
  }
  return ret;
 }
 if (singleType === "i8") {
  if (slab.subarray || slab.slice) {
   HEAPU8.set(slab, ret);
  } else {
   HEAPU8.set(new Uint8Array(slab), ret);
  }
  return ret;
 }
 var i = 0, type, typeSize, previousType;
 while (i < size) {
  var curr = slab[i];
  if (typeof curr === "function") {
   curr = Runtime.getFunctionIndex(curr);
  }
  type = singleType || types[i];
  if (type === 0) {
   i++;
   continue;
  }
  if (type == "i64") type = "i32";
  setValue(ret + i, curr, type);
  if (previousType !== type) {
   typeSize = Runtime.getNativeTypeSize(type);
   previousType = type;
  }
  i += typeSize;
 }
 return ret;
}
Module["allocate"] = allocate;
function getMemory(size) {
 if (!staticSealed) return Runtime.staticAlloc(size);
 if (typeof _sbrk !== "undefined" && !_sbrk.called || !runtimeInitialized) return Runtime.dynamicAlloc(size);
 return _malloc(size);
}
Module["getMemory"] = getMemory;
function Pointer_stringify(ptr, length) {
 if (length === 0 || !ptr) return "";
 var hasUtf = 0;
 var t;
 var i = 0;
 while (1) {
  t = HEAPU8[ptr + i >> 0];
  hasUtf |= t;
  if (t == 0 && !length) break;
  i++;
  if (length && i == length) break;
 }
 if (!length) length = i;
 var ret = "";
 if (hasUtf < 128) {
  var MAX_CHUNK = 1024;
  var curr;
  while (length > 0) {
   curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
   ret = ret ? ret + curr : curr;
   ptr += MAX_CHUNK;
   length -= MAX_CHUNK;
  }
  return ret;
 }
 return Module["UTF8ToString"](ptr);
}
Module["Pointer_stringify"] = Pointer_stringify;
function AsciiToString(ptr) {
 var str = "";
 while (1) {
  var ch = HEAP8[ptr++ >> 0];
  if (!ch) return str;
  str += String.fromCharCode(ch);
 }
}
Module["AsciiToString"] = AsciiToString;
function stringToAscii(str, outPtr) {
 return writeAsciiToMemory(str, outPtr, false);
}
Module["stringToAscii"] = stringToAscii;
function UTF8ArrayToString(u8Array, idx) {
 var u0, u1, u2, u3, u4, u5;
 var str = "";
 while (1) {
  u0 = u8Array[idx++];
  if (!u0) return str;
  if (!(u0 & 128)) {
   str += String.fromCharCode(u0);
   continue;
  }
  u1 = u8Array[idx++] & 63;
  if ((u0 & 224) == 192) {
   str += String.fromCharCode((u0 & 31) << 6 | u1);
   continue;
  }
  u2 = u8Array[idx++] & 63;
  if ((u0 & 240) == 224) {
   u0 = (u0 & 15) << 12 | u1 << 6 | u2;
  } else {
   u3 = u8Array[idx++] & 63;
   if ((u0 & 248) == 240) {
    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;
   } else {
    u4 = u8Array[idx++] & 63;
    if ((u0 & 252) == 248) {
     u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;
    } else {
     u5 = u8Array[idx++] & 63;
     u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;
    }
   }
  }
  if (u0 < 65536) {
   str += String.fromCharCode(u0);
  } else {
   var ch = u0 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  }
 }
}
Module["UTF8ArrayToString"] = UTF8ArrayToString;
function UTF8ToString(ptr) {
 return UTF8ArrayToString(HEAPU8, ptr);
}
Module["UTF8ToString"] = UTF8ToString;
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   outU8Array[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   outU8Array[outIdx++] = 192 | u >> 6;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   outU8Array[outIdx++] = 224 | u >> 12;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 2097151) {
   if (outIdx + 3 >= endIdx) break;
   outU8Array[outIdx++] = 240 | u >> 18;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 67108863) {
   if (outIdx + 4 >= endIdx) break;
   outU8Array[outIdx++] = 248 | u >> 24;
   outU8Array[outIdx++] = 128 | u >> 18 & 63;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 5 >= endIdx) break;
   outU8Array[outIdx++] = 252 | u >> 30;
   outU8Array[outIdx++] = 128 | u >> 24 & 63;
   outU8Array[outIdx++] = 128 | u >> 18 & 63;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  }
 }
 outU8Array[outIdx] = 0;
 return outIdx - startIdx;
}
Module["stringToUTF8Array"] = stringToUTF8Array;
function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
Module["stringToUTF8"] = stringToUTF8;
function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) {
   ++len;
  } else if (u <= 2047) {
   len += 2;
  } else if (u <= 65535) {
   len += 3;
  } else if (u <= 2097151) {
   len += 4;
  } else if (u <= 67108863) {
   len += 5;
  } else {
   len += 6;
  }
 }
 return len;
}
Module["lengthBytesUTF8"] = lengthBytesUTF8;
function demangle(func) {
 var hasLibcxxabi = !!Module["___cxa_demangle"];
 if (hasLibcxxabi) {
  try {
   var buf = _malloc(func.length);
   writeStringToMemory(func.substr(1), buf);
   var status = _malloc(4);
   var ret = Module["___cxa_demangle"](buf, 0, 0, status);
   if (getValue(status, "i32") === 0 && ret) {
    return Pointer_stringify(ret);
   }
  } catch (e) {
   return func;
  } finally {
   if (buf) _free(buf);
   if (status) _free(status);
   if (ret) _free(ret);
  }
 }
 Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");
 return func;
}
function demangleAll(text) {
 return text.replace(/__Z[\w\d_]+/g, (function(x) {
  var y = demangle(x);
  return x === y ? x : x + " [" + y + "]";
 }));
}
function jsStackTrace() {
 var err = new Error;
 if (!err.stack) {
  try {
   throw new Error(0);
  } catch (e) {
   err = e;
  }
  if (!err.stack) {
   return "(no stack trace available)";
  }
 }
 return err.stack.toString();
}
function stackTrace() {
 return demangleAll(jsStackTrace());
}
Module["stackTrace"] = stackTrace;
var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
 if (x % 4096 > 0) {
  x += 4096 - x % 4096;
 }
 return x;
}
var HEAP;
var buffer;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
function updateGlobalBufferViews() {
 Module["HEAP8"] = HEAP8 = new Int8Array(buffer);
 Module["HEAP16"] = HEAP16 = new Int16Array(buffer);
 Module["HEAP32"] = HEAP32 = new Int32Array(buffer);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer);
}
var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false;
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0;
var DYNAMIC_BASE = 0, DYNAMICTOP = 0;
function abortOnCannotGrowMemory() {
 abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
}
function enlargeMemory() {
 abortOnCannotGrowMemory();
}
var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;
var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216;
var totalMemory = 64 * 1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2 * TOTAL_STACK) {
 if (totalMemory < 16 * 1024 * 1024) {
  totalMemory *= 2;
 } else {
  totalMemory += 16 * 1024 * 1024;
 }
}
if (totalMemory !== TOTAL_MEMORY) {
 TOTAL_MEMORY = totalMemory;
}
if (Module["buffer"]) {
 buffer = Module["buffer"];
} else {
 buffer = new ArrayBuffer(TOTAL_MEMORY);
}
updateGlobalBufferViews();
HEAP32[0] = 255;
if (HEAPU8[0] !== 255 || HEAPU8[3] !== 0) throw "Typed arrays 2 must be run on a little-endian system";
Module["HEAP"] = HEAP;
Module["buffer"] = buffer;
Module["HEAP8"] = HEAP8;
Module["HEAP16"] = HEAP16;
Module["HEAP32"] = HEAP32;
Module["HEAPU8"] = HEAPU8;
Module["HEAPU16"] = HEAPU16;
Module["HEAPU32"] = HEAPU32;
Module["HEAPF32"] = HEAPF32;
Module["HEAPF64"] = HEAPF64;
function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback();
   continue;
  }
  var func = callback.func;
  if (typeof func === "number") {
   if (callback.arg === undefined) {
    Runtime.dynCall("v", func);
   } else {
    Runtime.dynCall("vi", func, [ callback.arg ]);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATEXIT__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;
var runtimeExited = false;
function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}
function ensureInitRuntime() {
 if (runtimeInitialized) return;
 runtimeInitialized = true;
 callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
 callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
 callRuntimeCallbacks(__ATEXIT__);
 runtimeExited = true;
}
function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}
function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}
Module["addOnPreRun"] = addOnPreRun;
function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}
Module["addOnInit"] = addOnInit;
function addOnPreMain(cb) {
 __ATMAIN__.unshift(cb);
}
Module["addOnPreMain"] = addOnPreMain;
function addOnExit(cb) {
 __ATEXIT__.unshift(cb);
}
Module["addOnExit"] = addOnExit;
function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}
Module["addOnPostRun"] = addOnPostRun;
function intArrayFromString(stringy, dontAddNull, length) {
 var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
 var u8array = new Array(len);
 var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
 if (dontAddNull) u8array.length = numBytesWritten;
 return u8array;
}
Module["intArrayFromString"] = intArrayFromString;
function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}
Module["intArrayToString"] = intArrayToString;
function writeStringToMemory(string, buffer, dontAddNull) {
 var array = intArrayFromString(string, dontAddNull);
 var i = 0;
 while (i < array.length) {
  var chr = array[i];
  HEAP8[buffer + i >> 0] = chr;
  i = i + 1;
 }
}
Module["writeStringToMemory"] = writeStringToMemory;
function writeArrayToMemory(array, buffer) {
 for (var i = 0; i < array.length; i++) {
  HEAP8[buffer++ >> 0] = array[i];
 }
}
Module["writeArrayToMemory"] = writeArrayToMemory;
function writeAsciiToMemory(str, buffer, dontAddNull) {
 for (var i = 0; i < str.length; ++i) {
  HEAP8[buffer++ >> 0] = str.charCodeAt(i);
 }
 if (!dontAddNull) HEAP8[buffer >> 0] = 0;
}
Module["writeAsciiToMemory"] = writeAsciiToMemory;
if (!Math["imul"] || Math["imul"](4294967295, 5) !== -5) Math["imul"] = function imul(a, b) {
 var ah = a >>> 16;
 var al = a & 65535;
 var bh = b >>> 16;
 var bl = b & 65535;
 return al * bl + (ah * bl + al * bh << 16) | 0;
};
Math.imul = Math["imul"];
if (!Math["fround"]) Math["fround"] = (function(x) {
 return x;
});
if (!Math["clz32"]) Math["clz32"] = (function(x) {
 x = x >>> 0;
 for (var i = 0; i < 32; i++) {
  if (x & 1 << 31 - i) return i;
 }
 return 32;
});
Math.clz32 = Math["clz32"];
var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;
function getUniqueRunDependency(id) {
 return id;
}
function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}
Module["addRunDependency"] = addRunDependency;
function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}
Module["removeRunDependency"] = removeRunDependency;
Module["preloadedImages"] = {};
Module["preloadedAudios"] = {};
addOnPreRun((function() {
 if (Module["dynamicLibraries"]) {
  Module["dynamicLibraries"].forEach((function(lib) {
   Runtime.loadDynamicLibrary(lib);
  }));
 }
 asm["runPostSets"]();
}));
var memoryInitializer = null;
var ASM_CONSTS = [];
STATIC_BASE = 8;
STATICTOP = STATIC_BASE + 45904;
__ATINIT__.push();
memoryInitializer = "quiet-emscripten.js.mem";
var tempDoublePtr = STATICTOP;
STATICTOP += 16;
function _chainback_viterbi29() {
 return Module["_chainback_viterbi29"].apply(null, arguments);
}
function _create_viterbi39() {
 return Module["_create_viterbi39"].apply(null, arguments);
}
Module["_i64Subtract"] = _i64Subtract;
function ___assert_fail(condition, filename, line, func) {
 ABORT = true;
 throw "Assertion failed: " + Pointer_stringify(condition) + ", at: " + [ filename ? Pointer_stringify(filename) : "unknown filename", line, func ? Pointer_stringify(func) : "unknown function" ] + " at " + stackTrace();
}
Module["___assert_fail"] = ___assert_fail;
Module["_roundf"] = _roundf;
function _chainback_viterbi615() {
 return Module["_chainback_viterbi615"].apply(null, arguments);
}
Module["_memset"] = _memset;
function _chainback_viterbi27() {
 return Module["_chainback_viterbi27"].apply(null, arguments);
}
function _update_viterbi27_blk() {
 return Module["_update_viterbi27_blk"].apply(null, arguments);
}
Module["_bitshift64Shl"] = _bitshift64Shl;
function _abort() {
 Module["abort"]();
}
Module["_abort"] = _abort;
function _init_viterbi39() {
 return Module["_init_viterbi39"].apply(null, arguments);
}
function _update_viterbi39_blk() {
 return Module["_update_viterbi39_blk"].apply(null, arguments);
}
function ___lock() {}
Module["___lock"] = ___lock;
function ___unlock() {}
Module["___unlock"] = ___unlock;
function _llvm_stacksave() {
 var self = _llvm_stacksave;
 if (!self.LLVM_SAVEDSTACKS) {
  self.LLVM_SAVEDSTACKS = [];
 }
 self.LLVM_SAVEDSTACKS.push(Runtime.stackSave());
 return self.LLVM_SAVEDSTACKS.length - 1;
}
Module["_llvm_stacksave"] = _llvm_stacksave;
function _delete_viterbi39() {
 return Module["_delete_viterbi39"].apply(null, arguments);
}
var _llvm_fabs_f64 = Math_abs;
Module["_llvm_fabs_f64"] = _llvm_fabs_f64;
Module["_i64Add"] = _i64Add;
function _emscripten_memcpy_big(dest, src, num) {
 HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
 return dest;
}
Module["_emscripten_memcpy_big"] = _emscripten_memcpy_big;
Module["_memcpy"] = _memcpy;
var _llvm_pow_f32 = Math_pow;
Module["_llvm_pow_f32"] = _llvm_pow_f32;
var PROCINFO = {
 ppid: 1,
 pid: 42,
 sid: 42,
 pgid: 42
};
Module["PROCINFO"] = PROCINFO;
var ERRNO_CODES = {
 EPERM: 1,
 ENOENT: 2,
 ESRCH: 3,
 EINTR: 4,
 EIO: 5,
 ENXIO: 6,
 E2BIG: 7,
 ENOEXEC: 8,
 EBADF: 9,
 ECHILD: 10,
 EAGAIN: 11,
 EWOULDBLOCK: 11,
 ENOMEM: 12,
 EACCES: 13,
 EFAULT: 14,
 ENOTBLK: 15,
 EBUSY: 16,
 EEXIST: 17,
 EXDEV: 18,
 ENODEV: 19,
 ENOTDIR: 20,
 EISDIR: 21,
 EINVAL: 22,
 ENFILE: 23,
 EMFILE: 24,
 ENOTTY: 25,
 ETXTBSY: 26,
 EFBIG: 27,
 ENOSPC: 28,
 ESPIPE: 29,
 EROFS: 30,
 EMLINK: 31,
 EPIPE: 32,
 EDOM: 33,
 ERANGE: 34,
 ENOMSG: 42,
 EIDRM: 43,
 ECHRNG: 44,
 EL2NSYNC: 45,
 EL3HLT: 46,
 EL3RST: 47,
 ELNRNG: 48,
 EUNATCH: 49,
 ENOCSI: 50,
 EL2HLT: 51,
 EDEADLK: 35,
 ENOLCK: 37,
 EBADE: 52,
 EBADR: 53,
 EXFULL: 54,
 ENOANO: 55,
 EBADRQC: 56,
 EBADSLT: 57,
 EDEADLOCK: 35,
 EBFONT: 59,
 ENOSTR: 60,
 ENODATA: 61,
 ETIME: 62,
 ENOSR: 63,
 ENONET: 64,
 ENOPKG: 65,
 EREMOTE: 66,
 ENOLINK: 67,
 EADV: 68,
 ESRMNT: 69,
 ECOMM: 70,
 EPROTO: 71,
 EMULTIHOP: 72,
 EDOTDOT: 73,
 EBADMSG: 74,
 ENOTUNIQ: 76,
 EBADFD: 77,
 EREMCHG: 78,
 ELIBACC: 79,
 ELIBBAD: 80,
 ELIBSCN: 81,
 ELIBMAX: 82,
 ELIBEXEC: 83,
 ENOSYS: 38,
 ENOTEMPTY: 39,
 ENAMETOOLONG: 36,
 ELOOP: 40,
 EOPNOTSUPP: 95,
 EPFNOSUPPORT: 96,
 ECONNRESET: 104,
 ENOBUFS: 105,
 EAFNOSUPPORT: 97,
 EPROTOTYPE: 91,
 ENOTSOCK: 88,
 ENOPROTOOPT: 92,
 ESHUTDOWN: 108,
 ECONNREFUSED: 111,
 EADDRINUSE: 98,
 ECONNABORTED: 103,
 ENETUNREACH: 101,
 ENETDOWN: 100,
 ETIMEDOUT: 110,
 EHOSTDOWN: 112,
 EHOSTUNREACH: 113,
 EINPROGRESS: 115,
 EALREADY: 114,
 EDESTADDRREQ: 89,
 EMSGSIZE: 90,
 EPROTONOSUPPORT: 93,
 ESOCKTNOSUPPORT: 94,
 EADDRNOTAVAIL: 99,
 ENETRESET: 102,
 EISCONN: 106,
 ENOTCONN: 107,
 ETOOMANYREFS: 109,
 EUSERS: 87,
 EDQUOT: 122,
 ESTALE: 116,
 ENOTSUP: 95,
 ENOMEDIUM: 123,
 EILSEQ: 84,
 EOVERFLOW: 75,
 ECANCELED: 125,
 ENOTRECOVERABLE: 131,
 EOWNERDEAD: 130,
 ESTRPIPE: 86
};
Module["ERRNO_CODES"] = ERRNO_CODES;
var ERRNO_MESSAGES = {
 0: "Success",
 1: "Not super-user",
 2: "No such file or directory",
 3: "No such process",
 4: "Interrupted system call",
 5: "I/O error",
 6: "No such device or address",
 7: "Arg list too long",
 8: "Exec format error",
 9: "Bad file number",
 10: "No children",
 11: "No more processes",
 12: "Not enough core",
 13: "Permission denied",
 14: "Bad address",
 15: "Block device required",
 16: "Mount device busy",
 17: "File exists",
 18: "Cross-device link",
 19: "No such device",
 20: "Not a directory",
 21: "Is a directory",
 22: "Invalid argument",
 23: "Too many open files in system",
 24: "Too many open files",
 25: "Not a typewriter",
 26: "Text file busy",
 27: "File too large",
 28: "No space left on device",
 29: "Illegal seek",
 30: "Read only file system",
 31: "Too many links",
 32: "Broken pipe",
 33: "Math arg out of domain of func",
 34: "Math result not representable",
 35: "File locking deadlock error",
 36: "File or path name too long",
 37: "No record locks available",
 38: "Function not implemented",
 39: "Directory not empty",
 40: "Too many symbolic links",
 42: "No message of desired type",
 43: "Identifier removed",
 44: "Channel number out of range",
 45: "Level 2 not synchronized",
 46: "Level 3 halted",
 47: "Level 3 reset",
 48: "Link number out of range",
 49: "Protocol driver not attached",
 50: "No CSI structure available",
 51: "Level 2 halted",
 52: "Invalid exchange",
 53: "Invalid request descriptor",
 54: "Exchange full",
 55: "No anode",
 56: "Invalid request code",
 57: "Invalid slot",
 59: "Bad font file fmt",
 60: "Device not a stream",
 61: "No data (for no delay io)",
 62: "Timer expired",
 63: "Out of streams resources",
 64: "Machine is not on the network",
 65: "Package not installed",
 66: "The object is remote",
 67: "The link has been severed",
 68: "Advertise error",
 69: "Srmount error",
 70: "Communication error on send",
 71: "Protocol error",
 72: "Multihop attempted",
 73: "Cross mount point (not really error)",
 74: "Trying to read unreadable message",
 75: "Value too large for defined data type",
 76: "Given log. name not unique",
 77: "f.d. invalid for this operation",
 78: "Remote address changed",
 79: "Can   access a needed shared lib",
 80: "Accessing a corrupted shared lib",
 81: ".lib section in a.out corrupted",
 82: "Attempting to link in too many libs",
 83: "Attempting to exec a shared library",
 84: "Illegal byte sequence",
 86: "Streams pipe error",
 87: "Too many users",
 88: "Socket operation on non-socket",
 89: "Destination address required",
 90: "Message too long",
 91: "Protocol wrong type for socket",
 92: "Protocol not available",
 93: "Unknown protocol",
 94: "Socket type not supported",
 95: "Not supported",
 96: "Protocol family not supported",
 97: "Address family not supported by protocol family",
 98: "Address already in use",
 99: "Address not available",
 100: "Network interface is not configured",
 101: "Network is unreachable",
 102: "Connection reset by network",
 103: "Connection aborted",
 104: "Connection reset by peer",
 105: "No buffer space available",
 106: "Socket is already connected",
 107: "Socket is not connected",
 108: "Can't send after socket shutdown",
 109: "Too many references",
 110: "Connection timed out",
 111: "Connection refused",
 112: "Host is down",
 113: "Host is unreachable",
 114: "Socket already connected",
 115: "Connection already in progress",
 116: "Stale file handle",
 122: "Quota exceeded",
 123: "No medium (in tape drive)",
 125: "Operation canceled",
 130: "Previous owner died",
 131: "State not recoverable"
};
Module["ERRNO_MESSAGES"] = ERRNO_MESSAGES;
function ___setErrNo(value) {
 if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value;
 return value;
}
Module["___setErrNo"] = ___setErrNo;
var PATH = {
 splitPath: (function(filename) {
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  return splitPathRe.exec(filename).slice(1);
 }),
 normalizeArray: (function(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
   var last = parts[i];
   if (last === ".") {
    parts.splice(i, 1);
   } else if (last === "..") {
    parts.splice(i, 1);
    up++;
   } else if (up) {
    parts.splice(i, 1);
    up--;
   }
  }
  if (allowAboveRoot) {
   for (; up--; up) {
    parts.unshift("..");
   }
  }
  return parts;
 }),
 normalize: (function(path) {
  var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
  path = PATH.normalizeArray(path.split("/").filter((function(p) {
   return !!p;
  })), !isAbsolute).join("/");
  if (!path && !isAbsolute) {
   path = ".";
  }
  if (path && trailingSlash) {
   path += "/";
  }
  return (isAbsolute ? "/" : "") + path;
 }),
 dirname: (function(path) {
  var result = PATH.splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
   return ".";
  }
  if (dir) {
   dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
 }),
 basename: (function(path) {
  if (path === "/") return "/";
  var lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) return path;
  return path.substr(lastSlash + 1);
 }),
 extname: (function(path) {
  return PATH.splitPath(path)[3];
 }),
 join: (function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return PATH.normalize(paths.join("/"));
 }),
 join2: (function(l, r) {
  return PATH.normalize(l + "/" + r);
 }),
 resolve: (function() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
   var path = i >= 0 ? arguments[i] : FS.cwd();
   if (typeof path !== "string") {
    throw new TypeError("Arguments to path.resolve must be strings");
   } else if (!path) {
    return "";
   }
   resolvedPath = path + "/" + resolvedPath;
   resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((function(p) {
   return !!p;
  })), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
 }),
 relative: (function(from, to) {
  from = PATH.resolve(from).substr(1);
  to = PATH.resolve(to).substr(1);
  function trim(arr) {
   var start = 0;
   for (; start < arr.length; start++) {
    if (arr[start] !== "") break;
   }
   var end = arr.length - 1;
   for (; end >= 0; end--) {
    if (arr[end] !== "") break;
   }
   if (start > end) return [];
   return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
   if (fromParts[i] !== toParts[i]) {
    samePartsLength = i;
    break;
   }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
   outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
 })
};
Module["PATH"] = PATH;
var TTY = {
 ttys: [],
 init: (function() {}),
 shutdown: (function() {}),
 register: (function(dev, ops) {
  TTY.ttys[dev] = {
   input: [],
   output: [],
   ops: ops
  };
  FS.registerDevice(dev, TTY.stream_ops);
 }),
 stream_ops: {
  open: (function(stream) {
   var tty = TTY.ttys[stream.node.rdev];
   if (!tty) {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
   }
   stream.tty = tty;
   stream.seekable = false;
  }),
  close: (function(stream) {
   stream.tty.ops.flush(stream.tty);
  }),
  flush: (function(stream) {
   stream.tty.ops.flush(stream.tty);
  }),
  read: (function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.get_char) {
    throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
   }
   var bytesRead = 0;
   for (var i = 0; i < length; i++) {
    var result;
    try {
     result = stream.tty.ops.get_char(stream.tty);
    } catch (e) {
     throw new FS.ErrnoError(ERRNO_CODES.EIO);
    }
    if (result === undefined && bytesRead === 0) {
     throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
    }
    if (result === null || result === undefined) break;
    bytesRead++;
    buffer[offset + i] = result;
   }
   if (bytesRead) {
    stream.node.timestamp = Date.now();
   }
   return bytesRead;
  }),
  write: (function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.put_char) {
    throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
   }
   for (var i = 0; i < length; i++) {
    try {
     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
    } catch (e) {
     throw new FS.ErrnoError(ERRNO_CODES.EIO);
    }
   }
   if (length) {
    stream.node.timestamp = Date.now();
   }
   return i;
  })
 },
 default_tty_ops: {
  get_char: (function(tty) {
   if (!tty.input.length) {
    var result = null;
    if (ENVIRONMENT_IS_NODE) {
     var BUFSIZE = 256;
     var buf = new Buffer(BUFSIZE);
     var bytesRead = 0;
     var fd = process.stdin.fd;
     var usingDevice = false;
     try {
      fd = fs.openSync("/dev/stdin", "r");
      usingDevice = true;
     } catch (e) {}
     bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
     if (usingDevice) {
      fs.closeSync(fd);
     }
     if (bytesRead > 0) {
      result = buf.slice(0, bytesRead).toString("utf-8");
     } else {
      result = null;
     }
    } else if (typeof window != "undefined" && typeof window.prompt == "function") {
     result = window.prompt("Input: ");
     if (result !== null) {
      result += "\n";
     }
    } else if (typeof readline == "function") {
     result = readline();
     if (result !== null) {
      result += "\n";
     }
    }
    if (!result) {
     return null;
    }
    tty.input = intArrayFromString(result, true);
   }
   return tty.input.shift();
  }),
  put_char: (function(tty, val) {
   if (val === null || val === 10) {
    Module["print"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  }),
  flush: (function(tty) {
   if (tty.output && tty.output.length > 0) {
    Module["print"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  })
 },
 default_tty1_ops: {
  put_char: (function(tty, val) {
   if (val === null || val === 10) {
    Module["printErr"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  }),
  flush: (function(tty) {
   if (tty.output && tty.output.length > 0) {
    Module["printErr"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  })
 }
};
Module["TTY"] = TTY;
var MEMFS = {
 ops_table: null,
 mount: (function(mount) {
  return MEMFS.createNode(null, "/", 16384 | 511, 0);
 }),
 createNode: (function(parent, name, mode, dev) {
  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (!MEMFS.ops_table) {
   MEMFS.ops_table = {
    dir: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      lookup: MEMFS.node_ops.lookup,
      mknod: MEMFS.node_ops.mknod,
      rename: MEMFS.node_ops.rename,
      unlink: MEMFS.node_ops.unlink,
      rmdir: MEMFS.node_ops.rmdir,
      readdir: MEMFS.node_ops.readdir,
      symlink: MEMFS.node_ops.symlink
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek
     }
    },
    file: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek,
      read: MEMFS.stream_ops.read,
      write: MEMFS.stream_ops.write,
      allocate: MEMFS.stream_ops.allocate,
      mmap: MEMFS.stream_ops.mmap,
      msync: MEMFS.stream_ops.msync
     }
    },
    link: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      readlink: MEMFS.node_ops.readlink
     },
     stream: {}
    },
    chrdev: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: FS.chrdev_stream_ops
    }
   };
  }
  var node = FS.createNode(parent, name, mode, dev);
  if (FS.isDir(node.mode)) {
   node.node_ops = MEMFS.ops_table.dir.node;
   node.stream_ops = MEMFS.ops_table.dir.stream;
   node.contents = {};
  } else if (FS.isFile(node.mode)) {
   node.node_ops = MEMFS.ops_table.file.node;
   node.stream_ops = MEMFS.ops_table.file.stream;
   node.usedBytes = 0;
   node.contents = null;
  } else if (FS.isLink(node.mode)) {
   node.node_ops = MEMFS.ops_table.link.node;
   node.stream_ops = MEMFS.ops_table.link.stream;
  } else if (FS.isChrdev(node.mode)) {
   node.node_ops = MEMFS.ops_table.chrdev.node;
   node.stream_ops = MEMFS.ops_table.chrdev.stream;
  }
  node.timestamp = Date.now();
  if (parent) {
   parent.contents[name] = node;
  }
  return node;
 }),
 getFileDataAsRegularArray: (function(node) {
  if (node.contents && node.contents.subarray) {
   var arr = [];
   for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
   return arr;
  }
  return node.contents;
 }),
 getFileDataAsTypedArray: (function(node) {
  if (!node.contents) return new Uint8Array;
  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
  return new Uint8Array(node.contents);
 }),
 expandFileStorage: (function(node, newCapacity) {
  if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
   node.contents = MEMFS.getFileDataAsRegularArray(node);
   node.usedBytes = node.contents.length;
  }
  if (!node.contents || node.contents.subarray) {
   var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
   if (prevCapacity >= newCapacity) return;
   var CAPACITY_DOUBLING_MAX = 1024 * 1024;
   newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);
   if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
   var oldContents = node.contents;
   node.contents = new Uint8Array(newCapacity);
   if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
   return;
  }
  if (!node.contents && newCapacity > 0) node.contents = [];
  while (node.contents.length < newCapacity) node.contents.push(0);
 }),
 resizeFileStorage: (function(node, newSize) {
  if (node.usedBytes == newSize) return;
  if (newSize == 0) {
   node.contents = null;
   node.usedBytes = 0;
   return;
  }
  if (!node.contents || node.contents.subarray) {
   var oldContents = node.contents;
   node.contents = new Uint8Array(new ArrayBuffer(newSize));
   if (oldContents) {
    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
   }
   node.usedBytes = newSize;
   return;
  }
  if (!node.contents) node.contents = [];
  if (node.contents.length > newSize) node.contents.length = newSize; else while (node.contents.length < newSize) node.contents.push(0);
  node.usedBytes = newSize;
 }),
 node_ops: {
  getattr: (function(node) {
   var attr = {};
   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
   attr.ino = node.id;
   attr.mode = node.mode;
   attr.nlink = 1;
   attr.uid = 0;
   attr.gid = 0;
   attr.rdev = node.rdev;
   if (FS.isDir(node.mode)) {
    attr.size = 4096;
   } else if (FS.isFile(node.mode)) {
    attr.size = node.usedBytes;
   } else if (FS.isLink(node.mode)) {
    attr.size = node.link.length;
   } else {
    attr.size = 0;
   }
   attr.atime = new Date(node.timestamp);
   attr.mtime = new Date(node.timestamp);
   attr.ctime = new Date(node.timestamp);
   attr.blksize = 4096;
   attr.blocks = Math.ceil(attr.size / attr.blksize);
   return attr;
  }),
  setattr: (function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
   if (attr.size !== undefined) {
    MEMFS.resizeFileStorage(node, attr.size);
   }
  }),
  lookup: (function(parent, name) {
   throw FS.genericErrors[ERRNO_CODES.ENOENT];
  }),
  mknod: (function(parent, name, mode, dev) {
   return MEMFS.createNode(parent, name, mode, dev);
  }),
  rename: (function(old_node, new_dir, new_name) {
   if (FS.isDir(old_node.mode)) {
    var new_node;
    try {
     new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    if (new_node) {
     for (var i in new_node.contents) {
      throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
     }
    }
   }
   delete old_node.parent.contents[old_node.name];
   old_node.name = new_name;
   new_dir.contents[new_name] = old_node;
   old_node.parent = new_dir;
  }),
  unlink: (function(parent, name) {
   delete parent.contents[name];
  }),
  rmdir: (function(parent, name) {
   var node = FS.lookupNode(parent, name);
   for (var i in node.contents) {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
   }
   delete parent.contents[name];
  }),
  readdir: (function(node) {
   var entries = [ ".", ".." ];
   for (var key in node.contents) {
    if (!node.contents.hasOwnProperty(key)) {
     continue;
    }
    entries.push(key);
   }
   return entries;
  }),
  symlink: (function(parent, newname, oldpath) {
   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
   node.link = oldpath;
   return node;
  }),
  readlink: (function(node) {
   if (!FS.isLink(node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return node.link;
  })
 },
 stream_ops: {
  read: (function(stream, buffer, offset, length, position) {
   var contents = stream.node.contents;
   if (position >= stream.node.usedBytes) return 0;
   var size = Math.min(stream.node.usedBytes - position, length);
   assert(size >= 0);
   if (size > 8 && contents.subarray) {
    buffer.set(contents.subarray(position, position + size), offset);
   } else {
    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
   }
   return size;
  }),
  write: (function(stream, buffer, offset, length, position, canOwn) {
   if (!length) return 0;
   var node = stream.node;
   node.timestamp = Date.now();
   if (buffer.subarray && (!node.contents || node.contents.subarray)) {
    if (canOwn) {
     node.contents = buffer.subarray(offset, offset + length);
     node.usedBytes = length;
     return length;
    } else if (node.usedBytes === 0 && position === 0) {
     node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
     node.usedBytes = length;
     return length;
    } else if (position + length <= node.usedBytes) {
     node.contents.set(buffer.subarray(offset, offset + length), position);
     return length;
    }
   }
   MEMFS.expandFileStorage(node, position + length);
   if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); else {
    for (var i = 0; i < length; i++) {
     node.contents[position + i] = buffer[offset + i];
    }
   }
   node.usedBytes = Math.max(node.usedBytes, position + length);
   return length;
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.usedBytes;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return position;
  }),
  allocate: (function(stream, offset, length) {
   MEMFS.expandFileStorage(stream.node, offset + length);
   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
  }),
  mmap: (function(stream, buffer, offset, length, position, prot, flags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
   }
   var ptr;
   var allocated;
   var contents = stream.node.contents;
   if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {
    allocated = false;
    ptr = contents.byteOffset;
   } else {
    if (position > 0 || position + length < stream.node.usedBytes) {
     if (contents.subarray) {
      contents = contents.subarray(position, position + length);
     } else {
      contents = Array.prototype.slice.call(contents, position, position + length);
     }
    }
    allocated = true;
    ptr = _malloc(length);
    if (!ptr) {
     throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
    }
    buffer.set(contents, ptr);
   }
   return {
    ptr: ptr,
    allocated: allocated
   };
  }),
  msync: (function(stream, buffer, offset, length, mmapFlags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
   }
   if (mmapFlags & 2) {
    return 0;
   }
   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
   return 0;
  })
 }
};
Module["MEMFS"] = MEMFS;
var IDBFS = {
 dbs: {},
 indexedDB: (function() {
  if (typeof indexedDB !== "undefined") return indexedDB;
  var ret = null;
  if (typeof window === "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
  assert(ret, "IDBFS used, but indexedDB not supported");
  return ret;
 }),
 DB_VERSION: 21,
 DB_STORE_NAME: "FILE_DATA",
 mount: (function(mount) {
  return MEMFS.mount.apply(null, arguments);
 }),
 syncfs: (function(mount, populate, callback) {
  IDBFS.getLocalSet(mount, (function(err, local) {
   if (err) return callback(err);
   IDBFS.getRemoteSet(mount, (function(err, remote) {
    if (err) return callback(err);
    var src = populate ? remote : local;
    var dst = populate ? local : remote;
    IDBFS.reconcile(src, dst, callback);
   }));
  }));
 }),
 getDB: (function(name, callback) {
  var db = IDBFS.dbs[name];
  if (db) {
   return callback(null, db);
  }
  var req;
  try {
   req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
  } catch (e) {
   return callback(e);
  }
  req.onupgradeneeded = (function(e) {
   var db = e.target.result;
   var transaction = e.target.transaction;
   var fileStore;
   if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
    fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
   } else {
    fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
   }
   if (!fileStore.indexNames.contains("timestamp")) {
    fileStore.createIndex("timestamp", "timestamp", {
     unique: false
    });
   }
  });
  req.onsuccess = (function() {
   db = req.result;
   IDBFS.dbs[name] = db;
   callback(null, db);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 getLocalSet: (function(mount, callback) {
  var entries = {};
  function isRealDir(p) {
   return p !== "." && p !== "..";
  }
  function toAbsolute(root) {
   return (function(p) {
    return PATH.join2(root, p);
   });
  }
  var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  while (check.length) {
   var path = check.pop();
   var stat;
   try {
    stat = FS.stat(path);
   } catch (e) {
    return callback(e);
   }
   if (FS.isDir(stat.mode)) {
    check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
   }
   entries[path] = {
    timestamp: stat.mtime
   };
  }
  return callback(null, {
   type: "local",
   entries: entries
  });
 }),
 getRemoteSet: (function(mount, callback) {
  var entries = {};
  IDBFS.getDB(mount.mountpoint, (function(err, db) {
   if (err) return callback(err);
   var transaction = db.transaction([ IDBFS.DB_STORE_NAME ], "readonly");
   transaction.onerror = (function(e) {
    callback(this.error);
    e.preventDefault();
   });
   var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
   var index = store.index("timestamp");
   index.openKeyCursor().onsuccess = (function(event) {
    var cursor = event.target.result;
    if (!cursor) {
     return callback(null, {
      type: "remote",
      db: db,
      entries: entries
     });
    }
    entries[cursor.primaryKey] = {
     timestamp: cursor.key
    };
    cursor.continue();
   });
  }));
 }),
 loadLocalEntry: (function(path, callback) {
  var stat, node;
  try {
   var lookup = FS.lookupPath(path);
   node = lookup.node;
   stat = FS.stat(path);
  } catch (e) {
   return callback(e);
  }
  if (FS.isDir(stat.mode)) {
   return callback(null, {
    timestamp: stat.mtime,
    mode: stat.mode
   });
  } else if (FS.isFile(stat.mode)) {
   node.contents = MEMFS.getFileDataAsTypedArray(node);
   return callback(null, {
    timestamp: stat.mtime,
    mode: stat.mode,
    contents: node.contents
   });
  } else {
   return callback(new Error("node type not supported"));
  }
 }),
 storeLocalEntry: (function(path, entry, callback) {
  try {
   if (FS.isDir(entry.mode)) {
    FS.mkdir(path, entry.mode);
   } else if (FS.isFile(entry.mode)) {
    FS.writeFile(path, entry.contents, {
     encoding: "binary",
     canOwn: true
    });
   } else {
    return callback(new Error("node type not supported"));
   }
   FS.chmod(path, entry.mode);
   FS.utime(path, entry.timestamp, entry.timestamp);
  } catch (e) {
   return callback(e);
  }
  callback(null);
 }),
 removeLocalEntry: (function(path, callback) {
  try {
   var lookup = FS.lookupPath(path);
   var stat = FS.stat(path);
   if (FS.isDir(stat.mode)) {
    FS.rmdir(path);
   } else if (FS.isFile(stat.mode)) {
    FS.unlink(path);
   }
  } catch (e) {
   return callback(e);
  }
  callback(null);
 }),
 loadRemoteEntry: (function(store, path, callback) {
  var req = store.get(path);
  req.onsuccess = (function(event) {
   callback(null, event.target.result);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 storeRemoteEntry: (function(store, path, entry, callback) {
  var req = store.put(entry, path);
  req.onsuccess = (function() {
   callback(null);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 removeRemoteEntry: (function(store, path, callback) {
  var req = store.delete(path);
  req.onsuccess = (function() {
   callback(null);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 reconcile: (function(src, dst, callback) {
  var total = 0;
  var create = [];
  Object.keys(src.entries).forEach((function(key) {
   var e = src.entries[key];
   var e2 = dst.entries[key];
   if (!e2 || e.timestamp > e2.timestamp) {
    create.push(key);
    total++;
   }
  }));
  var remove = [];
  Object.keys(dst.entries).forEach((function(key) {
   var e = dst.entries[key];
   var e2 = src.entries[key];
   if (!e2) {
    remove.push(key);
    total++;
   }
  }));
  if (!total) {
   return callback(null);
  }
  var completed = 0;
  var db = src.type === "remote" ? src.db : dst.db;
  var transaction = db.transaction([ IDBFS.DB_STORE_NAME ], "readwrite");
  var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  function done(err) {
   if (err) {
    if (!done.errored) {
     done.errored = true;
     return callback(err);
    }
    return;
   }
   if (++completed >= total) {
    return callback(null);
   }
  }
  transaction.onerror = (function(e) {
   done(this.error);
   e.preventDefault();
  });
  create.sort().forEach((function(path) {
   if (dst.type === "local") {
    IDBFS.loadRemoteEntry(store, path, (function(err, entry) {
     if (err) return done(err);
     IDBFS.storeLocalEntry(path, entry, done);
    }));
   } else {
    IDBFS.loadLocalEntry(path, (function(err, entry) {
     if (err) return done(err);
     IDBFS.storeRemoteEntry(store, path, entry, done);
    }));
   }
  }));
  remove.sort().reverse().forEach((function(path) {
   if (dst.type === "local") {
    IDBFS.removeLocalEntry(path, done);
   } else {
    IDBFS.removeRemoteEntry(store, path, done);
   }
  }));
 })
};
Module["IDBFS"] = IDBFS;
var NODEFS = {
 isWindows: false,
 staticInit: (function() {
  NODEFS.isWindows = !!process.platform.match(/^win/);
 }),
 mount: (function(mount) {
  assert(ENVIRONMENT_IS_NODE);
  return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
 }),
 createNode: (function(parent, name, mode, dev) {
  if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var node = FS.createNode(parent, name, mode);
  node.node_ops = NODEFS.node_ops;
  node.stream_ops = NODEFS.stream_ops;
  return node;
 }),
 getMode: (function(path) {
  var stat;
  try {
   stat = fs.lstatSync(path);
   if (NODEFS.isWindows) {
    stat.mode = stat.mode | (stat.mode & 146) >> 1;
   }
  } catch (e) {
   if (!e.code) throw e;
   throw new FS.ErrnoError(ERRNO_CODES[e.code]);
  }
  return stat.mode;
 }),
 realPath: (function(node) {
  var parts = [];
  while (node.parent !== node) {
   parts.push(node.name);
   node = node.parent;
  }
  parts.push(node.mount.opts.root);
  parts.reverse();
  return PATH.join.apply(null, parts);
 }),
 flagsToPermissionStringMap: {
  0: "r",
  1: "r+",
  2: "r+",
  64: "r",
  65: "r+",
  66: "r+",
  129: "rx+",
  193: "rx+",
  514: "w+",
  577: "w",
  578: "w+",
  705: "wx",
  706: "wx+",
  1024: "a",
  1025: "a",
  1026: "a+",
  1089: "a",
  1090: "a+",
  1153: "ax",
  1154: "ax+",
  1217: "ax",
  1218: "ax+",
  4096: "rs",
  4098: "rs+"
 },
 flagsToPermissionString: (function(flags) {
  flags &= ~32768;
  flags &= ~524288;
  if (flags in NODEFS.flagsToPermissionStringMap) {
   return NODEFS.flagsToPermissionStringMap[flags];
  } else {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
 }),
 node_ops: {
  getattr: (function(node) {
   var path = NODEFS.realPath(node);
   var stat;
   try {
    stat = fs.lstatSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   if (NODEFS.isWindows && !stat.blksize) {
    stat.blksize = 4096;
   }
   if (NODEFS.isWindows && !stat.blocks) {
    stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
   }
   return {
    dev: stat.dev,
    ino: stat.ino,
    mode: stat.mode,
    nlink: stat.nlink,
    uid: stat.uid,
    gid: stat.gid,
    rdev: stat.rdev,
    size: stat.size,
    atime: stat.atime,
    mtime: stat.mtime,
    ctime: stat.ctime,
    blksize: stat.blksize,
    blocks: stat.blocks
   };
  }),
  setattr: (function(node, attr) {
   var path = NODEFS.realPath(node);
   try {
    if (attr.mode !== undefined) {
     fs.chmodSync(path, attr.mode);
     node.mode = attr.mode;
    }
    if (attr.timestamp !== undefined) {
     var date = new Date(attr.timestamp);
     fs.utimesSync(path, date, date);
    }
    if (attr.size !== undefined) {
     fs.truncateSync(path, attr.size);
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  lookup: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   var mode = NODEFS.getMode(path);
   return NODEFS.createNode(parent, name, mode);
  }),
  mknod: (function(parent, name, mode, dev) {
   var node = NODEFS.createNode(parent, name, mode, dev);
   var path = NODEFS.realPath(node);
   try {
    if (FS.isDir(node.mode)) {
     fs.mkdirSync(path, node.mode);
    } else {
     fs.writeFileSync(path, "", {
      mode: node.mode
     });
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   return node;
  }),
  rename: (function(oldNode, newDir, newName) {
   var oldPath = NODEFS.realPath(oldNode);
   var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
   try {
    fs.renameSync(oldPath, newPath);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  unlink: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   try {
    fs.unlinkSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  rmdir: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   try {
    fs.rmdirSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  readdir: (function(node) {
   var path = NODEFS.realPath(node);
   try {
    return fs.readdirSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  symlink: (function(parent, newName, oldPath) {
   var newPath = PATH.join2(NODEFS.realPath(parent), newName);
   try {
    fs.symlinkSync(oldPath, newPath);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  readlink: (function(node) {
   var path = NODEFS.realPath(node);
   try {
    path = fs.readlinkSync(path);
    path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
    return path;
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  })
 },
 stream_ops: {
  open: (function(stream) {
   var path = NODEFS.realPath(stream.node);
   try {
    if (FS.isFile(stream.node.mode)) {
     stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  close: (function(stream) {
   try {
    if (FS.isFile(stream.node.mode) && stream.nfd) {
     fs.closeSync(stream.nfd);
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  read: (function(stream, buffer, offset, length, position) {
   if (length === 0) return 0;
   var nbuffer = new Buffer(length);
   var res;
   try {
    res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
   } catch (e) {
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   if (res > 0) {
    for (var i = 0; i < res; i++) {
     buffer[offset + i] = nbuffer[i];
    }
   }
   return res;
  }),
  write: (function(stream, buffer, offset, length, position) {
   var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
   var res;
   try {
    res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
   } catch (e) {
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   return res;
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     try {
      var stat = fs.fstatSync(stream.nfd);
      position += stat.size;
     } catch (e) {
      throw new FS.ErrnoError(ERRNO_CODES[e.code]);
     }
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return position;
  })
 }
};
Module["NODEFS"] = NODEFS;
var WORKERFS = {
 DIR_MODE: 16895,
 FILE_MODE: 33279,
 reader: null,
 mount: (function(mount) {
  assert(ENVIRONMENT_IS_WORKER);
  if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync;
  var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0);
  var createdParents = {};
  function ensureParent(path) {
   var parts = path.split("/");
   var parent = root;
   for (var i = 0; i < parts.length - 1; i++) {
    var curr = parts.slice(0, i + 1).join("/");
    if (!createdParents[curr]) {
     createdParents[curr] = WORKERFS.createNode(parent, curr, WORKERFS.DIR_MODE, 0);
    }
    parent = createdParents[curr];
   }
   return parent;
  }
  function base(path) {
   var parts = path.split("/");
   return parts[parts.length - 1];
  }
  Array.prototype.forEach.call(mount.opts["files"] || [], (function(file) {
   WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);
  }));
  (mount.opts["blobs"] || []).forEach((function(obj) {
   WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);
  }));
  (mount.opts["packages"] || []).forEach((function(pack) {
   pack["metadata"].files.forEach((function(file) {
    var name = file.filename.substr(1);
    WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack["blob"].slice(file.start, file.end));
   }));
  }));
  return root;
 }),
 createNode: (function(parent, name, mode, dev, contents, mtime) {
  var node = FS.createNode(parent, name, mode);
  node.mode = mode;
  node.node_ops = WORKERFS.node_ops;
  node.stream_ops = WORKERFS.stream_ops;
  node.timestamp = (mtime || new Date).getTime();
  assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
  if (mode === WORKERFS.FILE_MODE) {
   node.size = contents.size;
   node.contents = contents;
  } else {
   node.size = 4096;
   node.contents = {};
  }
  if (parent) {
   parent.contents[name] = node;
  }
  return node;
 }),
 node_ops: {
  getattr: (function(node) {
   return {
    dev: 1,
    ino: undefined,
    mode: node.mode,
    nlink: 1,
    uid: 0,
    gid: 0,
    rdev: undefined,
    size: node.size,
    atime: new Date(node.timestamp),
    mtime: new Date(node.timestamp),
    ctime: new Date(node.timestamp),
    blksize: 4096,
    blocks: Math.ceil(node.size / 4096)
   };
  }),
  setattr: (function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
  }),
  lookup: (function(parent, name) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }),
  mknod: (function(parent, name, mode, dev) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  rename: (function(oldNode, newDir, newName) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  unlink: (function(parent, name) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  rmdir: (function(parent, name) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  readdir: (function(node) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  symlink: (function(parent, newName, oldPath) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  readlink: (function(node) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  })
 },
 stream_ops: {
  read: (function(stream, buffer, offset, length, position) {
   if (position >= stream.node.size) return 0;
   var chunk = stream.node.contents.slice(position, position + length);
   var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
   buffer.set(new Uint8Array(ab), offset);
   return chunk.size;
  }),
  write: (function(stream, buffer, offset, length, position) {
   throw new FS.ErrnoError(ERRNO_CODES.EIO);
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.size;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return position;
  })
 }
};
Module["WORKERFS"] = WORKERFS;
var _stdin = STATICTOP;
STATICTOP += 16;
Module["_stdin"] = _stdin;
var _stdout = STATICTOP;
STATICTOP += 16;
Module["_stdout"] = _stdout;
var _stderr = STATICTOP;
STATICTOP += 16;
Module["_stderr"] = _stderr;
var FS = {
 root: null,
 mounts: [],
 devices: [ null ],
 streams: [],
 nextInode: 1,
 nameTable: null,
 currentPath: "/",
 initialized: false,
 ignorePermissions: true,
 trackingDelegate: {},
 tracking: {
  openFlags: {
   READ: 1,
   WRITE: 2
  }
 },
 ErrnoError: null,
 genericErrors: {},
 filesystems: null,
 syncFSRequests: 0,
 handleFSError: (function(e) {
  if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
  return ___setErrNo(e.errno);
 }),
 lookupPath: (function(path, opts) {
  path = PATH.resolve(FS.cwd(), path);
  opts = opts || {};
  if (!path) return {
   path: "",
   node: null
  };
  var defaults = {
   follow_mount: true,
   recurse_count: 0
  };
  for (var key in defaults) {
   if (opts[key] === undefined) {
    opts[key] = defaults[key];
   }
  }
  if (opts.recurse_count > 8) {
   throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
  }
  var parts = PATH.normalizeArray(path.split("/").filter((function(p) {
   return !!p;
  })), false);
  var current = FS.root;
  var current_path = "/";
  for (var i = 0; i < parts.length; i++) {
   var islast = i === parts.length - 1;
   if (islast && opts.parent) {
    break;
   }
   current = FS.lookupNode(current, parts[i]);
   current_path = PATH.join2(current_path, parts[i]);
   if (FS.isMountpoint(current)) {
    if (!islast || islast && opts.follow_mount) {
     current = current.mounted.root;
    }
   }
   if (!islast || opts.follow) {
    var count = 0;
    while (FS.isLink(current.mode)) {
     var link = FS.readlink(current_path);
     current_path = PATH.resolve(PATH.dirname(current_path), link);
     var lookup = FS.lookupPath(current_path, {
      recurse_count: opts.recurse_count
     });
     current = lookup.node;
     if (count++ > 40) {
      throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
     }
    }
   }
  }
  return {
   path: current_path,
   node: current
  };
 }),
 getPath: (function(node) {
  var path;
  while (true) {
   if (FS.isRoot(node)) {
    var mount = node.mount.mountpoint;
    if (!path) return mount;
    return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
   }
   path = path ? node.name + "/" + path : node.name;
   node = node.parent;
  }
 }),
 hashName: (function(parentid, name) {
  var hash = 0;
  for (var i = 0; i < name.length; i++) {
   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
  }
  return (parentid + hash >>> 0) % FS.nameTable.length;
 }),
 hashAddNode: (function(node) {
  var hash = FS.hashName(node.parent.id, node.name);
  node.name_next = FS.nameTable[hash];
  FS.nameTable[hash] = node;
 }),
 hashRemoveNode: (function(node) {
  var hash = FS.hashName(node.parent.id, node.name);
  if (FS.nameTable[hash] === node) {
   FS.nameTable[hash] = node.name_next;
  } else {
   var current = FS.nameTable[hash];
   while (current) {
    if (current.name_next === node) {
     current.name_next = node.name_next;
     break;
    }
    current = current.name_next;
   }
  }
 }),
 lookupNode: (function(parent, name) {
  var err = FS.mayLookup(parent);
  if (err) {
   throw new FS.ErrnoError(err, parent);
  }
  var hash = FS.hashName(parent.id, name);
  for (var node = FS.nameTable[hash]; node; node = node.name_next) {
   var nodeName = node.name;
   if (node.parent.id === parent.id && nodeName === name) {
    return node;
   }
  }
  return FS.lookup(parent, name);
 }),
 createNode: (function(parent, name, mode, rdev) {
  if (!FS.FSNode) {
   FS.FSNode = (function(parent, name, mode, rdev) {
    if (!parent) {
     parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
   });
   FS.FSNode.prototype = {};
   var readMode = 292 | 73;
   var writeMode = 146;
   Object.defineProperties(FS.FSNode.prototype, {
    read: {
     get: (function() {
      return (this.mode & readMode) === readMode;
     }),
     set: (function(val) {
      val ? this.mode |= readMode : this.mode &= ~readMode;
     })
    },
    write: {
     get: (function() {
      return (this.mode & writeMode) === writeMode;
     }),
     set: (function(val) {
      val ? this.mode |= writeMode : this.mode &= ~writeMode;
     })
    },
    isFolder: {
     get: (function() {
      return FS.isDir(this.mode);
     })
    },
    isDevice: {
     get: (function() {
      return FS.isChrdev(this.mode);
     })
    }
   });
  }
  var node = new FS.FSNode(parent, name, mode, rdev);
  FS.hashAddNode(node);
  return node;
 }),
 destroyNode: (function(node) {
  FS.hashRemoveNode(node);
 }),
 isRoot: (function(node) {
  return node === node.parent;
 }),
 isMountpoint: (function(node) {
  return !!node.mounted;
 }),
 isFile: (function(mode) {
  return (mode & 61440) === 32768;
 }),
 isDir: (function(mode) {
  return (mode & 61440) === 16384;
 }),
 isLink: (function(mode) {
  return (mode & 61440) === 40960;
 }),
 isChrdev: (function(mode) {
  return (mode & 61440) === 8192;
 }),
 isBlkdev: (function(mode) {
  return (mode & 61440) === 24576;
 }),
 isFIFO: (function(mode) {
  return (mode & 61440) === 4096;
 }),
 isSocket: (function(mode) {
  return (mode & 49152) === 49152;
 }),
 flagModes: {
  "r": 0,
  "rs": 1052672,
  "r+": 2,
  "w": 577,
  "wx": 705,
  "xw": 705,
  "w+": 578,
  "wx+": 706,
  "xw+": 706,
  "a": 1089,
  "ax": 1217,
  "xa": 1217,
  "a+": 1090,
  "ax+": 1218,
  "xa+": 1218
 },
 modeStringToFlags: (function(str) {
  var flags = FS.flagModes[str];
  if (typeof flags === "undefined") {
   throw new Error("Unknown file open mode: " + str);
  }
  return flags;
 }),
 flagsToPermissionString: (function(flag) {
  var perms = [ "r", "w", "rw" ][flag & 3];
  if (flag & 512) {
   perms += "w";
  }
  return perms;
 }),
 nodePermissions: (function(node, perms) {
  if (FS.ignorePermissions) {
   return 0;
  }
  if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
   return ERRNO_CODES.EACCES;
  } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
   return ERRNO_CODES.EACCES;
  } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
   return ERRNO_CODES.EACCES;
  }
  return 0;
 }),
 mayLookup: (function(dir) {
  var err = FS.nodePermissions(dir, "x");
  if (err) return err;
  if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
  return 0;
 }),
 mayCreate: (function(dir, name) {
  try {
   var node = FS.lookupNode(dir, name);
   return ERRNO_CODES.EEXIST;
  } catch (e) {}
  return FS.nodePermissions(dir, "wx");
 }),
 mayDelete: (function(dir, name, isdir) {
  var node;
  try {
   node = FS.lookupNode(dir, name);
  } catch (e) {
   return e.errno;
  }
  var err = FS.nodePermissions(dir, "wx");
  if (err) {
   return err;
  }
  if (isdir) {
   if (!FS.isDir(node.mode)) {
    return ERRNO_CODES.ENOTDIR;
   }
   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
    return ERRNO_CODES.EBUSY;
   }
  } else {
   if (FS.isDir(node.mode)) {
    return ERRNO_CODES.EISDIR;
   }
  }
  return 0;
 }),
 mayOpen: (function(node, flags) {
  if (!node) {
   return ERRNO_CODES.ENOENT;
  }
  if (FS.isLink(node.mode)) {
   return ERRNO_CODES.ELOOP;
  } else if (FS.isDir(node.mode)) {
   if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
    return ERRNO_CODES.EISDIR;
   }
  }
  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
 }),
 MAX_OPEN_FDS: 4096,
 nextfd: (function(fd_start, fd_end) {
  fd_start = fd_start || 0;
  fd_end = fd_end || FS.MAX_OPEN_FDS;
  for (var fd = fd_start; fd <= fd_end; fd++) {
   if (!FS.streams[fd]) {
    return fd;
   }
  }
  throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
 }),
 getStream: (function(fd) {
  return FS.streams[fd];
 }),
 createStream: (function(stream, fd_start, fd_end) {
  if (!FS.FSStream) {
   FS.FSStream = (function() {});
   FS.FSStream.prototype = {};
   Object.defineProperties(FS.FSStream.prototype, {
    object: {
     get: (function() {
      return this.node;
     }),
     set: (function(val) {
      this.node = val;
     })
    },
    isRead: {
     get: (function() {
      return (this.flags & 2097155) !== 1;
     })
    },
    isWrite: {
     get: (function() {
      return (this.flags & 2097155) !== 0;
     })
    },
    isAppend: {
     get: (function() {
      return this.flags & 1024;
     })
    }
   });
  }
  var newStream = new FS.FSStream;
  for (var p in stream) {
   newStream[p] = stream[p];
  }
  stream = newStream;
  var fd = FS.nextfd(fd_start, fd_end);
  stream.fd = fd;
  FS.streams[fd] = stream;
  return stream;
 }),
 closeStream: (function(fd) {
  FS.streams[fd] = null;
 }),
 chrdev_stream_ops: {
  open: (function(stream) {
   var device = FS.getDevice(stream.node.rdev);
   stream.stream_ops = device.stream_ops;
   if (stream.stream_ops.open) {
    stream.stream_ops.open(stream);
   }
  }),
  llseek: (function() {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  })
 },
 major: (function(dev) {
  return dev >> 8;
 }),
 minor: (function(dev) {
  return dev & 255;
 }),
 makedev: (function(ma, mi) {
  return ma << 8 | mi;
 }),
 registerDevice: (function(dev, ops) {
  FS.devices[dev] = {
   stream_ops: ops
  };
 }),
 getDevice: (function(dev) {
  return FS.devices[dev];
 }),
 getMounts: (function(mount) {
  var mounts = [];
  var check = [ mount ];
  while (check.length) {
   var m = check.pop();
   mounts.push(m);
   check.push.apply(check, m.mounts);
  }
  return mounts;
 }),
 syncfs: (function(populate, callback) {
  if (typeof populate === "function") {
   callback = populate;
   populate = false;
  }
  FS.syncFSRequests++;
  if (FS.syncFSRequests > 1) {
   console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
  }
  var mounts = FS.getMounts(FS.root.mount);
  var completed = 0;
  function doCallback(err) {
   assert(FS.syncFSRequests > 0);
   FS.syncFSRequests--;
   return callback(err);
  }
  function done(err) {
   if (err) {
    if (!done.errored) {
     done.errored = true;
     return doCallback(err);
    }
    return;
   }
   if (++completed >= mounts.length) {
    doCallback(null);
   }
  }
  mounts.forEach((function(mount) {
   if (!mount.type.syncfs) {
    return done(null);
   }
   mount.type.syncfs(mount, populate, done);
  }));
 }),
 mount: (function(type, opts, mountpoint) {
  var root = mountpoint === "/";
  var pseudo = !mountpoint;
  var node;
  if (root && FS.root) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  } else if (!root && !pseudo) {
   var lookup = FS.lookupPath(mountpoint, {
    follow_mount: false
   });
   mountpoint = lookup.path;
   node = lookup.node;
   if (FS.isMountpoint(node)) {
    throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
   }
   if (!FS.isDir(node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
   }
  }
  var mount = {
   type: type,
   opts: opts,
   mountpoint: mountpoint,
   mounts: []
  };
  var mountRoot = type.mount(mount);
  mountRoot.mount = mount;
  mount.root = mountRoot;
  if (root) {
   FS.root = mountRoot;
  } else if (node) {
   node.mounted = mount;
   if (node.mount) {
    node.mount.mounts.push(mount);
   }
  }
  return mountRoot;
 }),
 unmount: (function(mountpoint) {
  var lookup = FS.lookupPath(mountpoint, {
   follow_mount: false
  });
  if (!FS.isMountpoint(lookup.node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var node = lookup.node;
  var mount = node.mounted;
  var mounts = FS.getMounts(mount);
  Object.keys(FS.nameTable).forEach((function(hash) {
   var current = FS.nameTable[hash];
   while (current) {
    var next = current.name_next;
    if (mounts.indexOf(current.mount) !== -1) {
     FS.destroyNode(current);
    }
    current = next;
   }
  }));
  node.mounted = null;
  var idx = node.mount.mounts.indexOf(mount);
  assert(idx !== -1);
  node.mount.mounts.splice(idx, 1);
 }),
 lookup: (function(parent, name) {
  return parent.node_ops.lookup(parent, name);
 }),
 mknod: (function(path, mode, dev) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  if (!name || name === "." || name === "..") {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var err = FS.mayCreate(parent, name);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.mknod) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  return parent.node_ops.mknod(parent, name, mode, dev);
 }),
 create: (function(path, mode) {
  mode = mode !== undefined ? mode : 438;
  mode &= 4095;
  mode |= 32768;
  return FS.mknod(path, mode, 0);
 }),
 mkdir: (function(path, mode) {
  mode = mode !== undefined ? mode : 511;
  mode &= 511 | 512;
  mode |= 16384;
  return FS.mknod(path, mode, 0);
 }),
 mkdev: (function(path, mode, dev) {
  if (typeof dev === "undefined") {
   dev = mode;
   mode = 438;
  }
  mode |= 8192;
  return FS.mknod(path, mode, dev);
 }),
 symlink: (function(oldpath, newpath) {
  if (!PATH.resolve(oldpath)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  var lookup = FS.lookupPath(newpath, {
   parent: true
  });
  var parent = lookup.node;
  if (!parent) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  var newname = PATH.basename(newpath);
  var err = FS.mayCreate(parent, newname);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.symlink) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  return parent.node_ops.symlink(parent, newname, oldpath);
 }),
 rename: (function(old_path, new_path) {
  var old_dirname = PATH.dirname(old_path);
  var new_dirname = PATH.dirname(new_path);
  var old_name = PATH.basename(old_path);
  var new_name = PATH.basename(new_path);
  var lookup, old_dir, new_dir;
  try {
   lookup = FS.lookupPath(old_path, {
    parent: true
   });
   old_dir = lookup.node;
   lookup = FS.lookupPath(new_path, {
    parent: true
   });
   new_dir = lookup.node;
  } catch (e) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  if (old_dir.mount !== new_dir.mount) {
   throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
  }
  var old_node = FS.lookupNode(old_dir, old_name);
  var relative = PATH.relative(old_path, new_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  relative = PATH.relative(new_path, old_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
  }
  var new_node;
  try {
   new_node = FS.lookupNode(new_dir, new_name);
  } catch (e) {}
  if (old_node === new_node) {
   return;
  }
  var isdir = FS.isDir(old_node.mode);
  var err = FS.mayDelete(old_dir, old_name, isdir);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!old_dir.node_ops.rename) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  if (new_dir !== old_dir) {
   err = FS.nodePermissions(old_dir, "w");
   if (err) {
    throw new FS.ErrnoError(err);
   }
  }
  try {
   if (FS.trackingDelegate["willMovePath"]) {
    FS.trackingDelegate["willMovePath"](old_path, new_path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
  }
  FS.hashRemoveNode(old_node);
  try {
   old_dir.node_ops.rename(old_node, new_dir, new_name);
  } catch (e) {
   throw e;
  } finally {
   FS.hashAddNode(old_node);
  }
  try {
   if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path);
  } catch (e) {
   console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
  }
 }),
 rmdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var err = FS.mayDelete(parent, name, true);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.rmdir) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  try {
   if (FS.trackingDelegate["willDeletePath"]) {
    FS.trackingDelegate["willDeletePath"](path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
  }
  parent.node_ops.rmdir(parent, name);
  FS.destroyNode(node);
  try {
   if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
  } catch (e) {
   console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
  }
 }),
 readdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  if (!node.node_ops.readdir) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
  }
  return node.node_ops.readdir(node);
 }),
 unlink: (function(path) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var err = FS.mayDelete(parent, name, false);
  if (err) {
   if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.unlink) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  try {
   if (FS.trackingDelegate["willDeletePath"]) {
    FS.trackingDelegate["willDeletePath"](path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
  }
  parent.node_ops.unlink(parent, name);
  FS.destroyNode(node);
  try {
   if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
  } catch (e) {
   console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
  }
 }),
 readlink: (function(path) {
  var lookup = FS.lookupPath(path);
  var link = lookup.node;
  if (!link) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  if (!link.node_ops.readlink) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
 }),
 stat: (function(path, dontFollow) {
  var lookup = FS.lookupPath(path, {
   follow: !dontFollow
  });
  var node = lookup.node;
  if (!node) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  if (!node.node_ops.getattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  return node.node_ops.getattr(node);
 }),
 lstat: (function(path) {
  return FS.stat(path, true);
 }),
 chmod: (function(path, mode, dontFollow) {
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  node.node_ops.setattr(node, {
   mode: mode & 4095 | node.mode & ~4095,
   timestamp: Date.now()
  });
 }),
 lchmod: (function(path, mode) {
  FS.chmod(path, mode, true);
 }),
 fchmod: (function(fd, mode) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  FS.chmod(stream.node, mode);
 }),
 chown: (function(path, uid, gid, dontFollow) {
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  node.node_ops.setattr(node, {
   timestamp: Date.now()
  });
 }),
 lchown: (function(path, uid, gid) {
  FS.chown(path, uid, gid, true);
 }),
 fchown: (function(fd, uid, gid) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  FS.chown(stream.node, uid, gid);
 }),
 truncate: (function(path, len) {
  if (len < 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: true
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isDir(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
  }
  if (!FS.isFile(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var err = FS.nodePermissions(node, "w");
  if (err) {
   throw new FS.ErrnoError(err);
  }
  node.node_ops.setattr(node, {
   size: len,
   timestamp: Date.now()
  });
 }),
 ftruncate: (function(fd, len) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  FS.truncate(stream.node, len);
 }),
 utime: (function(path, atime, mtime) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  node.node_ops.setattr(node, {
   timestamp: Math.max(atime, mtime)
  });
 }),
 open: (function(path, flags, mode, fd_start, fd_end) {
  if (path === "") {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
  mode = typeof mode === "undefined" ? 438 : mode;
  if (flags & 64) {
   mode = mode & 4095 | 32768;
  } else {
   mode = 0;
  }
  var node;
  if (typeof path === "object") {
   node = path;
  } else {
   path = PATH.normalize(path);
   try {
    var lookup = FS.lookupPath(path, {
     follow: !(flags & 131072)
    });
    node = lookup.node;
   } catch (e) {}
  }
  var created = false;
  if (flags & 64) {
   if (node) {
    if (flags & 128) {
     throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
    }
   } else {
    node = FS.mknod(path, mode, 0);
    created = true;
   }
  }
  if (!node) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  if (FS.isChrdev(node.mode)) {
   flags &= ~512;
  }
  if (flags & 65536 && !FS.isDir(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
  }
  if (!created) {
   var err = FS.mayOpen(node, flags);
   if (err) {
    throw new FS.ErrnoError(err);
   }
  }
  if (flags & 512) {
   FS.truncate(node, 0);
  }
  flags &= ~(128 | 512);
  var stream = FS.createStream({
   node: node,
   path: FS.getPath(node),
   flags: flags,
   seekable: true,
   position: 0,
   stream_ops: node.stream_ops,
   ungotten: [],
   error: false
  }, fd_start, fd_end);
  if (stream.stream_ops.open) {
   stream.stream_ops.open(stream);
  }
  if (Module["logReadFiles"] && !(flags & 1)) {
   if (!FS.readFiles) FS.readFiles = {};
   if (!(path in FS.readFiles)) {
    FS.readFiles[path] = 1;
    Module["printErr"]("read file: " + path);
   }
  }
  try {
   if (FS.trackingDelegate["onOpenFile"]) {
    var trackingFlags = 0;
    if ((flags & 2097155) !== 1) {
     trackingFlags |= FS.tracking.openFlags.READ;
    }
    if ((flags & 2097155) !== 0) {
     trackingFlags |= FS.tracking.openFlags.WRITE;
    }
    FS.trackingDelegate["onOpenFile"](path, trackingFlags);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
  }
  return stream;
 }),
 close: (function(stream) {
  if (stream.getdents) stream.getdents = null;
  try {
   if (stream.stream_ops.close) {
    stream.stream_ops.close(stream);
   }
  } catch (e) {
   throw e;
  } finally {
   FS.closeStream(stream.fd);
  }
 }),
 llseek: (function(stream, offset, whence) {
  if (!stream.seekable || !stream.stream_ops.llseek) {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  }
  stream.position = stream.stream_ops.llseek(stream, offset, whence);
  stream.ungotten = [];
  return stream.position;
 }),
 read: (function(stream, buffer, offset, length, position) {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
  }
  if (!stream.stream_ops.read) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var seeking = true;
  if (typeof position === "undefined") {
   position = stream.position;
   seeking = false;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  }
  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
  if (!seeking) stream.position += bytesRead;
  return bytesRead;
 }),
 write: (function(stream, buffer, offset, length, position, canOwn) {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
  }
  if (!stream.stream_ops.write) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if (stream.flags & 1024) {
   FS.llseek(stream, 0, 2);
  }
  var seeking = true;
  if (typeof position === "undefined") {
   position = stream.position;
   seeking = false;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  }
  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
  if (!seeking) stream.position += bytesWritten;
  try {
   if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path);
  } catch (e) {
   console.log("FS.trackingDelegate['onWriteToFile']('" + path + "') threw an exception: " + e.message);
  }
  return bytesWritten;
 }),
 allocate: (function(stream, offset, length) {
  if (offset < 0 || length <= 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
  }
  if (!stream.stream_ops.allocate) {
   throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
  }
  stream.stream_ops.allocate(stream, offset, length);
 }),
 mmap: (function(stream, buffer, offset, length, position, prot, flags) {
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(ERRNO_CODES.EACCES);
  }
  if (!stream.stream_ops.mmap) {
   throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
  }
  return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
 }),
 msync: (function(stream, buffer, offset, length, mmapFlags) {
  if (!stream || !stream.stream_ops.msync) {
   return 0;
  }
  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
 }),
 munmap: (function(stream) {
  return 0;
 }),
 ioctl: (function(stream, cmd, arg) {
  if (!stream.stream_ops.ioctl) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
  }
  return stream.stream_ops.ioctl(stream, cmd, arg);
 }),
 readFile: (function(path, opts) {
  opts = opts || {};
  opts.flags = opts.flags || "r";
  opts.encoding = opts.encoding || "binary";
  if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
   throw new Error('Invalid encoding type "' + opts.encoding + '"');
  }
  var ret;
  var stream = FS.open(path, opts.flags);
  var stat = FS.stat(path);
  var length = stat.size;
  var buf = new Uint8Array(length);
  FS.read(stream, buf, 0, length, 0);
  if (opts.encoding === "utf8") {
   ret = UTF8ArrayToString(buf, 0);
  } else if (opts.encoding === "binary") {
   ret = buf;
  }
  FS.close(stream);
  return ret;
 }),
 writeFile: (function(path, data, opts) {
  opts = opts || {};
  opts.flags = opts.flags || "w";
  opts.encoding = opts.encoding || "utf8";
  if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
   throw new Error('Invalid encoding type "' + opts.encoding + '"');
  }
  var stream = FS.open(path, opts.flags, opts.mode);
  if (opts.encoding === "utf8") {
   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
   FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);
  } else if (opts.encoding === "binary") {
   FS.write(stream, data, 0, data.length, 0, opts.canOwn);
  }
  FS.close(stream);
 }),
 cwd: (function() {
  return FS.currentPath;
 }),
 chdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  if (!FS.isDir(lookup.node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
  }
  var err = FS.nodePermissions(lookup.node, "x");
  if (err) {
   throw new FS.ErrnoError(err);
  }
  FS.currentPath = lookup.path;
 }),
 createDefaultDirectories: (function() {
  FS.mkdir("/tmp");
  FS.mkdir("/home");
  FS.mkdir("/home/web_user");
 }),
 createDefaultDevices: (function() {
  FS.mkdir("/dev");
  FS.registerDevice(FS.makedev(1, 3), {
   read: (function() {
    return 0;
   }),
   write: (function(stream, buffer, offset, length, pos) {
    return length;
   })
  });
  FS.mkdev("/dev/null", FS.makedev(1, 3));
  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
  FS.mkdev("/dev/tty", FS.makedev(5, 0));
  FS.mkdev("/dev/tty1", FS.makedev(6, 0));
  var random_device;
  if (typeof crypto !== "undefined") {
   var randomBuffer = new Uint8Array(1);
   random_device = (function() {
    crypto.getRandomValues(randomBuffer);
    return randomBuffer[0];
   });
  } else if (ENVIRONMENT_IS_NODE) {
   random_device = (function() {
    return require("crypto").randomBytes(1)[0];
   });
  } else {
   random_device = (function() {
    return Math.random() * 256 | 0;
   });
  }
  FS.createDevice("/dev", "random", random_device);
  FS.createDevice("/dev", "urandom", random_device);
  FS.mkdir("/dev/shm");
  FS.mkdir("/dev/shm/tmp");
 }),
 createSpecialDirectories: (function() {
  FS.mkdir("/proc");
  FS.mkdir("/proc/self");
  FS.mkdir("/proc/self/fd");
  FS.mount({
   mount: (function() {
    var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
    node.node_ops = {
     lookup: (function(parent, name) {
      var fd = +name;
      var stream = FS.getStream(fd);
      if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
      var ret = {
       parent: null,
       mount: {
        mountpoint: "fake"
       },
       node_ops: {
        readlink: (function() {
         return stream.path;
        })
       }
      };
      ret.parent = ret;
      return ret;
     })
    };
    return node;
   })
  }, {}, "/proc/self/fd");
 }),
 createStandardStreams: (function() {
  if (Module["stdin"]) {
   FS.createDevice("/dev", "stdin", Module["stdin"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdin");
  }
  if (Module["stdout"]) {
   FS.createDevice("/dev", "stdout", null, Module["stdout"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdout");
  }
  if (Module["stderr"]) {
   FS.createDevice("/dev", "stderr", null, Module["stderr"]);
  } else {
   FS.symlink("/dev/tty1", "/dev/stderr");
  }
  var stdin = FS.open("/dev/stdin", "r");
  assert(stdin.fd === 0, "invalid handle for stdin (" + stdin.fd + ")");
  var stdout = FS.open("/dev/stdout", "w");
  assert(stdout.fd === 1, "invalid handle for stdout (" + stdout.fd + ")");
  var stderr = FS.open("/dev/stderr", "w");
  assert(stderr.fd === 2, "invalid handle for stderr (" + stderr.fd + ")");
 }),
 ensureErrnoError: (function() {
  if (FS.ErrnoError) return;
  FS.ErrnoError = function ErrnoError(errno, node) {
   this.node = node;
   this.setErrno = (function(errno) {
    this.errno = errno;
    for (var key in ERRNO_CODES) {
     if (ERRNO_CODES[key] === errno) {
      this.code = key;
      break;
     }
    }
   });
   this.setErrno(errno);
   this.message = ERRNO_MESSAGES[errno];
  };
  FS.ErrnoError.prototype = new Error;
  FS.ErrnoError.prototype.constructor = FS.ErrnoError;
  [ ERRNO_CODES.ENOENT ].forEach((function(code) {
   FS.genericErrors[code] = new FS.ErrnoError(code);
   FS.genericErrors[code].stack = "<generic error, no stack>";
  }));
 }),
 staticInit: (function() {
  FS.ensureErrnoError();
  FS.nameTable = new Array(4096);
  FS.mount(MEMFS, {}, "/");
  FS.createDefaultDirectories();
  FS.createDefaultDevices();
  FS.createSpecialDirectories();
  FS.filesystems = {
   "MEMFS": MEMFS,
   "IDBFS": IDBFS,
   "NODEFS": NODEFS,
   "WORKERFS": WORKERFS
  };
 }),
 init: (function(input, output, error) {
  assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
  FS.init.initialized = true;
  FS.ensureErrnoError();
  Module["stdin"] = input || Module["stdin"];
  Module["stdout"] = output || Module["stdout"];
  Module["stderr"] = error || Module["stderr"];
  FS.createStandardStreams();
 }),
 quit: (function() {
  FS.init.initialized = false;
  var fflush = Module["_fflush"];
  if (fflush) fflush(0);
  for (var i = 0; i < FS.streams.length; i++) {
   var stream = FS.streams[i];
   if (!stream) {
    continue;
   }
   FS.close(stream);
  }
 }),
 getMode: (function(canRead, canWrite) {
  var mode = 0;
  if (canRead) mode |= 292 | 73;
  if (canWrite) mode |= 146;
  return mode;
 }),
 joinPath: (function(parts, forceRelative) {
  var path = PATH.join.apply(null, parts);
  if (forceRelative && path[0] == "/") path = path.substr(1);
  return path;
 }),
 absolutePath: (function(relative, base) {
  return PATH.resolve(base, relative);
 }),
 standardizePath: (function(path) {
  return PATH.normalize(path);
 }),
 findObject: (function(path, dontResolveLastLink) {
  var ret = FS.analyzePath(path, dontResolveLastLink);
  if (ret.exists) {
   return ret.object;
  } else {
   ___setErrNo(ret.error);
   return null;
  }
 }),
 analyzePath: (function(path, dontResolveLastLink) {
  try {
   var lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   path = lookup.path;
  } catch (e) {}
  var ret = {
   isRoot: false,
   exists: false,
   error: 0,
   name: null,
   path: null,
   object: null,
   parentExists: false,
   parentPath: null,
   parentObject: null
  };
  try {
   var lookup = FS.lookupPath(path, {
    parent: true
   });
   ret.parentExists = true;
   ret.parentPath = lookup.path;
   ret.parentObject = lookup.node;
   ret.name = PATH.basename(path);
   lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   ret.exists = true;
   ret.path = lookup.path;
   ret.object = lookup.node;
   ret.name = lookup.node.name;
   ret.isRoot = lookup.path === "/";
  } catch (e) {
   ret.error = e.errno;
  }
  return ret;
 }),
 createFolder: (function(parent, name, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.mkdir(path, mode);
 }),
 createPath: (function(parent, path, canRead, canWrite) {
  parent = typeof parent === "string" ? parent : FS.getPath(parent);
  var parts = path.split("/").reverse();
  while (parts.length) {
   var part = parts.pop();
   if (!part) continue;
   var current = PATH.join2(parent, part);
   try {
    FS.mkdir(current);
   } catch (e) {}
   parent = current;
  }
  return current;
 }),
 createFile: (function(parent, name, properties, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.create(path, mode);
 }),
 createDataFile: (function(parent, name, data, canRead, canWrite, canOwn) {
  var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
  var mode = FS.getMode(canRead, canWrite);
  var node = FS.create(path, mode);
  if (data) {
   if (typeof data === "string") {
    var arr = new Array(data.length);
    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
    data = arr;
   }
   FS.chmod(node, mode | 146);
   var stream = FS.open(node, "w");
   FS.write(stream, data, 0, data.length, 0, canOwn);
   FS.close(stream);
   FS.chmod(node, mode);
  }
  return node;
 }),
 createDevice: (function(parent, name, input, output) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(!!input, !!output);
  if (!FS.createDevice.major) FS.createDevice.major = 64;
  var dev = FS.makedev(FS.createDevice.major++, 0);
  FS.registerDevice(dev, {
   open: (function(stream) {
    stream.seekable = false;
   }),
   close: (function(stream) {
    if (output && output.buffer && output.buffer.length) {
     output(10);
    }
   }),
   read: (function(stream, buffer, offset, length, pos) {
    var bytesRead = 0;
    for (var i = 0; i < length; i++) {
     var result;
     try {
      result = input();
     } catch (e) {
      throw new FS.ErrnoError(ERRNO_CODES.EIO);
     }
     if (result === undefined && bytesRead === 0) {
      throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
     }
     if (result === null || result === undefined) break;
     bytesRead++;
     buffer[offset + i] = result;
    }
    if (bytesRead) {
     stream.node.timestamp = Date.now();
    }
    return bytesRead;
   }),
   write: (function(stream, buffer, offset, length, pos) {
    for (var i = 0; i < length; i++) {
     try {
      output(buffer[offset + i]);
     } catch (e) {
      throw new FS.ErrnoError(ERRNO_CODES.EIO);
     }
    }
    if (length) {
     stream.node.timestamp = Date.now();
    }
    return i;
   })
  });
  return FS.mkdev(path, mode, dev);
 }),
 createLink: (function(parent, name, target, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  return FS.symlink(target, path);
 }),
 forceLoadFile: (function(obj) {
  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
  var success = true;
  if (typeof XMLHttpRequest !== "undefined") {
   throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
  } else if (Module["read"]) {
   try {
    obj.contents = intArrayFromString(Module["read"](obj.url), true);
    obj.usedBytes = obj.contents.length;
   } catch (e) {
    success = false;
   }
  } else {
   throw new Error("Cannot load without read() or XMLHttpRequest.");
  }
  if (!success) ___setErrNo(ERRNO_CODES.EIO);
  return success;
 }),
 createLazyFile: (function(parent, name, url, canRead, canWrite) {
  function LazyUint8Array() {
   this.lengthKnown = false;
   this.chunks = [];
  }
  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
   if (idx > this.length - 1 || idx < 0) {
    return undefined;
   }
   var chunkOffset = idx % this.chunkSize;
   var chunkNum = idx / this.chunkSize | 0;
   return this.getter(chunkNum)[chunkOffset];
  };
  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
   this.getter = getter;
  };
  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
   var xhr = new XMLHttpRequest;
   xhr.open("HEAD", url, false);
   xhr.send(null);
   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
   var datalength = Number(xhr.getResponseHeader("Content-length"));
   var header;
   var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
   var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
   var chunkSize = 1024 * 1024;
   if (!hasByteServing) chunkSize = datalength;
   var doXHR = (function(from, to) {
    if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
    if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
    var xhr = new XMLHttpRequest;
    xhr.open("GET", url, false);
    if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
    if (xhr.overrideMimeType) {
     xhr.overrideMimeType("text/plain; charset=x-user-defined");
    }
    xhr.send(null);
    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
    if (xhr.response !== undefined) {
     return new Uint8Array(xhr.response || []);
    } else {
     return intArrayFromString(xhr.responseText || "", true);
    }
   });
   var lazyArray = this;
   lazyArray.setDataGetter((function(chunkNum) {
    var start = chunkNum * chunkSize;
    var end = (chunkNum + 1) * chunkSize - 1;
    end = Math.min(end, datalength - 1);
    if (typeof lazyArray.chunks[chunkNum] === "undefined") {
     lazyArray.chunks[chunkNum] = doXHR(start, end);
    }
    if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
    return lazyArray.chunks[chunkNum];
   }));
   if (usesGzip || !datalength) {
    chunkSize = datalength = 1;
    datalength = this.getter(0).length;
    chunkSize = datalength;
    console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
   }
   this._length = datalength;
   this._chunkSize = chunkSize;
   this.lengthKnown = true;
  };
  if (typeof XMLHttpRequest !== "undefined") {
   if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
   var lazyArray = new LazyUint8Array;
   Object.defineProperties(lazyArray, {
    length: {
     get: (function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._length;
     })
    },
    chunkSize: {
     get: (function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._chunkSize;
     })
    }
   });
   var properties = {
    isDevice: false,
    contents: lazyArray
   };
  } else {
   var properties = {
    isDevice: false,
    url: url
   };
  }
  var node = FS.createFile(parent, name, properties, canRead, canWrite);
  if (properties.contents) {
   node.contents = properties.contents;
  } else if (properties.url) {
   node.contents = null;
   node.url = properties.url;
  }
  Object.defineProperties(node, {
   usedBytes: {
    get: (function() {
     return this.contents.length;
    })
   }
  });
  var stream_ops = {};
  var keys = Object.keys(node.stream_ops);
  keys.forEach((function(key) {
   var fn = node.stream_ops[key];
   stream_ops[key] = function forceLoadLazyFile() {
    if (!FS.forceLoadFile(node)) {
     throw new FS.ErrnoError(ERRNO_CODES.EIO);
    }
    return fn.apply(null, arguments);
   };
  }));
  stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
   if (!FS.forceLoadFile(node)) {
    throw new FS.ErrnoError(ERRNO_CODES.EIO);
   }
   var contents = stream.node.contents;
   if (position >= contents.length) return 0;
   var size = Math.min(contents.length - position, length);
   assert(size >= 0);
   if (contents.slice) {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents[position + i];
    }
   } else {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents.get(position + i);
    }
   }
   return size;
  };
  node.stream_ops = stream_ops;
  return node;
 }),
 createPreloadedFile: (function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
  Browser.init();
  var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
  var dep = getUniqueRunDependency("cp " + fullname);
  function processData(byteArray) {
   function finish(byteArray) {
    if (preFinish) preFinish();
    if (!dontCreateFile) {
     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
    }
    if (onload) onload();
    removeRunDependency(dep);
   }
   var handled = false;
   Module["preloadPlugins"].forEach((function(plugin) {
    if (handled) return;
    if (plugin["canHandle"](fullname)) {
     plugin["handle"](byteArray, fullname, finish, (function() {
      if (onerror) onerror();
      removeRunDependency(dep);
     }));
     handled = true;
    }
   }));
   if (!handled) finish(byteArray);
  }
  addRunDependency(dep);
  if (typeof url == "string") {
   Browser.asyncLoad(url, (function(byteArray) {
    processData(byteArray);
   }), onerror);
  } else {
   processData(url);
  }
 }),
 indexedDB: (function() {
  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
 }),
 DB_NAME: (function() {
  return "EM_FS_" + window.location.pathname;
 }),
 DB_VERSION: 20,
 DB_STORE_NAME: "FILE_DATA",
 saveFilesToDB: (function(paths, onload, onerror) {
  onload = onload || (function() {});
  onerror = onerror || (function() {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
   console.log("creating db");
   var db = openRequest.result;
   db.createObjectStore(FS.DB_STORE_NAME);
  };
  openRequest.onsuccess = function openRequest_onsuccess() {
   var db = openRequest.result;
   var transaction = db.transaction([ FS.DB_STORE_NAME ], "readwrite");
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach((function(path) {
    var putRequest = files.put(FS.analyzePath(path).object.contents, path);
    putRequest.onsuccess = function putRequest_onsuccess() {
     ok++;
     if (ok + fail == total) finish();
    };
    putRequest.onerror = function putRequest_onerror() {
     fail++;
     if (ok + fail == total) finish();
    };
   }));
   transaction.onerror = onerror;
  };
  openRequest.onerror = onerror;
 }),
 loadFilesFromDB: (function(paths, onload, onerror) {
  onload = onload || (function() {});
  onerror = onerror || (function() {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = onerror;
  openRequest.onsuccess = function openRequest_onsuccess() {
   var db = openRequest.result;
   try {
    var transaction = db.transaction([ FS.DB_STORE_NAME ], "readonly");
   } catch (e) {
    onerror(e);
    return;
   }
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach((function(path) {
    var getRequest = files.get(path);
    getRequest.onsuccess = function getRequest_onsuccess() {
     if (FS.analyzePath(path).exists) {
      FS.unlink(path);
     }
     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
     ok++;
     if (ok + fail == total) finish();
    };
    getRequest.onerror = function getRequest_onerror() {
     fail++;
     if (ok + fail == total) finish();
    };
   }));
   transaction.onerror = onerror;
  };
  openRequest.onerror = onerror;
 })
};
Module["FS"] = FS;
var SYSCALLS = {
 DEFAULT_POLLMASK: 5,
 mappings: {},
 umask: 511,
 calculateAt: (function(dirfd, path) {
  if (path[0] !== "/") {
   var dir;
   if (dirfd === -100) {
    dir = FS.cwd();
   } else {
    var dirstream = FS.getStream(dirfd);
    if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
    dir = dirstream.path;
   }
   path = PATH.join2(dir, path);
  }
  return path;
 }),
 doStat: (function(func, path, buf) {
  try {
   var stat = func(path);
  } catch (e) {
   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
    return -ERRNO_CODES.ENOTDIR;
   }
   throw e;
  }
  HEAP32[buf >> 2] = stat.dev;
  HEAP32[buf + 4 >> 2] = 0;
  HEAP32[buf + 8 >> 2] = stat.ino;
  HEAP32[buf + 12 >> 2] = stat.mode;
  HEAP32[buf + 16 >> 2] = stat.nlink;
  HEAP32[buf + 20 >> 2] = stat.uid;
  HEAP32[buf + 24 >> 2] = stat.gid;
  HEAP32[buf + 28 >> 2] = stat.rdev;
  HEAP32[buf + 32 >> 2] = 0;
  HEAP32[buf + 36 >> 2] = stat.size;
  HEAP32[buf + 40 >> 2] = 4096;
  HEAP32[buf + 44 >> 2] = stat.blocks;
  HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;
  HEAP32[buf + 52 >> 2] = 0;
  HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;
  HEAP32[buf + 60 >> 2] = 0;
  HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;
  HEAP32[buf + 68 >> 2] = 0;
  HEAP32[buf + 72 >> 2] = stat.ino;
  return 0;
 }),
 doMsync: (function(addr, stream, len, flags) {
  var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
  FS.msync(stream, buffer, 0, len, flags);
 }),
 doMkdir: (function(path, mode) {
  path = PATH.normalize(path);
  if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
  FS.mkdir(path, mode, 0);
  return 0;
 }),
 doMknod: (function(path, mode, dev) {
  switch (mode & 61440) {
  case 32768:
  case 8192:
  case 24576:
  case 4096:
  case 49152:
   break;
  default:
   return -ERRNO_CODES.EINVAL;
  }
  FS.mknod(path, mode, dev);
  return 0;
 }),
 doReadlink: (function(path, buf, bufsize) {
  if (bufsize <= 0) return -ERRNO_CODES.EINVAL;
  var ret = FS.readlink(path);
  ret = ret.slice(0, Math.max(0, bufsize));
  writeStringToMemory(ret, buf, true);
  return ret.length;
 }),
 doAccess: (function(path, amode) {
  if (amode & ~7) {
   return -ERRNO_CODES.EINVAL;
  }
  var node;
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  node = lookup.node;
  var perms = "";
  if (amode & 4) perms += "r";
  if (amode & 2) perms += "w";
  if (amode & 1) perms += "x";
  if (perms && FS.nodePermissions(node, perms)) {
   return -ERRNO_CODES.EACCES;
  }
  return 0;
 }),
 doDup: (function(path, flags, suggestFD) {
  var suggest = FS.getStream(suggestFD);
  if (suggest) FS.close(suggest);
  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
 }),
 doReadv: (function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = HEAP32[iov + i * 8 >> 2];
   var len = HEAP32[iov + (i * 8 + 4) >> 2];
   var curr = FS.read(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
   if (curr < len) break;
  }
  return ret;
 }),
 doWritev: (function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = HEAP32[iov + i * 8 >> 2];
   var len = HEAP32[iov + (i * 8 + 4) >> 2];
   var curr = FS.write(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
  }
  return ret;
 }),
 varargs: 0,
 get: (function(varargs) {
  SYSCALLS.varargs += 4;
  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
  return ret;
 }),
 getStr: (function() {
  var ret = Pointer_stringify(SYSCALLS.get());
  return ret;
 }),
 getStreamFromFD: (function() {
  var stream = FS.getStream(SYSCALLS.get());
  if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  return stream;
 }),
 getSocketFromFD: (function() {
  var socket = SOCKFS.getSocket(SYSCALLS.get());
  if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  return socket;
 }),
 getSocketAddress: (function(allowNull) {
  var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
  if (allowNull && addrp === 0) return null;
  var info = __read_sockaddr(addrp, addrlen);
  if (info.errno) throw new FS.ErrnoError(info.errno);
  info.addr = DNS.lookup_addr(info.addr) || info.addr;
  return info;
 }),
 get64: (function() {
  var low = SYSCALLS.get(), high = SYSCALLS.get();
  if (low >= 0) assert(high === 0); else assert(high === -1);
  return low;
 }),
 getZero: (function() {
  assert(SYSCALLS.get() === 0);
 })
};
Module["SYSCALLS"] = SYSCALLS;
function ___syscall20(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  return PROCINFO.pid;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall20"] = ___syscall20;
function __exit(status) {
 Module["exit"](status);
}
Module["__exit"] = __exit;
function _exit(status) {
 __exit(status);
}
Module["_exit"] = _exit;
function _create_viterbi27() {
 return Module["_create_viterbi27"].apply(null, arguments);
}
function _create_viterbi29() {
 return Module["_create_viterbi29"].apply(null, arguments);
}
function ___syscall6(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD();
  FS.close(stream);
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall6"] = ___syscall6;
function ___syscall54(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();
  switch (op) {
  case 21505:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    return 0;
   }
  case 21506:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    return 0;
   }
  case 21519:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    var argp = SYSCALLS.get();
    HEAP32[argp >> 2] = 0;
    return 0;
   }
  case 21520:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    return -ERRNO_CODES.EINVAL;
   }
  case 21531:
   {
    var argp = SYSCALLS.get();
    return FS.ioctl(stream, op, argp);
   }
  default:
   abort("bad ioctl syscall " + op);
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall54"] = ___syscall54;
function _init_viterbi27() {
 return Module["_init_viterbi27"].apply(null, arguments);
}
function _sysconf(name) {
 switch (name) {
 case 30:
  return PAGE_SIZE;
 case 85:
  return totalMemory / PAGE_SIZE;
 case 132:
 case 133:
 case 12:
 case 137:
 case 138:
 case 15:
 case 235:
 case 16:
 case 17:
 case 18:
 case 19:
 case 20:
 case 149:
 case 13:
 case 10:
 case 236:
 case 153:
 case 9:
 case 21:
 case 22:
 case 159:
 case 154:
 case 14:
 case 77:
 case 78:
 case 139:
 case 80:
 case 81:
 case 82:
 case 68:
 case 67:
 case 164:
 case 11:
 case 29:
 case 47:
 case 48:
 case 95:
 case 52:
 case 51:
 case 46:
  return 200809;
 case 79:
  return 0;
 case 27:
 case 246:
 case 127:
 case 128:
 case 23:
 case 24:
 case 160:
 case 161:
 case 181:
 case 182:
 case 242:
 case 183:
 case 184:
 case 243:
 case 244:
 case 245:
 case 165:
 case 178:
 case 179:
 case 49:
 case 50:
 case 168:
 case 169:
 case 175:
 case 170:
 case 171:
 case 172:
 case 97:
 case 76:
 case 32:
 case 173:
 case 35:
  return -1;
 case 176:
 case 177:
 case 7:
 case 155:
 case 8:
 case 157:
 case 125:
 case 126:
 case 92:
 case 93:
 case 129:
 case 130:
 case 131:
 case 94:
 case 91:
  return 1;
 case 74:
 case 60:
 case 69:
 case 70:
 case 4:
  return 1024;
 case 31:
 case 42:
 case 72:
  return 32;
 case 87:
 case 26:
 case 33:
  return 2147483647;
 case 34:
 case 1:
  return 47839;
 case 38:
 case 36:
  return 99;
 case 43:
 case 37:
  return 2048;
 case 0:
  return 2097152;
 case 3:
  return 65536;
 case 28:
  return 32768;
 case 44:
  return 32767;
 case 75:
  return 16384;
 case 39:
  return 1e3;
 case 89:
  return 700;
 case 71:
  return 256;
 case 40:
  return 255;
 case 2:
  return 100;
 case 180:
  return 64;
 case 25:
  return 20;
 case 5:
  return 16;
 case 6:
  return 6;
 case 73:
  return 4;
 case 84:
  {
   if (typeof navigator === "object") return navigator["hardwareConcurrency"] || 1;
   return 1;
  }
 }
 ___setErrNo(ERRNO_CODES.EINVAL);
 return -1;
}
Module["_sysconf"] = _sysconf;
Module["_bitshift64Lshr"] = _bitshift64Lshr;
function _chainback_viterbi39() {
 return Module["_chainback_viterbi39"].apply(null, arguments);
}
function _sched_yield() {
 return 0;
}
Module["_sched_yield"] = _sched_yield;
function _update_viterbi29_blk() {
 return Module["_update_viterbi29_blk"].apply(null, arguments);
}
function _pthread_cleanup_push(routine, arg) {
 __ATEXIT__.push((function() {
  Runtime.dynCall("vi", routine, [ arg ]);
 }));
 _pthread_cleanup_push.level = __ATEXIT__.length;
}
Module["_pthread_cleanup_push"] = _pthread_cleanup_push;
function _gettimeofday(ptr) {
 var now = Date.now();
 HEAP32[ptr >> 2] = now / 1e3 | 0;
 HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0;
 return 0;
}
Module["_gettimeofday"] = _gettimeofday;
function _update_viterbi615_blk() {
 return Module["_update_viterbi615_blk"].apply(null, arguments);
}
function _partab_init() {
 return Module["_partab_init"].apply(null, arguments);
}
function ___syscall3(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get();
  return FS.read(stream, HEAP8, buf, count);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall3"] = ___syscall3;
function _free_rs_char() {
 return Module["_free_rs_char"].apply(null, arguments);
}
function ___syscall5(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get();
  var stream = FS.open(pathname, flags, mode);
  return stream.fd;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall5"] = ___syscall5;
function _decode_rs_char() {
 return Module["_decode_rs_char"].apply(null, arguments);
}
function _llvm_stackrestore(p) {
 var self = _llvm_stacksave;
 var ret = self.LLVM_SAVEDSTACKS[p];
 self.LLVM_SAVEDSTACKS.splice(p, 1);
 Runtime.stackRestore(ret);
}
Module["_llvm_stackrestore"] = _llvm_stackrestore;
function _create_viterbi615() {
 return Module["_create_viterbi615"].apply(null, arguments);
}
function _delete_viterbi29() {
 return Module["_delete_viterbi29"].apply(null, arguments);
}
function _encode_rs_char() {
 return Module["_encode_rs_char"].apply(null, arguments);
}
function _sbrk(bytes) {
 var self = _sbrk;
 if (!self.called) {
  DYNAMICTOP = alignMemoryPage(DYNAMICTOP);
  self.called = true;
  assert(Runtime.dynamicAlloc);
  self.alloc = Runtime.dynamicAlloc;
  Runtime.dynamicAlloc = (function() {
   abort("cannot dynamically allocate, sbrk now has control");
  });
 }
 var ret = DYNAMICTOP;
 if (bytes != 0) {
  var success = self.alloc(bytes);
  if (!success) return -1 >>> 0;
 }
 return ret;
}
Module["_sbrk"] = _sbrk;
Module["_memmove"] = _memmove;
function _init_viterbi29() {
 return Module["_init_viterbi29"].apply(null, arguments);
}
function _delete_viterbi27() {
 return Module["_delete_viterbi27"].apply(null, arguments);
}
function _init_viterbi615() {
 return Module["_init_viterbi615"].apply(null, arguments);
}
function _init_rs_char() {
 return Module["_init_rs_char"].apply(null, arguments);
}
function _pthread_cleanup_pop() {
 assert(_pthread_cleanup_push.level == __ATEXIT__.length, "cannot pop if something else added meanwhile!");
 __ATEXIT__.pop();
 _pthread_cleanup_push.level = __ATEXIT__.length;
}
Module["_pthread_cleanup_pop"] = _pthread_cleanup_pop;
var _llvm_fabs_f32 = Math_abs;
Module["_llvm_fabs_f32"] = _llvm_fabs_f32;
function _delete_viterbi615() {
 return Module["_delete_viterbi615"].apply(null, arguments);
}
function _time(ptr) {
 var ret = Date.now() / 1e3 | 0;
 if (ptr) {
  HEAP32[ptr >> 2] = ret;
 }
 return ret;
}
Module["_time"] = _time;
function _pthread_self() {
 return 0;
}
Module["_pthread_self"] = _pthread_self;
function ___syscall140(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
  var offset = offset_low;
  assert(offset_high === 0);
  FS.llseek(stream, offset, whence);
  HEAP32[result >> 2] = stream.position;
  if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall140"] = ___syscall140;
function ___syscall146(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
  return SYSCALLS.doWritev(stream, iov, iovcnt);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall146"] = ___syscall146;
function ___syscall221(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();
  switch (cmd) {
  case 0:
   {
    var arg = SYSCALLS.get();
    if (arg < 0) {
     return -ERRNO_CODES.EINVAL;
    }
    var newStream;
    newStream = FS.open(stream.path, stream.flags, 0, arg);
    return newStream.fd;
   }
  case 1:
  case 2:
   return 0;
  case 3:
   return stream.flags;
  case 4:
   {
    var arg = SYSCALLS.get();
    stream.flags |= arg;
    return 0;
   }
  case 12:
  case 12:
   {
    var arg = SYSCALLS.get();
    var offset = 0;
    HEAP16[arg + offset >> 1] = 2;
    return 0;
   }
  case 13:
  case 14:
  case 13:
  case 14:
   return 0;
  case 16:
  case 8:
   return -ERRNO_CODES.EINVAL;
  case 9:
   ___setErrNo(ERRNO_CODES.EINVAL);
   return -1;
  default:
   {
    return -ERRNO_CODES.EINVAL;
   }
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall221"] = ___syscall221;
function ___syscall145(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
  return SYSCALLS.doReadv(stream, iov, iovcnt);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall145"] = ___syscall145;
function _P_init() {
 return Module["_P_init"].apply(null, arguments);
}
function _Partab() {
 return Module["_Partab"].apply(null, arguments);
}
FS.staticInit();
__ATINIT__.unshift((function() {
 if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
}));
__ATMAIN__.push((function() {
 FS.ignorePermissions = false;
}));
__ATEXIT__.push((function() {
 FS.quit();
}));
Module["FS_createFolder"] = FS.createFolder;
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createLink"] = FS.createLink;
Module["FS_createDevice"] = FS.createDevice;
Module["FS_unlink"] = FS.unlink;
__ATINIT__.unshift((function() {
 TTY.init();
}));
__ATEXIT__.push((function() {
 TTY.shutdown();
}));
if (ENVIRONMENT_IS_NODE) {
 var fs = require("fs");
 var NODEJS_PATH = require("path");
 NODEFS.staticInit();
}
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);
staticSealed = true;
STACK_MAX = STACK_BASE + TOTAL_STACK;
DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);
var cttz_i8 = allocate([ 8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 ], "i8", ALLOC_DYNAMIC);
var gb = Runtime.GLOBAL_BASE, fb = 0;
var setTempRet0 = Runtime.setTempRet0, getTempRet0 = Runtime.getTempRet0;
function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
 try {
  return Module["dynCall_iiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iiiiiiii(x, a0, a1, a2, a3, a4, a5, a6) {
 if (x < 0 || x >= FUNCTION_TABLE_iiiiiiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iiiiiiii[x](a0, a1, a2, a3, a4, a5, a6);
}
function invoke_iiii(index, a1, a2, a3) {
 try {
  return Module["dynCall_iiii"](index, a1, a2, a3);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iiii(x, a0, a1, a2) {
 if (x < 0 || x >= FUNCTION_TABLE_iiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iiii[x](a0, a1, a2);
}
function invoke_vi(index, a1) {
 try {
  Module["dynCall_vi"](index, a1);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_vi(x, a0) {
 if (x < 0 || x >= FUNCTION_TABLE_vi.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_vi[x](a0);
}
function invoke_ii(index, a1) {
 try {
  return Module["dynCall_ii"](index, a1);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_ii(x, a0) {
 if (x < 0 || x >= FUNCTION_TABLE_ii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_ii[x](a0);
}
function invoke_viii(index, a1, a2, a3) {
 try {
  Module["dynCall_viii"](index, a1, a2, a3);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_viii(x, a0, a1, a2) {
 if (x < 0 || x >= FUNCTION_TABLE_viii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_viii[x](a0, a1, a2);
}
function invoke_iiiii(index, a1, a2, a3, a4) {
 try {
  return Module["dynCall_iiiii"](index, a1, a2, a3, a4);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iiiii(x, a0, a1, a2, a3) {
 if (x < 0 || x >= FUNCTION_TABLE_iiiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iiiii[x](a0, a1, a2, a3);
}
function invoke_iii(index, a1, a2) {
 try {
  return Module["dynCall_iii"](index, a1, a2);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iii(x, a0, a1) {
 if (x < 0 || x >= FUNCTION_TABLE_iii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iii[x](a0, a1);
}
function invoke_viiii(index, a1, a2, a3, a4) {
 try {
  Module["dynCall_viiii"](index, a1, a2, a3, a4);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_viiii(x, a0, a1, a2, a3) {
 if (x < 0 || x >= FUNCTION_TABLE_viiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_viiii[x](a0, a1, a2, a3);
}
var g$_P_init = (function() {
 return Module["_P_init"];
});
var g$_Partab = (function() {
 return Module["_Partab"];
});
var dynCall_iiiiiiii = ftCall_iiiiiiii;
var dynCall_iiii = ftCall_iiii;
var dynCall_vi = ftCall_vi;
var dynCall_ii = ftCall_ii;
var dynCall_viii = ftCall_viii;
var dynCall_iiiii = ftCall_iiiii;
var dynCall_iii = ftCall_iii;
var dynCall_viiii = ftCall_viiii;
Module.asmGlobalArg = {
 "Math": Math,
 "Int8Array": Int8Array,
 "Int16Array": Int16Array,
 "Int32Array": Int32Array,
 "Uint8Array": Uint8Array,
 "Uint16Array": Uint16Array,
 "Uint32Array": Uint32Array,
 "Float32Array": Float32Array,
 "Float64Array": Float64Array,
 "NaN": NaN,
 "Infinity": Infinity,
 "SIMD": SIMD
};
Module.asmLibraryArg = {
 "abort": abort,
 "assert": assert,
 "setTempRet0": setTempRet0,
 "getTempRet0": getTempRet0,
 "invoke_iiiiiiii": invoke_iiiiiiii,
 "ftCall_iiiiiiii": ftCall_iiiiiiii,
 "invoke_iiii": invoke_iiii,
 "ftCall_iiii": ftCall_iiii,
 "invoke_vi": invoke_vi,
 "ftCall_vi": ftCall_vi,
 "invoke_ii": invoke_ii,
 "ftCall_ii": ftCall_ii,
 "invoke_viii": invoke_viii,
 "ftCall_viii": ftCall_viii,
 "invoke_iiiii": invoke_iiiii,
 "ftCall_iiiii": ftCall_iiiii,
 "invoke_iii": invoke_iii,
 "ftCall_iii": ftCall_iii,
 "invoke_viiii": invoke_viiii,
 "ftCall_viiii": ftCall_viiii,
 "_pthread_cleanup_pop": _pthread_cleanup_pop,
 "___syscall221": ___syscall221,
 "_delete_viterbi615": _delete_viterbi615,
 "_chainback_viterbi615": _chainback_viterbi615,
 "_create_viterbi615": _create_viterbi615,
 "_init_viterbi39": _init_viterbi39,
 "_sched_yield": _sched_yield,
 "_abort": _abort,
 "_llvm_fabs_f64": _llvm_fabs_f64,
 "_pthread_cleanup_push": _pthread_cleanup_push,
 "_delete_viterbi29": _delete_viterbi29,
 "_delete_viterbi27": _delete_viterbi27,
 "___syscall20": ___syscall20,
 "_llvm_stackrestore": _llvm_stackrestore,
 "___assert_fail": ___assert_fail,
 "_decode_rs_char": _decode_rs_char,
 "_update_viterbi29_blk": _update_viterbi29_blk,
 "_create_viterbi27": _create_viterbi27,
 "_delete_viterbi39": _delete_viterbi39,
 "_chainback_viterbi29": _chainback_viterbi29,
 "___setErrNo": ___setErrNo,
 "_sbrk": _sbrk,
 "_chainback_viterbi39": _chainback_viterbi39,
 "_llvm_pow_f32": _llvm_pow_f32,
 "_emscripten_memcpy_big": _emscripten_memcpy_big,
 "_P_init": _P_init,
 "_llvm_fabs_f32": _llvm_fabs_f32,
 "__exit": __exit,
 "_create_viterbi29": _create_viterbi29,
 "_init_viterbi29": _init_viterbi29,
 "_encode_rs_char": _encode_rs_char,
 "_init_viterbi27": _init_viterbi27,
 "_pthread_self": _pthread_self,
 "_llvm_stacksave": _llvm_stacksave,
 "_update_viterbi27_blk": _update_viterbi27_blk,
 "_free_rs_char": _free_rs_char,
 "_update_viterbi615_blk": _update_viterbi615_blk,
 "_init_rs_char": _init_rs_char,
 "___syscall54": ___syscall54,
 "___unlock": ___unlock,
 "_partab_init": _partab_init,
 "_update_viterbi39_blk": _update_viterbi39_blk,
 "_chainback_viterbi27": _chainback_viterbi27,
 "_init_viterbi615": _init_viterbi615,
 "___syscall3": ___syscall3,
 "_sysconf": _sysconf,
 "___lock": ___lock,
 "___syscall6": ___syscall6,
 "___syscall5": ___syscall5,
 "_time": _time,
 "_Partab": _Partab,
 "_gettimeofday": _gettimeofday,
 "___syscall140": ___syscall140,
 "_exit": _exit,
 "_create_viterbi39": _create_viterbi39,
 "___syscall145": ___syscall145,
 "___syscall146": ___syscall146,
 "g$_P_init": g$_P_init,
 "g$_Partab": g$_Partab,
 "STACKTOP": STACKTOP,
 "STACK_MAX": STACK_MAX,
 "tempDoublePtr": tempDoublePtr,
 "ABORT": ABORT,
 "cttz_i8": cttz_i8,
 "gb": gb,
 "fb": fb
};
// EMSCRIPTEN_START_ASM

var asm = (function(global,env,buffer) {

  'use asm';
  
  
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;
  var gb=env.gb|0;
  var fb=env.fb|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_clz32=global.Math.clz32;
  var Math_fround=global.Math.fround;
  var abort=env.abort;
  var assert=env.assert;
  var setTempRet0=env.setTempRet0;
  var getTempRet0=env.getTempRet0;
  var invoke_iiiiiiii=env.invoke_iiiiiiii;
  var ftCall_iiiiiiii=env.ftCall_iiiiiiii;
  var invoke_iiii=env.invoke_iiii;
  var ftCall_iiii=env.ftCall_iiii;
  var invoke_vi=env.invoke_vi;
  var ftCall_vi=env.ftCall_vi;
  var invoke_ii=env.invoke_ii;
  var ftCall_ii=env.ftCall_ii;
  var invoke_viii=env.invoke_viii;
  var ftCall_viii=env.ftCall_viii;
  var invoke_iiiii=env.invoke_iiiii;
  var ftCall_iiiii=env.ftCall_iiiii;
  var invoke_iii=env.invoke_iii;
  var ftCall_iii=env.ftCall_iii;
  var invoke_viiii=env.invoke_viiii;
  var ftCall_viiii=env.ftCall_viiii;
  var _pthread_cleanup_pop=env._pthread_cleanup_pop;
  var ___syscall221=env.___syscall221;
  var _delete_viterbi615=env._delete_viterbi615;
  var _chainback_viterbi615=env._chainback_viterbi615;
  var _create_viterbi615=env._create_viterbi615;
  var _init_viterbi39=env._init_viterbi39;
  var _sched_yield=env._sched_yield;
  var _abort=env._abort;
  var _llvm_fabs_f64=env._llvm_fabs_f64;
  var _pthread_cleanup_push=env._pthread_cleanup_push;
  var _delete_viterbi29=env._delete_viterbi29;
  var _delete_viterbi27=env._delete_viterbi27;
  var ___syscall20=env.___syscall20;
  var _llvm_stackrestore=env._llvm_stackrestore;
  var ___assert_fail=env.___assert_fail;
  var _decode_rs_char=env._decode_rs_char;
  var _update_viterbi29_blk=env._update_viterbi29_blk;
  var _create_viterbi27=env._create_viterbi27;
  var _delete_viterbi39=env._delete_viterbi39;
  var _chainback_viterbi29=env._chainback_viterbi29;
  var ___setErrNo=env.___setErrNo;
  var _sbrk=env._sbrk;
  var _chainback_viterbi39=env._chainback_viterbi39;
  var _llvm_pow_f32=env._llvm_pow_f32;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _P_init=env._P_init;
  var _llvm_fabs_f32=env._llvm_fabs_f32;
  var __exit=env.__exit;
  var _create_viterbi29=env._create_viterbi29;
  var _init_viterbi29=env._init_viterbi29;
  var _encode_rs_char=env._encode_rs_char;
  var _init_viterbi27=env._init_viterbi27;
  var _pthread_self=env._pthread_self;
  var _llvm_stacksave=env._llvm_stacksave;
  var _update_viterbi27_blk=env._update_viterbi27_blk;
  var _free_rs_char=env._free_rs_char;
  var _update_viterbi615_blk=env._update_viterbi615_blk;
  var _init_rs_char=env._init_rs_char;
  var ___syscall54=env.___syscall54;
  var ___unlock=env.___unlock;
  var _partab_init=env._partab_init;
  var _update_viterbi39_blk=env._update_viterbi39_blk;
  var _chainback_viterbi27=env._chainback_viterbi27;
  var _init_viterbi615=env._init_viterbi615;
  var ___syscall3=env.___syscall3;
  var _sysconf=env._sysconf;
  var ___lock=env.___lock;
  var ___syscall6=env.___syscall6;
  var ___syscall5=env.___syscall5;
  var _time=env._time;
  var _Partab=env._Partab;
  var _gettimeofday=env._gettimeofday;
  var ___syscall140=env.___syscall140;
  var _exit=env._exit;
  var _create_viterbi39=env._create_viterbi39;
  var ___syscall145=env.___syscall145;
  var ___syscall146=env.___syscall146;
  var g$_P_init=env.g$_P_init;
  var g$_Partab=env.g$_Partab;
  var SIMD_Float32x4=global.SIMD.Float32x4;
  var SIMD_Int32x4=global.SIMD.Int32x4;
  var SIMD_Int32x4_splat=SIMD_Int32x4.splat;
  var SIMD_Int32x4_check=SIMD_Int32x4.check;
  var SIMD_Int32x4_extractLane=SIMD_Int32x4.extractLane;
  var SIMD_Int32x4_replaceLane=SIMD_Int32x4.replaceLane;
  var SIMD_Int32x4_add=SIMD_Int32x4.add;
  var SIMD_Int32x4_sub=SIMD_Int32x4.sub;
  var SIMD_Int32x4_neg=SIMD_Int32x4.neg;
  var SIMD_Int32x4_mul=SIMD_Int32x4.mul;
  var SIMD_Int32x4_equal=SIMD_Int32x4.equal;
  var SIMD_Int32x4_lessThan=SIMD_Int32x4.lessThan;
  var SIMD_Int32x4_greaterThan=SIMD_Int32x4.greaterThan;
  var SIMD_Int32x4_notEqual=SIMD_Int32x4.notEqual;
  var SIMD_Int32x4_lessThanOrEqual=SIMD_Int32x4.lessThanOrEqual;
  var SIMD_Int32x4_greaterThanOrEqual=SIMD_Int32x4.greaterThanOrEqual;
  var SIMD_Int32x4_select=SIMD_Int32x4.select;
  var SIMD_Int32x4_swizzle=SIMD_Int32x4.swizzle;
  var SIMD_Int32x4_shuffle=SIMD_Int32x4.shuffle;
  var SIMD_Int32x4_load=SIMD_Int32x4.load;
  var SIMD_Int32x4_store=SIMD_Int32x4.store;
  var SIMD_Int32x4_load1=SIMD_Int32x4.load1;
  var SIMD_Int32x4_store1=SIMD_Int32x4.store1;
  var SIMD_Int32x4_load2=SIMD_Int32x4.load2;
  var SIMD_Int32x4_store2=SIMD_Int32x4.store2;
  var SIMD_Int32x4_load3=SIMD_Int32x4.load3;
  var SIMD_Int32x4_store3=SIMD_Int32x4.store3;
  var SIMD_Int32x4_fromFloat32x4=SIMD_Int32x4.fromFloat32x4;
  var SIMD_Int32x4_fromFloat32x4Bits=SIMD_Int32x4.fromFloat32x4Bits;
  var SIMD_Int32x4_and=SIMD_Int32x4.and;
  var SIMD_Int32x4_xor=SIMD_Int32x4.xor;
  var SIMD_Int32x4_or=SIMD_Int32x4.or;
  var SIMD_Int32x4_not=SIMD_Int32x4.not;
  var SIMD_Int32x4_shiftLeftByScalar=SIMD_Int32x4.shiftLeftByScalar;
  var SIMD_Int32x4_shiftRightByScalar=SIMD_Int32x4.shiftRightByScalar;
  var SIMD_Float32x4_splat=SIMD_Float32x4.splat;
  var SIMD_Float32x4_check=SIMD_Float32x4.check;
  var SIMD_Float32x4_extractLane=SIMD_Float32x4.extractLane;
  var SIMD_Float32x4_replaceLane=SIMD_Float32x4.replaceLane;
  var SIMD_Float32x4_add=SIMD_Float32x4.add;
  var SIMD_Float32x4_sub=SIMD_Float32x4.sub;
  var SIMD_Float32x4_neg=SIMD_Float32x4.neg;
  var SIMD_Float32x4_mul=SIMD_Float32x4.mul;
  var SIMD_Float32x4_equal=SIMD_Float32x4.equal;
  var SIMD_Float32x4_lessThan=SIMD_Float32x4.lessThan;
  var SIMD_Float32x4_greaterThan=SIMD_Float32x4.greaterThan;
  var SIMD_Float32x4_notEqual=SIMD_Float32x4.notEqual;
  var SIMD_Float32x4_lessThanOrEqual=SIMD_Float32x4.lessThanOrEqual;
  var SIMD_Float32x4_greaterThanOrEqual=SIMD_Float32x4.greaterThanOrEqual;
  var SIMD_Float32x4_select=SIMD_Float32x4.select;
  var SIMD_Float32x4_swizzle=SIMD_Float32x4.swizzle;
  var SIMD_Float32x4_shuffle=SIMD_Float32x4.shuffle;
  var SIMD_Float32x4_load=SIMD_Float32x4.load;
  var SIMD_Float32x4_store=SIMD_Float32x4.store;
  var SIMD_Float32x4_load1=SIMD_Float32x4.load1;
  var SIMD_Float32x4_store1=SIMD_Float32x4.store1;
  var SIMD_Float32x4_load2=SIMD_Float32x4.load2;
  var SIMD_Float32x4_store2=SIMD_Float32x4.store2;
  var SIMD_Float32x4_load3=SIMD_Float32x4.load3;
  var SIMD_Float32x4_store3=SIMD_Float32x4.store3;
  var SIMD_Float32x4_fromInt32x4=SIMD_Float32x4.fromInt32x4;
  var SIMD_Float32x4_fromInt32x4Bits=SIMD_Float32x4.fromInt32x4Bits;
  var SIMD_Float32x4_div=SIMD_Float32x4.div;
  var SIMD_Float32x4_min=SIMD_Float32x4.min;
  var SIMD_Float32x4_max=SIMD_Float32x4.max;
  var SIMD_Float32x4_minNum=SIMD_Float32x4.minNum;
  var SIMD_Float32x4_maxNum=SIMD_Float32x4.maxNum;
  var SIMD_Float32x4_sqrt=SIMD_Float32x4.sqrt;
  var SIMD_Float32x4_abs=SIMD_Float32x4.abs;
  var SIMD_Float32x4_reciprocalApproximation=SIMD_Float32x4.reciprocalApproximation;
  var SIMD_Float32x4_reciprocalSqrtApproximation=SIMD_Float32x4.reciprocalSqrtApproximation;
  var tempFloat = Math_fround(0);
  const f0 = Math_fround(0);

// EMSCRIPTEN_START_FUNCS

function _malloc(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0;
 do if (i1 >>> 0 < 245) {
  i14 = i1 >>> 0 < 11 ? 16 : i1 + 11 & -8;
  i1 = i14 >>> 3;
  i9 = HEAP32[gb + 44352 >> 2] | 0;
  i2 = i9 >>> i1;
  if (i2 & 3 | 0) {
   i2 = (i2 & 1 ^ 1) + i1 | 0;
   i3 = gb + 44352 + 40 + (i2 << 1 << 2) | 0;
   i4 = i3 + 8 | 0;
   i5 = HEAP32[i4 >> 2] | 0;
   i6 = i5 + 8 | 0;
   i7 = HEAP32[i6 >> 2] | 0;
   do if ((i3 | 0) != (i7 | 0)) {
    if (i7 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i7 + 12 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i5 | 0)) {
     HEAP32[i1 >> 2] = i3;
     HEAP32[i4 >> 2] = i7;
     break;
    } else _abort();
   } else HEAP32[gb + 44352 >> 2] = i9 & ~(1 << i2); while (0);
   i37 = i2 << 3;
   HEAP32[i5 + 4 >> 2] = i37 | 3;
   i37 = i5 + i37 + 4 | 0;
   HEAP32[i37 >> 2] = HEAP32[i37 >> 2] | 1;
   i37 = i6;
   return i37 | 0;
  }
  i7 = HEAP32[gb + 44352 + 8 >> 2] | 0;
  if (i14 >>> 0 > i7 >>> 0) {
   if (i2 | 0) {
    i3 = 2 << i1;
    i3 = i2 << i1 & (i3 | 0 - i3);
    i3 = (i3 & 0 - i3) + -1 | 0;
    i8 = i3 >>> 12 & 16;
    i3 = i3 >>> i8;
    i5 = i3 >>> 5 & 8;
    i3 = i3 >>> i5;
    i6 = i3 >>> 2 & 4;
    i3 = i3 >>> i6;
    i4 = i3 >>> 1 & 2;
    i3 = i3 >>> i4;
    i2 = i3 >>> 1 & 1;
    i2 = (i5 | i8 | i6 | i4 | i2) + (i3 >>> i2) | 0;
    i3 = gb + 44352 + 40 + (i2 << 1 << 2) | 0;
    i4 = i3 + 8 | 0;
    i6 = HEAP32[i4 >> 2] | 0;
    i8 = i6 + 8 | 0;
    i5 = HEAP32[i8 >> 2] | 0;
    do if ((i3 | 0) != (i5 | 0)) {
     if (i5 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
     i1 = i5 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i6 | 0)) {
      HEAP32[i1 >> 2] = i3;
      HEAP32[i4 >> 2] = i5;
      i10 = HEAP32[gb + 44352 + 8 >> 2] | 0;
      break;
     } else _abort();
    } else {
     HEAP32[gb + 44352 >> 2] = i9 & ~(1 << i2);
     i10 = i7;
    } while (0);
    i7 = (i2 << 3) - i14 | 0;
    HEAP32[i6 + 4 >> 2] = i14 | 3;
    i4 = i6 + i14 | 0;
    HEAP32[i4 + 4 >> 2] = i7 | 1;
    HEAP32[i4 + i7 >> 2] = i7;
    if (i10 | 0) {
     i5 = HEAP32[gb + 44352 + 20 >> 2] | 0;
     i2 = i10 >>> 3;
     i3 = gb + 44352 + 40 + (i2 << 1 << 2) | 0;
     i1 = HEAP32[gb + 44352 >> 2] | 0;
     i2 = 1 << i2;
     if (i1 & i2) {
      i1 = i3 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
       i11 = i1;
       i12 = i2;
      }
     } else {
      HEAP32[gb + 44352 >> 2] = i1 | i2;
      i11 = i3 + 8 | 0;
      i12 = i3;
     }
     HEAP32[i11 >> 2] = i5;
     HEAP32[i12 + 12 >> 2] = i5;
     HEAP32[i5 + 8 >> 2] = i12;
     HEAP32[i5 + 12 >> 2] = i3;
    }
    HEAP32[gb + 44352 + 8 >> 2] = i7;
    HEAP32[gb + 44352 + 20 >> 2] = i4;
    i37 = i8;
    return i37 | 0;
   }
   i1 = HEAP32[gb + 44352 + 4 >> 2] | 0;
   if (i1) {
    i3 = (i1 & 0 - i1) + -1 | 0;
    i36 = i3 >>> 12 & 16;
    i3 = i3 >>> i36;
    i35 = i3 >>> 5 & 8;
    i3 = i3 >>> i35;
    i37 = i3 >>> 2 & 4;
    i3 = i3 >>> i37;
    i2 = i3 >>> 1 & 2;
    i3 = i3 >>> i2;
    i4 = i3 >>> 1 & 1;
    i4 = HEAP32[gb + 44352 + 304 + ((i35 | i36 | i37 | i2 | i4) + (i3 >>> i4) << 2) >> 2] | 0;
    i3 = (HEAP32[i4 + 4 >> 2] & -8) - i14 | 0;
    i2 = i4;
    while (1) {
     i1 = HEAP32[i2 + 16 >> 2] | 0;
     if (!i1) {
      i1 = HEAP32[i2 + 20 >> 2] | 0;
      if (!i1) {
       i9 = i4;
       break;
      }
     }
     i2 = (HEAP32[i1 + 4 >> 2] & -8) - i14 | 0;
     i37 = i2 >>> 0 < i3 >>> 0;
     i3 = i37 ? i2 : i3;
     i2 = i1;
     i4 = i37 ? i1 : i4;
    }
    i6 = HEAP32[gb + 44352 + 16 >> 2] | 0;
    if (i9 >>> 0 < i6 >>> 0) _abort();
    i8 = i9 + i14 | 0;
    if (i9 >>> 0 >= i8 >>> 0) _abort();
    i7 = HEAP32[i9 + 24 >> 2] | 0;
    i4 = HEAP32[i9 + 12 >> 2] | 0;
    do if ((i4 | 0) == (i9 | 0)) {
     i2 = i9 + 20 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i2 = i9 + 16 | 0;
      i1 = HEAP32[i2 >> 2] | 0;
      if (!i1) {
       i13 = 0;
       break;
      }
     }
     while (1) {
      i4 = i1 + 20 | 0;
      i5 = HEAP32[i4 >> 2] | 0;
      if (i5 | 0) {
       i1 = i5;
       i2 = i4;
       continue;
      }
      i4 = i1 + 16 | 0;
      i5 = HEAP32[i4 >> 2] | 0;
      if (!i5) break; else {
       i1 = i5;
       i2 = i4;
      }
     }
     if (i2 >>> 0 < i6 >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = 0;
      i13 = i1;
      break;
     }
    } else {
     i5 = HEAP32[i9 + 8 >> 2] | 0;
     if (i5 >>> 0 < i6 >>> 0) _abort();
     i1 = i5 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) != (i9 | 0)) _abort();
     i2 = i4 + 8 | 0;
     if ((HEAP32[i2 >> 2] | 0) == (i9 | 0)) {
      HEAP32[i1 >> 2] = i4;
      HEAP32[i2 >> 2] = i5;
      i13 = i4;
      break;
     } else _abort();
    } while (0);
    do if (i7 | 0) {
     i1 = HEAP32[i9 + 28 >> 2] | 0;
     i2 = gb + 44352 + 304 + (i1 << 2) | 0;
     if ((i9 | 0) == (HEAP32[i2 >> 2] | 0)) {
      HEAP32[i2 >> 2] = i13;
      if (!i13) {
       HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
       break;
      }
     } else {
      if (i7 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
      i1 = i7 + 16 | 0;
      if ((HEAP32[i1 >> 2] | 0) == (i9 | 0)) HEAP32[i1 >> 2] = i13; else HEAP32[i7 + 20 >> 2] = i13;
      if (!i13) break;
     }
     i2 = HEAP32[gb + 44352 + 16 >> 2] | 0;
     if (i13 >>> 0 < i2 >>> 0) _abort();
     HEAP32[i13 + 24 >> 2] = i7;
     i1 = HEAP32[i9 + 16 >> 2] | 0;
     do if (i1 | 0) if (i1 >>> 0 < i2 >>> 0) _abort(); else {
      HEAP32[i13 + 16 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i13;
      break;
     } while (0);
     i1 = HEAP32[i9 + 20 >> 2] | 0;
     if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i13 + 20 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i13;
      break;
     }
    } while (0);
    if (i3 >>> 0 < 16) {
     i37 = i3 + i14 | 0;
     HEAP32[i9 + 4 >> 2] = i37 | 3;
     i37 = i9 + i37 + 4 | 0;
     HEAP32[i37 >> 2] = HEAP32[i37 >> 2] | 1;
    } else {
     HEAP32[i9 + 4 >> 2] = i14 | 3;
     HEAP32[i8 + 4 >> 2] = i3 | 1;
     HEAP32[i8 + i3 >> 2] = i3;
     i1 = HEAP32[gb + 44352 + 8 >> 2] | 0;
     if (i1 | 0) {
      i5 = HEAP32[gb + 44352 + 20 >> 2] | 0;
      i2 = i1 >>> 3;
      i4 = gb + 44352 + 40 + (i2 << 1 << 2) | 0;
      i1 = HEAP32[gb + 44352 >> 2] | 0;
      i2 = 1 << i2;
      if (i1 & i2) {
       i1 = i4 + 8 | 0;
       i2 = HEAP32[i1 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
        i15 = i1;
        i16 = i2;
       }
      } else {
       HEAP32[gb + 44352 >> 2] = i1 | i2;
       i15 = i4 + 8 | 0;
       i16 = i4;
      }
      HEAP32[i15 >> 2] = i5;
      HEAP32[i16 + 12 >> 2] = i5;
      HEAP32[i5 + 8 >> 2] = i16;
      HEAP32[i5 + 12 >> 2] = i4;
     }
     HEAP32[gb + 44352 + 8 >> 2] = i3;
     HEAP32[gb + 44352 + 20 >> 2] = i8;
    }
    i37 = i9 + 8 | 0;
    return i37 | 0;
   }
  }
 } else if (i1 >>> 0 <= 4294967231) {
  i1 = i1 + 11 | 0;
  i14 = i1 & -8;
  i9 = HEAP32[gb + 44352 + 4 >> 2] | 0;
  if (i9) {
   i3 = 0 - i14 | 0;
   i1 = i1 >>> 8;
   if (i1) if (i14 >>> 0 > 16777215) i8 = 31; else {
    i16 = (i1 + 1048320 | 0) >>> 16 & 8;
    i30 = i1 << i16;
    i15 = (i30 + 520192 | 0) >>> 16 & 4;
    i30 = i30 << i15;
    i8 = (i30 + 245760 | 0) >>> 16 & 2;
    i8 = 14 - (i15 | i16 | i8) + (i30 << i8 >>> 15) | 0;
    i8 = i14 >>> (i8 + 7 | 0) & 1 | i8 << 1;
   } else i8 = 0;
   i2 = HEAP32[gb + 44352 + 304 + (i8 << 2) >> 2] | 0;
   L123 : do if (!i2) {
    i1 = 0;
    i2 = 0;
    i30 = 86;
   } else {
    i5 = i3;
    i1 = 0;
    i6 = i14 << ((i8 | 0) == 31 ? 0 : 25 - (i8 >>> 1) | 0);
    i7 = i2;
    i2 = 0;
    while (1) {
     i4 = HEAP32[i7 + 4 >> 2] & -8;
     i3 = i4 - i14 | 0;
     if (i3 >>> 0 < i5 >>> 0) if ((i4 | 0) == (i14 | 0)) {
      i1 = i7;
      i2 = i7;
      i30 = 90;
      break L123;
     } else i2 = i7; else i3 = i5;
     i4 = HEAP32[i7 + 20 >> 2] | 0;
     i7 = HEAP32[i7 + 16 + (i6 >>> 31 << 2) >> 2] | 0;
     i1 = (i4 | 0) == 0 | (i4 | 0) == (i7 | 0) ? i1 : i4;
     i4 = (i7 | 0) == 0;
     if (i4) {
      i30 = 86;
      break;
     } else {
      i5 = i3;
      i6 = i6 << (i4 & 1 ^ 1);
     }
    }
   } while (0);
   if ((i30 | 0) == 86) {
    if ((i1 | 0) == 0 & (i2 | 0) == 0) {
     i1 = 2 << i8;
     i1 = i9 & (i1 | 0 - i1);
     if (!i1) break;
     i16 = (i1 & 0 - i1) + -1 | 0;
     i12 = i16 >>> 12 & 16;
     i16 = i16 >>> i12;
     i11 = i16 >>> 5 & 8;
     i16 = i16 >>> i11;
     i13 = i16 >>> 2 & 4;
     i16 = i16 >>> i13;
     i15 = i16 >>> 1 & 2;
     i16 = i16 >>> i15;
     i1 = i16 >>> 1 & 1;
     i1 = HEAP32[gb + 44352 + 304 + ((i11 | i12 | i13 | i15 | i1) + (i16 >>> i1) << 2) >> 2] | 0;
    }
    if (!i1) {
     i8 = i3;
     i9 = i2;
    } else i30 = 90;
   }
   if ((i30 | 0) == 90) while (1) {
    i30 = 0;
    i16 = (HEAP32[i1 + 4 >> 2] & -8) - i14 | 0;
    i4 = i16 >>> 0 < i3 >>> 0;
    i3 = i4 ? i16 : i3;
    i2 = i4 ? i1 : i2;
    i4 = HEAP32[i1 + 16 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i30 = 90;
     continue;
    }
    i1 = HEAP32[i1 + 20 >> 2] | 0;
    if (!i1) {
     i8 = i3;
     i9 = i2;
     break;
    } else i30 = 90;
   }
   if ((i9 | 0) != 0 ? i8 >>> 0 < ((HEAP32[gb + 44352 + 8 >> 2] | 0) - i14 | 0) >>> 0 : 0) {
    i5 = HEAP32[gb + 44352 + 16 >> 2] | 0;
    if (i9 >>> 0 < i5 >>> 0) _abort();
    i7 = i9 + i14 | 0;
    if (i9 >>> 0 >= i7 >>> 0) _abort();
    i6 = HEAP32[i9 + 24 >> 2] | 0;
    i3 = HEAP32[i9 + 12 >> 2] | 0;
    do if ((i3 | 0) == (i9 | 0)) {
     i2 = i9 + 20 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i2 = i9 + 16 | 0;
      i1 = HEAP32[i2 >> 2] | 0;
      if (!i1) {
       i18 = 0;
       break;
      }
     }
     while (1) {
      i3 = i1 + 20 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (i4 | 0) {
       i1 = i4;
       i2 = i3;
       continue;
      }
      i3 = i1 + 16 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (!i4) break; else {
       i1 = i4;
       i2 = i3;
      }
     }
     if (i2 >>> 0 < i5 >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = 0;
      i18 = i1;
      break;
     }
    } else {
     i4 = HEAP32[i9 + 8 >> 2] | 0;
     if (i4 >>> 0 < i5 >>> 0) _abort();
     i1 = i4 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) != (i9 | 0)) _abort();
     i2 = i3 + 8 | 0;
     if ((HEAP32[i2 >> 2] | 0) == (i9 | 0)) {
      HEAP32[i1 >> 2] = i3;
      HEAP32[i2 >> 2] = i4;
      i18 = i3;
      break;
     } else _abort();
    } while (0);
    do if (i6 | 0) {
     i1 = HEAP32[i9 + 28 >> 2] | 0;
     i2 = gb + 44352 + 304 + (i1 << 2) | 0;
     if ((i9 | 0) == (HEAP32[i2 >> 2] | 0)) {
      HEAP32[i2 >> 2] = i18;
      if (!i18) {
       HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
       break;
      }
     } else {
      if (i6 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
      i1 = i6 + 16 | 0;
      if ((HEAP32[i1 >> 2] | 0) == (i9 | 0)) HEAP32[i1 >> 2] = i18; else HEAP32[i6 + 20 >> 2] = i18;
      if (!i18) break;
     }
     i2 = HEAP32[gb + 44352 + 16 >> 2] | 0;
     if (i18 >>> 0 < i2 >>> 0) _abort();
     HEAP32[i18 + 24 >> 2] = i6;
     i1 = HEAP32[i9 + 16 >> 2] | 0;
     do if (i1 | 0) if (i1 >>> 0 < i2 >>> 0) _abort(); else {
      HEAP32[i18 + 16 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i18;
      break;
     } while (0);
     i1 = HEAP32[i9 + 20 >> 2] | 0;
     if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i18 + 20 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i18;
      break;
     }
    } while (0);
    do if (i8 >>> 0 >= 16) {
     HEAP32[i9 + 4 >> 2] = i14 | 3;
     HEAP32[i7 + 4 >> 2] = i8 | 1;
     HEAP32[i7 + i8 >> 2] = i8;
     i1 = i8 >>> 3;
     if (i8 >>> 0 < 256) {
      i3 = gb + 44352 + 40 + (i1 << 1 << 2) | 0;
      i2 = HEAP32[gb + 44352 >> 2] | 0;
      i1 = 1 << i1;
      if (i2 & i1) {
       i1 = i3 + 8 | 0;
       i2 = HEAP32[i1 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
        i20 = i1;
        i21 = i2;
       }
      } else {
       HEAP32[gb + 44352 >> 2] = i2 | i1;
       i20 = i3 + 8 | 0;
       i21 = i3;
      }
      HEAP32[i20 >> 2] = i7;
      HEAP32[i21 + 12 >> 2] = i7;
      HEAP32[i7 + 8 >> 2] = i21;
      HEAP32[i7 + 12 >> 2] = i3;
      break;
     }
     i1 = i8 >>> 8;
     if (i1) if (i8 >>> 0 > 16777215) i3 = 31; else {
      i36 = (i1 + 1048320 | 0) >>> 16 & 8;
      i37 = i1 << i36;
      i35 = (i37 + 520192 | 0) >>> 16 & 4;
      i37 = i37 << i35;
      i3 = (i37 + 245760 | 0) >>> 16 & 2;
      i3 = 14 - (i35 | i36 | i3) + (i37 << i3 >>> 15) | 0;
      i3 = i8 >>> (i3 + 7 | 0) & 1 | i3 << 1;
     } else i3 = 0;
     i4 = gb + 44352 + 304 + (i3 << 2) | 0;
     HEAP32[i7 + 28 >> 2] = i3;
     i1 = i7 + 16 | 0;
     HEAP32[i1 + 4 >> 2] = 0;
     HEAP32[i1 >> 2] = 0;
     i1 = HEAP32[gb + 44352 + 4 >> 2] | 0;
     i2 = 1 << i3;
     if (!(i1 & i2)) {
      HEAP32[gb + 44352 + 4 >> 2] = i1 | i2;
      HEAP32[i4 >> 2] = i7;
      HEAP32[i7 + 24 >> 2] = i4;
      HEAP32[i7 + 12 >> 2] = i7;
      HEAP32[i7 + 8 >> 2] = i7;
      break;
     }
     i5 = i8 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
     i1 = HEAP32[i4 >> 2] | 0;
     while (1) {
      if ((HEAP32[i1 + 4 >> 2] & -8 | 0) == (i8 | 0)) {
       i3 = i1;
       i30 = 148;
       break;
      }
      i2 = i1 + 16 + (i5 >>> 31 << 2) | 0;
      i3 = HEAP32[i2 >> 2] | 0;
      if (!i3) {
       i30 = 145;
       break;
      } else {
       i5 = i5 << 1;
       i1 = i3;
      }
     }
     if ((i30 | 0) == 145) if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = i7;
      HEAP32[i7 + 24 >> 2] = i1;
      HEAP32[i7 + 12 >> 2] = i7;
      HEAP32[i7 + 8 >> 2] = i7;
      break;
     } else if ((i30 | 0) == 148) {
      i1 = i3 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      i37 = HEAP32[gb + 44352 + 16 >> 2] | 0;
      if (i2 >>> 0 >= i37 >>> 0 & i3 >>> 0 >= i37 >>> 0) {
       HEAP32[i2 + 12 >> 2] = i7;
       HEAP32[i1 >> 2] = i7;
       HEAP32[i7 + 8 >> 2] = i2;
       HEAP32[i7 + 12 >> 2] = i3;
       HEAP32[i7 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } else {
     i37 = i8 + i14 | 0;
     HEAP32[i9 + 4 >> 2] = i37 | 3;
     i37 = i9 + i37 + 4 | 0;
     HEAP32[i37 >> 2] = HEAP32[i37 >> 2] | 1;
    } while (0);
    i37 = i9 + 8 | 0;
    return i37 | 0;
   }
  }
 } else i14 = -1; while (0);
 i3 = HEAP32[gb + 44352 + 8 >> 2] | 0;
 if (i3 >>> 0 >= i14 >>> 0) {
  i1 = i3 - i14 | 0;
  i2 = HEAP32[gb + 44352 + 20 >> 2] | 0;
  if (i1 >>> 0 > 15) {
   i37 = i2 + i14 | 0;
   HEAP32[gb + 44352 + 20 >> 2] = i37;
   HEAP32[gb + 44352 + 8 >> 2] = i1;
   HEAP32[i37 + 4 >> 2] = i1 | 1;
   HEAP32[i37 + i1 >> 2] = i1;
   HEAP32[i2 + 4 >> 2] = i14 | 3;
  } else {
   HEAP32[gb + 44352 + 8 >> 2] = 0;
   HEAP32[gb + 44352 + 20 >> 2] = 0;
   HEAP32[i2 + 4 >> 2] = i3 | 3;
   i37 = i2 + i3 + 4 | 0;
   HEAP32[i37 >> 2] = HEAP32[i37 >> 2] | 1;
  }
  i37 = i2 + 8 | 0;
  return i37 | 0;
 }
 i1 = HEAP32[gb + 44352 + 12 >> 2] | 0;
 if (i1 >>> 0 > i14 >>> 0) {
  i35 = i1 - i14 | 0;
  HEAP32[gb + 44352 + 12 >> 2] = i35;
  i37 = HEAP32[gb + 44352 + 24 >> 2] | 0;
  i36 = i37 + i14 | 0;
  HEAP32[gb + 44352 + 24 >> 2] = i36;
  HEAP32[i36 + 4 >> 2] = i35 | 1;
  HEAP32[i37 + 4 >> 2] = i14 | 3;
  i37 = i37 + 8 | 0;
  return i37 | 0;
 }
 do if (!(HEAP32[gb + 44824 >> 2] | 0)) {
  i1 = _sysconf(30) | 0;
  if (!(i1 + -1 & i1)) {
   HEAP32[gb + 44824 + 8 >> 2] = i1;
   HEAP32[gb + 44824 + 4 >> 2] = i1;
   HEAP32[gb + 44824 + 12 >> 2] = -1;
   HEAP32[gb + 44824 + 16 >> 2] = -1;
   HEAP32[gb + 44824 + 20 >> 2] = 0;
   HEAP32[gb + 44352 + 444 >> 2] = 0;
   i21 = (_time(0) | 0) & -16 ^ 1431655768;
   HEAP32[gb + 44824 >> 2] = i21;
   break;
  } else _abort();
 } while (0);
 i7 = i14 + 48 | 0;
 i6 = HEAP32[gb + 44824 + 8 >> 2] | 0;
 i8 = i14 + 47 | 0;
 i5 = i6 + i8 | 0;
 i6 = 0 - i6 | 0;
 i9 = i5 & i6;
 if (i9 >>> 0 <= i14 >>> 0) {
  i37 = 0;
  return i37 | 0;
 }
 i1 = HEAP32[gb + 44352 + 440 >> 2] | 0;
 if (i1 | 0 ? (i20 = HEAP32[gb + 44352 + 432 >> 2] | 0, i21 = i20 + i9 | 0, i21 >>> 0 <= i20 >>> 0 | i21 >>> 0 > i1 >>> 0) : 0) {
  i37 = 0;
  return i37 | 0;
 }
 L257 : do if (!(HEAP32[gb + 44352 + 444 >> 2] & 4)) {
  i1 = HEAP32[gb + 44352 + 24 >> 2] | 0;
  L259 : do if (i1) {
   i3 = gb + 44352 + 448 | 0;
   while (1) {
    i2 = HEAP32[i3 >> 2] | 0;
    if (i2 >>> 0 <= i1 >>> 0 ? (i17 = i3 + 4 | 0, (i2 + (HEAP32[i17 >> 2] | 0) | 0) >>> 0 > i1 >>> 0) : 0) {
     i4 = i3;
     i3 = i17;
     break;
    }
    i3 = HEAP32[i3 + 8 >> 2] | 0;
    if (!i3) {
     i30 = 173;
     break L259;
    }
   }
   i1 = i5 - (HEAP32[gb + 44352 + 12 >> 2] | 0) & i6;
   if (i1 >>> 0 < 2147483647) {
    i2 = _sbrk(i1 | 0) | 0;
    if ((i2 | 0) == ((HEAP32[i4 >> 2] | 0) + (HEAP32[i3 >> 2] | 0) | 0)) {
     if ((i2 | 0) != (-1 | 0)) {
      i7 = i2;
      i5 = i1;
      i30 = 193;
      break L257;
     }
    } else i30 = 183;
   }
  } else i30 = 173; while (0);
  do if ((i30 | 0) == 173 ? (i19 = _sbrk(0) | 0, (i19 | 0) != (-1 | 0)) : 0) {
   i1 = i19;
   i2 = HEAP32[gb + 44824 + 4 >> 2] | 0;
   i3 = i2 + -1 | 0;
   if (!(i3 & i1)) i1 = i9; else i1 = i9 - i1 + (i3 + i1 & 0 - i2) | 0;
   i2 = HEAP32[gb + 44352 + 432 >> 2] | 0;
   i3 = i2 + i1 | 0;
   if (i1 >>> 0 > i14 >>> 0 & i1 >>> 0 < 2147483647) {
    i21 = HEAP32[gb + 44352 + 440 >> 2] | 0;
    if (i21 | 0 ? i3 >>> 0 <= i2 >>> 0 | i3 >>> 0 > i21 >>> 0 : 0) break;
    i2 = _sbrk(i1 | 0) | 0;
    if ((i2 | 0) == (i19 | 0)) {
     i7 = i19;
     i5 = i1;
     i30 = 193;
     break L257;
    } else i30 = 183;
   }
  } while (0);
  L279 : do if ((i30 | 0) == 183) {
   i3 = 0 - i1 | 0;
   do if (i7 >>> 0 > i1 >>> 0 & (i1 >>> 0 < 2147483647 & (i2 | 0) != (-1 | 0)) ? (i22 = HEAP32[gb + 44824 + 8 >> 2] | 0, i22 = i8 - i1 + i22 & 0 - i22, i22 >>> 0 < 2147483647) : 0) if ((_sbrk(i22 | 0) | 0) == (-1 | 0)) {
    _sbrk(i3 | 0) | 0;
    break L279;
   } else {
    i1 = i22 + i1 | 0;
    break;
   } while (0);
   if ((i2 | 0) != (-1 | 0)) {
    i7 = i2;
    i5 = i1;
    i30 = 193;
    break L257;
   }
  } while (0);
  HEAP32[gb + 44352 + 444 >> 2] = HEAP32[gb + 44352 + 444 >> 2] | 4;
  i30 = 190;
 } else i30 = 190; while (0);
 if ((((i30 | 0) == 190 ? i9 >>> 0 < 2147483647 : 0) ? (i23 = _sbrk(i9 | 0) | 0, i24 = _sbrk(0) | 0, i23 >>> 0 < i24 >>> 0 & ((i23 | 0) != (-1 | 0) & (i24 | 0) != (-1 | 0))) : 0) ? (i25 = i24 - i23 | 0, i25 >>> 0 > (i14 + 40 | 0) >>> 0) : 0) {
  i7 = i23;
  i5 = i25;
  i30 = 193;
 }
 if ((i30 | 0) == 193) {
  i1 = (HEAP32[gb + 44352 + 432 >> 2] | 0) + i5 | 0;
  HEAP32[gb + 44352 + 432 >> 2] = i1;
  if (i1 >>> 0 > (HEAP32[gb + 44352 + 436 >> 2] | 0) >>> 0) HEAP32[gb + 44352 + 436 >> 2] = i1;
  i8 = HEAP32[gb + 44352 + 24 >> 2] | 0;
  do if (i8) {
   i4 = gb + 44352 + 448 | 0;
   do {
    i1 = HEAP32[i4 >> 2] | 0;
    i2 = i4 + 4 | 0;
    i3 = HEAP32[i2 >> 2] | 0;
    if ((i7 | 0) == (i1 + i3 | 0)) {
     i26 = i1;
     i27 = i2;
     i28 = i3;
     i29 = i4;
     i30 = 203;
     break;
    }
    i4 = HEAP32[i4 + 8 >> 2] | 0;
   } while ((i4 | 0) != 0);
   if (((i30 | 0) == 203 ? (HEAP32[i29 + 12 >> 2] & 8 | 0) == 0 : 0) ? i8 >>> 0 < i7 >>> 0 & i8 >>> 0 >= i26 >>> 0 : 0) {
    HEAP32[i27 >> 2] = i28 + i5;
    i37 = i8 + 8 | 0;
    i37 = (i37 & 7 | 0) == 0 ? 0 : 0 - i37 & 7;
    i36 = i8 + i37 | 0;
    i37 = i5 - i37 + (HEAP32[gb + 44352 + 12 >> 2] | 0) | 0;
    HEAP32[gb + 44352 + 24 >> 2] = i36;
    HEAP32[gb + 44352 + 12 >> 2] = i37;
    HEAP32[i36 + 4 >> 2] = i37 | 1;
    HEAP32[i36 + i37 + 4 >> 2] = 40;
    HEAP32[gb + 44352 + 28 >> 2] = HEAP32[gb + 44824 + 16 >> 2];
    break;
   }
   i1 = HEAP32[gb + 44352 + 16 >> 2] | 0;
   if (i7 >>> 0 < i1 >>> 0) {
    HEAP32[gb + 44352 + 16 >> 2] = i7;
    i9 = i7;
   } else i9 = i1;
   i3 = i7 + i5 | 0;
   i1 = gb + 44352 + 448 | 0;
   while (1) {
    if ((HEAP32[i1 >> 2] | 0) == (i3 | 0)) {
     i2 = i1;
     i30 = 211;
     break;
    }
    i1 = HEAP32[i1 + 8 >> 2] | 0;
    if (!i1) {
     i2 = gb + 44352 + 448 | 0;
     break;
    }
   }
   if ((i30 | 0) == 211) if (!(HEAP32[i1 + 12 >> 2] & 8)) {
    HEAP32[i2 >> 2] = i7;
    i11 = i1 + 4 | 0;
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + i5;
    i11 = i7 + 8 | 0;
    i11 = i7 + ((i11 & 7 | 0) == 0 ? 0 : 0 - i11 & 7) | 0;
    i1 = i3 + 8 | 0;
    i1 = i3 + ((i1 & 7 | 0) == 0 ? 0 : 0 - i1 & 7) | 0;
    i10 = i11 + i14 | 0;
    i6 = i1 - i11 - i14 | 0;
    HEAP32[i11 + 4 >> 2] = i14 | 3;
    do if ((i1 | 0) != (i8 | 0)) {
     if ((i1 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
      i37 = (HEAP32[gb + 44352 + 8 >> 2] | 0) + i6 | 0;
      HEAP32[gb + 44352 + 8 >> 2] = i37;
      HEAP32[gb + 44352 + 20 >> 2] = i10;
      HEAP32[i10 + 4 >> 2] = i37 | 1;
      HEAP32[i10 + i37 >> 2] = i37;
      break;
     }
     i2 = HEAP32[i1 + 4 >> 2] | 0;
     if ((i2 & 3 | 0) == 1) {
      i8 = i2 & -8;
      i5 = i2 >>> 3;
      L331 : do if (i2 >>> 0 >= 256) {
       i7 = HEAP32[i1 + 24 >> 2] | 0;
       i4 = HEAP32[i1 + 12 >> 2] | 0;
       do if ((i4 | 0) == (i1 | 0)) {
        i3 = i1 + 16 | 0;
        i4 = i3 + 4 | 0;
        i2 = HEAP32[i4 >> 2] | 0;
        if (!i2) {
         i2 = HEAP32[i3 >> 2] | 0;
         if (!i2) {
          i35 = 0;
          break;
         }
        } else i3 = i4;
        while (1) {
         i4 = i2 + 20 | 0;
         i5 = HEAP32[i4 >> 2] | 0;
         if (i5 | 0) {
          i2 = i5;
          i3 = i4;
          continue;
         }
         i4 = i2 + 16 | 0;
         i5 = HEAP32[i4 >> 2] | 0;
         if (!i5) break; else {
          i2 = i5;
          i3 = i4;
         }
        }
        if (i3 >>> 0 < i9 >>> 0) _abort(); else {
         HEAP32[i3 >> 2] = 0;
         i35 = i2;
         break;
        }
       } else {
        i5 = HEAP32[i1 + 8 >> 2] | 0;
        if (i5 >>> 0 < i9 >>> 0) _abort();
        i2 = i5 + 12 | 0;
        if ((HEAP32[i2 >> 2] | 0) != (i1 | 0)) _abort();
        i3 = i4 + 8 | 0;
        if ((HEAP32[i3 >> 2] | 0) == (i1 | 0)) {
         HEAP32[i2 >> 2] = i4;
         HEAP32[i3 >> 2] = i5;
         i35 = i4;
         break;
        } else _abort();
       } while (0);
       if (!i7) break;
       i2 = HEAP32[i1 + 28 >> 2] | 0;
       i3 = gb + 44352 + 304 + (i2 << 2) | 0;
       do if ((i1 | 0) != (HEAP32[i3 >> 2] | 0)) {
        if (i7 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
        i2 = i7 + 16 | 0;
        if ((HEAP32[i2 >> 2] | 0) == (i1 | 0)) HEAP32[i2 >> 2] = i35; else HEAP32[i7 + 20 >> 2] = i35;
        if (!i35) break L331;
       } else {
        HEAP32[i3 >> 2] = i35;
        if (i35 | 0) break;
        HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i2);
        break L331;
       } while (0);
       i4 = HEAP32[gb + 44352 + 16 >> 2] | 0;
       if (i35 >>> 0 < i4 >>> 0) _abort();
       HEAP32[i35 + 24 >> 2] = i7;
       i2 = i1 + 16 | 0;
       i3 = HEAP32[i2 >> 2] | 0;
       do if (i3 | 0) if (i3 >>> 0 < i4 >>> 0) _abort(); else {
        HEAP32[i35 + 16 >> 2] = i3;
        HEAP32[i3 + 24 >> 2] = i35;
        break;
       } while (0);
       i2 = HEAP32[i2 + 4 >> 2] | 0;
       if (!i2) break;
       if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
        HEAP32[i35 + 20 >> 2] = i2;
        HEAP32[i2 + 24 >> 2] = i35;
        break;
       }
      } else {
       i3 = HEAP32[i1 + 8 >> 2] | 0;
       i4 = HEAP32[i1 + 12 >> 2] | 0;
       i2 = gb + 44352 + 40 + (i5 << 1 << 2) | 0;
       do if ((i3 | 0) != (i2 | 0)) {
        if (i3 >>> 0 < i9 >>> 0) _abort();
        if ((HEAP32[i3 + 12 >> 2] | 0) == (i1 | 0)) break;
        _abort();
       } while (0);
       if ((i4 | 0) == (i3 | 0)) {
        HEAP32[gb + 44352 >> 2] = HEAP32[gb + 44352 >> 2] & ~(1 << i5);
        break;
       }
       do if ((i4 | 0) == (i2 | 0)) i32 = i4 + 8 | 0; else {
        if (i4 >>> 0 < i9 >>> 0) _abort();
        i2 = i4 + 8 | 0;
        if ((HEAP32[i2 >> 2] | 0) == (i1 | 0)) {
         i32 = i2;
         break;
        }
        _abort();
       } while (0);
       HEAP32[i3 + 12 >> 2] = i4;
       HEAP32[i32 >> 2] = i3;
      } while (0);
      i1 = i1 + i8 | 0;
      i6 = i8 + i6 | 0;
     }
     i1 = i1 + 4 | 0;
     HEAP32[i1 >> 2] = HEAP32[i1 >> 2] & -2;
     HEAP32[i10 + 4 >> 2] = i6 | 1;
     HEAP32[i10 + i6 >> 2] = i6;
     i1 = i6 >>> 3;
     if (i6 >>> 0 < 256) {
      i3 = gb + 44352 + 40 + (i1 << 1 << 2) | 0;
      i2 = HEAP32[gb + 44352 >> 2] | 0;
      i1 = 1 << i1;
      do if (!(i2 & i1)) {
       HEAP32[gb + 44352 >> 2] = i2 | i1;
       i36 = i3 + 8 | 0;
       i37 = i3;
      } else {
       i1 = i3 + 8 | 0;
       i2 = HEAP32[i1 >> 2] | 0;
       if (i2 >>> 0 >= (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) {
        i36 = i1;
        i37 = i2;
        break;
       }
       _abort();
      } while (0);
      HEAP32[i36 >> 2] = i10;
      HEAP32[i37 + 12 >> 2] = i10;
      HEAP32[i10 + 8 >> 2] = i37;
      HEAP32[i10 + 12 >> 2] = i3;
      break;
     }
     i1 = i6 >>> 8;
     do if (!i1) i3 = 0; else {
      if (i6 >>> 0 > 16777215) {
       i3 = 31;
       break;
      }
      i36 = (i1 + 1048320 | 0) >>> 16 & 8;
      i37 = i1 << i36;
      i35 = (i37 + 520192 | 0) >>> 16 & 4;
      i37 = i37 << i35;
      i3 = (i37 + 245760 | 0) >>> 16 & 2;
      i3 = 14 - (i35 | i36 | i3) + (i37 << i3 >>> 15) | 0;
      i3 = i6 >>> (i3 + 7 | 0) & 1 | i3 << 1;
     } while (0);
     i4 = gb + 44352 + 304 + (i3 << 2) | 0;
     HEAP32[i10 + 28 >> 2] = i3;
     i1 = i10 + 16 | 0;
     HEAP32[i1 + 4 >> 2] = 0;
     HEAP32[i1 >> 2] = 0;
     i1 = HEAP32[gb + 44352 + 4 >> 2] | 0;
     i2 = 1 << i3;
     if (!(i1 & i2)) {
      HEAP32[gb + 44352 + 4 >> 2] = i1 | i2;
      HEAP32[i4 >> 2] = i10;
      HEAP32[i10 + 24 >> 2] = i4;
      HEAP32[i10 + 12 >> 2] = i10;
      HEAP32[i10 + 8 >> 2] = i10;
      break;
     }
     i5 = i6 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
     i1 = HEAP32[i4 >> 2] | 0;
     while (1) {
      if ((HEAP32[i1 + 4 >> 2] & -8 | 0) == (i6 | 0)) {
       i3 = i1;
       i30 = 281;
       break;
      }
      i2 = i1 + 16 + (i5 >>> 31 << 2) | 0;
      i3 = HEAP32[i2 >> 2] | 0;
      if (!i3) {
       i30 = 278;
       break;
      } else {
       i5 = i5 << 1;
       i1 = i3;
      }
     }
     if ((i30 | 0) == 278) if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = i10;
      HEAP32[i10 + 24 >> 2] = i1;
      HEAP32[i10 + 12 >> 2] = i10;
      HEAP32[i10 + 8 >> 2] = i10;
      break;
     } else if ((i30 | 0) == 281) {
      i1 = i3 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      i37 = HEAP32[gb + 44352 + 16 >> 2] | 0;
      if (i2 >>> 0 >= i37 >>> 0 & i3 >>> 0 >= i37 >>> 0) {
       HEAP32[i2 + 12 >> 2] = i10;
       HEAP32[i1 >> 2] = i10;
       HEAP32[i10 + 8 >> 2] = i2;
       HEAP32[i10 + 12 >> 2] = i3;
       HEAP32[i10 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } else {
     i37 = (HEAP32[gb + 44352 + 12 >> 2] | 0) + i6 | 0;
     HEAP32[gb + 44352 + 12 >> 2] = i37;
     HEAP32[gb + 44352 + 24 >> 2] = i10;
     HEAP32[i10 + 4 >> 2] = i37 | 1;
    } while (0);
    i37 = i11 + 8 | 0;
    return i37 | 0;
   } else i2 = gb + 44352 + 448 | 0;
   while (1) {
    i1 = HEAP32[i2 >> 2] | 0;
    if (i1 >>> 0 <= i8 >>> 0 ? (i31 = i1 + (HEAP32[i2 + 4 >> 2] | 0) | 0, i31 >>> 0 > i8 >>> 0) : 0) {
     i2 = i31;
     break;
    }
    i2 = HEAP32[i2 + 8 >> 2] | 0;
   }
   i6 = i2 + -47 | 0;
   i3 = i6 + 8 | 0;
   i3 = i6 + ((i3 & 7 | 0) == 0 ? 0 : 0 - i3 & 7) | 0;
   i6 = i8 + 16 | 0;
   i3 = i3 >>> 0 < i6 >>> 0 ? i8 : i3;
   i1 = i3 + 8 | 0;
   i4 = i7 + 8 | 0;
   i4 = (i4 & 7 | 0) == 0 ? 0 : 0 - i4 & 7;
   i37 = i7 + i4 | 0;
   i4 = i5 + -40 - i4 | 0;
   HEAP32[gb + 44352 + 24 >> 2] = i37;
   HEAP32[gb + 44352 + 12 >> 2] = i4;
   HEAP32[i37 + 4 >> 2] = i4 | 1;
   HEAP32[i37 + i4 + 4 >> 2] = 40;
   HEAP32[gb + 44352 + 28 >> 2] = HEAP32[gb + 44824 + 16 >> 2];
   i4 = i3 + 4 | 0;
   HEAP32[i4 >> 2] = 27;
   HEAP32[i1 >> 2] = HEAP32[gb + 44352 + 448 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[gb + 44352 + 448 + 4 >> 2];
   HEAP32[i1 + 8 >> 2] = HEAP32[gb + 44352 + 448 + 8 >> 2];
   HEAP32[i1 + 12 >> 2] = HEAP32[gb + 44352 + 448 + 12 >> 2];
   HEAP32[gb + 44352 + 448 >> 2] = i7;
   HEAP32[gb + 44352 + 452 >> 2] = i5;
   HEAP32[gb + 44352 + 460 >> 2] = 0;
   HEAP32[gb + 44352 + 456 >> 2] = i1;
   i1 = i3 + 24 | 0;
   do {
    i1 = i1 + 4 | 0;
    HEAP32[i1 >> 2] = 7;
   } while ((i1 + 4 | 0) >>> 0 < i2 >>> 0);
   if ((i3 | 0) != (i8 | 0)) {
    i7 = i3 - i8 | 0;
    HEAP32[i4 >> 2] = HEAP32[i4 >> 2] & -2;
    HEAP32[i8 + 4 >> 2] = i7 | 1;
    HEAP32[i3 >> 2] = i7;
    i1 = i7 >>> 3;
    if (i7 >>> 0 < 256) {
     i3 = gb + 44352 + 40 + (i1 << 1 << 2) | 0;
     i2 = HEAP32[gb + 44352 >> 2] | 0;
     i1 = 1 << i1;
     if (i2 & i1) {
      i1 = i3 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
       i33 = i1;
       i34 = i2;
      }
     } else {
      HEAP32[gb + 44352 >> 2] = i2 | i1;
      i33 = i3 + 8 | 0;
      i34 = i3;
     }
     HEAP32[i33 >> 2] = i8;
     HEAP32[i34 + 12 >> 2] = i8;
     HEAP32[i8 + 8 >> 2] = i34;
     HEAP32[i8 + 12 >> 2] = i3;
     break;
    }
    i1 = i7 >>> 8;
    if (i1) if (i7 >>> 0 > 16777215) i3 = 31; else {
     i36 = (i1 + 1048320 | 0) >>> 16 & 8;
     i37 = i1 << i36;
     i35 = (i37 + 520192 | 0) >>> 16 & 4;
     i37 = i37 << i35;
     i3 = (i37 + 245760 | 0) >>> 16 & 2;
     i3 = 14 - (i35 | i36 | i3) + (i37 << i3 >>> 15) | 0;
     i3 = i7 >>> (i3 + 7 | 0) & 1 | i3 << 1;
    } else i3 = 0;
    i5 = gb + 44352 + 304 + (i3 << 2) | 0;
    HEAP32[i8 + 28 >> 2] = i3;
    HEAP32[i8 + 20 >> 2] = 0;
    HEAP32[i6 >> 2] = 0;
    i1 = HEAP32[gb + 44352 + 4 >> 2] | 0;
    i2 = 1 << i3;
    if (!(i1 & i2)) {
     HEAP32[gb + 44352 + 4 >> 2] = i1 | i2;
     HEAP32[i5 >> 2] = i8;
     HEAP32[i8 + 24 >> 2] = i5;
     HEAP32[i8 + 12 >> 2] = i8;
     HEAP32[i8 + 8 >> 2] = i8;
     break;
    }
    i4 = i7 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
    i1 = HEAP32[i5 >> 2] | 0;
    while (1) {
     if ((HEAP32[i1 + 4 >> 2] & -8 | 0) == (i7 | 0)) {
      i3 = i1;
      i30 = 307;
      break;
     }
     i2 = i1 + 16 + (i4 >>> 31 << 2) | 0;
     i3 = HEAP32[i2 >> 2] | 0;
     if (!i3) {
      i30 = 304;
      break;
     } else {
      i4 = i4 << 1;
      i1 = i3;
     }
    }
    if ((i30 | 0) == 304) if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i2 >> 2] = i8;
     HEAP32[i8 + 24 >> 2] = i1;
     HEAP32[i8 + 12 >> 2] = i8;
     HEAP32[i8 + 8 >> 2] = i8;
     break;
    } else if ((i30 | 0) == 307) {
     i1 = i3 + 8 | 0;
     i2 = HEAP32[i1 >> 2] | 0;
     i37 = HEAP32[gb + 44352 + 16 >> 2] | 0;
     if (i2 >>> 0 >= i37 >>> 0 & i3 >>> 0 >= i37 >>> 0) {
      HEAP32[i2 + 12 >> 2] = i8;
      HEAP32[i1 >> 2] = i8;
      HEAP32[i8 + 8 >> 2] = i2;
      HEAP32[i8 + 12 >> 2] = i3;
      HEAP32[i8 + 24 >> 2] = 0;
      break;
     } else _abort();
    }
   }
  } else {
   i37 = HEAP32[gb + 44352 + 16 >> 2] | 0;
   if ((i37 | 0) == 0 | i7 >>> 0 < i37 >>> 0) HEAP32[gb + 44352 + 16 >> 2] = i7;
   HEAP32[gb + 44352 + 448 >> 2] = i7;
   HEAP32[gb + 44352 + 452 >> 2] = i5;
   HEAP32[gb + 44352 + 460 >> 2] = 0;
   HEAP32[gb + 44352 + 36 >> 2] = HEAP32[gb + 44824 >> 2];
   HEAP32[gb + 44352 + 32 >> 2] = -1;
   i1 = 0;
   do {
    i37 = gb + 44352 + 40 + (i1 << 1 << 2) | 0;
    HEAP32[i37 + 12 >> 2] = i37;
    HEAP32[i37 + 8 >> 2] = i37;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != 32);
   i37 = i7 + 8 | 0;
   i37 = (i37 & 7 | 0) == 0 ? 0 : 0 - i37 & 7;
   i36 = i7 + i37 | 0;
   i37 = i5 + -40 - i37 | 0;
   HEAP32[gb + 44352 + 24 >> 2] = i36;
   HEAP32[gb + 44352 + 12 >> 2] = i37;
   HEAP32[i36 + 4 >> 2] = i37 | 1;
   HEAP32[i36 + i37 + 4 >> 2] = 40;
   HEAP32[gb + 44352 + 28 >> 2] = HEAP32[gb + 44824 + 16 >> 2];
  } while (0);
  i1 = HEAP32[gb + 44352 + 12 >> 2] | 0;
  if (i1 >>> 0 > i14 >>> 0) {
   i35 = i1 - i14 | 0;
   HEAP32[gb + 44352 + 12 >> 2] = i35;
   i37 = HEAP32[gb + 44352 + 24 >> 2] | 0;
   i36 = i37 + i14 | 0;
   HEAP32[gb + 44352 + 24 >> 2] = i36;
   HEAP32[i36 + 4 >> 2] = i35 | 1;
   HEAP32[i37 + 4 >> 2] = i14 | 3;
   i37 = i37 + 8 | 0;
   return i37 | 0;
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12;
 i37 = 0;
 return i37 | 0;
}

function _modem_create(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i10;
 do switch (i1 | 0) {
 case 1:
  {
   i9 = _modem_create_psk(1) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 2:
  {
   i9 = _modem_create_psk(2) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 3:
  {
   i9 = _modem_create_psk(3) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 4:
  {
   i9 = _modem_create_psk(4) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 5:
  {
   i9 = _modem_create_psk(5) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 6:
  {
   i9 = _modem_create_psk(6) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 7:
  {
   i9 = _modem_create_psk(7) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 8:
  {
   i9 = _modem_create_psk(8) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 9:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 9;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 1;
   HEAP32[i1 + 8 >> 2] = 2;
   i9 = i1 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAPF32[i1 + 12 >> 2] = 1.5707963705062866;
   HEAP32[i9 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   SIMD_Float32x4_store(HEAPU8, i1 + 96 | 0, SIMD_Float32x4(Math_fround(0.0), Math_fround(1.5707963705062866), Math_fround(0.0), Math_fround(1.5707963705062866)));
   if (!(_liquid_modem_is_dpsk(9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 10:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 10;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   i2 = i1 + 4 | 0;
   HEAP32[i2 >> 2] = 2;
   i3 = i1 + 8 | 0;
   HEAP32[i3 >> 2] = 4;
   i4 = i1 + 236 | 0;
   HEAP32[i4 >> 2] = 0;
   HEAP32[i4 + 4 >> 2] = 0;
   HEAP32[i4 + 8 >> 2] = 0;
   HEAP32[i4 + 12 >> 2] = 0;
   i5 = i1 + 100 | 0;
   i6 = i1 + 108 | 0;
   HEAPF32[i6 >> 2] = .7853981852531433;
   i7 = i1 + 104 | 0;
   HEAPF32[i7 >> 2] = 0.0;
   i8 = i1 + 12 | 0;
   HEAPF32[i8 >> 2] = .7853981852531433;
   HEAPF32[i1 + 16 >> 2] = 1.5707963705062866;
   if ((HEAP32[i2 >> 2] | 0) >>> 0 > 2) {
    i9 = 2;
    do {
     HEAPF32[i8 + (i9 << 2) >> 2] = +HEAPF32[i6 >> 2] * +(1 << i9 | 0);
     i9 = i9 + 1 | 0;
    } while (i9 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 >> 2] = (1.0 - 1.0 / +((HEAP32[i3 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i4 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i7 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 11:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 11;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   i2 = i1 + 4 | 0;
   HEAP32[i2 >> 2] = 3;
   i3 = i1 + 8 | 0;
   HEAP32[i3 >> 2] = 8;
   i4 = i1 + 236 | 0;
   HEAP32[i4 >> 2] = 0;
   HEAP32[i4 + 4 >> 2] = 0;
   HEAP32[i4 + 8 >> 2] = 0;
   HEAP32[i4 + 12 >> 2] = 0;
   i5 = i1 + 100 | 0;
   i6 = i1 + 108 | 0;
   HEAPF32[i6 >> 2] = .39269909262657166;
   i7 = i1 + 104 | 0;
   HEAPF32[i7 >> 2] = 0.0;
   i8 = i1 + 12 | 0;
   HEAPF32[i8 >> 2] = .39269909262657166;
   HEAPF32[i1 + 16 >> 2] = .7853981852531433;
   if ((HEAP32[i2 >> 2] | 0) >>> 0 > 2) {
    i9 = 2;
    do {
     HEAPF32[i8 + (i9 << 2) >> 2] = +HEAPF32[i6 >> 2] * +(1 << i9 | 0);
     i9 = i9 + 1 | 0;
    } while (i9 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 >> 2] = (1.0 - 1.0 / +((HEAP32[i3 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i4 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i7 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 12:
  {
   i2 = _malloc(252) | 0;
   HEAP32[i2 >> 2] = 12;
   HEAP32[i2 + 76 >> 2] = 0;
   HEAP32[i2 + 80 >> 2] = 0;
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 4;
   i4 = i2 + 8 | 0;
   HEAP32[i4 >> 2] = 16;
   i5 = i2 + 236 | 0;
   HEAP32[i5 >> 2] = 0;
   HEAP32[i5 + 4 >> 2] = 0;
   HEAP32[i5 + 8 >> 2] = 0;
   HEAP32[i5 + 12 >> 2] = 0;
   i6 = i2 + 100 | 0;
   i7 = i2 + 108 | 0;
   HEAPF32[i7 >> 2] = .19634954631328583;
   i8 = i2 + 104 | 0;
   HEAPF32[i8 >> 2] = 0.0;
   i9 = i2 + 12 | 0;
   HEAPF32[i9 >> 2] = .19634954631328583;
   HEAPF32[i2 + 16 >> 2] = .39269909262657166;
   if ((HEAP32[i3 >> 2] | 0) >>> 0 > 2) {
    i1 = 2;
    do {
     HEAPF32[i9 + (i1 << 2) >> 2] = +HEAPF32[i7 >> 2] * +(1 << i1 | 0);
     i1 = i1 + 1 | 0;
    } while (i1 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i2 >> 2] | 0;
   HEAPF32[i6 >> 2] = (1.0 - 1.0 / +((HEAP32[i4 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i5 >> 2] = fb + 1;
   HEAP32[i2 + 240 >> 2] = fb + 2;
   HEAPF32[i2 + 84 >> 2] = 1.0;
   HEAPF32[i2 + 88 >> 2] = 0.0;
   HEAP32[i2 + 92 >> 2] = 1065353216;
   HEAPF32[i2 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i2;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i8 >> 2] = 0.0;
   i9 = i2;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 13:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 13;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   i2 = i1 + 4 | 0;
   HEAP32[i2 >> 2] = 5;
   i3 = i1 + 8 | 0;
   HEAP32[i3 >> 2] = 32;
   i4 = i1 + 236 | 0;
   HEAP32[i4 >> 2] = 0;
   HEAP32[i4 + 4 >> 2] = 0;
   HEAP32[i4 + 8 >> 2] = 0;
   HEAP32[i4 + 12 >> 2] = 0;
   i5 = i1 + 100 | 0;
   i6 = i1 + 108 | 0;
   HEAPF32[i6 >> 2] = .09817477315664291;
   i7 = i1 + 104 | 0;
   HEAPF32[i7 >> 2] = 0.0;
   i8 = i1 + 12 | 0;
   HEAPF32[i8 >> 2] = .09817477315664291;
   HEAPF32[i1 + 16 >> 2] = .19634954631328583;
   if ((HEAP32[i2 >> 2] | 0) >>> 0 > 2) {
    i9 = 2;
    do {
     HEAPF32[i8 + (i9 << 2) >> 2] = +HEAPF32[i6 >> 2] * +(1 << i9 | 0);
     i9 = i9 + 1 | 0;
    } while (i9 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 >> 2] = (1.0 - 1.0 / +((HEAP32[i3 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i4 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i7 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 14:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 14;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   i2 = i1 + 4 | 0;
   HEAP32[i2 >> 2] = 6;
   i3 = i1 + 8 | 0;
   HEAP32[i3 >> 2] = 64;
   i4 = i1 + 236 | 0;
   HEAP32[i4 >> 2] = 0;
   HEAP32[i4 + 4 >> 2] = 0;
   HEAP32[i4 + 8 >> 2] = 0;
   HEAP32[i4 + 12 >> 2] = 0;
   i5 = i1 + 100 | 0;
   i6 = i1 + 108 | 0;
   HEAPF32[i6 >> 2] = .04908738657832146;
   i7 = i1 + 104 | 0;
   HEAPF32[i7 >> 2] = 0.0;
   i8 = i1 + 12 | 0;
   HEAPF32[i8 >> 2] = .04908738657832146;
   HEAPF32[i1 + 16 >> 2] = .09817477315664291;
   if ((HEAP32[i2 >> 2] | 0) >>> 0 > 2) {
    i9 = 2;
    do {
     HEAPF32[i8 + (i9 << 2) >> 2] = +HEAPF32[i6 >> 2] * +(1 << i9 | 0);
     i9 = i9 + 1 | 0;
    } while (i9 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 >> 2] = (1.0 - 1.0 / +((HEAP32[i3 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i4 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i7 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 15:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 15;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   i2 = i1 + 4 | 0;
   HEAP32[i2 >> 2] = 7;
   i3 = i1 + 8 | 0;
   HEAP32[i3 >> 2] = 128;
   i4 = i1 + 236 | 0;
   HEAP32[i4 >> 2] = 0;
   HEAP32[i4 + 4 >> 2] = 0;
   HEAP32[i4 + 8 >> 2] = 0;
   HEAP32[i4 + 12 >> 2] = 0;
   i5 = i1 + 100 | 0;
   i6 = i1 + 108 | 0;
   HEAPF32[i6 >> 2] = .02454369328916073;
   i7 = i1 + 104 | 0;
   HEAPF32[i7 >> 2] = 0.0;
   i8 = i1 + 12 | 0;
   HEAPF32[i8 >> 2] = .02454369328916073;
   HEAPF32[i1 + 16 >> 2] = .04908738657832146;
   if ((HEAP32[i2 >> 2] | 0) >>> 0 > 2) {
    i9 = 2;
    do {
     HEAPF32[i8 + (i9 << 2) >> 2] = +HEAPF32[i6 >> 2] * +(1 << i9 | 0);
     i9 = i9 + 1 | 0;
    } while (i9 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 >> 2] = (1.0 - 1.0 / +((HEAP32[i3 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i4 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i7 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 16:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 16;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   i2 = i1 + 4 | 0;
   HEAP32[i2 >> 2] = 8;
   i3 = i1 + 8 | 0;
   HEAP32[i3 >> 2] = 256;
   i4 = i1 + 236 | 0;
   HEAP32[i4 >> 2] = 0;
   HEAP32[i4 + 4 >> 2] = 0;
   HEAP32[i4 + 8 >> 2] = 0;
   HEAP32[i4 + 12 >> 2] = 0;
   i5 = i1 + 100 | 0;
   i6 = i1 + 108 | 0;
   HEAPF32[i6 >> 2] = .012271846644580364;
   i7 = i1 + 104 | 0;
   HEAPF32[i7 >> 2] = 0.0;
   i8 = i1 + 12 | 0;
   HEAPF32[i8 >> 2] = .012271846644580364;
   HEAPF32[i1 + 16 >> 2] = .02454369328916073;
   if ((HEAP32[i2 >> 2] | 0) >>> 0 > 2) {
    i9 = 2;
    do {
     HEAPF32[i8 + (i9 << 2) >> 2] = +HEAPF32[i6 >> 2] * +(1 << i9 | 0);
     i9 = i9 + 1 | 0;
    } while (i9 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   i9 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 >> 2] = (1.0 - 1.0 / +((HEAP32[i3 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i4 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(i9) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i7 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 17:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 1;
   HEAP32[i1 + 8 >> 2] = 2;
   i9 = i1 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAPF32[i1 + 100 >> 2] = 1.0;
   HEAP32[i1 >> 2] = 17;
   HEAPF32[i1 + 12 >> 2] = 1.0;
   HEAP32[i9 >> 2] = fb + 3;
   HEAP32[i1 + 240 >> 2] = fb + 4;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(17) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 18:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 2;
   HEAP32[i6 + 8 >> 2] = 4;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .4472135901451111;
   HEAP32[i6 >> 2] = 18;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .4472135901451111;
   HEAPF32[i6 + 16 >> 2] = .8944271802902222;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 19:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 3;
   HEAP32[i6 + 8 >> 2] = 8;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .2182178944349289;
   HEAP32[i6 >> 2] = 19;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .2182178944349289;
   HEAPF32[i6 + 16 >> 2] = .4364357888698578;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 20:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 4;
   HEAP32[i6 + 8 >> 2] = 16;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .10846523195505142;
   HEAP32[i6 >> 2] = 20;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .10846523195505142;
   HEAPF32[i6 + 16 >> 2] = .21693046391010284;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 21:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 5;
   HEAP32[i6 + 8 >> 2] = 32;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .05415303632616997;
   HEAP32[i6 >> 2] = 21;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .05415303632616997;
   HEAPF32[i6 + 16 >> 2] = .10830607265233994;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 22:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 6;
   HEAP32[i6 + 8 >> 2] = 64;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .02706659771502018;
   HEAP32[i6 >> 2] = 22;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .02706659771502018;
   HEAPF32[i6 + 16 >> 2] = .05413319543004036;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 23:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 7;
   HEAP32[i6 + 8 >> 2] = 128;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .013532060198485851;
   HEAP32[i6 >> 2] = 23;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .013532060198485851;
   HEAPF32[i6 + 16 >> 2] = .027064120396971703;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 24:
  {
   i6 = _malloc(252) | 0;
   HEAP32[i6 + 76 >> 2] = 0;
   HEAP32[i6 + 80 >> 2] = 0;
   i3 = i6 + 4 | 0;
   HEAP32[i3 >> 2] = 8;
   HEAP32[i6 + 8 >> 2] = 256;
   i7 = i6 + 236 | 0;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i7 + 4 >> 2] = 0;
   HEAP32[i7 + 8 >> 2] = 0;
   HEAP32[i7 + 12 >> 2] = 0;
   i4 = i6 + 100 | 0;
   HEAPF32[i4 >> 2] = .006765875034034252;
   HEAP32[i6 >> 2] = 24;
   i5 = i6 + 12 | 0;
   HEAPF32[i5 >> 2] = .006765875034034252;
   HEAPF32[i6 + 16 >> 2] = .013531750068068504;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 >>> 0 > 2) {
    i2 = 2;
    do {
     HEAPF32[i5 + (i2 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i2 | 0);
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i3 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAP32[i7 >> 2] = fb + 3;
   HEAP32[i6 + 240 >> 2] = fb + 4;
   if ((i1 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i6, 2);
   HEAPF32[i6 + 84 >> 2] = 1.0;
   HEAPF32[i6 + 88 >> 2] = 0.0;
   HEAP32[i6 + 92 >> 2] = 1065353216;
   HEAPF32[i6 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(HEAP32[i6 >> 2] | 0) | 0)) {
    i9 = i6;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i6 + 104 >> 2] = 0.0;
   i9 = i6;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 25:
  {
   i9 = _modem_create_qam(2) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 26:
  {
   i9 = _modem_create_qam(3) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 27:
  {
   i9 = _modem_create_qam(4) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 28:
  {
   i9 = _modem_create_qam(5) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 29:
  {
   i9 = _modem_create_qam(6) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 30:
  {
   i9 = _modem_create_qam(7) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 31:
  {
   i9 = _modem_create_qam(8) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 32:
  {
   i9 = _modem_create_qam(9) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 33:
  {
   i9 = _modem_create_qam(10) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 34:
  {
   i9 = _modem_create_qam(11) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 35:
  {
   i9 = _modem_create_qam(12) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 36:
  {
   i9 = _modem_create_qam(13) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 37:
  {
   i9 = _modem_create_qam(14) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 38:
  {
   i9 = _modem_create_qam(15) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 39:
  {
   i9 = _modem_create_qam(16) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 40:
  {
   i9 = _modem_create_apsk(2) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 41:
  {
   i9 = _modem_create_apsk(3) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 42:
  {
   i9 = _modem_create_apsk(4) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 43:
  {
   i9 = _modem_create_apsk(5) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 44:
  {
   i9 = _modem_create_apsk(6) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 45:
  {
   i9 = _modem_create_apsk(7) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 46:
  {
   i9 = _modem_create_apsk(8) | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 47:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 47;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 1;
   HEAP32[i1 + 8 >> 2] = 2;
   i9 = i1 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 >> 2] = fb + 5;
   HEAP32[i1 + 240 >> 2] = fb + 6;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(47) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 48:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 48;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 2;
   HEAP32[i1 + 8 >> 2] = 4;
   i9 = i1 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 >> 2] = fb + 7;
   HEAP32[i1 + 240 >> 2] = fb + 8;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(48) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 49:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 49;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 1;
   HEAP32[i1 + 8 >> 2] = 2;
   i9 = i1 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 >> 2] = fb + 9;
   HEAP32[i1 + 240 >> 2] = fb + 10;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(49) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 50:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 50;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 5;
   HEAP32[i1 + 8 >> 2] = 32;
   i2 = i1 + 236 | 0;
   HEAP32[i2 >> 2] = 0;
   HEAP32[i2 + 4 >> 2] = 0;
   HEAP32[i2 + 8 >> 2] = 0;
   HEAP32[i2 + 12 >> 2] = 0;
   i3 = _malloc(64) | 0;
   HEAP32[i1 + 100 >> 2] = i3;
   i4 = gb + 2008 | 0;
   i5 = i3 + 64 | 0;
   do {
    HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
    i3 = i3 + 4 | 0;
    i4 = i4 + 4 | 0;
   } while ((i3 | 0) < (i5 | 0));
   HEAP32[i2 >> 2] = fb + 11;
   HEAP32[i1 + 240 >> 2] = fb + 12;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(50) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 51:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 51;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 7;
   HEAP32[i1 + 8 >> 2] = 128;
   i9 = i1 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   i8 = _malloc(256) | 0;
   HEAP32[i1 + 100 >> 2] = i8;
   _memcpy(i8 | 0, gb + 2072 | 0, 256) | 0;
   HEAP32[i9 >> 2] = fb + 13;
   HEAP32[i1 + 240 >> 2] = fb + 14;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!(_liquid_modem_is_dpsk(51) | 0)) {
    i9 = i1;
    STACKTOP = i10;
    return i9 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i9 = i1;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 52:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 4;
   HEAP32[i9 + 8 >> 2] = 16;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(16, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 2328 | 0, 16);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 53:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 4;
   HEAP32[i9 + 8 >> 2] = 16;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(16, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 2968 | 0, 16);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 54:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 5;
   HEAP32[i9 + 8 >> 2] = 32;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(32, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 3096 | 0, 32);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 55:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 6;
   HEAP32[i9 + 8 >> 2] = 64;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(64, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 3352 | 0, 64);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 56:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 7;
   HEAP32[i9 + 8 >> 2] = 128;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(128, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 3864 | 0, 128);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 57:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 8;
   HEAP32[i9 + 8 >> 2] = 256;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(256, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 4888 | 0, 256);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 58:
  {
   i9 = _malloc(252) | 0;
   HEAP32[i9 >> 2] = 59;
   HEAP32[i9 + 80 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 6;
   HEAP32[i9 + 8 >> 2] = 64;
   i8 = i9 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAP32[i9 + 76 >> 2] = _calloc(64, 8) | 0;
   HEAP32[i8 >> 2] = fb + 15;
   HEAP32[i9 + 240 >> 2] = fb + 16;
   _modem_arb_init(i9, gb + 2456 | 0, 64);
   STACKTOP = i10;
   return i9 | 0;
  }
 case 59:
  {
   _fwrite(gb + 31688 | 0, 105, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
   break;
  }
 default:
  {
   i10 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i2 >> 2] = i1;
   _fprintf(i10, gb + 31794 | 0, i2) | 0;
   _exit(1);
  }
 } while (0);
 return 0;
}

function _printf_core(i50, i3, i51, i52, i53) {
 i50 = i50 | 0;
 i3 = i3 | 0;
 i51 = i51 | 0;
 i52 = i52 | 0;
 i53 = i53 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, d13 = 0.0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i54 = 0;
 i54 = STACKTOP;
 STACKTOP = STACKTOP + 624 | 0;
 i45 = i54 + 24 | 0;
 i47 = i54 + 16 | 0;
 i46 = i54 + 588 | 0;
 i42 = i54 + 576 | 0;
 i44 = i54;
 i37 = i54 + 536 | 0;
 i49 = i54 + 8 | 0;
 i48 = i54 + 528 | 0;
 i27 = (i50 | 0) != 0;
 i28 = i37 + 40 | 0;
 i36 = i28;
 i37 = i37 + 39 | 0;
 i38 = i49 + 4 | 0;
 i39 = i46;
 i40 = 0 - i39 | 0;
 i41 = i42 + 12 | 0;
 i42 = i42 + 11 | 0;
 i43 = i41;
 i29 = i43 - i39 | 0;
 i30 = -2 - i39 | 0;
 i31 = i43 + 2 | 0;
 i32 = i45 + 288 | 0;
 i33 = i46 + 9 | 0;
 i34 = i33;
 i35 = i46 + 8 | 0;
 i1 = 0;
 i4 = 0;
 i2 = 0;
 i14 = i3;
 L1 : while (1) {
  do if ((i1 | 0) > -1) if ((i4 | 0) > (2147483647 - i1 | 0)) {
   HEAP32[(___errno_location() | 0) >> 2] = 75;
   i1 = -1;
   break;
  } else {
   i1 = i4 + i1 | 0;
   break;
  } while (0);
  i3 = HEAP8[i14 >> 0] | 0;
  if (!(i3 << 24 >> 24)) {
   i26 = 244;
   break;
  } else i4 = i14;
  L9 : while (1) {
   switch (i3 << 24 >> 24) {
   case 37:
    {
     i3 = i4;
     i26 = 9;
     break L9;
    }
   case 0:
    {
     i3 = i4;
     break L9;
    }
   default:
    {}
   }
   i25 = i4 + 1 | 0;
   i3 = HEAP8[i25 >> 0] | 0;
   i4 = i25;
  }
  L12 : do if ((i26 | 0) == 9) while (1) {
   i26 = 0;
   if ((HEAP8[i3 + 1 >> 0] | 0) != 37) break L12;
   i4 = i4 + 1 | 0;
   i3 = i3 + 2 | 0;
   if ((HEAP8[i3 >> 0] | 0) == 37) i26 = 9; else break;
  } while (0);
  i12 = i4 - i14 | 0;
  if (i27 ? (HEAP32[i50 >> 2] & 32 | 0) == 0 : 0) ___fwritex(i14, i12, i50) | 0;
  if ((i4 | 0) != (i14 | 0)) {
   i4 = i12;
   i14 = i3;
   continue;
  }
  i7 = i3 + 1 | 0;
  i4 = HEAP8[i7 >> 0] | 0;
  i5 = (i4 << 24 >> 24) + -48 | 0;
  if (i5 >>> 0 < 10) {
   i25 = (HEAP8[i3 + 2 >> 0] | 0) == 36;
   i7 = i25 ? i3 + 3 | 0 : i7;
   i4 = HEAP8[i7 >> 0] | 0;
   i10 = i25 ? i5 : -1;
   i2 = i25 ? 1 : i2;
  } else i10 = -1;
  i3 = i4 << 24 >> 24;
  L25 : do if ((i3 & -32 | 0) == 32) {
   i5 = 0;
   while (1) {
    if (!(1 << i3 + -32 & 75913)) {
     i8 = i5;
     break L25;
    }
    i5 = 1 << (i4 << 24 >> 24) + -32 | i5;
    i7 = i7 + 1 | 0;
    i4 = HEAP8[i7 >> 0] | 0;
    i3 = i4 << 24 >> 24;
    if ((i3 & -32 | 0) != 32) {
     i8 = i5;
     break;
    }
   }
  } else i8 = 0; while (0);
  do if (i4 << 24 >> 24 == 42) {
   i4 = i7 + 1 | 0;
   i3 = (HEAP8[i4 >> 0] | 0) + -48 | 0;
   if (i3 >>> 0 < 10 ? (HEAP8[i7 + 2 >> 0] | 0) == 36 : 0) {
    HEAP32[i53 + (i3 << 2) >> 2] = 10;
    i2 = 1;
    i7 = i7 + 3 | 0;
    i3 = HEAP32[i52 + ((HEAP8[i4 >> 0] | 0) + -48 << 3) >> 2] | 0;
   } else {
    if (i2 | 0) {
     i1 = -1;
     break L1;
    }
    if (!i27) {
     i11 = i8;
     i2 = 0;
     i7 = i4;
     i25 = 0;
     break;
    }
    i2 = (HEAP32[i51 >> 2] | 0) + (4 - 1) & ~(4 - 1);
    i3 = HEAP32[i2 >> 2] | 0;
    HEAP32[i51 >> 2] = i2 + 4;
    i2 = 0;
    i7 = i4;
   }
   if ((i3 | 0) < 0) {
    i11 = i8 | 8192;
    i25 = 0 - i3 | 0;
   } else {
    i11 = i8;
    i25 = i3;
   }
  } else {
   i5 = (i4 << 24 >> 24) + -48 | 0;
   if (i5 >>> 0 < 10) {
    i3 = i7;
    i4 = 0;
    do {
     i4 = (i4 * 10 | 0) + i5 | 0;
     i3 = i3 + 1 | 0;
     i5 = (HEAP8[i3 >> 0] | 0) + -48 | 0;
    } while (i5 >>> 0 < 10);
    if ((i4 | 0) < 0) {
     i1 = -1;
     break L1;
    } else {
     i11 = i8;
     i7 = i3;
     i25 = i4;
    }
   } else {
    i11 = i8;
    i25 = 0;
   }
  } while (0);
  L46 : do if ((HEAP8[i7 >> 0] | 0) == 46) {
   i3 = i7 + 1 | 0;
   i4 = HEAP8[i3 >> 0] | 0;
   if (i4 << 24 >> 24 != 42) {
    i5 = (i4 << 24 >> 24) + -48 | 0;
    if (i5 >>> 0 < 10) i4 = 0; else {
     i8 = 0;
     break;
    }
    while (1) {
     i4 = (i4 * 10 | 0) + i5 | 0;
     i3 = i3 + 1 | 0;
     i5 = (HEAP8[i3 >> 0] | 0) + -48 | 0;
     if (i5 >>> 0 >= 10) {
      i8 = i4;
      break L46;
     }
    }
   }
   i3 = i7 + 2 | 0;
   i4 = (HEAP8[i3 >> 0] | 0) + -48 | 0;
   if (i4 >>> 0 < 10 ? (HEAP8[i7 + 3 >> 0] | 0) == 36 : 0) {
    HEAP32[i53 + (i4 << 2) >> 2] = 10;
    i8 = HEAP32[i52 + ((HEAP8[i3 >> 0] | 0) + -48 << 3) >> 2] | 0;
    i3 = i7 + 4 | 0;
    break;
   }
   if (i2 | 0) {
    i1 = -1;
    break L1;
   }
   if (i27) {
    i24 = (HEAP32[i51 >> 2] | 0) + (4 - 1) & ~(4 - 1);
    i8 = HEAP32[i24 >> 2] | 0;
    HEAP32[i51 >> 2] = i24 + 4;
   } else i8 = 0;
  } else {
   i8 = -1;
   i3 = i7;
  } while (0);
  i9 = 0;
  while (1) {
   i4 = (HEAP8[i3 >> 0] | 0) + -65 | 0;
   if (i4 >>> 0 > 57) {
    i1 = -1;
    break L1;
   }
   i5 = i3 + 1 | 0;
   i4 = HEAP8[gb + 41708 + (i9 * 58 | 0) + i4 >> 0] | 0;
   i7 = i4 & 255;
   if ((i7 + -1 | 0) >>> 0 < 8) {
    i3 = i5;
    i9 = i7;
   } else {
    i24 = i5;
    break;
   }
  }
  if (!(i4 << 24 >> 24)) {
   i1 = -1;
   break;
  }
  i5 = (i10 | 0) > -1;
  do if (i4 << 24 >> 24 == 19) if (i5) {
   i1 = -1;
   break L1;
  } else i26 = 52; else {
   if (i5) {
    HEAP32[i53 + (i10 << 2) >> 2] = i7;
    i22 = i52 + (i10 << 3) | 0;
    i23 = HEAP32[i22 + 4 >> 2] | 0;
    i26 = i44;
    HEAP32[i26 >> 2] = HEAP32[i22 >> 2];
    HEAP32[i26 + 4 >> 2] = i23;
    i26 = 52;
    break;
   }
   if (!i27) {
    i1 = 0;
    break L1;
   }
   _pop_arg(i44, i7, i51);
  } while (0);
  if ((i26 | 0) == 52 ? (i26 = 0, !i27) : 0) {
   i4 = i12;
   i14 = i24;
   continue;
  }
  i10 = HEAP8[i3 >> 0] | 0;
  i10 = (i9 | 0) != 0 & (i10 & 15 | 0) == 3 ? i10 & -33 : i10;
  i5 = i11 & -65537;
  i23 = (i11 & 8192 | 0) == 0 ? i11 : i5;
  L75 : do switch (i10 | 0) {
  case 110:
   switch (i9 | 0) {
   case 0:
    {
     HEAP32[HEAP32[i44 >> 2] >> 2] = i1;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   case 1:
    {
     HEAP32[HEAP32[i44 >> 2] >> 2] = i1;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   case 2:
    {
     i4 = HEAP32[i44 >> 2] | 0;
     HEAP32[i4 >> 2] = i1;
     HEAP32[i4 + 4 >> 2] = ((i1 | 0) < 0) << 31 >> 31;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   case 3:
    {
     HEAP16[HEAP32[i44 >> 2] >> 1] = i1;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   case 4:
    {
     HEAP8[HEAP32[i44 >> 2] >> 0] = i1;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   case 6:
    {
     HEAP32[HEAP32[i44 >> 2] >> 2] = i1;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   case 7:
    {
     i4 = HEAP32[i44 >> 2] | 0;
     HEAP32[i4 >> 2] = i1;
     HEAP32[i4 + 4 >> 2] = ((i1 | 0) < 0) << 31 >> 31;
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   default:
    {
     i4 = i12;
     i14 = i24;
     continue L1;
    }
   }
  case 112:
   {
    i9 = i23 | 8;
    i8 = i8 >>> 0 > 8 ? i8 : 8;
    i10 = 120;
    i26 = 64;
    break;
   }
  case 88:
  case 120:
   {
    i9 = i23;
    i26 = 64;
    break;
   }
  case 111:
   {
    i5 = i44;
    i4 = HEAP32[i5 >> 2] | 0;
    i5 = HEAP32[i5 + 4 >> 2] | 0;
    if ((i4 | 0) == 0 & (i5 | 0) == 0) i3 = i28; else {
     i3 = i28;
     do {
      i3 = i3 + -1 | 0;
      HEAP8[i3 >> 0] = i4 & 7 | 48;
      i4 = _bitshift64Lshr(i4 | 0, i5 | 0, 3) | 0;
      i5 = getTempRet0() | 0;
     } while (!((i4 | 0) == 0 & (i5 | 0) == 0));
    }
    if (!(i23 & 8)) {
     i4 = i23;
     i9 = 0;
     i7 = gb + 42188 | 0;
     i26 = 77;
    } else {
     i9 = i36 - i3 | 0;
     i4 = i23;
     i8 = (i8 | 0) > (i9 | 0) ? i8 : i9 + 1 | 0;
     i9 = 0;
     i7 = gb + 42188 | 0;
     i26 = 77;
    }
    break;
   }
  case 105:
  case 100:
   {
    i4 = i44;
    i3 = HEAP32[i4 >> 2] | 0;
    i4 = HEAP32[i4 + 4 >> 2] | 0;
    if ((i4 | 0) < 0) {
     i3 = _i64Subtract(0, 0, i3 | 0, i4 | 0) | 0;
     i4 = getTempRet0() | 0;
     i5 = i44;
     HEAP32[i5 >> 2] = i3;
     HEAP32[i5 + 4 >> 2] = i4;
     i5 = 1;
     i7 = gb + 42188 | 0;
     i26 = 76;
     break L75;
    }
    if (!(i23 & 2048)) {
     i7 = i23 & 1;
     i5 = i7;
     i7 = (i7 | 0) == 0 ? gb + 42188 | 0 : gb + 42188 + 2 | 0;
     i26 = 76;
    } else {
     i5 = 1;
     i7 = gb + 42188 + 1 | 0;
     i26 = 76;
    }
    break;
   }
  case 117:
   {
    i4 = i44;
    i3 = HEAP32[i4 >> 2] | 0;
    i4 = HEAP32[i4 + 4 >> 2] | 0;
    i5 = 0;
    i7 = gb + 42188 | 0;
    i26 = 76;
    break;
   }
  case 99:
   {
    HEAP8[i37 >> 0] = HEAP32[i44 >> 2];
    i3 = i37;
    i10 = 1;
    i12 = 0;
    i11 = gb + 42188 | 0;
    i4 = i28;
    break;
   }
  case 109:
   {
    i4 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0;
    i26 = 82;
    break;
   }
  case 115:
   {
    i4 = HEAP32[i44 >> 2] | 0;
    i4 = i4 | 0 ? i4 : gb + 44090 | 0;
    i26 = 82;
    break;
   }
  case 67:
   {
    HEAP32[i49 >> 2] = HEAP32[i44 >> 2];
    HEAP32[i38 >> 2] = 0;
    HEAP32[i44 >> 2] = i49;
    i3 = i49;
    i8 = -1;
    i26 = 86;
    break;
   }
  case 83:
   {
    i3 = HEAP32[i44 >> 2] | 0;
    if (!i8) {
     _pad(i50, 32, i25, 0, i23);
     i3 = 0;
     i26 = 97;
    } else i26 = 86;
    break;
   }
  case 65:
  case 71:
  case 70:
  case 69:
  case 97:
  case 103:
  case 102:
  case 101:
   {
    d6 = +HEAPF64[i44 >> 3];
    HEAP32[i47 >> 2] = 0;
    HEAPF64[tempDoublePtr >> 3] = d6;
    if ((HEAP32[tempDoublePtr + 4 >> 2] | 0) >= 0) if (!(i23 & 2048)) {
     i22 = i23 & 1;
     i21 = i22;
     i22 = (i22 | 0) == 0 ? gb + 44097 + 1 | 0 : gb + 44097 + 6 | 0;
    } else {
     i21 = 1;
     i22 = gb + 44097 + 3 | 0;
    } else {
     d6 = -d6;
     i21 = 1;
     i22 = gb + 44097 | 0;
    }
    HEAPF64[tempDoublePtr >> 3] = d6;
    i20 = HEAP32[tempDoublePtr + 4 >> 2] & 2146435072;
    do if (i20 >>> 0 < 2146435072 | (i20 | 0) == 2146435072 & 0 < 0) {
     d13 = +_frexpl(d6, i47) * 2.0;
     i4 = d13 != 0.0;
     if (i4) HEAP32[i47 >> 2] = (HEAP32[i47 >> 2] | 0) + -1;
     i18 = i10 | 32;
     if ((i18 | 0) == 97) {
      i11 = i10 & 32;
      i14 = (i11 | 0) == 0 ? i22 : i22 + 9 | 0;
      i12 = i21 | 2;
      i3 = 12 - i8 | 0;
      do if (!(i8 >>> 0 > 11 | (i3 | 0) == 0)) {
       d6 = 8.0;
       do {
        i3 = i3 + -1 | 0;
        d6 = d6 * 16.0;
       } while ((i3 | 0) != 0);
       if ((HEAP8[i14 >> 0] | 0) == 45) {
        d6 = -(d6 + (-d13 - d6));
        break;
       } else {
        d6 = d13 + d6 - d6;
        break;
       }
      } else d6 = d13; while (0);
      i4 = HEAP32[i47 >> 2] | 0;
      i3 = (i4 | 0) < 0 ? 0 - i4 | 0 : i4;
      i3 = _fmt_u(i3, ((i3 | 0) < 0) << 31 >> 31, i41) | 0;
      if ((i3 | 0) == (i41 | 0)) {
       HEAP8[i42 >> 0] = 48;
       i3 = i42;
      }
      HEAP8[i3 + -1 >> 0] = (i4 >> 31 & 2) + 43;
      i9 = i3 + -2 | 0;
      HEAP8[i9 >> 0] = i10 + 15;
      i7 = (i8 | 0) < 1;
      i5 = (i23 & 8 | 0) == 0;
      i4 = i46;
      while (1) {
       i22 = ~~d6;
       i3 = i4 + 1 | 0;
       HEAP8[i4 >> 0] = HEAPU8[gb + 42172 + i22 >> 0] | i11;
       d6 = (d6 - +(i22 | 0)) * 16.0;
       do if ((i3 - i39 | 0) == 1) {
        if (i5 & (i7 & d6 == 0.0)) break;
        HEAP8[i3 >> 0] = 46;
        i3 = i4 + 2 | 0;
       } while (0);
       if (!(d6 != 0.0)) break; else i4 = i3;
      }
      i5 = i9;
      i8 = (i8 | 0) != 0 & (i30 + i3 | 0) < (i8 | 0) ? i31 + i8 - i5 | 0 : i29 - i5 + i3 | 0;
      i7 = i8 + i12 | 0;
      _pad(i50, 32, i25, i7, i23);
      if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i14, i12, i50) | 0;
      _pad(i50, 48, i25, i7, i23 ^ 65536);
      i4 = i3 - i39 | 0;
      if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i46, i4, i50) | 0;
      i3 = i43 - i5 | 0;
      _pad(i50, 48, i8 - (i4 + i3) | 0, 0, 0);
      if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i9, i3, i50) | 0;
      _pad(i50, 32, i25, i7, i23 ^ 8192);
      i3 = (i7 | 0) < (i25 | 0) ? i25 : i7;
      break;
     }
     i3 = (i8 | 0) < 0 ? 6 : i8;
     if (i4) {
      i4 = (HEAP32[i47 >> 2] | 0) + -28 | 0;
      HEAP32[i47 >> 2] = i4;
      d6 = d13 * 268435456.0;
     } else {
      d6 = d13;
      i4 = HEAP32[i47 >> 2] | 0;
     }
     i20 = (i4 | 0) < 0 ? i45 : i32;
     i19 = i20;
     i4 = i20;
     do {
      i17 = ~~d6 >>> 0;
      HEAP32[i4 >> 2] = i17;
      i4 = i4 + 4 | 0;
      d6 = (d6 - +(i17 >>> 0)) * 1.0e9;
     } while (d6 != 0.0);
     i5 = i4;
     i4 = HEAP32[i47 >> 2] | 0;
     if ((i4 | 0) > 0) {
      i8 = i20;
      while (1) {
       i9 = (i4 | 0) > 29 ? 29 : i4;
       i7 = i5 + -4 | 0;
       do if (i7 >>> 0 < i8 >>> 0) i7 = i8; else {
        i4 = 0;
        do {
         i17 = _bitshift64Shl(HEAP32[i7 >> 2] | 0, 0, i9 | 0) | 0;
         i17 = _i64Add(i17 | 0, getTempRet0() | 0, i4 | 0, 0) | 0;
         i4 = getTempRet0() | 0;
         i16 = ___uremdi3(i17 | 0, i4 | 0, 1e9, 0) | 0;
         getTempRet0() | 0;
         HEAP32[i7 >> 2] = i16;
         i4 = ___udivdi3(i17 | 0, i4 | 0, 1e9, 0) | 0;
         getTempRet0() | 0;
         i7 = i7 + -4 | 0;
        } while (i7 >>> 0 >= i8 >>> 0);
        if (!i4) {
         i7 = i8;
         break;
        }
        i7 = i8 + -4 | 0;
        HEAP32[i7 >> 2] = i4;
       } while (0);
       while (1) {
        if (i5 >>> 0 <= i7 >>> 0) break;
        i4 = i5 + -4 | 0;
        if (!(HEAP32[i4 >> 2] | 0)) i5 = i4; else break;
       }
       i4 = (HEAP32[i47 >> 2] | 0) - i9 | 0;
       HEAP32[i47 >> 2] = i4;
       if ((i4 | 0) > 0) i8 = i7; else break;
      }
     } else i7 = i20;
     if ((i4 | 0) < 0) {
      i14 = ((i3 + 25 | 0) / 9 | 0) + 1 | 0;
      i15 = (i18 | 0) == 102;
      i11 = i7;
      while (1) {
       i12 = 0 - i4 | 0;
       i12 = (i12 | 0) > 9 ? 9 : i12;
       do if (i11 >>> 0 < i5 >>> 0) {
        i4 = (1 << i12) + -1 | 0;
        i8 = 1e9 >>> i12;
        i7 = 0;
        i9 = i11;
        do {
         i17 = HEAP32[i9 >> 2] | 0;
         HEAP32[i9 >> 2] = (i17 >>> i12) + i7;
         i7 = Math_imul(i17 & i4, i8) | 0;
         i9 = i9 + 4 | 0;
        } while (i9 >>> 0 < i5 >>> 0);
        i4 = (HEAP32[i11 >> 2] | 0) == 0 ? i11 + 4 | 0 : i11;
        if (!i7) {
         i7 = i4;
         break;
        }
        HEAP32[i5 >> 2] = i7;
        i7 = i4;
        i5 = i5 + 4 | 0;
       } else i7 = (HEAP32[i11 >> 2] | 0) == 0 ? i11 + 4 | 0 : i11; while (0);
       i4 = i15 ? i20 : i7;
       i5 = (i5 - i4 >> 2 | 0) > (i14 | 0) ? i4 + (i14 << 2) | 0 : i5;
       i4 = (HEAP32[i47 >> 2] | 0) + i12 | 0;
       HEAP32[i47 >> 2] = i4;
       if ((i4 | 0) >= 0) {
        i15 = i7;
        break;
       } else i11 = i7;
      }
     } else i15 = i7;
     do if (i15 >>> 0 < i5 >>> 0) {
      i4 = (i19 - i15 >> 2) * 9 | 0;
      i8 = HEAP32[i15 >> 2] | 0;
      if (i8 >>> 0 < 10) break; else i7 = 10;
      do {
       i7 = i7 * 10 | 0;
       i4 = i4 + 1 | 0;
      } while (i8 >>> 0 >= i7 >>> 0);
     } else i4 = 0; while (0);
     i16 = (i18 | 0) == 103;
     i17 = (i3 | 0) != 0;
     i7 = i3 - ((i18 | 0) != 102 ? i4 : 0) + ((i17 & i16) << 31 >> 31) | 0;
     if ((i7 | 0) < (((i5 - i19 >> 2) * 9 | 0) + -9 | 0)) {
      i9 = i7 + 9216 | 0;
      i7 = i20 + 4 + (((i9 | 0) / 9 | 0) + -1024 << 2) | 0;
      i9 = ((i9 | 0) % 9 | 0) + 1 | 0;
      if ((i9 | 0) < 9) {
       i8 = 10;
       do {
        i8 = i8 * 10 | 0;
        i9 = i9 + 1 | 0;
       } while ((i9 | 0) != 9);
      } else i8 = 10;
      i12 = HEAP32[i7 >> 2] | 0;
      i14 = (i12 >>> 0) % (i8 >>> 0) | 0;
      i9 = (i7 + 4 | 0) == (i5 | 0);
      do if (i9 & (i14 | 0) == 0) i8 = i15; else {
       d13 = (((i12 >>> 0) / (i8 >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0;
       i11 = (i8 | 0) / 2 | 0;
       if (i14 >>> 0 < i11 >>> 0) d6 = .5; else d6 = i9 & (i14 | 0) == (i11 | 0) ? 1.0 : 1.5;
       do if (i21) {
        if ((HEAP8[i22 >> 0] | 0) != 45) break;
        d13 = -d13;
        d6 = -d6;
       } while (0);
       i9 = i12 - i14 | 0;
       HEAP32[i7 >> 2] = i9;
       if (!(d13 + d6 != d13)) {
        i8 = i15;
        break;
       }
       i18 = i9 + i8 | 0;
       HEAP32[i7 >> 2] = i18;
       if (i18 >>> 0 > 999999999) {
        i4 = i15;
        while (1) {
         i8 = i7 + -4 | 0;
         HEAP32[i7 >> 2] = 0;
         if (i8 >>> 0 < i4 >>> 0) {
          i4 = i4 + -4 | 0;
          HEAP32[i4 >> 2] = 0;
         }
         i18 = (HEAP32[i8 >> 2] | 0) + 1 | 0;
         HEAP32[i8 >> 2] = i18;
         if (i18 >>> 0 > 999999999) i7 = i8; else {
          i11 = i4;
          i7 = i8;
          break;
         }
        }
       } else i11 = i15;
       i4 = (i19 - i11 >> 2) * 9 | 0;
       i9 = HEAP32[i11 >> 2] | 0;
       if (i9 >>> 0 < 10) {
        i8 = i11;
        break;
       } else i8 = 10;
       do {
        i8 = i8 * 10 | 0;
        i4 = i4 + 1 | 0;
       } while (i9 >>> 0 >= i8 >>> 0);
       i8 = i11;
      } while (0);
      i18 = i7 + 4 | 0;
      i15 = i8;
      i5 = i5 >>> 0 > i18 >>> 0 ? i18 : i5;
     }
     i12 = 0 - i4 | 0;
     while (1) {
      if (i5 >>> 0 <= i15 >>> 0) {
       i14 = 0;
       i18 = i5;
       break;
      }
      i7 = i5 + -4 | 0;
      if (!(HEAP32[i7 >> 2] | 0)) i5 = i7; else {
       i14 = 1;
       i18 = i5;
       break;
      }
     }
     do if (i16) {
      i3 = (i17 & 1 ^ 1) + i3 | 0;
      if ((i3 | 0) > (i4 | 0) & (i4 | 0) > -5) {
       i10 = i10 + -1 | 0;
       i3 = i3 + -1 - i4 | 0;
      } else {
       i10 = i10 + -2 | 0;
       i3 = i3 + -1 | 0;
      }
      i5 = i23 & 8;
      if (i5 | 0) break;
      do if (i14) {
       i5 = HEAP32[i18 + -4 >> 2] | 0;
       if (!i5) {
        i7 = 9;
        break;
       }
       if (!((i5 >>> 0) % 10 | 0)) {
        i8 = 10;
        i7 = 0;
       } else {
        i7 = 0;
        break;
       }
       do {
        i8 = i8 * 10 | 0;
        i7 = i7 + 1 | 0;
       } while (!((i5 >>> 0) % (i8 >>> 0) | 0 | 0));
      } else i7 = 9; while (0);
      i5 = ((i18 - i19 >> 2) * 9 | 0) + -9 | 0;
      if ((i10 | 32 | 0) == 102) {
       i5 = i5 - i7 | 0;
       i5 = (i5 | 0) < 0 ? 0 : i5;
       i3 = (i3 | 0) < (i5 | 0) ? i3 : i5;
       i5 = 0;
       break;
      } else {
       i5 = i5 + i4 - i7 | 0;
       i5 = (i5 | 0) < 0 ? 0 : i5;
       i3 = (i3 | 0) < (i5 | 0) ? i3 : i5;
       i5 = 0;
       break;
      }
     } else i5 = i23 & 8; while (0);
     i11 = i3 | i5;
     i8 = (i11 | 0) != 0 & 1;
     i9 = (i10 | 32 | 0) == 102;
     if (i9) {
      i4 = (i4 | 0) > 0 ? i4 : 0;
      i10 = 0;
     } else {
      i7 = (i4 | 0) < 0 ? i12 : i4;
      i7 = _fmt_u(i7, ((i7 | 0) < 0) << 31 >> 31, i41) | 0;
      if ((i43 - i7 | 0) < 2) do {
       i7 = i7 + -1 | 0;
       HEAP8[i7 >> 0] = 48;
      } while ((i43 - i7 | 0) < 2);
      HEAP8[i7 + -1 >> 0] = (i4 >> 31 & 2) + 43;
      i19 = i7 + -2 | 0;
      HEAP8[i19 >> 0] = i10;
      i4 = i43 - i19 | 0;
      i10 = i19;
     }
     i12 = i21 + 1 + i3 + i8 + i4 | 0;
     _pad(i50, 32, i25, i12, i23);
     if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i22, i21, i50) | 0;
     _pad(i50, 48, i25, i12, i23 ^ 65536);
     do if (i9) {
      i7 = i15 >>> 0 > i20 >>> 0 ? i20 : i15;
      i4 = i7;
      do {
       i5 = _fmt_u(HEAP32[i4 >> 2] | 0, 0, i33) | 0;
       do if ((i4 | 0) == (i7 | 0)) {
        if ((i5 | 0) != (i33 | 0)) break;
        HEAP8[i35 >> 0] = 48;
        i5 = i35;
       } else {
        if (i5 >>> 0 <= i46 >>> 0) break;
        _memset(i46 | 0, 48, i5 - i39 | 0) | 0;
        do i5 = i5 + -1 | 0; while (i5 >>> 0 > i46 >>> 0);
       } while (0);
       if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i5, i34 - i5 | 0, i50) | 0;
       i4 = i4 + 4 | 0;
      } while (i4 >>> 0 <= i20 >>> 0);
      do if (i11 | 0) {
       if (HEAP32[i50 >> 2] & 32 | 0) break;
       ___fwritex(gb + 44141 | 0, 1, i50) | 0;
      } while (0);
      if ((i3 | 0) > 0 & i4 >>> 0 < i18 >>> 0) {
       i5 = i4;
       while (1) {
        i4 = _fmt_u(HEAP32[i5 >> 2] | 0, 0, i33) | 0;
        if (i4 >>> 0 > i46 >>> 0) {
         _memset(i46 | 0, 48, i4 - i39 | 0) | 0;
         do i4 = i4 + -1 | 0; while (i4 >>> 0 > i46 >>> 0);
        }
        if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i4, (i3 | 0) > 9 ? 9 : i3, i50) | 0;
        i5 = i5 + 4 | 0;
        i4 = i3 + -9 | 0;
        if (!((i3 | 0) > 9 & i5 >>> 0 < i18 >>> 0)) {
         i3 = i4;
         break;
        } else i3 = i4;
       }
      }
      _pad(i50, 48, i3 + 9 | 0, 9, 0);
     } else {
      i9 = i14 ? i18 : i15 + 4 | 0;
      if ((i3 | 0) > -1) {
       i8 = (i5 | 0) == 0;
       i7 = i15;
       do {
        i4 = _fmt_u(HEAP32[i7 >> 2] | 0, 0, i33) | 0;
        if ((i4 | 0) == (i33 | 0)) {
         HEAP8[i35 >> 0] = 48;
         i4 = i35;
        }
        do if ((i7 | 0) == (i15 | 0)) {
         i5 = i4 + 1 | 0;
         if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i4, 1, i50) | 0;
         if (i8 & (i3 | 0) < 1) {
          i4 = i5;
          break;
         }
         if (HEAP32[i50 >> 2] & 32 | 0) {
          i4 = i5;
          break;
         }
         ___fwritex(gb + 44141 | 0, 1, i50) | 0;
         i4 = i5;
        } else {
         if (i4 >>> 0 <= i46 >>> 0) break;
         _memset(i46 | 0, 48, i4 + i40 | 0) | 0;
         do i4 = i4 + -1 | 0; while (i4 >>> 0 > i46 >>> 0);
        } while (0);
        i5 = i34 - i4 | 0;
        if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i4, (i3 | 0) > (i5 | 0) ? i5 : i3, i50) | 0;
        i3 = i3 - i5 | 0;
        i7 = i7 + 4 | 0;
       } while (i7 >>> 0 < i9 >>> 0 & (i3 | 0) > -1);
      }
      _pad(i50, 48, i3 + 18 | 0, 18, 0);
      if (HEAP32[i50 >> 2] & 32 | 0) break;
      ___fwritex(i10, i43 - i10 | 0, i50) | 0;
     } while (0);
     _pad(i50, 32, i25, i12, i23 ^ 8192);
     i3 = (i12 | 0) < (i25 | 0) ? i25 : i12;
    } else {
     i8 = (i10 & 32 | 0) != 0;
     i7 = d6 != d6 | 0.0 != 0.0;
     i4 = i7 ? 0 : i21;
     i8 = i7 ? (i8 ? gb + 44137 | 0 : gb + 44124 | 0) : i8 ? gb + 44116 | 0 : gb + 44120 | 0;
     i7 = i4 + 3 | 0;
     _pad(i50, 32, i25, i7, i5);
     i3 = HEAP32[i50 >> 2] | 0;
     if (!(i3 & 32)) {
      ___fwritex(i22, i4, i50) | 0;
      i3 = HEAP32[i50 >> 2] | 0;
     }
     if (!(i3 & 32)) ___fwritex(i8, 3, i50) | 0;
     _pad(i50, 32, i25, i7, i23 ^ 8192);
     i3 = (i7 | 0) < (i25 | 0) ? i25 : i7;
    } while (0);
    i4 = i3;
    i14 = i24;
    continue L1;
   }
  default:
   {
    i3 = i14;
    i5 = i23;
    i10 = i8;
    i12 = 0;
    i11 = gb + 42188 | 0;
    i4 = i28;
   }
  } while (0);
  L311 : do if ((i26 | 0) == 64) {
   i5 = i44;
   i4 = HEAP32[i5 >> 2] | 0;
   i5 = HEAP32[i5 + 4 >> 2] | 0;
   i7 = i10 & 32;
   if (!((i4 | 0) == 0 & (i5 | 0) == 0)) {
    i3 = i28;
    do {
     i3 = i3 + -1 | 0;
     HEAP8[i3 >> 0] = HEAPU8[(i4 & 15) + (gb + 42172) >> 0] | i7;
     i4 = _bitshift64Lshr(i4 | 0, i5 | 0, 4) | 0;
     i5 = getTempRet0() | 0;
    } while (!((i4 | 0) == 0 & (i5 | 0) == 0));
    i26 = i44;
    if ((i9 & 8 | 0) == 0 | (HEAP32[i26 >> 2] | 0) == 0 & (HEAP32[i26 + 4 >> 2] | 0) == 0) {
     i4 = i9;
     i9 = 0;
     i7 = gb + 42188 | 0;
     i26 = 77;
    } else {
     i4 = i9;
     i9 = 2;
     i7 = (i10 >> 4) + (gb + 42188) | 0;
     i26 = 77;
    }
   } else {
    i3 = i28;
    i4 = i9;
    i9 = 0;
    i7 = gb + 42188 | 0;
    i26 = 77;
   }
  } else if ((i26 | 0) == 76) {
   i3 = _fmt_u(i3, i4, i28) | 0;
   i4 = i23;
   i9 = i5;
   i26 = 77;
  } else if ((i26 | 0) == 82) {
   i26 = 0;
   i23 = _memchr(i4, 0, i8) | 0;
   i22 = (i23 | 0) == 0;
   i3 = i4;
   i10 = i22 ? i8 : i23 - i4 | 0;
   i12 = 0;
   i11 = gb + 42188 | 0;
   i4 = i22 ? i4 + i8 | 0 : i23;
  } else if ((i26 | 0) == 86) {
   i26 = 0;
   i5 = 0;
   i4 = 0;
   i9 = i3;
   while (1) {
    i7 = HEAP32[i9 >> 2] | 0;
    if (!i7) break;
    i4 = _wctomb(i48, i7) | 0;
    if ((i4 | 0) < 0 | i4 >>> 0 > (i8 - i5 | 0) >>> 0) break;
    i5 = i4 + i5 | 0;
    if (i8 >>> 0 > i5 >>> 0) i9 = i9 + 4 | 0; else break;
   }
   if ((i4 | 0) < 0) {
    i1 = -1;
    break L1;
   }
   _pad(i50, 32, i25, i5, i23);
   if (!i5) {
    i3 = 0;
    i26 = 97;
   } else {
    i7 = 0;
    while (1) {
     i4 = HEAP32[i3 >> 2] | 0;
     if (!i4) {
      i3 = i5;
      i26 = 97;
      break L311;
     }
     i4 = _wctomb(i48, i4) | 0;
     i7 = i4 + i7 | 0;
     if ((i7 | 0) > (i5 | 0)) {
      i3 = i5;
      i26 = 97;
      break L311;
     }
     if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i48, i4, i50) | 0;
     if (i7 >>> 0 >= i5 >>> 0) {
      i3 = i5;
      i26 = 97;
      break;
     } else i3 = i3 + 4 | 0;
    }
   }
  } while (0);
  if ((i26 | 0) == 97) {
   i26 = 0;
   _pad(i50, 32, i25, i3, i23 ^ 8192);
   i4 = (i25 | 0) > (i3 | 0) ? i25 : i3;
   i14 = i24;
   continue;
  }
  if ((i26 | 0) == 77) {
   i26 = 0;
   i5 = (i8 | 0) > -1 ? i4 & -65537 : i4;
   i4 = i44;
   i4 = (HEAP32[i4 >> 2] | 0) != 0 | (HEAP32[i4 + 4 >> 2] | 0) != 0;
   if ((i8 | 0) != 0 | i4) {
    i10 = (i4 & 1 ^ 1) + (i36 - i3) | 0;
    i10 = (i8 | 0) > (i10 | 0) ? i8 : i10;
    i12 = i9;
    i11 = i7;
    i4 = i28;
   } else {
    i3 = i28;
    i10 = 0;
    i12 = i9;
    i11 = i7;
    i4 = i28;
   }
  }
  i9 = i4 - i3 | 0;
  i7 = (i10 | 0) < (i9 | 0) ? i9 : i10;
  i8 = i12 + i7 | 0;
  i4 = (i25 | 0) < (i8 | 0) ? i8 : i25;
  _pad(i50, 32, i4, i8, i5);
  if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i11, i12, i50) | 0;
  _pad(i50, 48, i4, i8, i5 ^ 65536);
  _pad(i50, 48, i7, i9, 0);
  if (!(HEAP32[i50 >> 2] & 32)) ___fwritex(i3, i9, i50) | 0;
  _pad(i50, 32, i4, i8, i5 ^ 8192);
  i14 = i24;
 }
 L345 : do if ((i26 | 0) == 244) if (!i50) if (i2) {
  i1 = 1;
  while (1) {
   i2 = HEAP32[i53 + (i1 << 2) >> 2] | 0;
   if (!i2) break;
   _pop_arg(i52 + (i1 << 3) | 0, i2, i51);
   i1 = i1 + 1 | 0;
   if ((i1 | 0) >= 10) {
    i1 = 1;
    break L345;
   }
  }
  if ((i1 | 0) < 10) while (1) {
   if (HEAP32[i53 + (i1 << 2) >> 2] | 0) {
    i1 = -1;
    break L345;
   }
   i1 = i1 + 1 | 0;
   if ((i1 | 0) >= 10) {
    i1 = 1;
    break;
   }
  } else i1 = 1;
 } else i1 = 0; while (0);
 STACKTOP = i54;
 return i1 | 0;
}

function ___floatscan(i24, i2, i21) {
 i24 = i24 | 0;
 i2 = i2 | 0;
 i21 = i21 | 0;
 var d1 = 0.0, i3 = 0, d4 = 0.0, i5 = 0, i6 = 0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i22 = 0, i23 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, d32 = 0.0;
 i31 = STACKTOP;
 STACKTOP = STACKTOP + 512 | 0;
 i27 = i31;
 switch (i2 | 0) {
 case 0:
  {
   i30 = 24;
   i29 = -149;
   i19 = 4;
   break;
  }
 case 1:
  {
   i30 = 53;
   i29 = -1074;
   i19 = 4;
   break;
  }
 case 2:
  {
   i30 = 53;
   i29 = -1074;
   i19 = 4;
   break;
  }
 default:
  d1 = 0.0;
 }
 L4 : do if ((i19 | 0) == 4) {
  i23 = i24 + 4 | 0;
  i22 = i24 + 100 | 0;
  do {
   i2 = HEAP32[i23 >> 2] | 0;
   if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
    HEAP32[i23 >> 2] = i2 + 1;
    i2 = HEAPU8[i2 >> 0] | 0;
   } else i2 = ___shgetc(i24) | 0;
  } while ((_isspace(i2) | 0) != 0);
  L13 : do switch (i2 | 0) {
  case 43:
  case 45:
   {
    i3 = 1 - (((i2 | 0) == 45 & 1) << 1) | 0;
    i2 = HEAP32[i23 >> 2] | 0;
    if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
     HEAP32[i23 >> 2] = i2 + 1;
     i2 = HEAPU8[i2 >> 0] | 0;
     i28 = i3;
     break L13;
    } else {
     i2 = ___shgetc(i24) | 0;
     i28 = i3;
     break L13;
    }
   }
  default:
   i28 = 1;
  } while (0);
  i3 = i2;
  i2 = 0;
  do {
   if ((i3 | 32 | 0) != (HEAP8[gb + 44128 + i2 >> 0] | 0)) break;
   do if (i2 >>> 0 < 7) {
    i3 = HEAP32[i23 >> 2] | 0;
    if (i3 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
     HEAP32[i23 >> 2] = i3 + 1;
     i3 = HEAPU8[i3 >> 0] | 0;
     break;
    } else {
     i3 = ___shgetc(i24) | 0;
     break;
    }
   } while (0);
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < 8);
  L29 : do switch (i2 | 0) {
  case 8:
   break;
  case 3:
   {
    i19 = 23;
    break;
   }
  default:
   {
    i5 = (i21 | 0) != 0;
    if (i5 & i2 >>> 0 > 3) if ((i2 | 0) == 8) break L29; else {
     i19 = 23;
     break L29;
    }
    L34 : do if (!i2) {
     i2 = 0;
     do {
      if ((i3 | 32 | 0) != (HEAP8[gb + 44137 + i2 >> 0] | 0)) break L34;
      do if (i2 >>> 0 < 2) {
       i3 = HEAP32[i23 >> 2] | 0;
       if (i3 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = i3 + 1;
        i3 = HEAPU8[i3 >> 0] | 0;
        break;
       } else {
        i3 = ___shgetc(i24) | 0;
        break;
       }
      } while (0);
      i2 = i2 + 1 | 0;
     } while (i2 >>> 0 < 3);
    } while (0);
    switch (i2 | 0) {
    case 3:
     {
      i2 = HEAP32[i23 >> 2] | 0;
      if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
       HEAP32[i23 >> 2] = i2 + 1;
       i2 = HEAPU8[i2 >> 0] | 0;
      } else i2 = ___shgetc(i24) | 0;
      if ((i2 | 0) == 40) i2 = 1; else {
       if (!(HEAP32[i22 >> 2] | 0)) {
        d1 = nan;
        break L4;
       }
       HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
       d1 = nan;
       break L4;
      }
      while (1) {
       i3 = HEAP32[i23 >> 2] | 0;
       if (i3 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = i3 + 1;
        i3 = HEAPU8[i3 >> 0] | 0;
       } else i3 = ___shgetc(i24) | 0;
       if (!((i3 + -48 | 0) >>> 0 < 10 | (i3 + -65 | 0) >>> 0 < 26) ? !((i3 | 0) == 95 | (i3 + -97 | 0) >>> 0 < 26) : 0) break;
       i2 = i2 + 1 | 0;
      }
      if ((i3 | 0) == 41) {
       d1 = nan;
       break L4;
      }
      i3 = (HEAP32[i22 >> 2] | 0) == 0;
      if (!i3) HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
      if (!i5) {
       HEAP32[(___errno_location() | 0) >> 2] = 22;
       ___shlim(i24, 0);
       d1 = 0.0;
       break L4;
      }
      if (!i2) {
       d1 = nan;
       break L4;
      }
      while (1) {
       i2 = i2 + -1 | 0;
       if (!i3) HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
       if (!i2) {
        d1 = nan;
        break L4;
       }
      }
     }
    case 0:
     {
      do if ((i3 | 0) == 48) {
       i2 = HEAP32[i23 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = i2 + 1;
        i2 = HEAPU8[i2 >> 0] | 0;
       } else i2 = ___shgetc(i24) | 0;
       if ((i2 | 32 | 0) != 120) {
        if (!(HEAP32[i22 >> 2] | 0)) {
         i2 = 48;
         break;
        }
        HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
        i2 = 48;
        break;
       }
       i2 = HEAP32[i23 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = i2 + 1;
        i2 = HEAPU8[i2 >> 0] | 0;
        i5 = 0;
       } else {
        i2 = ___shgetc(i24) | 0;
        i5 = 0;
       }
       L94 : while (1) {
        switch (i2 | 0) {
        case 46:
         {
          i19 = 74;
          break L94;
         }
        case 48:
         break;
        default:
         {
          i17 = 0;
          i6 = 0;
          i16 = 0;
          i3 = 0;
          i8 = i5;
          i9 = 0;
          i15 = 0;
          d7 = 1.0;
          i5 = 0;
          d1 = 0.0;
          break L94;
         }
        }
        i2 = HEAP32[i23 >> 2] | 0;
        if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i23 >> 2] = i2 + 1;
         i2 = HEAPU8[i2 >> 0] | 0;
         i5 = 1;
         continue;
        } else {
         i2 = ___shgetc(i24) | 0;
         i5 = 1;
         continue;
        }
       }
       if ((i19 | 0) == 74) {
        i2 = HEAP32[i23 >> 2] | 0;
        if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i23 >> 2] = i2 + 1;
         i2 = HEAPU8[i2 >> 0] | 0;
        } else i2 = ___shgetc(i24) | 0;
        if ((i2 | 0) == 48) {
         i5 = 0;
         i3 = 0;
         do {
          i2 = HEAP32[i23 >> 2] | 0;
          if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
           HEAP32[i23 >> 2] = i2 + 1;
           i2 = HEAPU8[i2 >> 0] | 0;
          } else i2 = ___shgetc(i24) | 0;
          i5 = _i64Add(i5 | 0, i3 | 0, -1, -1) | 0;
          i3 = getTempRet0() | 0;
         } while ((i2 | 0) == 48);
         i17 = 0;
         i6 = 0;
         i16 = i5;
         i8 = 1;
         i9 = 1;
         i15 = 0;
         d7 = 1.0;
         i5 = 0;
         d1 = 0.0;
        } else {
         i17 = 0;
         i6 = 0;
         i16 = 0;
         i3 = 0;
         i8 = i5;
         i9 = 1;
         i15 = 0;
         d7 = 1.0;
         i5 = 0;
         d1 = 0.0;
        }
       }
       while (1) {
        i13 = i2 + -48 | 0;
        i10 = i2 | 32;
        if (i13 >>> 0 >= 10) {
         i14 = (i2 | 0) == 46;
         if (!(i14 | (i10 + -97 | 0) >>> 0 < 6)) {
          i10 = i16;
          i13 = i17;
          break;
         }
         if (i14) if (!i9) {
          i14 = i6;
          i3 = i17;
          i13 = i17;
          i9 = 1;
          i10 = i15;
          d4 = d7;
         } else {
          i10 = i16;
          i13 = i17;
          i2 = 46;
          break;
         } else i19 = 86;
        } else i19 = 86;
        if ((i19 | 0) == 86) {
         i19 = 0;
         i2 = (i2 | 0) > 57 ? i10 + -87 | 0 : i13;
         do if (!((i17 | 0) < 0 | (i17 | 0) == 0 & i6 >>> 0 < 8)) {
          if ((i17 | 0) < 0 | (i17 | 0) == 0 & i6 >>> 0 < 14) {
           d12 = d7 * .0625;
           i10 = i15;
           d4 = d12;
           d1 = d1 + d12 * +(i2 | 0);
           break;
          }
          if ((i15 | 0) != 0 | (i2 | 0) == 0) {
           i10 = i15;
           d4 = d7;
          } else {
           i10 = 1;
           d4 = d7;
           d1 = d1 + d7 * .5;
          }
         } else {
          i10 = i15;
          d4 = d7;
          i5 = i2 + (i5 << 4) | 0;
         } while (0);
         i6 = _i64Add(i6 | 0, i17 | 0, 1, 0) | 0;
         i14 = i16;
         i13 = getTempRet0() | 0;
         i8 = 1;
        }
        i2 = HEAP32[i23 >> 2] | 0;
        if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i23 >> 2] = i2 + 1;
         i17 = i13;
         i16 = i14;
         i2 = HEAPU8[i2 >> 0] | 0;
         i15 = i10;
         d7 = d4;
         continue;
        } else {
         i17 = i13;
         i16 = i14;
         i2 = ___shgetc(i24) | 0;
         i15 = i10;
         d7 = d4;
         continue;
        }
       }
       if (!i8) {
        i2 = (HEAP32[i22 >> 2] | 0) == 0;
        if (!i2) HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
        if (i21) {
         if (!i2 ? (i18 = HEAP32[i23 >> 2] | 0, HEAP32[i23 >> 2] = i18 + -1, i9 | 0) : 0) HEAP32[i23 >> 2] = i18 + -2;
        } else ___shlim(i24, 0);
        d1 = +(i28 | 0) * 0.0;
        break L4;
       }
       i8 = (i9 | 0) == 0;
       i9 = i8 ? i6 : i10;
       i8 = i8 ? i13 : i3;
       if ((i13 | 0) < 0 | (i13 | 0) == 0 & i6 >>> 0 < 8) {
        i3 = i13;
        do {
         i5 = i5 << 4;
         i6 = _i64Add(i6 | 0, i3 | 0, 1, 0) | 0;
         i3 = getTempRet0() | 0;
        } while ((i3 | 0) < 0 | (i3 | 0) == 0 & i6 >>> 0 < 8);
       }
       if ((i2 | 32 | 0) == 112) {
        i3 = _scanexp(i24, i21) | 0;
        i2 = getTempRet0() | 0;
        if ((i3 | 0) == 0 & (i2 | 0) == -2147483648) {
         if (!i21) {
          ___shlim(i24, 0);
          d1 = 0.0;
          break L4;
         }
         if (!(HEAP32[i22 >> 2] | 0)) {
          i3 = 0;
          i2 = 0;
         } else {
          HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
          i3 = 0;
          i2 = 0;
         }
        }
       } else if (!(HEAP32[i22 >> 2] | 0)) {
        i3 = 0;
        i2 = 0;
       } else {
        HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
        i3 = 0;
        i2 = 0;
       }
       i27 = _bitshift64Shl(i9 | 0, i8 | 0, 2) | 0;
       i27 = _i64Add(i27 | 0, getTempRet0() | 0, -32, -1) | 0;
       i2 = _i64Add(i27 | 0, getTempRet0() | 0, i3 | 0, i2 | 0) | 0;
       i3 = getTempRet0() | 0;
       if (!i5) {
        d1 = +(i28 | 0) * 0.0;
        break L4;
       }
       if ((i3 | 0) > 0 | (i3 | 0) == 0 & i2 >>> 0 > (0 - i29 | 0) >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        d1 = +(i28 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;
        break L4;
       }
       i27 = i29 + -106 | 0;
       i26 = ((i27 | 0) < 0) << 31 >> 31;
       if ((i3 | 0) < (i26 | 0) | (i3 | 0) == (i26 | 0) & i2 >>> 0 < i27 >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        d1 = +(i28 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;
        break L4;
       }
       if ((i5 | 0) > -1) {
        do {
         i26 = !(d1 >= .5);
         i27 = i26 & 1 | i5 << 1;
         i5 = i27 ^ 1;
         d1 = d1 + (i26 ? d1 : d1 + -1.0);
         i2 = _i64Add(i2 | 0, i3 | 0, -1, -1) | 0;
         i3 = getTempRet0() | 0;
        } while ((i27 | 0) > -1);
        i6 = i2;
        d7 = d1;
       } else {
        i6 = i2;
        d7 = d1;
       }
       i2 = _i64Subtract(32, 0, i29 | 0, ((i29 | 0) < 0) << 31 >> 31 | 0) | 0;
       i2 = _i64Add(i6 | 0, i3 | 0, i2 | 0, getTempRet0() | 0) | 0;
       i29 = getTempRet0() | 0;
       if (0 > (i29 | 0) | 0 == (i29 | 0) & i30 >>> 0 > i2 >>> 0) if ((i2 | 0) < 0) {
        i2 = 0;
        i19 = 127;
       } else i19 = 125; else {
        i2 = i30;
        i19 = 125;
       }
       if ((i19 | 0) == 125) if ((i2 | 0) < 53) i19 = 127; else {
        i3 = i2;
        d4 = +(i28 | 0);
        d1 = 0.0;
       }
       if ((i19 | 0) == 127) {
        d1 = +(i28 | 0);
        i3 = i2;
        d4 = d1;
        d1 = +_copysignl(+_scalbn(1.0, 84 - i2 | 0), d1);
       }
       i30 = (i5 & 1 | 0) == 0 & (d7 != 0.0 & (i3 | 0) < 32);
       d1 = d4 * (i30 ? 0.0 : d7) + (d1 + d4 * +(((i30 & 1) + i5 | 0) >>> 0)) - d1;
       if (!(d1 != 0.0)) HEAP32[(___errno_location() | 0) >> 2] = 34;
       d1 = +_scalbnl(d1, i6);
       break L4;
      } else i2 = i3; while (0);
      i25 = i29 + i30 | 0;
      i26 = 0 - i25 | 0;
      i5 = 0;
      L184 : while (1) {
       switch (i2 | 0) {
       case 46:
        {
         i19 = 138;
         break L184;
        }
       case 48:
        break;
       default:
        {
         i3 = 0;
         i10 = 0;
         i9 = 0;
         break L184;
        }
       }
       i2 = HEAP32[i23 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = i2 + 1;
        i2 = HEAPU8[i2 >> 0] | 0;
        i5 = 1;
        continue;
       } else {
        i2 = ___shgetc(i24) | 0;
        i5 = 1;
        continue;
       }
      }
      if ((i19 | 0) == 138) {
       i2 = HEAP32[i23 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = i2 + 1;
        i2 = HEAPU8[i2 >> 0] | 0;
       } else i2 = ___shgetc(i24) | 0;
       if ((i2 | 0) == 48) {
        i3 = 0;
        i2 = 0;
        while (1) {
         i3 = _i64Add(i3 | 0, i2 | 0, -1, -1) | 0;
         i5 = getTempRet0() | 0;
         i2 = HEAP32[i23 >> 2] | 0;
         if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
          HEAP32[i23 >> 2] = i2 + 1;
          i2 = HEAPU8[i2 >> 0] | 0;
         } else i2 = ___shgetc(i24) | 0;
         if ((i2 | 0) == 48) i2 = i5; else {
          i10 = i5;
          i5 = 1;
          i9 = 1;
          break;
         }
        }
       } else {
        i3 = 0;
        i10 = 0;
        i9 = 1;
       }
      }
      HEAP32[i27 >> 2] = 0;
      i8 = i2 + -48 | 0;
      i6 = (i2 | 0) == 46;
      L203 : do if (i6 | i8 >>> 0 < 10) {
       i20 = i27 + 496 | 0;
       i17 = 0;
       i14 = 0;
       i15 = i6;
       i19 = i10;
       i13 = i5;
       i18 = i9;
       i5 = 0;
       i6 = 0;
       i9 = 0;
       L205 : while (1) {
        do if (i15) if (!i18) {
         i3 = i17;
         i10 = i14;
         i18 = 1;
        } else {
         i10 = i19;
         i2 = i17;
         i8 = i14;
         break L205;
        } else {
         i15 = _i64Add(i17 | 0, i14 | 0, 1, 0) | 0;
         i14 = getTempRet0() | 0;
         i16 = (i2 | 0) != 48;
         if ((i6 | 0) >= 125) {
          if (!i16) {
           i10 = i19;
           i17 = i15;
           break;
          }
          HEAP32[i20 >> 2] = HEAP32[i20 >> 2] | 1;
          i10 = i19;
          i17 = i15;
          break;
         }
         i10 = i27 + (i6 << 2) | 0;
         if (i5) i8 = i2 + -48 + ((HEAP32[i10 >> 2] | 0) * 10 | 0) | 0;
         HEAP32[i10 >> 2] = i8;
         i5 = i5 + 1 | 0;
         i8 = (i5 | 0) == 9;
         i10 = i19;
         i17 = i15;
         i13 = 1;
         i5 = i8 ? 0 : i5;
         i6 = (i8 & 1) + i6 | 0;
         i9 = i16 ? i15 : i9;
        } while (0);
        i2 = HEAP32[i23 >> 2] | 0;
        if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i23 >> 2] = i2 + 1;
         i2 = HEAPU8[i2 >> 0] | 0;
        } else i2 = ___shgetc(i24) | 0;
        i8 = i2 + -48 | 0;
        i15 = (i2 | 0) == 46;
        if (!(i15 | i8 >>> 0 < 10)) {
         i8 = i18;
         i19 = 161;
         break L203;
        } else i19 = i10;
       }
       i13 = (i13 | 0) != 0;
       i19 = 169;
      } else {
       i17 = 0;
       i14 = 0;
       i13 = i5;
       i8 = i9;
       i5 = 0;
       i6 = 0;
       i9 = 0;
       i19 = 161;
      } while (0);
      do if ((i19 | 0) == 161) {
       i20 = (i8 | 0) == 0;
       i3 = i20 ? i17 : i3;
       i10 = i20 ? i14 : i10;
       i13 = (i13 | 0) != 0;
       if (!((i2 | 32 | 0) == 101 & i13)) if ((i2 | 0) > -1) {
        i2 = i17;
        i8 = i14;
        i19 = 169;
        break;
       } else {
        i2 = i17;
        i8 = i14;
        i19 = 171;
        break;
       }
       i8 = _scanexp(i24, i21) | 0;
       i2 = getTempRet0() | 0;
       if ((i8 | 0) == 0 & (i2 | 0) == -2147483648) {
        if (!i21) {
         ___shlim(i24, 0);
         d1 = 0.0;
         break;
        }
        if (!(HEAP32[i22 >> 2] | 0)) {
         i8 = 0;
         i2 = 0;
        } else {
         HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
         i8 = 0;
         i2 = 0;
        }
       }
       i3 = _i64Add(i8 | 0, i2 | 0, i3 | 0, i10 | 0) | 0;
       i13 = i17;
       i10 = getTempRet0() | 0;
       i8 = i14;
       i19 = 173;
      } while (0);
      if ((i19 | 0) == 169) if (HEAP32[i22 >> 2] | 0) {
       HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
       if (i13) {
        i13 = i2;
        i19 = 173;
       } else i19 = 172;
      } else i19 = 171;
      if ((i19 | 0) == 171) if (i13) {
       i13 = i2;
       i19 = 173;
      } else i19 = 172;
      do if ((i19 | 0) == 172) {
       HEAP32[(___errno_location() | 0) >> 2] = 22;
       ___shlim(i24, 0);
       d1 = 0.0;
      } else if ((i19 | 0) == 173) {
       i2 = HEAP32[i27 >> 2] | 0;
       if (!i2) {
        d1 = +(i28 | 0) * 0.0;
        break;
       }
       if (((i8 | 0) < 0 | (i8 | 0) == 0 & i13 >>> 0 < 10) & ((i3 | 0) == (i13 | 0) & (i10 | 0) == (i8 | 0)) ? i30 >>> 0 > 30 | (i2 >>> i30 | 0) == 0 : 0) {
        d1 = +(i28 | 0) * +(i2 >>> 0);
        break;
       }
       i24 = (i29 | 0) / -2 | 0;
       i23 = ((i24 | 0) < 0) << 31 >> 31;
       if ((i10 | 0) > (i23 | 0) | (i10 | 0) == (i23 | 0) & i3 >>> 0 > i24 >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        d1 = +(i28 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;
        break;
       }
       i24 = i29 + -106 | 0;
       i23 = ((i24 | 0) < 0) << 31 >> 31;
       if ((i10 | 0) < (i23 | 0) | (i10 | 0) == (i23 | 0) & i3 >>> 0 < i24 >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        d1 = +(i28 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;
        break;
       }
       if (i5) {
        if ((i5 | 0) < 9) {
         i8 = i27 + (i6 << 2) | 0;
         i2 = HEAP32[i8 >> 2] | 0;
         do {
          i2 = i2 * 10 | 0;
          i5 = i5 + 1 | 0;
         } while ((i5 | 0) != 9);
         HEAP32[i8 >> 2] = i2;
        }
        i6 = i6 + 1 | 0;
       }
       if ((i9 | 0) < 9 ? (i9 | 0) <= (i3 | 0) & (i3 | 0) < 18 : 0) {
        if ((i3 | 0) == 9) {
         d1 = +(i28 | 0) * +((HEAP32[i27 >> 2] | 0) >>> 0);
         break;
        }
        if ((i3 | 0) < 9) {
         d1 = +(i28 | 0) * +((HEAP32[i27 >> 2] | 0) >>> 0) / +(HEAP32[gb + 9156 + (8 - i3 << 2) >> 2] | 0);
         break;
        }
        i24 = i30 + 27 + (Math_imul(i3, -3) | 0) | 0;
        i2 = HEAP32[i27 >> 2] | 0;
        if ((i24 | 0) > 30 | (i2 >>> i24 | 0) == 0) {
         d1 = +(i28 | 0) * +(i2 >>> 0) * +(HEAP32[gb + 9156 + (i3 + -10 << 2) >> 2] | 0);
         break;
        }
       }
       i2 = (i3 | 0) % 9 | 0;
       if (!i2) {
        i5 = 0;
        i2 = 0;
       } else {
        i13 = (i3 | 0) > -1 ? i2 : i2 + 9 | 0;
        i8 = HEAP32[gb + 9156 + (8 - i13 << 2) >> 2] | 0;
        if (i6) {
         i9 = 1e9 / (i8 | 0) | 0;
         i5 = 0;
         i2 = 0;
         i10 = 0;
         do {
          i22 = i27 + (i10 << 2) | 0;
          i23 = HEAP32[i22 >> 2] | 0;
          i24 = ((i23 >>> 0) / (i8 >>> 0) | 0) + i2 | 0;
          HEAP32[i22 >> 2] = i24;
          i2 = Math_imul((i23 >>> 0) % (i8 >>> 0) | 0, i9) | 0;
          i24 = (i10 | 0) == (i5 | 0) & (i24 | 0) == 0;
          i10 = i10 + 1 | 0;
          i3 = i24 ? i3 + -9 | 0 : i3;
          i5 = i24 ? i10 & 127 : i5;
         } while ((i10 | 0) != (i6 | 0));
         if (i2) {
          HEAP32[i27 + (i6 << 2) >> 2] = i2;
          i6 = i6 + 1 | 0;
         }
        } else {
         i5 = 0;
         i6 = 0;
        }
        i2 = 0;
        i3 = 9 - i13 + i3 | 0;
       }
       L284 : while (1) {
        i14 = (i3 | 0) < 18;
        i15 = (i3 | 0) == 18;
        i16 = i27 + (i5 << 2) | 0;
        do {
         if (!i14) {
          if (!i15) {
           i17 = i6;
           break L284;
          }
          if ((HEAP32[i16 >> 2] | 0) >>> 0 >= 9007199) {
           i3 = 18;
           i17 = i6;
           break L284;
          }
         }
         i8 = 0;
         i9 = i6 + 127 | 0;
         while (1) {
          i13 = i9 & 127;
          i10 = i27 + (i13 << 2) | 0;
          i9 = _bitshift64Shl(HEAP32[i10 >> 2] | 0, 0, 29) | 0;
          i9 = _i64Add(i9 | 0, getTempRet0() | 0, i8 | 0, 0) | 0;
          i8 = getTempRet0() | 0;
          if (i8 >>> 0 > 0 | (i8 | 0) == 0 & i9 >>> 0 > 1e9) {
           i24 = ___udivdi3(i9 | 0, i8 | 0, 1e9, 0) | 0;
           getTempRet0() | 0;
           i9 = ___uremdi3(i9 | 0, i8 | 0, 1e9, 0) | 0;
           getTempRet0() | 0;
           i8 = i24;
          } else i8 = 0;
          HEAP32[i10 >> 2] = i9;
          i24 = (i13 | 0) == (i5 | 0);
          i6 = (i13 | 0) != (i6 + 127 & 127 | 0) | i24 ? i6 : (i9 | 0) == 0 ? i13 : i6;
          if (i24) break; else i9 = i13 + -1 | 0;
         }
         i2 = i2 + -29 | 0;
        } while ((i8 | 0) == 0);
        i5 = i5 + 127 & 127;
        if ((i5 | 0) == (i6 | 0)) {
         i24 = i6 + 127 & 127;
         i6 = i27 + ((i6 + 126 & 127) << 2) | 0;
         HEAP32[i6 >> 2] = HEAP32[i6 >> 2] | HEAP32[i27 + (i24 << 2) >> 2];
         i6 = i24;
        }
        HEAP32[i27 + (i5 << 2) >> 2] = i8;
        i3 = i3 + 9 | 0;
       }
       L302 : while (1) {
        i6 = i17 + 1 & 127;
        i16 = i27 + ((i17 + 127 & 127) << 2) | 0;
        while (1) {
         i14 = (i3 | 0) == 18;
         i15 = (i3 | 0) > 27 ? 9 : 1;
         i13 = i14 ^ 1;
         while (1) {
          i9 = i5 & 127;
          i10 = (i9 | 0) == (i17 | 0);
          do if (!i10) {
           i8 = HEAP32[i27 + (i9 << 2) >> 2] | 0;
           if (i8 >>> 0 < 9007199) {
            i19 = 219;
            break;
           }
           if (i8 >>> 0 > 9007199) break;
           i8 = i5 + 1 & 127;
           if ((i8 | 0) == (i17 | 0)) {
            i19 = 219;
            break;
           }
           i8 = HEAP32[i27 + (i8 << 2) >> 2] | 0;
           if (i8 >>> 0 < 254740991) {
            i19 = 219;
            break;
           }
           if (!(i8 >>> 0 > 254740991 | i13)) {
            i3 = i9;
            i6 = i17;
            break L302;
           }
          } else i19 = 219; while (0);
          if ((i19 | 0) == 219 ? (i19 = 0, i14) : 0) {
           i19 = 220;
           break L302;
          }
          i2 = i2 + i15 | 0;
          if ((i5 | 0) == (i17 | 0)) i5 = i17; else break;
         }
         i13 = (1 << i15) + -1 | 0;
         i14 = 1e9 >>> i15;
         i9 = i5;
         i8 = 0;
         i10 = i5;
         while (1) {
          i23 = i27 + (i10 << 2) | 0;
          i24 = HEAP32[i23 >> 2] | 0;
          i5 = (i24 >>> i15) + i8 | 0;
          HEAP32[i23 >> 2] = i5;
          i8 = Math_imul(i24 & i13, i14) | 0;
          i5 = (i10 | 0) == (i9 | 0) & (i5 | 0) == 0;
          i10 = i10 + 1 & 127;
          i3 = i5 ? i3 + -9 | 0 : i3;
          i5 = i5 ? i10 : i9;
          if ((i10 | 0) == (i17 | 0)) break; else i9 = i5;
         }
         if (!i8) continue;
         if ((i6 | 0) != (i5 | 0)) break;
         HEAP32[i16 >> 2] = HEAP32[i16 >> 2] | 1;
        }
        HEAP32[i27 + (i17 << 2) >> 2] = i8;
        i17 = i6;
       }
       if ((i19 | 0) == 220) if (i10) {
        HEAP32[i27 + (i6 + -1 << 2) >> 2] = 0;
        i3 = i17;
       } else {
        i3 = i9;
        i6 = i17;
       }
       d1 = +((HEAP32[i27 + (i3 << 2) >> 2] | 0) >>> 0);
       i3 = i5 + 1 & 127;
       if ((i3 | 0) == (i6 | 0)) {
        i6 = i5 + 2 & 127;
        HEAP32[i27 + (i6 + -1 << 2) >> 2] = 0;
       }
       d12 = +(i28 | 0);
       d4 = d12 * (d1 * 1.0e9 + +((HEAP32[i27 + (i3 << 2) >> 2] | 0) >>> 0));
       i14 = i2 + 53 | 0;
       i10 = i14 - i29 | 0;
       i13 = (i10 | 0) < (i30 | 0);
       i3 = i13 & 1;
       i9 = i13 ? ((i10 | 0) < 0 ? 0 : i10) : i30;
       if ((i9 | 0) < 53) {
        d32 = +_copysignl(+_scalbn(1.0, 105 - i9 | 0), d4);
        d7 = +_fmodl(d4, +_scalbn(1.0, 53 - i9 | 0));
        d11 = d32;
        d1 = d7;
        d7 = d32 + (d4 - d7);
       } else {
        d11 = 0.0;
        d1 = 0.0;
        d7 = d4;
       }
       i8 = i5 + 2 & 127;
       do if ((i8 | 0) == (i6 | 0)) d4 = d1; else {
        i8 = HEAP32[i27 + (i8 << 2) >> 2] | 0;
        do if (i8 >>> 0 >= 5e8) {
         if (i8 >>> 0 > 5e8) {
          d1 = d12 * .75 + d1;
          break;
         }
         if ((i5 + 3 & 127 | 0) == (i6 | 0)) {
          d1 = d12 * .5 + d1;
          break;
         } else {
          d1 = d12 * .75 + d1;
          break;
         }
        } else {
         if ((i8 | 0) == 0 ? (i5 + 3 & 127 | 0) == (i6 | 0) : 0) break;
         d1 = d12 * .25 + d1;
        } while (0);
        if ((53 - i9 | 0) <= 1) {
         d4 = d1;
         break;
        }
        if (+_fmodl(d1, 1.0) != 0.0) {
         d4 = d1;
         break;
        }
        d4 = d1 + 1.0;
       } while (0);
       d1 = d7 + d4 - d11;
       do if ((i14 & 2147483647 | 0) > (-2 - i25 | 0)) {
        if (+Math_abs(+d1) >= 9007199254740992.0) {
         i3 = i13 & (i9 | 0) == (i10 | 0) ? 0 : i3;
         i2 = i2 + 1 | 0;
         d1 = d1 * .5;
        }
        if ((i2 + 50 | 0) <= (i26 | 0) ? !(d4 != 0.0 & (i3 | 0) != 0) : 0) break;
        HEAP32[(___errno_location() | 0) >> 2] = 34;
       } while (0);
       d1 = +_scalbnl(d1, i2);
      } while (0);
      break L4;
     }
    default:
     {
      if (HEAP32[i22 >> 2] | 0) HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
      HEAP32[(___errno_location() | 0) >> 2] = 22;
      ___shlim(i24, 0);
      d1 = 0.0;
      break L4;
     }
    }
   }
  } while (0);
  if ((i19 | 0) == 23) {
   i3 = (HEAP32[i22 >> 2] | 0) == 0;
   if (!i3) HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
   if ((i21 | 0) != 0 & i2 >>> 0 > 3) do {
    if (!i3) HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + -1;
    i2 = i2 + -1 | 0;
   } while (i2 >>> 0 > 3);
  }
  d1 = +(i28 | 0) * inf;
 } while (0);
 STACKTOP = i31;
 return +d1;
}

function _fft_execute_dft_16(i5) {
 i5 = i5 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, i74 = 0, i75 = 0, d76 = 0.0, d77 = 0.0, d78 = 0.0, d79 = 0.0, d80 = 0.0, d81 = 0.0, d82 = 0.0, d83 = 0.0, d84 = 0.0, d85 = 0.0, d86 = 0.0, d87 = 0.0, d88 = 0.0;
 i75 = STACKTOP;
 STACKTOP = STACKTOP + 432 | 0;
 i9 = i75 + 424 | 0;
 i11 = i75 + 416 | 0;
 i13 = i75 + 408 | 0;
 i15 = i75 + 400 | 0;
 i10 = i75 + 392 | 0;
 i12 = i75 + 384 | 0;
 i14 = i75 + 376 | 0;
 i16 = i75 + 368 | 0;
 i18 = i75 + 304 | 0;
 i20 = i75 + 288 | 0;
 i21 = i75 + 360 | 0;
 i23 = i75 + 352 | 0;
 i25 = i75 + 272 | 0;
 i27 = i75 + 256 | 0;
 i17 = i75 + 240 | 0;
 i19 = i75 + 224 | 0;
 i22 = i75 + 344 | 0;
 i24 = i75 + 336 | 0;
 i26 = i75 + 208 | 0;
 i28 = i75 + 192 | 0;
 i33 = i75 + 176 | 0;
 i39 = i75 + 160 | 0;
 i41 = i75 + 144 | 0;
 i47 = i75 + 328 | 0;
 i49 = i75 + 128 | 0;
 i55 = i75 + 112 | 0;
 i57 = i75 + 96 | 0;
 i34 = i75 + 80 | 0;
 i40 = i75 + 64 | 0;
 i42 = i75 + 48 | 0;
 i48 = i75 + 320 | 0;
 i50 = i75 + 32 | 0;
 i56 = i75 + 16 | 0;
 i58 = i75;
 i71 = HEAP32[i5 + 4 >> 2] | 0;
 i31 = HEAP32[i5 + 8 >> 2] | 0;
 i32 = (HEAP32[i5 + 12 >> 2] | 0) == 1;
 i72 = HEAP32[i71 + 4 >> 2] | 0;
 i5 = i31 + 4 | 0;
 HEAP32[i31 >> 2] = HEAP32[i71 >> 2];
 HEAP32[i5 >> 2] = i72;
 i72 = HEAP32[i71 + 68 >> 2] | 0;
 i35 = i31 + 8 | 0;
 i36 = i31 + 12 | 0;
 HEAP32[i35 >> 2] = HEAP32[i71 + 64 >> 2];
 HEAP32[i36 >> 2] = i72;
 i72 = HEAP32[i71 + 36 >> 2] | 0;
 i45 = i31 + 16 | 0;
 i46 = i31 + 20 | 0;
 HEAP32[i45 >> 2] = HEAP32[i71 + 32 >> 2];
 HEAP32[i46 >> 2] = i72;
 i72 = HEAP32[i71 + 100 >> 2] | 0;
 i53 = i31 + 24 | 0;
 i54 = i31 + 28 | 0;
 HEAP32[i53 >> 2] = HEAP32[i71 + 96 >> 2];
 HEAP32[i54 >> 2] = i72;
 i72 = HEAP32[i71 + 20 >> 2] | 0;
 i61 = i31 + 32 | 0;
 i62 = i31 + 36 | 0;
 HEAP32[i61 >> 2] = HEAP32[i71 + 16 >> 2];
 HEAP32[i62 >> 2] = i72;
 i72 = HEAP32[i71 + 84 >> 2] | 0;
 i65 = i31 + 40 | 0;
 i66 = i31 + 44 | 0;
 HEAP32[i65 >> 2] = HEAP32[i71 + 80 >> 2];
 HEAP32[i66 >> 2] = i72;
 i72 = HEAP32[i71 + 52 >> 2] | 0;
 i69 = i31 + 48 | 0;
 i70 = i31 + 52 | 0;
 HEAP32[i69 >> 2] = HEAP32[i71 + 48 >> 2];
 HEAP32[i70 >> 2] = i72;
 i72 = HEAP32[i71 + 116 >> 2] | 0;
 i73 = i31 + 56 | 0;
 i74 = i31 + 60 | 0;
 HEAP32[i73 >> 2] = HEAP32[i71 + 112 >> 2];
 HEAP32[i74 >> 2] = i72;
 i72 = HEAP32[i71 + 12 >> 2] | 0;
 i29 = i31 + 64 | 0;
 i30 = i31 + 68 | 0;
 HEAP32[i29 >> 2] = HEAP32[i71 + 8 >> 2];
 HEAP32[i30 >> 2] = i72;
 i72 = HEAP32[i71 + 76 >> 2] | 0;
 i37 = i31 + 72 | 0;
 i38 = i31 + 76 | 0;
 HEAP32[i37 >> 2] = HEAP32[i71 + 72 >> 2];
 HEAP32[i38 >> 2] = i72;
 i72 = HEAP32[i71 + 44 >> 2] | 0;
 i43 = i31 + 80 | 0;
 i44 = i31 + 84 | 0;
 HEAP32[i43 >> 2] = HEAP32[i71 + 40 >> 2];
 HEAP32[i44 >> 2] = i72;
 i72 = HEAP32[i71 + 108 >> 2] | 0;
 i51 = i31 + 88 | 0;
 i52 = i31 + 92 | 0;
 HEAP32[i51 >> 2] = HEAP32[i71 + 104 >> 2];
 HEAP32[i52 >> 2] = i72;
 i72 = HEAP32[i71 + 28 >> 2] | 0;
 i59 = i31 + 96 | 0;
 i60 = i31 + 100 | 0;
 HEAP32[i59 >> 2] = HEAP32[i71 + 24 >> 2];
 HEAP32[i60 >> 2] = i72;
 i72 = HEAP32[i71 + 92 >> 2] | 0;
 i63 = i31 + 104 | 0;
 i64 = i31 + 108 | 0;
 HEAP32[i63 >> 2] = HEAP32[i71 + 88 >> 2];
 HEAP32[i64 >> 2] = i72;
 i72 = HEAP32[i71 + 60 >> 2] | 0;
 i67 = i31 + 112 | 0;
 i68 = i31 + 116 | 0;
 HEAP32[i67 >> 2] = HEAP32[i71 + 56 >> 2];
 HEAP32[i68 >> 2] = i72;
 d88 = +HEAPF32[i71 + 120 >> 2];
 d87 = +HEAPF32[i71 + 124 >> 2];
 i71 = i31 + 120 | 0;
 i72 = i31 + 124 | 0;
 d7 = +HEAPF32[i35 >> 2];
 d8 = +HEAPF32[i36 >> 2];
 d85 = +HEAPF32[i31 >> 2];
 d83 = +HEAPF32[i5 >> 2];
 HEAPF32[i35 >> 2] = d85 - d7;
 HEAPF32[i36 >> 2] = d83 - d8;
 d85 = d7 + d85;
 d83 = d8 + d83;
 d8 = +HEAPF32[i53 >> 2];
 d7 = +HEAPF32[i54 >> 2];
 d86 = +HEAPF32[i45 >> 2];
 d84 = +HEAPF32[i46 >> 2];
 HEAPF32[i53 >> 2] = d86 - d8;
 HEAPF32[i54 >> 2] = d84 - d7;
 d86 = d8 + d86;
 d84 = d7 + d84;
 d7 = +HEAPF32[i65 >> 2];
 d8 = +HEAPF32[i66 >> 2];
 d81 = +HEAPF32[i61 >> 2];
 d79 = +HEAPF32[i62 >> 2];
 HEAPF32[i65 >> 2] = d81 - d7;
 HEAPF32[i66 >> 2] = d79 - d8;
 d81 = d7 + d81;
 d79 = d8 + d79;
 d8 = +HEAPF32[i73 >> 2];
 d7 = +HEAPF32[i74 >> 2];
 d82 = +HEAPF32[i69 >> 2];
 d80 = +HEAPF32[i70 >> 2];
 d4 = d82 - d8;
 d3 = d80 - d7;
 HEAPF32[i73 >> 2] = d4;
 HEAPF32[i74 >> 2] = d3;
 d82 = d8 + d82;
 d80 = d7 + d80;
 d7 = +HEAPF32[i37 >> 2];
 d8 = +HEAPF32[i38 >> 2];
 d77 = +HEAPF32[i29 >> 2];
 d2 = +HEAPF32[i30 >> 2];
 HEAPF32[i37 >> 2] = d77 - d7;
 HEAPF32[i38 >> 2] = d2 - d8;
 d77 = d7 + d77;
 d2 = d8 + d2;
 d8 = +HEAPF32[i51 >> 2];
 d7 = +HEAPF32[i52 >> 2];
 d78 = +HEAPF32[i43 >> 2];
 d76 = +HEAPF32[i44 >> 2];
 HEAPF32[i51 >> 2] = d78 - d8;
 HEAPF32[i52 >> 2] = d76 - d7;
 d78 = d8 + d78;
 d76 = d7 + d76;
 d7 = +HEAPF32[i63 >> 2];
 d8 = +HEAPF32[i64 >> 2];
 d1 = +HEAPF32[i59 >> 2];
 d6 = +HEAPF32[i60 >> 2];
 HEAPF32[i63 >> 2] = d1 - d7;
 HEAPF32[i64 >> 2] = d6 - d8;
 d1 = d7 + d1;
 d6 = d8 + d6;
 d8 = +HEAPF32[i67 >> 2];
 d7 = +HEAPF32[i68 >> 2];
 HEAPF32[i71 >> 2] = d8 - d88;
 HEAPF32[i72 >> 2] = d7 - d87;
 d8 = d88 + d8;
 d7 = d87 + d7;
 HEAPF32[i45 >> 2] = d85 - d86;
 HEAPF32[i46 >> 2] = d83 - d84;
 HEAPF32[i31 >> 2] = d86 + d85;
 HEAPF32[i5 >> 2] = d84 + d83;
 HEAPF32[i69 >> 2] = d81 - d82;
 HEAPF32[i70 >> 2] = d79 - d80;
 HEAPF32[i61 >> 2] = d82 + d81;
 HEAPF32[i62 >> 2] = d80 + d79;
 HEAPF32[i43 >> 2] = d77 - d78;
 HEAPF32[i44 >> 2] = d2 - d76;
 HEAPF32[i29 >> 2] = d78 + d77;
 HEAPF32[i30 >> 2] = d76 + d2;
 HEAPF32[i67 >> 2] = d1 - d8;
 HEAPF32[i68 >> 2] = d6 - d7;
 HEAPF32[i59 >> 2] = d8 + d1;
 HEAPF32[i60 >> 2] = d7 + d6;
 d6 = +HEAPF32[i53 >> 2];
 d7 = +HEAPF32[i54 >> 2];
 d1 = d6 * 0.0;
 if (i32) {
  d2 = d7 - d1;
  d1 = d7 * -0.0 - d6;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i9, -d6, -d7, 0.0, 1.0);
   d2 = +HEAPF32[i9 >> 2];
   d1 = +HEAPF32[i9 + 4 >> 2];
   d4 = +HEAPF32[i73 >> 2];
   d3 = +HEAPF32[i74 >> 2];
  }
  d87 = +HEAPF32[i35 >> 2];
  d88 = +HEAPF32[i36 >> 2];
  HEAPF32[i53 >> 2] = d87 - d2;
  HEAPF32[i54 >> 2] = d88 - d1;
  HEAPF32[i35 >> 2] = d2 + d87;
  HEAPF32[i36 >> 2] = d1 + d88;
  d2 = d3 - d4 * 0.0;
  d1 = d3 * -0.0 - d4;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i11, -d4, -d3, 0.0, 1.0);
   d2 = +HEAPF32[i11 >> 2];
   d1 = +HEAPF32[i11 + 4 >> 2];
  }
  d4 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i73 >> 2] = d4 - d2;
  HEAPF32[i74 >> 2] = d3 - d1;
  HEAPF32[i65 >> 2] = d2 + d4;
  HEAPF32[i66 >> 2] = d1 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i13, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i13 >> 2];
   d1 = +HEAPF32[i13 + 4 >> 2];
  }
  d4 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i51 >> 2] = d4 - d2;
  HEAPF32[i52 >> 2] = d3 - d1;
  HEAPF32[i37 >> 2] = d2 + d4;
  HEAPF32[i38 >> 2] = d1 + d3;
  d2 = +HEAPF32[i71 >> 2];
  d3 = +HEAPF32[i72 >> 2];
  d4 = d3 - d2 * 0.0;
  d1 = d3 * -0.0 - d2;
  if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i15, -d2, -d3, 0.0, 1.0);
   d4 = +HEAPF32[i15 >> 2];
   d1 = +HEAPF32[i15 + 4 >> 2];
  }
  d88 = +HEAPF32[i63 >> 2];
  d3 = +HEAPF32[i64 >> 2];
  HEAPF32[i71 >> 2] = d88 - d4;
  HEAPF32[i72 >> 2] = d3 - d1;
  d3 = d1 + d3;
  d4 = d4 + d88;
 } else {
  d2 = d1 - d7;
  d1 = d6 + d7 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i10, d6, d7, 0.0, 1.0);
   d2 = +HEAPF32[i10 >> 2];
   d1 = +HEAPF32[i10 + 4 >> 2];
   d4 = +HEAPF32[i73 >> 2];
   d3 = +HEAPF32[i74 >> 2];
  }
  d87 = +HEAPF32[i35 >> 2];
  d88 = +HEAPF32[i36 >> 2];
  HEAPF32[i53 >> 2] = d87 - d2;
  HEAPF32[i54 >> 2] = d88 - d1;
  HEAPF32[i35 >> 2] = d2 + d87;
  HEAPF32[i36 >> 2] = d1 + d88;
  d2 = d4 * 0.0 - d3;
  d1 = d4 + d3 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i12, d4, d3, 0.0, 1.0);
   d2 = +HEAPF32[i12 >> 2];
   d1 = +HEAPF32[i12 + 4 >> 2];
  }
  d4 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i73 >> 2] = d4 - d2;
  HEAPF32[i74 >> 2] = d3 - d1;
  HEAPF32[i65 >> 2] = d2 + d4;
  HEAPF32[i66 >> 2] = d1 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i14, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i14 >> 2];
   d1 = +HEAPF32[i14 + 4 >> 2];
  }
  d4 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i51 >> 2] = d4 - d2;
  HEAPF32[i52 >> 2] = d3 - d1;
  HEAPF32[i37 >> 2] = d2 + d4;
  HEAPF32[i38 >> 2] = d1 + d3;
  d2 = +HEAPF32[i71 >> 2];
  d3 = +HEAPF32[i72 >> 2];
  d4 = d2 * 0.0 - d3;
  d1 = d2 + d3 * 0.0;
  if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i16, d2, d3, 0.0, 1.0);
   d4 = +HEAPF32[i16 >> 2];
   d1 = +HEAPF32[i16 + 4 >> 2];
  }
  d88 = +HEAPF32[i63 >> 2];
  d3 = +HEAPF32[i64 >> 2];
  HEAPF32[i71 >> 2] = d88 - d4;
  HEAPF32[i72 >> 2] = d3 - d1;
  d3 = d1 + d3;
  d4 = d4 + d88;
 }
 HEAPF32[i63 >> 2] = d4;
 HEAPF32[i64 >> 2] = d3;
 d7 = +HEAPF32[i61 >> 2];
 d8 = +HEAPF32[i62 >> 2];
 d1 = +HEAPF32[i31 >> 2];
 d6 = +HEAPF32[i5 >> 2];
 HEAPF32[i61 >> 2] = d1 - d7;
 HEAPF32[i62 >> 2] = d6 - d8;
 HEAPF32[i31 >> 2] = d7 + d1;
 HEAPF32[i5 >> 2] = d8 + d6;
 d6 = +HEAPF32[i59 >> 2];
 d8 = +HEAPF32[i60 >> 2];
 d1 = +HEAPF32[i29 >> 2];
 d7 = +HEAPF32[i30 >> 2];
 HEAPF32[i59 >> 2] = d1 - d6;
 HEAPF32[i60 >> 2] = d7 - d8;
 HEAPF32[i29 >> 2] = d6 + d1;
 HEAPF32[i30 >> 2] = d8 + d7;
 d7 = +HEAPF32[i65 >> 2];
 d8 = +HEAPF32[i66 >> 2];
 d1 = d7 * .70710677;
 d6 = d8 * .70710677;
 if (i32) {
  d2 = d1 + d6;
  d1 = d6 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i18, d7, d8, .70710677, -.70710677);
   d2 = +HEAPF64[i18 >> 3];
   d1 = +HEAPF64[i18 + 8 >> 3];
   d4 = +HEAPF32[i63 >> 2];
   d3 = +HEAPF32[i64 >> 2];
  }
  d87 = d2;
  d88 = d1;
  d2 = +HEAPF32[i35 >> 2];
  d1 = +HEAPF32[i36 >> 2];
  HEAPF32[i65 >> 2] = d2 - d87;
  HEAPF32[i66 >> 2] = d1 - d88;
  HEAPF32[i35 >> 2] = d87 + d2;
  HEAPF32[i36 >> 2] = d88 + d1;
  d1 = d4 * .70710677;
  d88 = d3 * .70710677;
  d2 = d1 + d88;
  d1 = d88 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i20, d4, d3, .70710677, -.70710677);
   d2 = +HEAPF64[i20 >> 3];
   d1 = +HEAPF64[i20 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i63 >> 2] = d2 - d88;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i37 >> 2] = d88 + d2;
  HEAPF32[i38 >> 2] = d4 + d3;
  d3 = +HEAPF32[i69 >> 2];
  d4 = +HEAPF32[i70 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i21, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i21 >> 2];
   d1 = +HEAPF32[i21 + 4 >> 2];
  }
  d4 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i69 >> 2] = d4 - d2;
  HEAPF32[i70 >> 2] = d3 - d1;
  HEAPF32[i45 >> 2] = d2 + d4;
  HEAPF32[i46 >> 2] = d1 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i23, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i23 >> 2];
   d1 = +HEAPF32[i23 + 4 >> 2];
  }
  d4 = +HEAPF32[i43 >> 2];
  d3 = +HEAPF32[i44 >> 2];
  HEAPF32[i67 >> 2] = d4 - d2;
  HEAPF32[i68 >> 2] = d3 - d1;
  HEAPF32[i43 >> 2] = d2 + d4;
  HEAPF32[i44 >> 2] = d1 + d3;
  d3 = +HEAPF32[i73 >> 2];
  d4 = +HEAPF32[i74 >> 2];
  d88 = d3 * -.70710677;
  d1 = d4 * -.70710677;
  d2 = d88 - d1;
  d1 = d88 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i25, d3, d4, -.70710677, -.70710677);
   d2 = +HEAPF64[i25 >> 3];
   d1 = +HEAPF64[i25 + 8 >> 3];
  }
  d4 = d1;
  d88 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i73 >> 2] = d88 - d2;
  HEAPF32[i74 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d2 + d88;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d88 = d3 * -.70710677;
  d1 = d4 * -.70710677;
  d2 = d88 - d1;
  d1 = d88 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i27, d3, d4, -.70710677, -.70710677);
   d2 = +HEAPF64[i27 >> 3];
   d1 = +HEAPF64[i27 + 8 >> 3];
  }
  d88 = d2;
  d87 = d1;
  d2 = +HEAPF32[i51 >> 2];
  d1 = +HEAPF32[i52 >> 2];
  HEAPF32[i71 >> 2] = d2 - d88;
  HEAPF32[i72 >> 2] = d1 - d87;
  d1 = d87 + d1;
  d2 = d88 + d2;
 } else {
  d2 = d1 - d6;
  d1 = d1 + d6;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i17, d7, d8, .70710677, .70710677);
   d2 = +HEAPF64[i17 >> 3];
   d1 = +HEAPF64[i17 + 8 >> 3];
   d4 = +HEAPF32[i63 >> 2];
   d3 = +HEAPF32[i64 >> 2];
  }
  d87 = d2;
  d2 = +HEAPF32[i35 >> 2];
  d88 = +HEAPF32[i36 >> 2];
  HEAPF32[i65 >> 2] = d2 - d87;
  HEAPF32[i66 >> 2] = d88 - d1;
  HEAPF32[i35 >> 2] = d87 + d2;
  HEAPF32[i36 >> 2] = d1 + d88;
  d88 = d4 * .70710677;
  d1 = d3 * .70710677;
  d2 = d88 - d1;
  d1 = d88 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i19, d4, d3, .70710677, .70710677);
   d2 = +HEAPF64[i19 >> 3];
   d1 = +HEAPF64[i19 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i63 >> 2] = d2 - d88;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i37 >> 2] = d88 + d2;
  HEAPF32[i38 >> 2] = d4 + d3;
  d3 = +HEAPF32[i69 >> 2];
  d4 = +HEAPF32[i70 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i22, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i22 >> 2];
   d1 = +HEAPF32[i22 + 4 >> 2];
  }
  d4 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i69 >> 2] = d4 - d2;
  HEAPF32[i70 >> 2] = d3 - d1;
  HEAPF32[i45 >> 2] = d2 + d4;
  HEAPF32[i46 >> 2] = d1 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i24, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i24 >> 2];
   d1 = +HEAPF32[i24 + 4 >> 2];
  }
  d4 = +HEAPF32[i43 >> 2];
  d3 = +HEAPF32[i44 >> 2];
  HEAPF32[i67 >> 2] = d4 - d2;
  HEAPF32[i68 >> 2] = d3 - d1;
  HEAPF32[i43 >> 2] = d2 + d4;
  HEAPF32[i44 >> 2] = d1 + d3;
  d3 = +HEAPF32[i73 >> 2];
  d4 = +HEAPF32[i74 >> 2];
  d1 = d4 * .70710677;
  d2 = d3 * -.70710677 - d1;
  d1 = d3 * .70710677 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i26, d3, d4, -.70710677, .70710677);
   d2 = +HEAPF64[i26 >> 3];
   d1 = +HEAPF64[i26 + 8 >> 3];
  }
  d4 = d1;
  d1 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i73 >> 2] = d1 - d2;
  HEAPF32[i74 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d2 + d1;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d1 = d4 * .70710677;
  d2 = d3 * -.70710677 - d1;
  d1 = d3 * .70710677 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i28, d3, d4, -.70710677, .70710677);
   d2 = +HEAPF64[i28 >> 3];
   d1 = +HEAPF64[i28 + 8 >> 3];
  }
  d88 = d2;
  d87 = d1;
  d2 = +HEAPF32[i51 >> 2];
  d1 = +HEAPF32[i52 >> 2];
  HEAPF32[i71 >> 2] = d2 - d88;
  HEAPF32[i72 >> 2] = d1 - d87;
  d1 = d87 + d1;
  d2 = d88 + d2;
 }
 HEAPF32[i51 >> 2] = d2;
 HEAPF32[i52 >> 2] = d1;
 d2 = +HEAPF32[i29 >> 2];
 d7 = +HEAPF32[i30 >> 2];
 d1 = +HEAPF32[i31 >> 2];
 d6 = +HEAPF32[i5 >> 2];
 HEAPF32[i29 >> 2] = d1 - d2;
 HEAPF32[i30 >> 2] = d6 - d7;
 HEAPF32[i31 >> 2] = d2 + d1;
 HEAPF32[i5 >> 2] = d7 + d6;
 d6 = +HEAPF32[i37 >> 2];
 d7 = +HEAPF32[i38 >> 2];
 d1 = d6 * .9238795;
 d2 = d7 * .38268346;
 d3 = d6 * .38268346;
 d4 = d7 * .9238795;
 if (i32) {
  d2 = d1 + d2;
  d1 = d4 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i33, d6, d7, .9238795, -.38268346);
   d2 = +HEAPF64[i33 >> 3];
   d1 = +HEAPF64[i33 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d1 = +HEAPF32[i35 >> 2];
  d3 = +HEAPF32[i36 >> 2];
  HEAPF32[i37 >> 2] = d1 - d88;
  HEAPF32[i38 >> 2] = d3 - d4;
  HEAPF32[i35 >> 2] = d88 + d1;
  HEAPF32[i36 >> 2] = d4 + d3;
  d3 = +HEAPF32[i43 >> 2];
  d4 = +HEAPF32[i44 >> 2];
  d1 = d3 * .70710677;
  d88 = d4 * .70710677;
  d2 = d1 + d88;
  d1 = d88 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i39, d3, d4, .70710677, -.70710677);
   d2 = +HEAPF64[i39 >> 3];
   d1 = +HEAPF64[i39 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i43 >> 2] = d2 - d88;
  HEAPF32[i44 >> 2] = d3 - d4;
  HEAPF32[i45 >> 2] = d88 + d2;
  HEAPF32[i46 >> 2] = d4 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d3 * .38268343 + d4 * .9238795;
  d1 = d4 * .38268343 - d3 * .9238795;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i41, d3, d4, .38268343, -.9238795);
   d2 = +HEAPF64[i41 >> 3];
   d1 = +HEAPF64[i41 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i51 >> 2] = d2 - d88;
  HEAPF32[i52 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d88 + d2;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i59 >> 2];
  d4 = +HEAPF32[i60 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i47, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i47 >> 2];
   d1 = +HEAPF32[i47 + 4 >> 2];
  }
  d4 = +HEAPF32[i61 >> 2];
  d3 = +HEAPF32[i62 >> 2];
  HEAPF32[i59 >> 2] = d4 - d2;
  HEAPF32[i60 >> 2] = d3 - d1;
  HEAPF32[i61 >> 2] = d2 + d4;
  HEAPF32[i62 >> 2] = d1 + d3;
  d3 = +HEAPF32[i63 >> 2];
  d4 = +HEAPF32[i64 >> 2];
  d2 = d4 * .92387956 - d3 * .3826834;
  d1 = d4 * -.3826834 - d3 * .92387956;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i49, d3, d4, -.3826834, -.92387956);
   d2 = +HEAPF64[i49 >> 3];
   d1 = +HEAPF64[i49 + 8 >> 3];
  }
  d4 = d1;
  d88 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i63 >> 2] = d88 - d2;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i65 >> 2] = d2 + d88;
  HEAPF32[i66 >> 2] = d4 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d88 = d3 * -.70710677;
  d1 = d4 * -.70710677;
  d2 = d88 - d1;
  d1 = d88 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i55, d3, d4, -.70710677, -.70710677);
   d2 = +HEAPF64[i55 >> 3];
   d1 = +HEAPF64[i55 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i69 >> 2];
  d3 = +HEAPF32[i70 >> 2];
  HEAPF32[i67 >> 2] = d2 - d88;
  HEAPF32[i68 >> 2] = d3 - d4;
  HEAPF32[i69 >> 2] = d88 + d2;
  HEAPF32[i70 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d2 = d4 * .38268349 - d3 * .9238795;
  d1 = d4 * -.9238795 - d3 * .38268349;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i57, d3, d4, -.9238795, -.38268349);
   d2 = +HEAPF64[i57 >> 3];
   d1 = +HEAPF64[i57 + 8 >> 3];
  }
  d86 = d2;
  d85 = d1;
  d87 = +HEAPF32[i73 >> 2];
  d88 = +HEAPF32[i74 >> 2];
  HEAPF32[i71 >> 2] = d87 - d86;
  HEAPF32[i72 >> 2] = d88 - d85;
  d88 = d85 + d88;
  d87 = d86 + d87;
  HEAPF32[i73 >> 2] = d87;
  HEAPF32[i74 >> 2] = d88;
  STACKTOP = i75;
  return;
 } else {
  d2 = d1 - d2;
  d1 = d3 + d4;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i34, d6, d7, .9238795, .38268346);
   d2 = +HEAPF64[i34 >> 3];
   d1 = +HEAPF64[i34 + 8 >> 3];
  }
  d4 = d1;
  d88 = +HEAPF32[i35 >> 2];
  d3 = +HEAPF32[i36 >> 2];
  HEAPF32[i37 >> 2] = d88 - d2;
  HEAPF32[i38 >> 2] = d3 - d4;
  HEAPF32[i35 >> 2] = d2 + d88;
  HEAPF32[i36 >> 2] = d4 + d3;
  d3 = +HEAPF32[i43 >> 2];
  d4 = +HEAPF32[i44 >> 2];
  d88 = d3 * .70710677;
  d1 = d4 * .70710677;
  d2 = d88 - d1;
  d1 = d88 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i40, d3, d4, .70710677, .70710677);
   d2 = +HEAPF64[i40 >> 3];
   d1 = +HEAPF64[i40 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i43 >> 2] = d2 - d88;
  HEAPF32[i44 >> 2] = d3 - d4;
  HEAPF32[i45 >> 2] = d88 + d2;
  HEAPF32[i46 >> 2] = d4 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d3 * .38268343 - d4 * .9238795;
  d1 = d3 * .9238795 + d4 * .38268343;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i42, d3, d4, .38268343, .9238795);
   d2 = +HEAPF64[i42 >> 3];
   d1 = +HEAPF64[i42 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i51 >> 2] = d2 - d88;
  HEAPF32[i52 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d88 + d2;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i59 >> 2];
  d4 = +HEAPF32[i60 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i48, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i48 >> 2];
   d1 = +HEAPF32[i48 + 4 >> 2];
  }
  d4 = +HEAPF32[i61 >> 2];
  d3 = +HEAPF32[i62 >> 2];
  HEAPF32[i59 >> 2] = d4 - d2;
  HEAPF32[i60 >> 2] = d3 - d1;
  HEAPF32[i61 >> 2] = d2 + d4;
  HEAPF32[i62 >> 2] = d1 + d3;
  d3 = +HEAPF32[i63 >> 2];
  d4 = +HEAPF32[i64 >> 2];
  d2 = d3 * -.3826834 - d4 * .92387956;
  d1 = d3 * .92387956 - d4 * .3826834;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i50, d3, d4, -.3826834, .92387956);
   d2 = +HEAPF64[i50 >> 3];
   d1 = +HEAPF64[i50 + 8 >> 3];
  }
  d4 = d1;
  d1 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i63 >> 2] = d1 - d2;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i65 >> 2] = d2 + d1;
  HEAPF32[i66 >> 2] = d4 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d1 = d4 * .70710677;
  d2 = d3 * -.70710677 - d1;
  d1 = d3 * .70710677 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i56, d3, d4, -.70710677, .70710677);
   d2 = +HEAPF64[i56 >> 3];
   d1 = +HEAPF64[i56 + 8 >> 3];
  }
  d88 = d2;
  d4 = d1;
  d2 = +HEAPF32[i69 >> 2];
  d3 = +HEAPF32[i70 >> 2];
  HEAPF32[i67 >> 2] = d2 - d88;
  HEAPF32[i68 >> 2] = d3 - d4;
  HEAPF32[i69 >> 2] = d88 + d2;
  HEAPF32[i70 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d2 = d3 * -.9238795 - d4 * .38268349;
  d1 = d3 * .38268349 - d4 * .9238795;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i58, d3, d4, -.9238795, .38268349);
   d2 = +HEAPF64[i58 >> 3];
   d1 = +HEAPF64[i58 + 8 >> 3];
  }
  d86 = d2;
  d85 = d1;
  d87 = +HEAPF32[i73 >> 2];
  d88 = +HEAPF32[i74 >> 2];
  HEAPF32[i71 >> 2] = d87 - d86;
  HEAPF32[i72 >> 2] = d88 - d85;
  d88 = d85 + d88;
  d87 = d86 + d87;
  HEAPF32[i73 >> 2] = d87;
  HEAPF32[i74 >> 2] = d88;
  STACKTOP = i75;
  return;
 }
}

function _hashlittle(i4, i5, i2) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i9 = i16 + 44 | 0;
 i1 = i16 + 40 | 0;
 i10 = i16 + 36 | 0;
 i17 = i16 + 32 | 0;
 i11 = i16 + 28 | 0;
 i12 = i16 + 24 | 0;
 i13 = i16 + 20 | 0;
 i7 = i16 + 16 | 0;
 i3 = i16 + 12 | 0;
 i14 = i16 + 8 | 0;
 i15 = i16 + 4 | 0;
 i6 = i16;
 HEAP32[i1 >> 2] = i4;
 HEAP32[i10 >> 2] = i5;
 HEAP32[i17 >> 2] = i2;
 i5 = (HEAP32[i10 >> 2] | 0) + -559038737 + (HEAP32[i17 >> 2] | 0) | 0;
 HEAP32[i13 >> 2] = i5;
 HEAP32[i12 >> 2] = i5;
 HEAP32[i11 >> 2] = i5;
 HEAP32[i7 >> 2] = HEAP32[i1 >> 2];
 L1 : do if (HEAP32[i7 >> 2] & 3) {
  i1 = HEAP32[i1 >> 2] | 0;
  if (!(HEAP32[i7 >> 2] & 1)) {
   HEAP32[i14 >> 2] = i1;
   while (1) {
    i1 = HEAP32[i14 >> 2] | 0;
    if ((HEAP32[i10 >> 2] | 0) >>> 0 <= 12) break;
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU16[i1 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 2 >> 1] | 0) << 16));
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 4 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 6 >> 1] | 0) << 16));
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 8 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 10 >> 1] | 0) << 16));
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] | 0);
    HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ (HEAP32[i13 >> 2] << 4 | (HEAP32[i13 >> 2] | 0) >>> 28);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[i12 >> 2] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] | 0);
    HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ (HEAP32[i11 >> 2] << 6 | (HEAP32[i11 >> 2] | 0) >>> 26);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] | 0);
    HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ (HEAP32[i12 >> 2] << 8 | (HEAP32[i12 >> 2] | 0) >>> 24);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] | 0);
    HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ (HEAP32[i13 >> 2] << 16 | (HEAP32[i13 >> 2] | 0) >>> 16);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[i12 >> 2] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] | 0);
    HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ (HEAP32[i11 >> 2] << 19 | (HEAP32[i11 >> 2] | 0) >>> 13);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] | 0);
    HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ (HEAP32[i12 >> 2] << 4 | (HEAP32[i12 >> 2] | 0) >>> 28);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0);
    HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) - 12;
    HEAP32[i14 >> 2] = (HEAP32[i14 >> 2] | 0) + 12;
   }
   HEAP32[i15 >> 2] = i1;
   switch (HEAP32[i10 >> 2] | 0) {
   case 12:
    {
     HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 8 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 10 >> 1] | 0) << 16));
     HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 4 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 6 >> 1] | 0) << 16));
     HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU16[HEAP32[i14 >> 2] >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 2 >> 1] | 0) << 16));
     break L1;
    }
   case 11:
    {
     HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i15 >> 2] | 0) + 10 >> 0] | 0) << 16);
     i8 = 26;
     break;
    }
   case 10:
    {
     i8 = 26;
     break;
    }
   case 9:
    {
     HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAPU8[(HEAP32[i15 >> 2] | 0) + 8 >> 0] | 0);
     i8 = 28;
     break;
    }
   case 8:
    {
     i8 = 28;
     break;
    }
   case 7:
    {
     HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i15 >> 2] | 0) + 6 >> 0] | 0) << 16);
     i8 = 30;
     break;
    }
   case 6:
    {
     i8 = 30;
     break;
    }
   case 5:
    {
     HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAPU8[(HEAP32[i15 >> 2] | 0) + 4 >> 0] | 0);
     i8 = 32;
     break;
    }
   case 4:
    {
     i8 = 32;
     break;
    }
   case 3:
    {
     HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i15 >> 2] | 0) + 2 >> 0] | 0) << 16);
     i8 = 34;
     break;
    }
   case 2:
    {
     i8 = 34;
     break;
    }
   case 1:
    {
     HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAPU8[HEAP32[i15 >> 2] >> 0] | 0);
     break L1;
    }
   case 0:
    {
     HEAP32[i9 >> 2] = HEAP32[i13 >> 2];
     i17 = HEAP32[i9 >> 2] | 0;
     STACKTOP = i16;
     return i17 | 0;
    }
   default:
    break L1;
   }
   if ((i8 | 0) == 26) {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAPU16[(HEAP32[i14 >> 2] | 0) + 8 >> 1] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 4 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 6 >> 1] | 0) << 16));
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU16[HEAP32[i14 >> 2] >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 2 >> 1] | 0) << 16));
    break;
   } else if ((i8 | 0) == 28) {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 4 >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 6 >> 1] | 0) << 16));
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU16[HEAP32[i14 >> 2] >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 2 >> 1] | 0) << 16));
    break;
   } else if ((i8 | 0) == 30) {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAPU16[(HEAP32[i14 >> 2] | 0) + 4 >> 1] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU16[HEAP32[i14 >> 2] >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 2 >> 1] | 0) << 16));
    break;
   } else if ((i8 | 0) == 32) {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU16[HEAP32[i14 >> 2] >> 1] | 0) + ((HEAPU16[(HEAP32[i14 >> 2] | 0) + 2 >> 1] | 0) << 16));
    break;
   } else if ((i8 | 0) == 34) {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAPU16[HEAP32[i14 >> 2] >> 1] | 0);
    break;
   }
  } else {
   HEAP32[i6 >> 2] = i1;
   while (1) {
    if ((HEAP32[i10 >> 2] | 0) >>> 0 <= 12) break;
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAPU8[HEAP32[i6 >> 2] >> 0] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 1 >> 0] | 0) << 8);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 2 >> 0] | 0) << 16);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 3 >> 0] | 0) << 24);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAPU8[(HEAP32[i6 >> 2] | 0) + 4 >> 0] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 5 >> 0] | 0) << 8);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 6 >> 0] | 0) << 16);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 7 >> 0] | 0) << 24);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAPU8[(HEAP32[i6 >> 2] | 0) + 8 >> 0] | 0);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 9 >> 0] | 0) << 8);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 10 >> 0] | 0) << 16);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 11 >> 0] | 0) << 24);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] | 0);
    HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ (HEAP32[i13 >> 2] << 4 | (HEAP32[i13 >> 2] | 0) >>> 28);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[i12 >> 2] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] | 0);
    HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ (HEAP32[i11 >> 2] << 6 | (HEAP32[i11 >> 2] | 0) >>> 26);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] | 0);
    HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ (HEAP32[i12 >> 2] << 8 | (HEAP32[i12 >> 2] | 0) >>> 24);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] | 0);
    HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ (HEAP32[i13 >> 2] << 16 | (HEAP32[i13 >> 2] | 0) >>> 16);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[i12 >> 2] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] | 0);
    HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ (HEAP32[i11 >> 2] << 19 | (HEAP32[i11 >> 2] | 0) >>> 13);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] | 0);
    HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ (HEAP32[i12 >> 2] << 4 | (HEAP32[i12 >> 2] | 0) >>> 28);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0);
    HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) - 12;
    HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + 12;
   }
   switch (HEAP32[i10 >> 2] | 0) {
   case 12:
    {
     HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 11 >> 0] | 0) << 24);
     i8 = 42;
     break;
    }
   case 11:
    {
     i8 = 42;
     break;
    }
   case 10:
    {
     i8 = 43;
     break;
    }
   case 9:
    {
     i8 = 44;
     break;
    }
   case 8:
    {
     i8 = 45;
     break;
    }
   case 7:
    {
     i8 = 46;
     break;
    }
   case 6:
    {
     i8 = 47;
     break;
    }
   case 5:
    {
     i8 = 48;
     break;
    }
   case 4:
    {
     i8 = 49;
     break;
    }
   case 3:
    {
     i8 = 50;
     break;
    }
   case 2:
    {
     i8 = 51;
     break;
    }
   case 1:
    break;
   case 0:
    {
     HEAP32[i9 >> 2] = HEAP32[i13 >> 2];
     i17 = HEAP32[i9 >> 2] | 0;
     STACKTOP = i16;
     return i17 | 0;
    }
   default:
    break L1;
   }
   if ((i8 | 0) == 42) {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 10 >> 0] | 0) << 16);
    i8 = 43;
   }
   if ((i8 | 0) == 43) {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 9 >> 0] | 0) << 8);
    i8 = 44;
   }
   if ((i8 | 0) == 44) {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAPU8[(HEAP32[i6 >> 2] | 0) + 8 >> 0] | 0);
    i8 = 45;
   }
   if ((i8 | 0) == 45) {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 7 >> 0] | 0) << 24);
    i8 = 46;
   }
   if ((i8 | 0) == 46) {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 6 >> 0] | 0) << 16);
    i8 = 47;
   }
   if ((i8 | 0) == 47) {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 5 >> 0] | 0) << 8);
    i8 = 48;
   }
   if ((i8 | 0) == 48) {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAPU8[(HEAP32[i6 >> 2] | 0) + 4 >> 0] | 0);
    i8 = 49;
   }
   if ((i8 | 0) == 49) {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 3 >> 0] | 0) << 24);
    i8 = 50;
   }
   if ((i8 | 0) == 50) {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 2 >> 0] | 0) << 16);
    i8 = 51;
   }
   if ((i8 | 0) == 51) HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + ((HEAPU8[(HEAP32[i6 >> 2] | 0) + 1 >> 0] | 0) << 8);
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAPU8[HEAP32[i6 >> 2] >> 0] | 0);
   break;
  }
 } else {
  HEAP32[i3 >> 2] = HEAP32[i1 >> 2];
  while (1) {
   if ((HEAP32[i10 >> 2] | 0) >>> 0 <= 12) break;
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
   HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] | 0);
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] | 0);
   HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ (HEAP32[i13 >> 2] << 4 | (HEAP32[i13 >> 2] | 0) >>> 28);
   HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[i12 >> 2] | 0);
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] | 0);
   HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ (HEAP32[i11 >> 2] << 6 | (HEAP32[i11 >> 2] | 0) >>> 26);
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
   HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] | 0);
   HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ (HEAP32[i12 >> 2] << 8 | (HEAP32[i12 >> 2] | 0) >>> 24);
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0);
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] | 0);
   HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ (HEAP32[i13 >> 2] << 16 | (HEAP32[i13 >> 2] | 0) >>> 16);
   HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[i12 >> 2] | 0);
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] | 0);
   HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ (HEAP32[i11 >> 2] << 19 | (HEAP32[i11 >> 2] | 0) >>> 13);
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
   HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] | 0);
   HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ (HEAP32[i12 >> 2] << 4 | (HEAP32[i12 >> 2] | 0) >>> 28);
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0);
   HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) - 12;
   HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + 12;
  }
  do switch (HEAP32[i10 >> 2] | 0) {
  case 12:
   {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] | 0);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 11:
   {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] & 16777215);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 10:
   {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] & 65535);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 9:
   {
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] & 255);
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 8:
   {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 7:
   {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] & 16777215);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 6:
   {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] & 65535);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 5:
   {
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] & 255);
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 4:
   {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] | 0);
    break L1;
   }
  case 3:
   {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] & 16777215);
    break L1;
   }
  case 2:
   {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] & 65535);
    break L1;
   }
  case 1:
   {
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[HEAP32[i3 >> 2] >> 2] & 255);
    break L1;
   }
  case 0:
   {
    HEAP32[i9 >> 2] = HEAP32[i13 >> 2];
    i17 = HEAP32[i9 >> 2] | 0;
    STACKTOP = i16;
    return i17 | 0;
   }
  default:
   break L1;
  } while (0);
 } while (0);
 HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ HEAP32[i12 >> 2];
 HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] << 14 | (HEAP32[i12 >> 2] | 0) >>> 18);
 HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ HEAP32[i13 >> 2];
 HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] << 11 | (HEAP32[i13 >> 2] | 0) >>> 21);
 HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ HEAP32[i11 >> 2];
 HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] << 25 | (HEAP32[i11 >> 2] | 0) >>> 7);
 HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ HEAP32[i12 >> 2];
 HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] << 16 | (HEAP32[i12 >> 2] | 0) >>> 16);
 HEAP32[i11 >> 2] = HEAP32[i11 >> 2] ^ HEAP32[i13 >> 2];
 HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[i13 >> 2] << 4 | (HEAP32[i13 >> 2] | 0) >>> 28);
 HEAP32[i12 >> 2] = HEAP32[i12 >> 2] ^ HEAP32[i11 >> 2];
 HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - (HEAP32[i11 >> 2] << 14 | (HEAP32[i11 >> 2] | 0) >>> 18);
 HEAP32[i13 >> 2] = HEAP32[i13 >> 2] ^ HEAP32[i12 >> 2];
 HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAP32[i12 >> 2] << 24 | (HEAP32[i12 >> 2] | 0) >>> 8);
 HEAP32[i9 >> 2] = HEAP32[i13 >> 2];
 i17 = HEAP32[i9 >> 2] | 0;
 STACKTOP = i16;
 return i17 | 0;
}

function _fft_execute_dft_7(i20) {
 i20 = i20 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, d29 = 0.0, d30 = 0.0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, d59 = 0.0, d60 = 0.0, i61 = 0, i62 = 0, i63 = 0, d64 = 0.0, i65 = 0, d66 = 0.0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, d71 = 0.0, i72 = 0, d73 = 0.0, i74 = 0, i75 = 0, i76 = 0, d77 = 0.0, d78 = 0.0, i79 = 0, i80 = 0, i81 = 0, d82 = 0.0, d83 = 0.0, i84 = 0, i85 = 0, i86 = 0, i87 = 0, d88 = 0.0, d89 = 0.0, i90 = 0, i91 = 0, i92 = 0, i93 = 0, i94 = 0;
 i94 = STACKTOP;
 STACKTOP = STACKTOP + 400 | 0;
 i26 = i94 + 384 | 0;
 i15 = i94 + 376 | 0;
 i16 = i94 + 368 | 0;
 i17 = i94 + 360 | 0;
 i18 = i94 + 352 | 0;
 i21 = i94 + 344 | 0;
 i19 = i94 + 336 | 0;
 i23 = i94 + 328 | 0;
 i22 = i94 + 320 | 0;
 i25 = i94 + 312 | 0;
 i24 = i94 + 304 | 0;
 i28 = i94 + 296 | 0;
 i27 = i94 + 288 | 0;
 i31 = i94 + 280 | 0;
 i32 = i94 + 272 | 0;
 i33 = i94 + 264 | 0;
 i34 = i94 + 256 | 0;
 i35 = i94 + 248 | 0;
 i36 = i94 + 240 | 0;
 i37 = i94 + 232 | 0;
 i38 = i94 + 224 | 0;
 i39 = i94 + 216 | 0;
 i40 = i94 + 208 | 0;
 i41 = i94 + 200 | 0;
 i42 = i94 + 192 | 0;
 i43 = i94 + 184 | 0;
 i44 = i94 + 176 | 0;
 i45 = i94 + 168 | 0;
 i46 = i94 + 160 | 0;
 i47 = i94 + 152 | 0;
 i48 = i94 + 144 | 0;
 i49 = i94 + 136 | 0;
 i50 = i94 + 128 | 0;
 i51 = i94 + 120 | 0;
 i52 = i94 + 112 | 0;
 i53 = i94 + 104 | 0;
 i54 = i94 + 96 | 0;
 i55 = i94 + 88 | 0;
 i56 = i94 + 80 | 0;
 i57 = i94 + 72 | 0;
 i58 = i94 + 64 | 0;
 i61 = i94 + 56 | 0;
 i62 = i94 + 48 | 0;
 i69 = i94 + 40 | 0;
 i74 = i94 + 32 | 0;
 i79 = i94 + 24 | 0;
 i84 = i94 + 16 | 0;
 i87 = i94 + 8 | 0;
 i92 = i94;
 i63 = HEAP32[i20 + 4 >> 2] | 0;
 i93 = HEAP32[i20 + 8 >> 2] | 0;
 i65 = i63 + 4 | 0;
 i67 = i63 + 8 | 0;
 i68 = i63 + 12 | 0;
 i70 = i63 + 16 | 0;
 i72 = i63 + 20 | 0;
 i75 = i63 + 24 | 0;
 i76 = i63 + 28 | 0;
 i80 = i63 + 32 | 0;
 i81 = i63 + 36 | 0;
 i85 = i63 + 40 | 0;
 i86 = i63 + 44 | 0;
 i90 = i63 + 48 | 0;
 i91 = i63 + 52 | 0;
 d89 = +HEAPF32[i65 >> 2] + +HEAPF32[i68 >> 2] + +HEAPF32[i72 >> 2] + +HEAPF32[i76 >> 2] + +HEAPF32[i81 >> 2] + +HEAPF32[i86 >> 2] + +HEAPF32[i91 >> 2];
 HEAPF32[i93 >> 2] = +HEAPF32[i63 >> 2] + +HEAPF32[i67 >> 2] + +HEAPF32[i70 >> 2] + +HEAPF32[i75 >> 2] + +HEAPF32[i80 >> 2] + +HEAPF32[i85 >> 2] + +HEAPF32[i90 >> 2];
 HEAPF32[i93 + 4 >> 2] = d89;
 if ((HEAP32[i20 + 12 >> 2] | 0) == 1) {
  d88 = .6234897971153259;
  d89 = -.7818315029144287;
  d82 = -.22252093255519867;
  d83 = -.9749279022216797;
  d78 = -.9009688496589661;
  d77 = -.4338837265968323;
 } else {
  HEAPF32[i16 >> 2] = .6234897971153259;
  HEAPF32[i16 + 4 >> 2] = -.7818315029144287;
  HEAP32[i26 >> 2] = HEAP32[i16 >> 2];
  HEAP32[i26 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
  _conjf(i15, i26);
  d88 = +HEAPF32[i15 >> 2];
  d89 = +HEAPF32[i15 + 4 >> 2];
  HEAPF32[i18 >> 2] = -.22252093255519867;
  HEAPF32[i18 + 4 >> 2] = -.9749279022216797;
  HEAP32[i26 >> 2] = HEAP32[i18 >> 2];
  HEAP32[i26 + 4 >> 2] = HEAP32[i18 + 4 >> 2];
  _conjf(i17, i26);
  d82 = +HEAPF32[i17 >> 2];
  d83 = +HEAPF32[i17 + 4 >> 2];
  HEAPF32[i19 >> 2] = -.9009688496589661;
  HEAPF32[i19 + 4 >> 2] = -.4338837265968323;
  HEAP32[i26 >> 2] = HEAP32[i19 >> 2];
  HEAP32[i26 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
  _conjf(i21, i26);
  d78 = +HEAPF32[i21 >> 2];
  d77 = +HEAPF32[i21 + 4 >> 2];
 }
 HEAPF32[i22 >> 2] = d78;
 HEAPF32[i22 + 4 >> 2] = d77;
 HEAP32[i26 >> 2] = HEAP32[i22 >> 2];
 HEAP32[i26 + 4 >> 2] = HEAP32[i22 + 4 >> 2];
 _conjf(i23, i26);
 d73 = +HEAPF32[i23 >> 2];
 d71 = +HEAPF32[i23 + 4 >> 2];
 HEAPF32[i24 >> 2] = d82;
 HEAPF32[i24 + 4 >> 2] = d83;
 HEAP32[i26 >> 2] = HEAP32[i24 >> 2];
 HEAP32[i26 + 4 >> 2] = HEAP32[i24 + 4 >> 2];
 _conjf(i25, i26);
 d66 = +HEAPF32[i25 >> 2];
 d64 = +HEAPF32[i25 + 4 >> 2];
 HEAPF32[i27 >> 2] = d88;
 HEAPF32[i27 + 4 >> 2] = d89;
 HEAP32[i26 >> 2] = HEAP32[i27 >> 2];
 HEAP32[i26 + 4 >> 2] = HEAP32[i27 + 4 >> 2];
 _conjf(i28, i26);
 d60 = +HEAPF32[i28 >> 2];
 d59 = +HEAPF32[i28 + 4 >> 2];
 d29 = +HEAPF32[i63 >> 2];
 d30 = +HEAPF32[i65 >> 2];
 d1 = +HEAPF32[i67 >> 2];
 d2 = +HEAPF32[i68 >> 2];
 d3 = d88 * d1 - d89 * d2;
 d4 = d89 * d1 + d88 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i31, d1, d2, d88, d89);
  d3 = +HEAPF32[i31 >> 2];
  d4 = +HEAPF32[i31 + 4 >> 2];
 }
 d1 = +HEAPF32[i70 >> 2];
 d2 = +HEAPF32[i72 >> 2];
 d5 = d82 * d1 - d83 * d2;
 d6 = d83 * d1 + d82 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i32, d1, d2, d82, d83);
  d5 = +HEAPF32[i32 >> 2];
  d6 = +HEAPF32[i32 + 4 >> 2];
 }
 d1 = +HEAPF32[i75 >> 2];
 d2 = +HEAPF32[i76 >> 2];
 d7 = d78 * d1 - d77 * d2;
 d8 = d77 * d1 + d78 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i33, d1, d2, d78, d77);
  d7 = +HEAPF32[i33 >> 2];
  d8 = +HEAPF32[i33 + 4 >> 2];
 }
 d1 = +HEAPF32[i80 >> 2];
 d2 = +HEAPF32[i81 >> 2];
 d9 = d73 * d1 - d71 * d2;
 d10 = d71 * d1 + d73 * d2;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i34, d1, d2, d73, d71);
  d9 = +HEAPF32[i34 >> 2];
  d10 = +HEAPF32[i34 + 4 >> 2];
 }
 d1 = +HEAPF32[i85 >> 2];
 d2 = +HEAPF32[i86 >> 2];
 d11 = d66 * d1 - d64 * d2;
 d12 = d64 * d1 + d66 * d2;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i35, d1, d2, d66, d64);
  d11 = +HEAPF32[i35 >> 2];
  d12 = +HEAPF32[i35 + 4 >> 2];
 }
 d13 = +HEAPF32[i90 >> 2];
 d14 = +HEAPF32[i91 >> 2];
 d2 = d60 * d13 - d59 * d14;
 d1 = d59 * d13 + d60 * d14;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i36, d13, d14, d60, d59);
  d2 = +HEAPF32[i36 >> 2];
  d1 = +HEAPF32[i36 + 4 >> 2];
 }
 HEAPF32[i93 + 8 >> 2] = d29 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i93 + 12 >> 2] = d30 + d4 + d6 + d8 + d10 + d12 + d1;
 d29 = +HEAPF32[i63 >> 2];
 d30 = +HEAPF32[i65 >> 2];
 d1 = +HEAPF32[i67 >> 2];
 d2 = +HEAPF32[i68 >> 2];
 d3 = d82 * d1 - d83 * d2;
 d4 = d83 * d1 + d82 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i37, d1, d2, d82, d83);
  d3 = +HEAPF32[i37 >> 2];
  d4 = +HEAPF32[i37 + 4 >> 2];
 }
 d1 = +HEAPF32[i70 >> 2];
 d2 = +HEAPF32[i72 >> 2];
 d5 = d73 * d1 - d71 * d2;
 d6 = d71 * d1 + d73 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i38, d1, d2, d73, d71);
  d5 = +HEAPF32[i38 >> 2];
  d6 = +HEAPF32[i38 + 4 >> 2];
 }
 d1 = +HEAPF32[i75 >> 2];
 d2 = +HEAPF32[i76 >> 2];
 d7 = d60 * d1 - d59 * d2;
 d8 = d59 * d1 + d60 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i39, d1, d2, d60, d59);
  d7 = +HEAPF32[i39 >> 2];
  d8 = +HEAPF32[i39 + 4 >> 2];
 }
 d1 = +HEAPF32[i80 >> 2];
 d2 = +HEAPF32[i81 >> 2];
 d9 = d88 * d1 - d89 * d2;
 d10 = d89 * d1 + d88 * d2;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i40, d1, d2, d88, d89);
  d9 = +HEAPF32[i40 >> 2];
  d10 = +HEAPF32[i40 + 4 >> 2];
 }
 d1 = +HEAPF32[i85 >> 2];
 d2 = +HEAPF32[i86 >> 2];
 d11 = d78 * d1 - d77 * d2;
 d12 = d77 * d1 + d78 * d2;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i41, d1, d2, d78, d77);
  d11 = +HEAPF32[i41 >> 2];
  d12 = +HEAPF32[i41 + 4 >> 2];
 }
 d13 = +HEAPF32[i90 >> 2];
 d14 = +HEAPF32[i91 >> 2];
 d2 = d66 * d13 - d64 * d14;
 d1 = d64 * d13 + d66 * d14;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i42, d13, d14, d66, d64);
  d2 = +HEAPF32[i42 >> 2];
  d1 = +HEAPF32[i42 + 4 >> 2];
 }
 HEAPF32[i93 + 16 >> 2] = d29 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i93 + 20 >> 2] = d30 + d4 + d6 + d8 + d10 + d12 + d1;
 d29 = +HEAPF32[i63 >> 2];
 d30 = +HEAPF32[i65 >> 2];
 d1 = +HEAPF32[i67 >> 2];
 d2 = +HEAPF32[i68 >> 2];
 d3 = d78 * d1 - d77 * d2;
 d4 = d77 * d1 + d78 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i43, d1, d2, d78, d77);
  d3 = +HEAPF32[i43 >> 2];
  d4 = +HEAPF32[i43 + 4 >> 2];
 }
 d1 = +HEAPF32[i70 >> 2];
 d2 = +HEAPF32[i72 >> 2];
 d5 = d60 * d1 - d59 * d2;
 d6 = d59 * d1 + d60 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i44, d1, d2, d60, d59);
  d5 = +HEAPF32[i44 >> 2];
  d6 = +HEAPF32[i44 + 4 >> 2];
 }
 d1 = +HEAPF32[i75 >> 2];
 d2 = +HEAPF32[i76 >> 2];
 d7 = d82 * d1 - d83 * d2;
 d8 = d83 * d1 + d82 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i45, d1, d2, d82, d83);
  d7 = +HEAPF32[i45 >> 2];
  d8 = +HEAPF32[i45 + 4 >> 2];
 }
 d1 = +HEAPF32[i80 >> 2];
 d2 = +HEAPF32[i81 >> 2];
 d9 = d66 * d1 - d64 * d2;
 d10 = d64 * d1 + d66 * d2;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i46, d1, d2, d66, d64);
  d9 = +HEAPF32[i46 >> 2];
  d10 = +HEAPF32[i46 + 4 >> 2];
 }
 d1 = +HEAPF32[i85 >> 2];
 d2 = +HEAPF32[i86 >> 2];
 d11 = d88 * d1 - d89 * d2;
 d12 = d89 * d1 + d88 * d2;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i47, d1, d2, d88, d89);
  d11 = +HEAPF32[i47 >> 2];
  d12 = +HEAPF32[i47 + 4 >> 2];
 }
 d13 = +HEAPF32[i90 >> 2];
 d14 = +HEAPF32[i91 >> 2];
 d2 = d73 * d13 - d71 * d14;
 d1 = d71 * d13 + d73 * d14;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i48, d13, d14, d73, d71);
  d2 = +HEAPF32[i48 >> 2];
  d1 = +HEAPF32[i48 + 4 >> 2];
 }
 HEAPF32[i93 + 24 >> 2] = d29 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i93 + 28 >> 2] = d30 + d4 + d6 + d8 + d10 + d12 + d1;
 d29 = +HEAPF32[i63 >> 2];
 d30 = +HEAPF32[i65 >> 2];
 d1 = +HEAPF32[i67 >> 2];
 d2 = +HEAPF32[i68 >> 2];
 d3 = d73 * d1 - d71 * d2;
 d4 = d71 * d1 + d73 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i49, d1, d2, d73, d71);
  d3 = +HEAPF32[i49 >> 2];
  d4 = +HEAPF32[i49 + 4 >> 2];
 }
 d1 = +HEAPF32[i70 >> 2];
 d2 = +HEAPF32[i72 >> 2];
 d5 = d88 * d1 - d89 * d2;
 d6 = d89 * d1 + d88 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i50, d1, d2, d88, d89);
  d5 = +HEAPF32[i50 >> 2];
  d6 = +HEAPF32[i50 + 4 >> 2];
 }
 d1 = +HEAPF32[i75 >> 2];
 d2 = +HEAPF32[i76 >> 2];
 d7 = d66 * d1 - d64 * d2;
 d8 = d64 * d1 + d66 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i51, d1, d2, d66, d64);
  d7 = +HEAPF32[i51 >> 2];
  d8 = +HEAPF32[i51 + 4 >> 2];
 }
 d1 = +HEAPF32[i80 >> 2];
 d2 = +HEAPF32[i81 >> 2];
 d9 = d82 * d1 - d83 * d2;
 d10 = d83 * d1 + d82 * d2;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i52, d1, d2, d82, d83);
  d9 = +HEAPF32[i52 >> 2];
  d10 = +HEAPF32[i52 + 4 >> 2];
 }
 d1 = +HEAPF32[i85 >> 2];
 d2 = +HEAPF32[i86 >> 2];
 d11 = d60 * d1 - d59 * d2;
 d12 = d59 * d1 + d60 * d2;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i53, d1, d2, d60, d59);
  d11 = +HEAPF32[i53 >> 2];
  d12 = +HEAPF32[i53 + 4 >> 2];
 }
 d13 = +HEAPF32[i90 >> 2];
 d14 = +HEAPF32[i91 >> 2];
 d2 = d78 * d13 - d77 * d14;
 d1 = d77 * d13 + d78 * d14;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i54, d13, d14, d78, d77);
  d2 = +HEAPF32[i54 >> 2];
  d1 = +HEAPF32[i54 + 4 >> 2];
 }
 HEAPF32[i93 + 32 >> 2] = d29 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i93 + 36 >> 2] = d30 + d4 + d6 + d8 + d10 + d12 + d1;
 d29 = +HEAPF32[i63 >> 2];
 d30 = +HEAPF32[i65 >> 2];
 d1 = +HEAPF32[i67 >> 2];
 d2 = +HEAPF32[i68 >> 2];
 d3 = d66 * d1 - d64 * d2;
 d4 = d64 * d1 + d66 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i55, d1, d2, d66, d64);
  d3 = +HEAPF32[i55 >> 2];
  d4 = +HEAPF32[i55 + 4 >> 2];
 }
 d1 = +HEAPF32[i70 >> 2];
 d2 = +HEAPF32[i72 >> 2];
 d5 = d78 * d1 - d77 * d2;
 d6 = d77 * d1 + d78 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i56, d1, d2, d78, d77);
  d5 = +HEAPF32[i56 >> 2];
  d6 = +HEAPF32[i56 + 4 >> 2];
 }
 d1 = +HEAPF32[i75 >> 2];
 d2 = +HEAPF32[i76 >> 2];
 d7 = d88 * d1 - d89 * d2;
 d8 = d89 * d1 + d88 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i57, d1, d2, d88, d89);
  d7 = +HEAPF32[i57 >> 2];
  d8 = +HEAPF32[i57 + 4 >> 2];
 }
 d1 = +HEAPF32[i80 >> 2];
 d2 = +HEAPF32[i81 >> 2];
 d9 = d60 * d1 - d59 * d2;
 d10 = d59 * d1 + d60 * d2;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i58, d1, d2, d60, d59);
  d9 = +HEAPF32[i58 >> 2];
  d10 = +HEAPF32[i58 + 4 >> 2];
 }
 d1 = +HEAPF32[i85 >> 2];
 d2 = +HEAPF32[i86 >> 2];
 d11 = d73 * d1 - d71 * d2;
 d12 = d71 * d1 + d73 * d2;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i61, d1, d2, d73, d71);
  d11 = +HEAPF32[i61 >> 2];
  d12 = +HEAPF32[i61 + 4 >> 2];
 }
 d13 = +HEAPF32[i90 >> 2];
 d14 = +HEAPF32[i91 >> 2];
 d2 = d82 * d13 - d83 * d14;
 d1 = d83 * d13 + d82 * d14;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i62, d13, d14, d82, d83);
  d2 = +HEAPF32[i62 >> 2];
  d1 = +HEAPF32[i62 + 4 >> 2];
 }
 HEAPF32[i93 + 40 >> 2] = d29 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i93 + 44 >> 2] = d30 + d4 + d6 + d8 + d10 + d12 + d1;
 d13 = +HEAPF32[i63 >> 2];
 d14 = +HEAPF32[i65 >> 2];
 d3 = +HEAPF32[i67 >> 2];
 d1 = +HEAPF32[i68 >> 2];
 d2 = d60 * d3 - d59 * d1;
 d4 = d59 * d3 + d60 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i69, d3, d1, d60, d59);
  d12 = +HEAPF32[i69 >> 2];
  d11 = +HEAPF32[i69 + 4 >> 2];
 } else {
  d12 = d2;
  d11 = d4;
 }
 d3 = +HEAPF32[i70 >> 2];
 d1 = +HEAPF32[i72 >> 2];
 d2 = d66 * d3 - d64 * d1;
 d4 = d64 * d3 + d66 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i74, d3, d1, d66, d64);
  d10 = +HEAPF32[i74 >> 2];
  d9 = +HEAPF32[i74 + 4 >> 2];
 } else {
  d10 = d2;
  d9 = d4;
 }
 d3 = +HEAPF32[i75 >> 2];
 d1 = +HEAPF32[i76 >> 2];
 d2 = d73 * d3 - d71 * d1;
 d4 = d71 * d3 + d73 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i79, d3, d1, d73, d71);
  d8 = +HEAPF32[i79 >> 2];
  d7 = +HEAPF32[i79 + 4 >> 2];
 } else {
  d8 = d2;
  d7 = d4;
 }
 d3 = +HEAPF32[i80 >> 2];
 d1 = +HEAPF32[i81 >> 2];
 d2 = d78 * d3 - d77 * d1;
 d4 = d77 * d3 + d78 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i84, d3, d1, d78, d77);
  d6 = +HEAPF32[i84 >> 2];
  d5 = +HEAPF32[i84 + 4 >> 2];
 } else {
  d6 = d2;
  d5 = d4;
 }
 d4 = +HEAPF32[i85 >> 2];
 d3 = +HEAPF32[i86 >> 2];
 d2 = d82 * d4 - d83 * d3;
 d1 = d83 * d4 + d82 * d3;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i87, d4, d3, d82, d83);
  d2 = +HEAPF32[i87 >> 2];
  d1 = +HEAPF32[i87 + 4 >> 2];
 }
 d6 = d13 + d12 + d10 + d8 + d6 + d2;
 d5 = d14 + d11 + d9 + d7 + d5 + d1;
 d4 = +HEAPF32[i90 >> 2];
 d1 = +HEAPF32[i91 >> 2];
 d2 = d88 * d4 - d89 * d1;
 d3 = d89 * d4 + d88 * d1;
 if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
  d88 = d2;
  d89 = d3;
  d88 = d6 + d88;
  d89 = d5 + d89;
  i92 = i93 + 48 | 0;
  i93 = i93 + 52 | 0;
  HEAPF32[i92 >> 2] = d88;
  HEAPF32[i93 >> 2] = d89;
  STACKTOP = i94;
  return;
 }
 ___mulsc3(i92, d4, d1, d88, d89);
 d88 = +HEAPF32[i92 >> 2];
 d89 = +HEAPF32[i92 + 4 >> 2];
 d88 = d6 + d88;
 d89 = d5 + d89;
 i92 = i93 + 48 | 0;
 i93 = i93 + 52 | 0;
 HEAPF32[i92 >> 2] = d88;
 HEAPF32[i93 >> 2] = d89;
 STACKTOP = i94;
 return;
}

function _ofdmframesync_debug_print(i28, i32) {
 i28 = i28 | 0;
 i32 = i32 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i29 = 0, i30 = 0, i31 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, d37 = 0.0, d38 = 0.0;
 i36 = STACKTOP;
 STACKTOP = STACKTOP + 464 | 0;
 i34 = i36 + 456 | 0;
 i33 = i36 + 432 | 0;
 i29 = i36 + 416 | 0;
 i27 = i36 + 400 | 0;
 i23 = i36 + 392 | 0;
 i26 = i36 + 384 | 0;
 i25 = i36 + 368 | 0;
 i24 = i36 + 352 | 0;
 i22 = i36 + 328 | 0;
 i21 = i36 + 304 | 0;
 i20 = i36 + 280 | 0;
 i19 = i36 + 256 | 0;
 i17 = i36 + 232 | 0;
 i16 = i36 + 208 | 0;
 i15 = i36 + 192 | 0;
 i14 = i36 + 184 | 0;
 i13 = i36 + 160 | 0;
 i12 = i36 + 136 | 0;
 i11 = i36 + 112 | 0;
 i10 = i36 + 88 | 0;
 i9 = i36 + 80 | 0;
 i8 = i36 + 72 | 0;
 i7 = i36 + 64 | 0;
 i6 = i36 + 56 | 0;
 i35 = i36 + 48 | 0;
 i30 = i36 + 40 | 0;
 i3 = i36 + 32 | 0;
 i5 = i36 + 24 | 0;
 i4 = i36 + 16 | 0;
 i2 = i36 + 8 | 0;
 i1 = i36;
 if (!(HEAP32[i28 + 172 >> 2] | 0)) {
  _fwrite(gb + 36039 | 0, 86, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  STACKTOP = i36;
  return;
 }
 i31 = _fopen(i32, gb + 36126 | 0) | 0;
 if (!i31) {
  i35 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = i32;
  _fprintf(i35, gb + 36128 | 0, i1) | 0;
  STACKTOP = i36;
  return;
 }
 HEAP32[i2 >> 2] = gb + 36222;
 _fprintf(i31, gb + 36193 | 0, i2) | 0;
 _fwrite(gb + 36253 | 0, 11, 1, i31) | 0;
 _fwrite(gb + 36265 | 0, 11, 1, i31) | 0;
 HEAP32[i4 >> 2] = 2048;
 _fprintf(i31, gb + 36277 | 0, i4) | 0;
 HEAP32[i5 >> 2] = HEAP32[i28 >> 2];
 _fprintf(i31, gb + 36286 | 0, i5) | 0;
 HEAP32[i3 >> 2] = HEAP32[i28 + 16 >> 2];
 _fprintf(i31, gb + 36295 | 0, i3) | 0;
 i18 = i28 + 20 | 0;
 HEAP32[i30 >> 2] = HEAP32[i18 >> 2];
 _fprintf(i31, gb + 36310 | 0, i30) | 0;
 HEAP32[i35 >> 2] = HEAP32[i28 + 24 >> 2];
 _fprintf(i31, gb + 36325 | 0, i35) | 0;
 _fwrite(gb + 36340 | 0, 16, 1, i31) | 0;
 if (HEAP32[i28 >> 2] | 0) {
  i1 = i28 + 12 | 0;
  i2 = 0;
  do {
   i5 = HEAPU8[(HEAP32[i1 >> 2] | 0) + i2 >> 0] | 0;
   i2 = i2 + 1 | 0;
   HEAP32[i6 >> 2] = i2;
   HEAP32[i6 + 4 >> 2] = i5;
   _fprintf(i31, gb + 36357 | 0, i6) | 0;
  } while (i2 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
 }
 HEAP32[i7 >> 2] = 0;
 _fprintf(i31, gb + 36371 | 0, i7) | 0;
 HEAP32[i8 >> 2] = 1;
 _fprintf(i31, gb + 36395 | 0, i8) | 0;
 HEAP32[i9 >> 2] = 2;
 _fprintf(i31, gb + 36419 | 0, i9) | 0;
 if (HEAP32[i28 >> 2] | 0) {
  i1 = i28 + 64 | 0;
  i2 = i28 + 72 | 0;
  i3 = 0;
  do {
   i9 = i3;
   i3 = i3 + 1 | 0;
   i8 = HEAP32[i1 >> 2] | 0;
   d37 = +HEAPF32[i8 + (i9 << 3) >> 2];
   d38 = +HEAPF32[i8 + (i9 << 3) + 4 >> 2];
   HEAP32[i10 >> 2] = i3;
   HEAPF64[i10 + 8 >> 3] = d37;
   HEAPF64[i10 + 16 >> 3] = d38;
   _fprintf(i31, gb + 36443 | 0, i10) | 0;
   i8 = HEAP32[i2 >> 2] | 0;
   d38 = +HEAPF32[i8 + (i9 << 3) >> 2];
   d37 = +HEAPF32[i8 + (i9 << 3) + 4 >> 2];
   HEAP32[i11 >> 2] = i3;
   HEAPF64[i11 + 8 >> 3] = d38;
   HEAPF64[i11 + 16 >> 3] = d37;
   _fprintf(i31, gb + 36473 | 0, i11) | 0;
  } while (i3 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
 }
 _fwrite(gb + 36503 | 0, 16, 1, i31) | 0;
 _windowcf_read(HEAP32[i28 + 176 >> 2] | 0, i35);
 i1 = 0;
 do {
  i11 = HEAP32[i35 >> 2] | 0;
  d37 = +HEAPF32[i11 + (i1 << 3) >> 2];
  d38 = +HEAPF32[i11 + (i1 << 3) + 4 >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i12 >> 2] = i1;
  HEAPF64[i12 + 8 >> 3] = d37;
  HEAPF64[i12 + 16 >> 3] = d38;
  _fprintf(i31, gb + 36520 | 0, i12) | 0;
 } while ((i1 | 0) != 2048);
 _fwrite(gb + 36549 | 0, 8, 1, i31) | 0;
 _fwrite(gb + 36558 | 0, 39, 1, i31) | 0;
 _fwrite(gb + 36598 | 0, 24, 1, i31) | 0;
 _fwrite(gb + 36623 | 0, 30, 1, i31) | 0;
 _fwrite(gb + 36654 | 0, 9, 1, i31) | 0;
 if (HEAP32[i28 >> 2] | 0) {
  i1 = i28 + 76 | 0;
  i2 = 0;
  do {
   i12 = HEAP32[i1 >> 2] | 0;
   d37 = +HEAPF32[i12 + (i2 << 3) >> 2];
   d38 = +HEAPF32[i12 + (i2 << 3) + 4 >> 2];
   i2 = i2 + 1 | 0;
   HEAP32[i13 >> 2] = i2;
   HEAPF64[i13 + 8 >> 3] = d37;
   HEAPF64[i13 + 16 >> 3] = d38;
   _fprintf(i31, gb + 36664 | 0, i13) | 0;
  } while (i2 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
 }
 _fwrite(gb + 36694 | 0, 2, 1, i31) | 0;
 HEAP32[i14 >> 2] = 2048;
 _fprintf(i31, gb + 36697 | 0, i14) | 0;
 _windowf_read(HEAP32[i28 + 180 >> 2] | 0, i30);
 i1 = 0;
 do {
  d38 = +HEAPF32[(HEAP32[i30 >> 2] | 0) + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i15 >> 2] = i1;
  HEAPF64[i15 + 8 >> 3] = d38;
  _fprintf(i31, gb + 36722 | 0, i15) | 0;
 } while ((i1 | 0) != 2048);
 _fwrite(gb + 36747 | 0, 91, 1, i31) | 0;
 _fwrite(gb + 36839 | 0, 33, 1, i31) | 0;
 _fwrite(gb + 36549 | 0, 8, 1, i31) | 0;
 _fwrite(gb + 36873 | 0, 15, 1, i31) | 0;
 _fwrite(gb + 36889 | 0, 21, 1, i31) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i31) | 0;
 _fwrite(gb + 36911 | 0, 17, 1, i31) | 0;
 _fwrite(gb + 36929 | 0, 17, 1, i31) | 0;
 if (HEAP32[i28 >> 2] | 0) {
  i1 = i28 + 64 | 0;
  i2 = i28 + 72 | 0;
  i3 = 0;
  do {
   i15 = i3;
   i3 = i3 + 1 | 0;
   i14 = HEAP32[i1 >> 2] | 0;
   d38 = +HEAPF32[i14 + (i15 << 3) >> 2];
   d37 = +HEAPF32[i14 + (i15 << 3) + 4 >> 2];
   HEAP32[i16 >> 2] = i3;
   HEAPF64[i16 + 8 >> 3] = d38;
   HEAPF64[i16 + 16 >> 3] = d37;
   _fprintf(i31, gb + 36947 | 0, i16) | 0;
   i14 = HEAP32[i2 >> 2] | 0;
   d37 = +HEAPF32[i14 + (i15 << 3) >> 2];
   d38 = +HEAPF32[i14 + (i15 << 3) + 4 >> 2];
   HEAP32[i17 >> 2] = i3;
   HEAPF64[i17 + 8 >> 3] = d37;
   HEAPF64[i17 + 16 >> 3] = d38;
   _fprintf(i31, gb + 36977 | 0, i17) | 0;
  } while (i3 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
 }
 _fwrite(gb + 36694 | 0, 2, 1, i31) | 0;
 _fwrite(gb + 37007 | 0, 21, 1, i31) | 0;
 _fwrite(gb + 37029 | 0, 21, 1, i31) | 0;
 _fwrite(gb + 37051 | 0, 21, 1, i31) | 0;
 _fwrite(gb + 37073 | 0, 21, 1, i31) | 0;
 if (HEAP32[i28 >> 2] | 0) {
  i3 = i28 + 84 | 0;
  i4 = i28 + 88 | 0;
  i1 = i28 + 188 | 0;
  i2 = i28 + 92 | 0;
  i5 = 0;
  do {
   i17 = i5;
   i5 = i5 + 1 | 0;
   i16 = HEAP32[i3 >> 2] | 0;
   d38 = +HEAPF32[i16 + (i17 << 3) >> 2];
   d37 = +HEAPF32[i16 + (i17 << 3) + 4 >> 2];
   HEAP32[i19 >> 2] = i5;
   HEAPF64[i19 + 8 >> 3] = d38;
   HEAPF64[i19 + 16 >> 3] = d37;
   _fprintf(i31, gb + 37095 | 0, i19) | 0;
   i16 = HEAP32[i4 >> 2] | 0;
   d37 = +HEAPF32[i16 + (i17 << 3) >> 2];
   d38 = +HEAPF32[i16 + (i17 << 3) + 4 >> 2];
   HEAP32[i20 >> 2] = i5;
   HEAPF64[i20 + 8 >> 3] = d37;
   HEAPF64[i20 + 16 >> 3] = d38;
   _fprintf(i31, gb + 37128 | 0, i20) | 0;
   i16 = HEAP32[i1 >> 2] | 0;
   d38 = +HEAPF32[i16 + (i17 << 3) >> 2];
   d37 = +HEAPF32[i16 + (i17 << 3) + 4 >> 2];
   HEAP32[i21 >> 2] = i5;
   HEAPF64[i21 + 8 >> 3] = d38;
   HEAPF64[i21 + 16 >> 3] = d37;
   _fprintf(i31, gb + 37161 | 0, i21) | 0;
   i16 = HEAP32[i2 >> 2] | 0;
   d37 = +HEAPF32[i16 + (i17 << 3) >> 2];
   d38 = +HEAPF32[i16 + (i17 << 3) + 4 >> 2];
   HEAP32[i22 >> 2] = i5;
   HEAPF64[i22 + 8 >> 3] = d37;
   HEAPF64[i22 + 16 >> 3] = d38;
   _fprintf(i31, gb + 37194 | 0, i22) | 0;
  } while (i5 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
 }
 _fwrite(gb + 37227 | 0, 15, 1, i31) | 0;
 _fwrite(gb + 36549 | 0, 8, 1, i31) | 0;
 _fwrite(gb + 37243 | 0, 16, 1, i31) | 0;
 _fwrite(gb + 37260 | 0, 40, 1, i31) | 0;
 _fwrite(gb + 37301 | 0, 48, 1, i31) | 0;
 _fwrite(gb + 37350 | 0, 11, 1, i31) | 0;
 _fwrite(gb + 37362 | 0, 30, 1, i31) | 0;
 _fwrite(gb + 37393 | 0, 33, 1, i31) | 0;
 _fwrite(gb + 37427 | 0, 16, 1, i31) | 0;
 _fwrite(gb + 37444 | 0, 58, 1, i31) | 0;
 _fwrite(gb + 37503 | 0, 48, 1, i31) | 0;
 _fwrite(gb + 37350 | 0, 11, 1, i31) | 0;
 _fwrite(gb + 37362 | 0, 30, 1, i31) | 0;
 _fwrite(gb + 37552 | 0, 35, 1, i31) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i31) | 0;
 _fwrite(gb + 37588 | 0, 23, 1, i31) | 0;
 _fwrite(gb + 37612 | 0, 23, 1, i31) | 0;
 if (HEAP32[i18 >> 2] | 0) {
  i1 = i28 + 192 | 0;
  i2 = i28 + 196 | 0;
  i3 = 0;
  do {
   i22 = i3;
   i3 = i3 + 1 | 0;
   d38 = +HEAPF32[(HEAP32[i1 >> 2] | 0) + (i22 << 2) >> 2];
   HEAP32[i24 >> 2] = i3;
   HEAPF64[i24 + 8 >> 3] = d38;
   _fprintf(i31, gb + 37636 | 0, i24) | 0;
   d38 = +HEAPF32[(HEAP32[i2 >> 2] | 0) + (i22 << 2) >> 2];
   HEAP32[i25 >> 2] = i3;
   HEAPF64[i25 + 8 >> 3] = d38;
   _fprintf(i31, gb + 37655 | 0, i25) | 0;
  } while (i3 >>> 0 < (HEAP32[i18 >> 2] | 0) >>> 0);
 }
 HEAPF64[i26 >> 3] = +HEAPF32[i28 + 200 >> 2];
 _fprintf(i31, gb + 37674 | 0, i26) | 0;
 HEAPF64[i23 >> 3] = +HEAPF32[i28 + 204 >> 2];
 _fprintf(i31, gb + 37696 | 0, i23) | 0;
 _fwrite(gb + 37718 | 0, 17, 1, i31) | 0;
 _windowf_read(HEAP32[i28 + 208 >> 2] | 0, i30);
 i1 = 0;
 do {
  d38 = +HEAPF32[(HEAP32[i30 >> 2] | 0) + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i27 >> 2] = i1;
  HEAPF64[i27 + 8 >> 3] = d38;
  _fprintf(i31, gb + 37736 | 0, i27) | 0;
 } while ((i1 | 0) != 2048);
 _fwrite(gb + 37755 | 0, 17, 1, i31) | 0;
 _windowf_read(HEAP32[i28 + 212 >> 2] | 0, i30);
 i1 = 0;
 do {
  d38 = +HEAPF32[(HEAP32[i30 >> 2] | 0) + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i29 >> 2] = i1;
  HEAPF64[i29 + 8 >> 3] = d38;
  _fprintf(i31, gb + 37773 | 0, i29) | 0;
 } while ((i1 | 0) != 2048);
 _fwrite(gb + 36549 | 0, 8, 1, i31) | 0;
 _fwrite(gb + 37792 | 0, 19, 1, i31) | 0;
 _fwrite(gb + 37812 | 0, 16, 1, i31) | 0;
 _fwrite(gb + 37829 | 0, 24, 1, i31) | 0;
 _fwrite(gb + 37854 | 0, 40, 1, i31) | 0;
 _fwrite(gb + 37350 | 0, 11, 1, i31) | 0;
 _fwrite(gb + 37895 | 0, 32, 1, i31) | 0;
 _fwrite(gb + 37928 | 0, 24, 1, i31) | 0;
 _fwrite(gb + 37953 | 0, 19, 1, i31) | 0;
 _fwrite(gb + 37973 | 0, 16, 1, i31) | 0;
 _fwrite(gb + 37990 | 0, 26, 1, i31) | 0;
 _fwrite(gb + 37350 | 0, 11, 1, i31) | 0;
 _fwrite(gb + 38017 | 0, 31, 1, i31) | 0;
 _fwrite(gb + 38049 | 0, 16, 1, i31) | 0;
 _fwrite(gb + 38066 | 0, 26, 1, i31) | 0;
 _fwrite(gb + 37350 | 0, 11, 1, i31) | 0;
 _fwrite(gb + 38093 | 0, 30, 1, i31) | 0;
 _fwrite(gb + 38124 | 0, 24, 1, i31) | 0;
 _windowcf_read(HEAP32[i28 + 184 >> 2] | 0, i35);
 i1 = 0;
 do {
  i30 = HEAP32[i35 >> 2] | 0;
  d37 = +HEAPF32[i30 + (i1 << 3) >> 2];
  d38 = +HEAPF32[i30 + (i1 << 3) + 4 >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i33 >> 2] = i1;
  HEAPF64[i33 + 8 >> 3] = d37;
  HEAPF64[i33 + 16 >> 3] = d38;
  _fprintf(i31, gb + 38149 | 0, i33) | 0;
 } while ((i1 | 0) != 2048);
 _fwrite(gb + 36549 | 0, 8, 1, i31) | 0;
 _fwrite(gb + 38186 | 0, 45, 1, i31) | 0;
 _fwrite(gb + 38232 | 0, 13, 1, i31) | 0;
 _fwrite(gb + 38246 | 0, 13, 1, i31) | 0;
 _fwrite(gb + 38260 | 0, 23, 1, i31) | 0;
 _fwrite(gb + 38284 | 0, 13, 1, i31) | 0;
 _fwrite(gb + 38298 | 0, 9, 1, i31) | 0;
 _fclose(i31) | 0;
 HEAP32[i34 >> 2] = i32;
 _printf(gb + 38308 | 0, i34) | 0;
 STACKTOP = i36;
 return;
}

function _free(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 if (!i1) return;
 i3 = i1 + -8 | 0;
 i7 = HEAP32[gb + 44352 + 16 >> 2] | 0;
 if (i3 >>> 0 < i7 >>> 0) _abort();
 i1 = HEAP32[i1 + -4 >> 2] | 0;
 i2 = i1 & 3;
 if ((i2 | 0) == 1) _abort();
 i4 = i1 & -8;
 i12 = i3 + i4 | 0;
 do if (!(i1 & 1)) {
  i1 = HEAP32[i3 >> 2] | 0;
  if (!i2) return;
  i10 = i3 + (0 - i1) | 0;
  i9 = i1 + i4 | 0;
  if (i10 >>> 0 < i7 >>> 0) _abort();
  if ((i10 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
   i1 = i12 + 4 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if ((i2 & 3 | 0) != 3) {
    i16 = i10;
    i6 = i9;
    break;
   }
   HEAP32[gb + 44352 + 8 >> 2] = i9;
   HEAP32[i1 >> 2] = i2 & -2;
   HEAP32[i10 + 4 >> 2] = i9 | 1;
   HEAP32[i10 + i9 >> 2] = i9;
   return;
  }
  i4 = i1 >>> 3;
  if (i1 >>> 0 < 256) {
   i2 = HEAP32[i10 + 8 >> 2] | 0;
   i3 = HEAP32[i10 + 12 >> 2] | 0;
   i1 = gb + 44352 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < i7 >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i10 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 44352 >> 2] = HEAP32[gb + 44352 >> 2] & ~(1 << i4);
    i16 = i10;
    i6 = i9;
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < i7 >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i10 | 0)) i5 = i1; else _abort();
   } else i5 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i5 >> 2] = i2;
   i16 = i10;
   i6 = i9;
   break;
  }
  i5 = HEAP32[i10 + 24 >> 2] | 0;
  i3 = HEAP32[i10 + 12 >> 2] | 0;
  do if ((i3 | 0) == (i10 | 0)) {
   i2 = i10 + 16 | 0;
   i3 = i2 + 4 | 0;
   i1 = HEAP32[i3 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i2 >> 2] | 0;
    if (!i1) {
     i8 = 0;
     break;
    }
   } else i2 = i3;
   while (1) {
    i3 = i1 + 20 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i2 = i3;
     continue;
    }
    i3 = i1 + 16 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (!i4) break; else {
     i1 = i4;
     i2 = i3;
    }
   }
   if (i2 >>> 0 < i7 >>> 0) _abort(); else {
    HEAP32[i2 >> 2] = 0;
    i8 = i1;
    break;
   }
  } else {
   i4 = HEAP32[i10 + 8 >> 2] | 0;
   if (i4 >>> 0 < i7 >>> 0) _abort();
   i1 = i4 + 12 | 0;
   if ((HEAP32[i1 >> 2] | 0) != (i10 | 0)) _abort();
   i2 = i3 + 8 | 0;
   if ((HEAP32[i2 >> 2] | 0) == (i10 | 0)) {
    HEAP32[i1 >> 2] = i3;
    HEAP32[i2 >> 2] = i4;
    i8 = i3;
    break;
   } else _abort();
  } while (0);
  if (i5) {
   i1 = HEAP32[i10 + 28 >> 2] | 0;
   i2 = gb + 44352 + 304 + (i1 << 2) | 0;
   if ((i10 | 0) == (HEAP32[i2 >> 2] | 0)) {
    HEAP32[i2 >> 2] = i8;
    if (!i8) {
     HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
     i16 = i10;
     i6 = i9;
     break;
    }
   } else {
    if (i5 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i5 + 16 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i10 | 0)) HEAP32[i1 >> 2] = i8; else HEAP32[i5 + 20 >> 2] = i8;
    if (!i8) {
     i16 = i10;
     i6 = i9;
     break;
    }
   }
   i3 = HEAP32[gb + 44352 + 16 >> 2] | 0;
   if (i8 >>> 0 < i3 >>> 0) _abort();
   HEAP32[i8 + 24 >> 2] = i5;
   i1 = i10 + 16 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
    HEAP32[i8 + 16 >> 2] = i2;
    HEAP32[i2 + 24 >> 2] = i8;
    break;
   } while (0);
   i1 = HEAP32[i1 + 4 >> 2] | 0;
   if (i1) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
    HEAP32[i8 + 20 >> 2] = i1;
    HEAP32[i1 + 24 >> 2] = i8;
    i16 = i10;
    i6 = i9;
    break;
   } else {
    i16 = i10;
    i6 = i9;
   }
  } else {
   i16 = i10;
   i6 = i9;
  }
 } else {
  i16 = i3;
  i6 = i4;
 } while (0);
 if (i16 >>> 0 >= i12 >>> 0) _abort();
 i1 = i12 + 4 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (!(i2 & 1)) _abort();
 if (!(i2 & 2)) {
  if ((i12 | 0) == (HEAP32[gb + 44352 + 24 >> 2] | 0)) {
   i15 = (HEAP32[gb + 44352 + 12 >> 2] | 0) + i6 | 0;
   HEAP32[gb + 44352 + 12 >> 2] = i15;
   HEAP32[gb + 44352 + 24 >> 2] = i16;
   HEAP32[i16 + 4 >> 2] = i15 | 1;
   if ((i16 | 0) != (HEAP32[gb + 44352 + 20 >> 2] | 0)) return;
   HEAP32[gb + 44352 + 20 >> 2] = 0;
   HEAP32[gb + 44352 + 8 >> 2] = 0;
   return;
  }
  if ((i12 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
   i15 = (HEAP32[gb + 44352 + 8 >> 2] | 0) + i6 | 0;
   HEAP32[gb + 44352 + 8 >> 2] = i15;
   HEAP32[gb + 44352 + 20 >> 2] = i16;
   HEAP32[i16 + 4 >> 2] = i15 | 1;
   HEAP32[i16 + i15 >> 2] = i15;
   return;
  }
  i6 = (i2 & -8) + i6 | 0;
  i4 = i2 >>> 3;
  do if (i2 >>> 0 >= 256) {
   i5 = HEAP32[i12 + 24 >> 2] | 0;
   i1 = HEAP32[i12 + 12 >> 2] | 0;
   do if ((i1 | 0) == (i12 | 0)) {
    i2 = i12 + 16 | 0;
    i3 = i2 + 4 | 0;
    i1 = HEAP32[i3 >> 2] | 0;
    if (!i1) {
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i13 = 0;
      break;
     }
    } else i2 = i3;
    while (1) {
     i3 = i1 + 20 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (i4 | 0) {
      i1 = i4;
      i2 = i3;
      continue;
     }
     i3 = i1 + 16 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (!i4) break; else {
      i1 = i4;
      i2 = i3;
     }
    }
    if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i2 >> 2] = 0;
     i13 = i1;
     break;
    }
   } else {
    i2 = HEAP32[i12 + 8 >> 2] | 0;
    if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    i3 = i2 + 12 | 0;
    if ((HEAP32[i3 >> 2] | 0) != (i12 | 0)) _abort();
    i4 = i1 + 8 | 0;
    if ((HEAP32[i4 >> 2] | 0) == (i12 | 0)) {
     HEAP32[i3 >> 2] = i1;
     HEAP32[i4 >> 2] = i2;
     i13 = i1;
     break;
    } else _abort();
   } while (0);
   if (i5 | 0) {
    i1 = HEAP32[i12 + 28 >> 2] | 0;
    i2 = gb + 44352 + 304 + (i1 << 2) | 0;
    if ((i12 | 0) == (HEAP32[i2 >> 2] | 0)) {
     HEAP32[i2 >> 2] = i13;
     if (!i13) {
      HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
      break;
     }
    } else {
     if (i5 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
     i1 = i5 + 16 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i12 | 0)) HEAP32[i1 >> 2] = i13; else HEAP32[i5 + 20 >> 2] = i13;
     if (!i13) break;
    }
    i3 = HEAP32[gb + 44352 + 16 >> 2] | 0;
    if (i13 >>> 0 < i3 >>> 0) _abort();
    HEAP32[i13 + 24 >> 2] = i5;
    i1 = i12 + 16 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
     HEAP32[i13 + 16 >> 2] = i2;
     HEAP32[i2 + 24 >> 2] = i13;
     break;
    } while (0);
    i1 = HEAP32[i1 + 4 >> 2] | 0;
    if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i13 + 20 >> 2] = i1;
     HEAP32[i1 + 24 >> 2] = i13;
     break;
    }
   }
  } else {
   i2 = HEAP32[i12 + 8 >> 2] | 0;
   i3 = HEAP32[i12 + 12 >> 2] | 0;
   i1 = gb + 44352 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i12 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 44352 >> 2] = HEAP32[gb + 44352 >> 2] & ~(1 << i4);
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i12 | 0)) i11 = i1; else _abort();
   } else i11 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i11 >> 2] = i2;
  } while (0);
  HEAP32[i16 + 4 >> 2] = i6 | 1;
  HEAP32[i16 + i6 >> 2] = i6;
  if ((i16 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
   HEAP32[gb + 44352 + 8 >> 2] = i6;
   return;
  }
 } else {
  HEAP32[i1 >> 2] = i2 & -2;
  HEAP32[i16 + 4 >> 2] = i6 | 1;
  HEAP32[i16 + i6 >> 2] = i6;
 }
 i1 = i6 >>> 3;
 if (i6 >>> 0 < 256) {
  i3 = gb + 44352 + 40 + (i1 << 1 << 2) | 0;
  i2 = HEAP32[gb + 44352 >> 2] | 0;
  i1 = 1 << i1;
  if (i2 & i1) {
   i1 = i3 + 8 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
    i14 = i1;
    i15 = i2;
   }
  } else {
   HEAP32[gb + 44352 >> 2] = i2 | i1;
   i14 = i3 + 8 | 0;
   i15 = i3;
  }
  HEAP32[i14 >> 2] = i16;
  HEAP32[i15 + 12 >> 2] = i16;
  HEAP32[i16 + 8 >> 2] = i15;
  HEAP32[i16 + 12 >> 2] = i3;
  return;
 }
 i1 = i6 >>> 8;
 if (i1) if (i6 >>> 0 > 16777215) i3 = 31; else {
  i14 = (i1 + 1048320 | 0) >>> 16 & 8;
  i15 = i1 << i14;
  i13 = (i15 + 520192 | 0) >>> 16 & 4;
  i15 = i15 << i13;
  i3 = (i15 + 245760 | 0) >>> 16 & 2;
  i3 = 14 - (i13 | i14 | i3) + (i15 << i3 >>> 15) | 0;
  i3 = i6 >>> (i3 + 7 | 0) & 1 | i3 << 1;
 } else i3 = 0;
 i4 = gb + 44352 + 304 + (i3 << 2) | 0;
 HEAP32[i16 + 28 >> 2] = i3;
 HEAP32[i16 + 20 >> 2] = 0;
 HEAP32[i16 + 16 >> 2] = 0;
 i1 = HEAP32[gb + 44352 + 4 >> 2] | 0;
 i2 = 1 << i3;
 do if (i1 & i2) {
  i5 = i6 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
  i1 = HEAP32[i4 >> 2] | 0;
  while (1) {
   if ((HEAP32[i1 + 4 >> 2] & -8 | 0) == (i6 | 0)) {
    i3 = i1;
    i4 = 130;
    break;
   }
   i2 = i1 + 16 + (i5 >>> 31 << 2) | 0;
   i3 = HEAP32[i2 >> 2] | 0;
   if (!i3) {
    i4 = 127;
    break;
   } else {
    i5 = i5 << 1;
    i1 = i3;
   }
  }
  if ((i4 | 0) == 127) if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
   HEAP32[i2 >> 2] = i16;
   HEAP32[i16 + 24 >> 2] = i1;
   HEAP32[i16 + 12 >> 2] = i16;
   HEAP32[i16 + 8 >> 2] = i16;
   break;
  } else if ((i4 | 0) == 130) {
   i1 = i3 + 8 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   i15 = HEAP32[gb + 44352 + 16 >> 2] | 0;
   if (i2 >>> 0 >= i15 >>> 0 & i3 >>> 0 >= i15 >>> 0) {
    HEAP32[i2 + 12 >> 2] = i16;
    HEAP32[i1 >> 2] = i16;
    HEAP32[i16 + 8 >> 2] = i2;
    HEAP32[i16 + 12 >> 2] = i3;
    HEAP32[i16 + 24 >> 2] = 0;
    break;
   } else _abort();
  }
 } else {
  HEAP32[gb + 44352 + 4 >> 2] = i1 | i2;
  HEAP32[i4 >> 2] = i16;
  HEAP32[i16 + 24 >> 2] = i4;
  HEAP32[i16 + 12 >> 2] = i16;
  HEAP32[i16 + 8 >> 2] = i16;
 } while (0);
 i16 = (HEAP32[gb + 44352 + 32 >> 2] | 0) + -1 | 0;
 HEAP32[gb + 44352 + 32 >> 2] = i16;
 if (!i16) i1 = gb + 44352 + 456 | 0; else return;
 while (1) {
  i1 = HEAP32[i1 >> 2] | 0;
  if (!i1) break; else i1 = i1 + 8 | 0;
 }
 HEAP32[gb + 44352 + 32 >> 2] = -1;
 return;
}

function _dispose_chunk(i2, i3) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0;
 i14 = i2 + i3 | 0;
 i1 = HEAP32[i2 + 4 >> 2] | 0;
 do if (!(i1 & 1)) {
  i5 = HEAP32[i2 >> 2] | 0;
  if (!(i1 & 3)) return;
  i11 = i2 + (0 - i5) | 0;
  i10 = i5 + i3 | 0;
  i8 = HEAP32[gb + 44352 + 16 >> 2] | 0;
  if (i11 >>> 0 < i8 >>> 0) _abort();
  if ((i11 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
   i2 = i14 + 4 | 0;
   i1 = HEAP32[i2 >> 2] | 0;
   if ((i1 & 3 | 0) != 3) {
    i17 = i11;
    i6 = i10;
    break;
   }
   HEAP32[gb + 44352 + 8 >> 2] = i10;
   HEAP32[i2 >> 2] = i1 & -2;
   HEAP32[i11 + 4 >> 2] = i10 | 1;
   HEAP32[i11 + i10 >> 2] = i10;
   return;
  }
  i4 = i5 >>> 3;
  if (i5 >>> 0 < 256) {
   i2 = HEAP32[i11 + 8 >> 2] | 0;
   i3 = HEAP32[i11 + 12 >> 2] | 0;
   i1 = gb + 44352 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < i8 >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i11 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 44352 >> 2] = HEAP32[gb + 44352 >> 2] & ~(1 << i4);
    i17 = i11;
    i6 = i10;
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < i8 >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i11 | 0)) i7 = i1; else _abort();
   } else i7 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i7 >> 2] = i2;
   i17 = i11;
   i6 = i10;
   break;
  }
  i5 = HEAP32[i11 + 24 >> 2] | 0;
  i3 = HEAP32[i11 + 12 >> 2] | 0;
  do if ((i3 | 0) == (i11 | 0)) {
   i2 = i11 + 16 | 0;
   i3 = i2 + 4 | 0;
   i1 = HEAP32[i3 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i2 >> 2] | 0;
    if (!i1) {
     i9 = 0;
     break;
    }
   } else i2 = i3;
   while (1) {
    i3 = i1 + 20 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i2 = i3;
     continue;
    }
    i3 = i1 + 16 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (!i4) break; else {
     i1 = i4;
     i2 = i3;
    }
   }
   if (i2 >>> 0 < i8 >>> 0) _abort(); else {
    HEAP32[i2 >> 2] = 0;
    i9 = i1;
    break;
   }
  } else {
   i4 = HEAP32[i11 + 8 >> 2] | 0;
   if (i4 >>> 0 < i8 >>> 0) _abort();
   i1 = i4 + 12 | 0;
   if ((HEAP32[i1 >> 2] | 0) != (i11 | 0)) _abort();
   i2 = i3 + 8 | 0;
   if ((HEAP32[i2 >> 2] | 0) == (i11 | 0)) {
    HEAP32[i1 >> 2] = i3;
    HEAP32[i2 >> 2] = i4;
    i9 = i3;
    break;
   } else _abort();
  } while (0);
  if (i5) {
   i1 = HEAP32[i11 + 28 >> 2] | 0;
   i2 = gb + 44352 + 304 + (i1 << 2) | 0;
   if ((i11 | 0) == (HEAP32[i2 >> 2] | 0)) {
    HEAP32[i2 >> 2] = i9;
    if (!i9) {
     HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
     i17 = i11;
     i6 = i10;
     break;
    }
   } else {
    if (i5 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i5 + 16 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i11 | 0)) HEAP32[i1 >> 2] = i9; else HEAP32[i5 + 20 >> 2] = i9;
    if (!i9) {
     i17 = i11;
     i6 = i10;
     break;
    }
   }
   i3 = HEAP32[gb + 44352 + 16 >> 2] | 0;
   if (i9 >>> 0 < i3 >>> 0) _abort();
   HEAP32[i9 + 24 >> 2] = i5;
   i1 = i11 + 16 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
    HEAP32[i9 + 16 >> 2] = i2;
    HEAP32[i2 + 24 >> 2] = i9;
    break;
   } while (0);
   i1 = HEAP32[i1 + 4 >> 2] | 0;
   if (i1) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
    HEAP32[i9 + 20 >> 2] = i1;
    HEAP32[i1 + 24 >> 2] = i9;
    i17 = i11;
    i6 = i10;
    break;
   } else {
    i17 = i11;
    i6 = i10;
   }
  } else {
   i17 = i11;
   i6 = i10;
  }
 } else {
  i17 = i2;
  i6 = i3;
 } while (0);
 i7 = HEAP32[gb + 44352 + 16 >> 2] | 0;
 if (i14 >>> 0 < i7 >>> 0) _abort();
 i1 = i14 + 4 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (!(i2 & 2)) {
  if ((i14 | 0) == (HEAP32[gb + 44352 + 24 >> 2] | 0)) {
   i16 = (HEAP32[gb + 44352 + 12 >> 2] | 0) + i6 | 0;
   HEAP32[gb + 44352 + 12 >> 2] = i16;
   HEAP32[gb + 44352 + 24 >> 2] = i17;
   HEAP32[i17 + 4 >> 2] = i16 | 1;
   if ((i17 | 0) != (HEAP32[gb + 44352 + 20 >> 2] | 0)) return;
   HEAP32[gb + 44352 + 20 >> 2] = 0;
   HEAP32[gb + 44352 + 8 >> 2] = 0;
   return;
  }
  if ((i14 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
   i16 = (HEAP32[gb + 44352 + 8 >> 2] | 0) + i6 | 0;
   HEAP32[gb + 44352 + 8 >> 2] = i16;
   HEAP32[gb + 44352 + 20 >> 2] = i17;
   HEAP32[i17 + 4 >> 2] = i16 | 1;
   HEAP32[i17 + i16 >> 2] = i16;
   return;
  }
  i6 = (i2 & -8) + i6 | 0;
  i4 = i2 >>> 3;
  do if (i2 >>> 0 >= 256) {
   i5 = HEAP32[i14 + 24 >> 2] | 0;
   i3 = HEAP32[i14 + 12 >> 2] | 0;
   do if ((i3 | 0) == (i14 | 0)) {
    i2 = i14 + 16 | 0;
    i3 = i2 + 4 | 0;
    i1 = HEAP32[i3 >> 2] | 0;
    if (!i1) {
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i13 = 0;
      break;
     }
    } else i2 = i3;
    while (1) {
     i3 = i1 + 20 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (i4 | 0) {
      i1 = i4;
      i2 = i3;
      continue;
     }
     i3 = i1 + 16 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (!i4) break; else {
      i1 = i4;
      i2 = i3;
     }
    }
    if (i2 >>> 0 < i7 >>> 0) _abort(); else {
     HEAP32[i2 >> 2] = 0;
     i13 = i1;
     break;
    }
   } else {
    i4 = HEAP32[i14 + 8 >> 2] | 0;
    if (i4 >>> 0 < i7 >>> 0) _abort();
    i1 = i4 + 12 | 0;
    if ((HEAP32[i1 >> 2] | 0) != (i14 | 0)) _abort();
    i2 = i3 + 8 | 0;
    if ((HEAP32[i2 >> 2] | 0) == (i14 | 0)) {
     HEAP32[i1 >> 2] = i3;
     HEAP32[i2 >> 2] = i4;
     i13 = i3;
     break;
    } else _abort();
   } while (0);
   if (i5 | 0) {
    i1 = HEAP32[i14 + 28 >> 2] | 0;
    i2 = gb + 44352 + 304 + (i1 << 2) | 0;
    if ((i14 | 0) == (HEAP32[i2 >> 2] | 0)) {
     HEAP32[i2 >> 2] = i13;
     if (!i13) {
      HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
      break;
     }
    } else {
     if (i5 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
     i1 = i5 + 16 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i14 | 0)) HEAP32[i1 >> 2] = i13; else HEAP32[i5 + 20 >> 2] = i13;
     if (!i13) break;
    }
    i3 = HEAP32[gb + 44352 + 16 >> 2] | 0;
    if (i13 >>> 0 < i3 >>> 0) _abort();
    HEAP32[i13 + 24 >> 2] = i5;
    i1 = i14 + 16 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
     HEAP32[i13 + 16 >> 2] = i2;
     HEAP32[i2 + 24 >> 2] = i13;
     break;
    } while (0);
    i1 = HEAP32[i1 + 4 >> 2] | 0;
    if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i13 + 20 >> 2] = i1;
     HEAP32[i1 + 24 >> 2] = i13;
     break;
    }
   }
  } else {
   i2 = HEAP32[i14 + 8 >> 2] | 0;
   i3 = HEAP32[i14 + 12 >> 2] | 0;
   i1 = gb + 44352 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < i7 >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i14 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 44352 >> 2] = HEAP32[gb + 44352 >> 2] & ~(1 << i4);
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < i7 >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i14 | 0)) i12 = i1; else _abort();
   } else i12 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i12 >> 2] = i2;
  } while (0);
  HEAP32[i17 + 4 >> 2] = i6 | 1;
  HEAP32[i17 + i6 >> 2] = i6;
  if ((i17 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
   HEAP32[gb + 44352 + 8 >> 2] = i6;
   return;
  }
 } else {
  HEAP32[i1 >> 2] = i2 & -2;
  HEAP32[i17 + 4 >> 2] = i6 | 1;
  HEAP32[i17 + i6 >> 2] = i6;
 }
 i1 = i6 >>> 3;
 if (i6 >>> 0 < 256) {
  i3 = gb + 44352 + 40 + (i1 << 1 << 2) | 0;
  i2 = HEAP32[gb + 44352 >> 2] | 0;
  i1 = 1 << i1;
  if (i2 & i1) {
   i1 = i3 + 8 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
    i15 = i1;
    i16 = i2;
   }
  } else {
   HEAP32[gb + 44352 >> 2] = i2 | i1;
   i15 = i3 + 8 | 0;
   i16 = i3;
  }
  HEAP32[i15 >> 2] = i17;
  HEAP32[i16 + 12 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i16;
  HEAP32[i17 + 12 >> 2] = i3;
  return;
 }
 i1 = i6 >>> 8;
 if (i1) if (i6 >>> 0 > 16777215) i3 = 31; else {
  i15 = (i1 + 1048320 | 0) >>> 16 & 8;
  i16 = i1 << i15;
  i14 = (i16 + 520192 | 0) >>> 16 & 4;
  i16 = i16 << i14;
  i3 = (i16 + 245760 | 0) >>> 16 & 2;
  i3 = 14 - (i14 | i15 | i3) + (i16 << i3 >>> 15) | 0;
  i3 = i6 >>> (i3 + 7 | 0) & 1 | i3 << 1;
 } else i3 = 0;
 i4 = gb + 44352 + 304 + (i3 << 2) | 0;
 HEAP32[i17 + 28 >> 2] = i3;
 HEAP32[i17 + 20 >> 2] = 0;
 HEAP32[i17 + 16 >> 2] = 0;
 i1 = HEAP32[gb + 44352 + 4 >> 2] | 0;
 i2 = 1 << i3;
 if (!(i1 & i2)) {
  HEAP32[gb + 44352 + 4 >> 2] = i1 | i2;
  HEAP32[i4 >> 2] = i17;
  HEAP32[i17 + 24 >> 2] = i4;
  HEAP32[i17 + 12 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i17;
  return;
 }
 i5 = i6 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
 i1 = HEAP32[i4 >> 2] | 0;
 while (1) {
  if ((HEAP32[i1 + 4 >> 2] & -8 | 0) == (i6 | 0)) {
   i3 = i1;
   i4 = 127;
   break;
  }
  i2 = i1 + 16 + (i5 >>> 31 << 2) | 0;
  i3 = HEAP32[i2 >> 2] | 0;
  if (!i3) {
   i4 = 124;
   break;
  } else {
   i5 = i5 << 1;
   i1 = i3;
  }
 }
 if ((i4 | 0) == 124) {
  if (i2 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
  HEAP32[i2 >> 2] = i17;
  HEAP32[i17 + 24 >> 2] = i1;
  HEAP32[i17 + 12 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i17;
  return;
 } else if ((i4 | 0) == 127) {
  i1 = i3 + 8 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  i16 = HEAP32[gb + 44352 + 16 >> 2] | 0;
  if (!(i2 >>> 0 >= i16 >>> 0 & i3 >>> 0 >= i16 >>> 0)) _abort();
  HEAP32[i2 + 12 >> 2] = i17;
  HEAP32[i1 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i2;
  HEAP32[i17 + 12 >> 2] = i3;
  HEAP32[i17 + 24 >> 2] = 0;
  return;
 }
}

function _ellip_azpkf(i41, d39, d1, i46, i42, i45) {
 i41 = i41 | 0;
 d39 = +d39;
 d1 = +d1;
 i46 = i46 | 0;
 i42 = i42 | 0;
 i45 = i45 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0, d20 = 0.0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, d27 = 0.0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i40 = 0, i43 = 0, i44 = 0, i47 = 0, i48 = 0;
 i47 = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 i36 = i47 + 176 | 0;
 i17 = i47 + 144 | 0;
 i15 = i47 + 128 | 0;
 i10 = i47 + 168 | 0;
 i11 = i47 + 160 | 0;
 i14 = i47 + 152 | 0;
 i18 = i47 + 136 | 0;
 i21 = i47 + 120 | 0;
 i23 = i47 + 112 | 0;
 i24 = i47 + 96 | 0;
 i25 = i47 + 88 | 0;
 i26 = i47 + 72 | 0;
 i29 = i47 + 64 | 0;
 i28 = i47 + 56 | 0;
 i30 = i47 + 48 | 0;
 i31 = i47 + 40 | 0;
 i32 = i47 + 32 | 0;
 i37 = i47 + 24 | 0;
 i38 = i47 + 16 | 0;
 i40 = i47 + 8 | 0;
 i44 = i47;
 d1 = d39 / d1;
 _llvm_stackrestore(_llvm_stacksave() | 0);
 _ellipkf(d1, 7, i47 + 104 | 0, i47 + 80 | 0);
 d8 = +(i41 >>> 0);
 _ellipkf(d1, 7, i36, i17);
 d27 = +Math_pow(+(+Math_exp(+(+HEAPF32[i17 >> 2] * -3.141592653589793 / +HEAPF32[i36 >> 2]))), +(1.0 / d8));
 d20 = (d27 * d27 + 1.0 + +Math_pow(+d27, 6.0) + +Math_pow(+d27, 12.0) + +Math_pow(+d27, 20.0) + +Math_pow(+d27, 30.0) + +Math_pow(+d27, 42.0)) / ((d27 + 0.0 + +Math_pow(+d27, 4.0) + +Math_pow(+d27, 9.0) + +Math_pow(+d27, 16.0) + +Math_pow(+d27, 25.0) + +Math_pow(+d27, 36.0)) * 2.0 + 1.0);
 d27 = d20 * (d20 * (+Math_sqrt(+d27) * 4.0));
 i35 = ~~+Math_floor(+(d8 * .5)) >>> 0;
 i33 = ~~d8 >>> 0 & 1;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i35 << 2) | 0) + 15 & -16) | 0;
 i34 = (i35 | 0) == 0;
 if (!i34) {
  i3 = 0;
  do {
   HEAPF32[i22 + (i3 << 2) >> 2] = ((+(i3 >>> 0) + 1.0) * 2.0 + -1.0) / d8;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i35 | 0));
  i13 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i35 << 3) | 0) + 15 & -16) | 0;
  if (!i34) {
   i3 = i11 + 4 | 0;
   i4 = i10 + 4 | 0;
   i5 = 0;
   do {
    HEAP32[i11 >> 2] = HEAP32[i22 + (i5 << 2) >> 2];
    HEAPF32[i3 >> 2] = 0.0;
    HEAP32[i36 >> 2] = HEAP32[i11 >> 2];
    HEAP32[i36 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
    _ellip_cdf(i10, i36, d27, 7);
    i48 = HEAP32[i4 >> 2] | 0;
    HEAP32[i13 + (i5 << 3) >> 2] = HEAP32[i10 >> 2];
    HEAP32[i13 + (i5 << 3) + 4 >> 2] = i48;
    i5 = i5 + 1 | 0;
   } while ((i5 | 0) != (i35 | 0));
   i3 = STACKTOP;
   STACKTOP = STACKTOP + ((1 * (i35 << 3) | 0) + 15 & -16) | 0;
   if (i34) i14 = i3; else {
    i4 = i14 + 4 | 0;
    i5 = 0;
    do {
     ___divsc3(i14, 0.0, .9999999403953552, d27 * +HEAPF32[i13 + (i5 << 3) >> 2], d27 * +HEAPF32[i13 + (i5 << 3) + 4 >> 2]);
     i48 = HEAP32[i4 >> 2] | 0;
     HEAP32[i3 + (i5 << 3) >> 2] = HEAP32[i14 >> 2];
     HEAP32[i3 + (i5 << 3) + 4 >> 2] = i48;
     i5 = i5 + 1 | 0;
    } while ((i5 | 0) != (i35 | 0));
    i14 = i3;
   }
  } else i16 = 6;
 } else i16 = 6;
 if ((i16 | 0) == 6) {
  i14 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i35 << 3) | 0) + 15 & -16) | 0;
 }
 HEAPF32[i15 >> 2] = 0.0 / d39;
 HEAPF32[i15 + 4 >> 2] = 1.0 / d39;
 HEAP32[i36 >> 2] = HEAP32[i15 >> 2];
 HEAP32[i36 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
 _ellip_acdf(i17, i36, d1, 7);
 d7 = +HEAPF32[i17 + 4 >> 2];
 d6 = 1.0 - +HEAPF32[i17 >> 2];
 d2 = d6 * -0.0 - d7;
 d1 = d7 * 0.0 - d6;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i18, -0.0, -1.0, d6, -d7);
  d2 = +HEAPF32[i18 >> 2];
  d1 = +HEAPF32[i18 + 4 >> 2];
 }
 d20 = d2 / d8;
 d19 = d1 / d8;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i35 << 3) | 0) + 15 & -16) | 0;
 d2 = d20 * 0.0 - d19;
 d1 = d20 + d19 * 0.0;
 L18 : do if (!i34) {
  i3 = i21 + 4 | 0;
  i5 = i24 + 4 | 0;
  i10 = i23 + 4 | 0;
  i11 = i25 + 4 | 0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   i4 = 0;
   while (1) {
    d9 = +HEAPF32[i22 + (i4 << 2) >> 2];
    ___mulsc3(i21, 0.0, 1.0, d20, d19);
    d8 = -+HEAPF32[i3 >> 2];
    HEAPF32[i24 >> 2] = d9 - +HEAPF32[i21 >> 2];
    HEAPF32[i5 >> 2] = d8;
    HEAP32[i36 >> 2] = HEAP32[i24 >> 2];
    HEAP32[i36 + 4 >> 2] = HEAP32[i24 + 4 >> 2];
    _ellip_cdf(i23, i36, d27, 7);
    d8 = +HEAPF32[i23 >> 2];
    d9 = +HEAPF32[i10 >> 2];
    d7 = d8 * 0.0 - d9 * .9999999403953552;
    d6 = d8 * .9999999403953552 + d9 * 0.0;
    if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
     ___mulsc3(i25, 0.0, .9999999403953552, d8, d9);
     d7 = +HEAPF32[i25 >> 2];
     d6 = +HEAPF32[i11 >> 2];
    }
    HEAPF32[i13 + (i4 << 3) >> 2] = d7;
    HEAPF32[i13 + (i4 << 3) + 4 >> 2] = d6;
    i4 = i4 + 1 | 0;
    if ((i4 | 0) == (i35 | 0)) break L18;
   }
  }
  d12 = -d1;
  i3 = 0;
  do {
   HEAPF32[i24 >> 2] = +HEAPF32[i22 + (i3 << 2) >> 2] - d2;
   HEAPF32[i5 >> 2] = d12;
   HEAP32[i36 >> 2] = HEAP32[i24 >> 2];
   HEAP32[i36 + 4 >> 2] = HEAP32[i24 + 4 >> 2];
   _ellip_cdf(i23, i36, d27, 7);
   d8 = +HEAPF32[i23 >> 2];
   d9 = +HEAPF32[i10 >> 2];
   d7 = d8 * 0.0 - d9 * .9999999403953552;
   d6 = d8 * .9999999403953552 + d9 * 0.0;
   if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
    ___mulsc3(i25, 0.0, .9999999403953552, d8, d9);
    d7 = +HEAPF32[i25 >> 2];
    d6 = +HEAPF32[i11 >> 2];
   }
   HEAPF32[i13 + (i3 << 3) >> 2] = d7;
   HEAPF32[i13 + (i3 << 3) + 4 >> 2] = d6;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i35 | 0));
 } while (0);
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i26, 0.0, 1.0, d20, d19);
  d2 = +HEAPF32[i26 >> 2];
  d1 = +HEAPF32[i26 + 4 >> 2];
 }
 HEAPF32[i28 >> 2] = d2;
 HEAPF32[i28 + 4 >> 2] = d1;
 HEAP32[i36 >> 2] = HEAP32[i28 >> 2];
 HEAP32[i36 + 4 >> 2] = HEAP32[i28 + 4 >> 2];
 _ellip_snf(i29, i36, d27, 7);
 d6 = +HEAPF32[i29 >> 2];
 d1 = +HEAPF32[i29 + 4 >> 2];
 d2 = d6 * 0.0 - d1 * .9999999403953552;
 d7 = d6 * .9999999403953552 + d1 * 0.0;
 if ((d2 != d2 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
  ___mulsc3(i30, 0.0, .9999999403953552, d6, d1);
  d2 = +HEAPF32[i30 >> 2];
  d7 = +HEAPF32[i30 + 4 >> 2];
 }
 if (i34) i3 = 0; else {
  i3 = i32 + 4 | 0;
  i4 = i31 + 4 | 0;
  i5 = 0;
  i10 = 0;
  while (1) {
   i29 = HEAP32[i13 + (i5 << 3) >> 2] | 0;
   i30 = HEAP32[i13 + (i5 << 3) + 4 >> 2] | 0;
   i48 = i10 | 1;
   HEAP32[i42 + (i10 << 3) >> 2] = i29;
   HEAP32[i42 + (i10 << 3) + 4 >> 2] = i30;
   HEAP32[i32 >> 2] = i29;
   HEAP32[i3 >> 2] = i30;
   HEAP32[i36 >> 2] = HEAP32[i32 >> 2];
   HEAP32[i36 + 4 >> 2] = HEAP32[i32 + 4 >> 2];
   _conjf(i31, i36);
   i30 = HEAP32[i4 >> 2] | 0;
   HEAP32[i42 + (i48 << 3) >> 2] = HEAP32[i31 >> 2];
   HEAP32[i42 + (i48 << 3) + 4 >> 2] = i30;
   i5 = i5 + 1 | 0;
   if ((i5 | 0) == (i35 | 0)) break; else i10 = i10 + 2 | 0;
  }
  i3 = i35 << 1;
 }
 i11 = (i33 | 0) != 0;
 if (i11) {
  HEAPF32[i42 + (i3 << 3) >> 2] = d2;
  HEAPF32[i42 + (i3 << 3) + 4 >> 2] = d7;
  i3 = i3 | 1;
 }
 if ((i3 | 0) != (i41 | 0)) ___assert_fail(gb + 40221 | 0, gb + 40227 | 0, 383, gb + 40250 | 0);
 if (i34) if (!(i35 & 2147483647)) i43 = 0; else ___assert_fail(gb + 40262 | 0, gb + 40227 | 0, 390, gb + 40250 | 0); else {
  i3 = i38 + 4 | 0;
  i4 = i37 + 4 | 0;
  i5 = 0;
  i10 = 0;
  while (1) {
   i34 = HEAP32[i14 + (i5 << 3) >> 2] | 0;
   i43 = HEAP32[i14 + (i5 << 3) + 4 >> 2] | 0;
   i48 = i10 | 1;
   HEAP32[i46 + (i10 << 3) >> 2] = i34;
   HEAP32[i46 + (i10 << 3) + 4 >> 2] = i43;
   HEAP32[i38 >> 2] = i34;
   HEAP32[i3 >> 2] = i43;
   HEAP32[i36 >> 2] = HEAP32[i38 >> 2];
   HEAP32[i36 + 4 >> 2] = HEAP32[i38 + 4 >> 2];
   _conjf(i37, i36);
   i43 = HEAP32[i4 >> 2] | 0;
   HEAP32[i46 + (i48 << 3) >> 2] = HEAP32[i37 >> 2];
   HEAP32[i46 + (i48 << 3) + 4 >> 2] = i43;
   i5 = i5 + 1 | 0;
   if ((i5 | 0) == (i35 | 0)) break; else i10 = i10 + 2 | 0;
  }
  i43 = i35 << 1;
 }
 if (i11) d1 = 1.0; else d1 = 1.0 / +Math_sqrt(+(d39 * d39 + 1.0));
 i10 = i45 + 4 | 0;
 HEAPF32[i45 >> 2] = d1;
 HEAPF32[i10 >> 2] = 0.0;
 if (!i41) d2 = 0.0; else {
  i4 = i40 + 4 | 0;
  d2 = 0.0;
  i3 = 0;
  do {
   d6 = +HEAPF32[i42 + (i3 << 3) >> 2];
   d7 = +HEAPF32[i42 + (i3 << 3) + 4 >> 2];
   d8 = d6 * d1 - d7 * d2;
   d9 = d7 * d1 + d6 * d2;
   if ((d8 != d8 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
    ___mulsc3(i40, d1, d2, d6, d7);
    d1 = +HEAPF32[i40 >> 2];
    d2 = +HEAPF32[i4 >> 2];
   } else {
    d1 = d8;
    d2 = d9;
   }
   HEAPF32[i45 >> 2] = d1;
   HEAPF32[i10 >> 2] = d2;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i41 | 0));
 }
 if (!i43) {
  STACKTOP = i47;
  return;
 }
 i5 = i44 + 4 | 0;
 i4 = 0;
 while (1) {
  ___divsc3(i44, d1, d2, +HEAPF32[i46 + (i4 << 3) >> 2], +HEAPF32[i46 + (i4 << 3) + 4 >> 2]);
  i48 = HEAP32[i44 >> 2] | 0;
  i3 = HEAP32[i5 >> 2] | 0;
  HEAP32[i45 >> 2] = i48;
  HEAP32[i10 >> 2] = i3;
  i4 = i4 + 1 | 0;
  d1 = (HEAP32[tempDoublePtr >> 2] = i48, +HEAPF32[tempDoublePtr >> 2]);
  if ((i4 | 0) == (i43 | 0)) break; else d2 = (HEAP32[tempDoublePtr >> 2] = i3, +HEAPF32[tempDoublePtr >> 2]);
 }
 STACKTOP = i47;
 return;
}

function _fft_execute_dft_6(i16) {
 i16 = i16 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, d17 = 0.0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, d31 = 0.0, d32 = 0.0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, d38 = 0.0, d39 = 0.0, i40 = 0, i41 = 0, i42 = 0, d43 = 0.0, d44 = 0.0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, d50 = 0.0, d51 = 0.0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0;
 i57 = STACKTOP;
 STACKTOP = STACKTOP + 208 | 0;
 i9 = i57 + 192 | 0;
 i10 = i57 + 184 | 0;
 i11 = i57 + 176 | 0;
 i19 = i57 + 168 | 0;
 i12 = i57 + 160 | 0;
 i13 = i57 + 152 | 0;
 i14 = i57 + 144 | 0;
 i18 = i57 + 136 | 0;
 i15 = i57 + 128 | 0;
 i20 = i57 + 120 | 0;
 i21 = i57 + 112 | 0;
 i22 = i57 + 104 | 0;
 i23 = i57 + 96 | 0;
 i24 = i57 + 88 | 0;
 i25 = i57 + 80 | 0;
 i26 = i57 + 72 | 0;
 i27 = i57 + 64 | 0;
 i28 = i57 + 56 | 0;
 i29 = i57 + 48 | 0;
 i30 = i57 + 40 | 0;
 i33 = i57 + 32 | 0;
 i40 = i57 + 24 | 0;
 i45 = i57 + 16 | 0;
 i52 = i57 + 8 | 0;
 i55 = i57;
 i34 = HEAP32[i16 + 4 >> 2] | 0;
 i56 = HEAP32[i16 + 8 >> 2] | 0;
 i35 = i34 + 4 | 0;
 i36 = i34 + 8 | 0;
 i37 = i34 + 12 | 0;
 i41 = i34 + 16 | 0;
 i42 = i34 + 20 | 0;
 i46 = i34 + 24 | 0;
 i47 = i34 + 28 | 0;
 i48 = i34 + 32 | 0;
 i49 = i34 + 36 | 0;
 i53 = i34 + 40 | 0;
 i54 = i34 + 44 | 0;
 d51 = +HEAPF32[i35 >> 2] + +HEAPF32[i37 >> 2] + +HEAPF32[i42 >> 2] + +HEAPF32[i47 >> 2] + +HEAPF32[i49 >> 2] + +HEAPF32[i54 >> 2];
 HEAPF32[i56 >> 2] = +HEAPF32[i34 >> 2] + +HEAPF32[i36 >> 2] + +HEAPF32[i41 >> 2] + +HEAPF32[i46 >> 2] + +HEAPF32[i48 >> 2] + +HEAPF32[i53 >> 2];
 HEAPF32[i56 + 4 >> 2] = d51;
 if ((HEAP32[i16 + 12 >> 2] | 0) == 1) {
  HEAPF32[i11 >> 2] = .5;
  HEAPF32[i11 + 4 >> 2] = -.8660253882408142;
  HEAP32[i9 >> 2] = HEAP32[i11 >> 2];
  HEAP32[i9 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
  _conjf(i10, i9);
  d43 = -+HEAPF32[i10 >> 2];
  d44 = -+HEAPF32[i10 + 4 >> 2];
  HEAPF32[i12 >> 2] = .5;
  HEAPF32[i12 + 4 >> 2] = -.8660253882408142;
  HEAP32[i9 >> 2] = HEAP32[i12 >> 2];
  HEAP32[i9 + 4 >> 2] = HEAP32[i12 + 4 >> 2];
  _conjf(i19, i9);
  d50 = .5;
  d51 = -.8660253882408142;
  d39 = -.5;
  d38 = .8660253882408142;
  d32 = +HEAPF32[i19 >> 2];
  d31 = +HEAPF32[i19 + 4 >> 2];
 } else {
  HEAPF32[i14 >> 2] = .5;
  HEAPF32[i14 + 4 >> 2] = -.8660253882408142;
  HEAP32[i9 >> 2] = HEAP32[i14 >> 2];
  HEAP32[i9 + 4 >> 2] = HEAP32[i14 + 4 >> 2];
  _conjf(i13, i9);
  d50 = +HEAPF32[i13 >> 2];
  d51 = +HEAPF32[i13 + 4 >> 2];
  HEAPF32[i15 >> 2] = .5;
  HEAPF32[i15 + 4 >> 2] = -.8660253882408142;
  HEAP32[i9 >> 2] = HEAP32[i15 >> 2];
  HEAP32[i9 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
  _conjf(i18, i9);
  d43 = -.5;
  d44 = .8660253882408142;
  d39 = -+HEAPF32[i18 >> 2];
  d38 = -+HEAPF32[i18 + 4 >> 2];
  d32 = .5;
  d31 = -.8660253882408142;
 }
 d7 = +HEAPF32[i34 >> 2];
 d17 = +HEAPF32[i35 >> 2];
 d1 = +HEAPF32[i36 >> 2];
 d2 = +HEAPF32[i37 >> 2];
 d3 = d50 * d1 - d51 * d2;
 d4 = d51 * d1 + d50 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i20, d1, d2, d50, d51);
  d3 = +HEAPF32[i20 >> 2];
  d6 = +HEAPF32[i20 + 4 >> 2];
 } else d6 = d4;
 d4 = +HEAPF32[i41 >> 2];
 d5 = +HEAPF32[i42 >> 2];
 d2 = d43 * d4 - d44 * d5;
 d1 = d44 * d4 + d43 * d5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i21, d4, d5, d43, d44);
  d2 = +HEAPF32[i21 >> 2];
  d1 = +HEAPF32[i21 + 4 >> 2];
 }
 d8 = d7 + d3 + d2 - +HEAPF32[i46 >> 2];
 d7 = d17 + d6 + d1 - +HEAPF32[i47 >> 2];
 d1 = +HEAPF32[i48 >> 2];
 d2 = +HEAPF32[i49 >> 2];
 d3 = d39 * d1 - d38 * d2;
 d4 = d38 * d1 + d39 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i22, d1, d2, d39, d38);
  d3 = +HEAPF32[i22 >> 2];
  d4 = +HEAPF32[i22 + 4 >> 2];
 }
 d5 = +HEAPF32[i53 >> 2];
 d6 = +HEAPF32[i54 >> 2];
 d2 = d32 * d5 - d31 * d6;
 d1 = d31 * d5 + d32 * d6;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i23, d5, d6, d32, d31);
  d2 = +HEAPF32[i23 >> 2];
  d1 = +HEAPF32[i23 + 4 >> 2];
 }
 HEAPF32[i56 + 8 >> 2] = d8 + d3 + d2;
 HEAPF32[i56 + 12 >> 2] = d7 + d4 + d1;
 d7 = +HEAPF32[i34 >> 2];
 d8 = +HEAPF32[i35 >> 2];
 d1 = +HEAPF32[i36 >> 2];
 d2 = +HEAPF32[i37 >> 2];
 d3 = d43 * d1 - d44 * d2;
 d4 = d44 * d1 + d43 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i24, d1, d2, d43, d44);
  d3 = +HEAPF32[i24 >> 2];
  d4 = +HEAPF32[i24 + 4 >> 2];
 }
 d5 = +HEAPF32[i41 >> 2];
 d6 = +HEAPF32[i42 >> 2];
 d2 = d39 * d5 - d38 * d6;
 d1 = d38 * d5 + d39 * d6;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i25, d5, d6, d39, d38);
  d2 = +HEAPF32[i25 >> 2];
  d1 = +HEAPF32[i25 + 4 >> 2];
 }
 d17 = d7 + d3 + d2 + +HEAPF32[i46 >> 2];
 d7 = d8 + d4 + d1 + +HEAPF32[i47 >> 2];
 d1 = +HEAPF32[i48 >> 2];
 d2 = +HEAPF32[i49 >> 2];
 d3 = d43 * d1 - d44 * d2;
 d4 = d44 * d1 + d43 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i26, d1, d2, d43, d44);
  d3 = +HEAPF32[i26 >> 2];
  d4 = +HEAPF32[i26 + 4 >> 2];
 }
 d5 = +HEAPF32[i53 >> 2];
 d6 = +HEAPF32[i54 >> 2];
 d2 = d39 * d5 - d38 * d6;
 d1 = d38 * d5 + d39 * d6;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i27, d5, d6, d39, d38);
  d2 = +HEAPF32[i27 >> 2];
  d1 = +HEAPF32[i27 + 4 >> 2];
 }
 HEAPF32[i56 + 16 >> 2] = d17 + d3 + d2;
 HEAPF32[i56 + 20 >> 2] = d7 + d4 + d1;
 d7 = +HEAPF32[i35 >> 2] - +HEAPF32[i37 >> 2] + +HEAPF32[i42 >> 2] - +HEAPF32[i47 >> 2] + +HEAPF32[i49 >> 2] - +HEAPF32[i54 >> 2];
 HEAPF32[i56 + 24 >> 2] = +HEAPF32[i34 >> 2] - +HEAPF32[i36 >> 2] + +HEAPF32[i41 >> 2] - +HEAPF32[i46 >> 2] + +HEAPF32[i48 >> 2] - +HEAPF32[i53 >> 2];
 HEAPF32[i56 + 28 >> 2] = d7;
 d7 = +HEAPF32[i34 >> 2];
 d8 = +HEAPF32[i35 >> 2];
 d1 = +HEAPF32[i36 >> 2];
 d2 = +HEAPF32[i37 >> 2];
 d3 = d39 * d1 - d38 * d2;
 d4 = d38 * d1 + d39 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i28, d1, d2, d39, d38);
  d3 = +HEAPF32[i28 >> 2];
  d4 = +HEAPF32[i28 + 4 >> 2];
 }
 d5 = +HEAPF32[i41 >> 2];
 d6 = +HEAPF32[i42 >> 2];
 d2 = d43 * d5 - d44 * d6;
 d1 = d44 * d5 + d43 * d6;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i29, d5, d6, d43, d44);
  d2 = +HEAPF32[i29 >> 2];
  d1 = +HEAPF32[i29 + 4 >> 2];
 }
 d17 = d7 + d3 + d2 + +HEAPF32[i46 >> 2];
 d7 = d8 + d4 + d1 + +HEAPF32[i47 >> 2];
 d1 = +HEAPF32[i48 >> 2];
 d2 = +HEAPF32[i49 >> 2];
 d3 = d39 * d1 - d38 * d2;
 d4 = d38 * d1 + d39 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i30, d1, d2, d39, d38);
  d3 = +HEAPF32[i30 >> 2];
  d4 = +HEAPF32[i30 + 4 >> 2];
 }
 d5 = +HEAPF32[i53 >> 2];
 d6 = +HEAPF32[i54 >> 2];
 d2 = d43 * d5 - d44 * d6;
 d1 = d44 * d5 + d43 * d6;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i33, d5, d6, d43, d44);
  d2 = +HEAPF32[i33 >> 2];
  d1 = +HEAPF32[i33 + 4 >> 2];
 }
 HEAPF32[i56 + 32 >> 2] = d17 + d3 + d2;
 HEAPF32[i56 + 36 >> 2] = d7 + d4 + d1;
 d7 = +HEAPF32[i34 >> 2];
 d8 = +HEAPF32[i35 >> 2];
 d3 = +HEAPF32[i36 >> 2];
 d1 = +HEAPF32[i37 >> 2];
 d2 = d32 * d3 - d31 * d1;
 d4 = d31 * d3 + d32 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i40, d3, d1, d32, d31);
  d6 = +HEAPF32[i40 >> 2];
  d5 = +HEAPF32[i40 + 4 >> 2];
 } else {
  d6 = d2;
  d5 = d4;
 }
 d4 = +HEAPF32[i41 >> 2];
 d3 = +HEAPF32[i42 >> 2];
 d2 = d39 * d4 - d38 * d3;
 d1 = d38 * d4 + d39 * d3;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i45, d4, d3, d39, d38);
  d2 = +HEAPF32[i45 >> 2];
  d1 = +HEAPF32[i45 + 4 >> 2];
 }
 d6 = d7 + d6 + d2 - +HEAPF32[i46 >> 2];
 d5 = d8 + d5 + d1 - +HEAPF32[i47 >> 2];
 d4 = +HEAPF32[i48 >> 2];
 d3 = +HEAPF32[i49 >> 2];
 d2 = d43 * d4 - d44 * d3;
 d1 = d44 * d4 + d43 * d3;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i52, d4, d3, d43, d44);
  d2 = +HEAPF32[i52 >> 2];
  d1 = +HEAPF32[i52 + 4 >> 2];
 }
 d6 = d6 + d2;
 d5 = d5 + d1;
 d4 = +HEAPF32[i53 >> 2];
 d1 = +HEAPF32[i54 >> 2];
 d2 = d50 * d4 - d51 * d1;
 d3 = d51 * d4 + d50 * d1;
 if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
  d50 = d2;
  d51 = d3;
  d50 = d6 + d50;
  d51 = d5 + d51;
  i55 = i56 + 40 | 0;
  i56 = i56 + 44 | 0;
  HEAPF32[i55 >> 2] = d50;
  HEAPF32[i56 >> 2] = d51;
  STACKTOP = i57;
  return;
 }
 ___mulsc3(i55, d4, d1, d50, d51);
 d50 = +HEAPF32[i55 >> 2];
 d51 = +HEAPF32[i55 + 4 >> 2];
 d50 = d6 + d50;
 d51 = d5 + d51;
 i55 = i56 + 40 | 0;
 i56 = i56 + 44 | 0;
 HEAPF32[i55 >> 2] = d50;
 HEAPF32[i56 >> 2] = d51;
 STACKTOP = i57;
 return;
}

function _qdetector_cccf_execute_align(i41, i3) {
 i41 = i41 | 0;
 i3 = i3 | 0;
 var d1 = 0.0, d2 = 0.0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, i13 = 0, d14 = 0.0, d15 = 0.0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i42 = 0, i43 = 0, i44 = 0;
 i42 = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 i39 = i42 + 136 | 0;
 i19 = i42 + 128 | 0;
 i20 = i42 + 120 | 0;
 i21 = i42 + 112 | 0;
 i22 = i42 + 104 | 0;
 i23 = i42 + 96 | 0;
 i24 = i42 + 88 | 0;
 i26 = i42 + 80 | 0;
 i27 = i42 + 72 | 0;
 i28 = i42 + 64 | 0;
 i29 = i42 + 56 | 0;
 i30 = i42 + 48 | 0;
 i31 = i42 + 40 | 0;
 i32 = i42 + 32 | 0;
 i33 = i42 + 24 | 0;
 i34 = i42 + 16 | 0;
 i35 = i42 + 8 | 0;
 i40 = i42;
 i17 = HEAP32[i3 >> 2] | 0;
 i18 = HEAP32[i3 + 4 >> 2] | 0;
 i36 = i41 + 44 | 0;
 i38 = HEAP32[i36 >> 2] | 0;
 HEAP32[i36 >> 2] = i38 + 1;
 i37 = i41 + 16 | 0;
 i25 = HEAP32[i37 >> 2] | 0;
 HEAP32[i25 + (i38 << 3) >> 2] = i17;
 HEAP32[i25 + (i38 << 3) + 4 >> 2] = i18;
 i38 = i41 + 32 | 0;
 if ((HEAP32[i36 >> 2] | 0) >>> 0 < (HEAP32[i38 >> 2] | 0) >>> 0) {
  STACKTOP = i42;
  return;
 }
 i25 = i41 + 36 | 0;
 _fft_execute(HEAP32[i25 >> 2] | 0);
 i3 = HEAP32[i38 >> 2] | 0;
 if (i3 | 0) {
  i5 = i41 + 68 | 0;
  i8 = i41 + 20 | 0;
  i9 = i41 + 8 | 0;
  i13 = i20 + 4 | 0;
  i16 = i19 + 4 | 0;
  i17 = i21 + 4 | 0;
  i18 = i41 + 24 | 0;
  i4 = 0;
  do {
   i43 = ((i3 + i4 - (HEAP32[i5 >> 2] | 0) | 0) >>> 0) % (i3 >>> 0) | 0;
   i44 = HEAP32[i8 >> 2] | 0;
   d6 = +HEAPF32[i44 + (i4 << 3) >> 2];
   d7 = +HEAPF32[i44 + (i4 << 3) + 4 >> 2];
   i44 = HEAP32[i9 >> 2] | 0;
   i3 = HEAP32[i44 + (i43 << 3) + 4 >> 2] | 0;
   HEAP32[i20 >> 2] = HEAP32[i44 + (i43 << 3) >> 2];
   HEAP32[i13 >> 2] = i3;
   HEAP32[i39 >> 2] = HEAP32[i20 >> 2];
   HEAP32[i39 + 4 >> 2] = HEAP32[i20 + 4 >> 2];
   _conjf(i19, i39);
   d10 = +HEAPF32[i19 >> 2];
   d11 = +HEAPF32[i16 >> 2];
   d2 = d6 * d10 - d7 * d11;
   d1 = d7 * d10 + d6 * d11;
   if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
    ___mulsc3(i21, d6, d7, d10, d11);
    d2 = +HEAPF32[i21 >> 2];
    d1 = +HEAPF32[i17 >> 2];
   }
   i3 = HEAP32[i18 >> 2] | 0;
   HEAPF32[i3 + (i4 << 3) >> 2] = d2;
   HEAPF32[i3 + (i4 << 3) + 4 >> 2] = d1;
   i4 = i4 + 1 | 0;
   i3 = HEAP32[i38 >> 2] | 0;
  } while (i4 >>> 0 < i3 >>> 0);
 }
 _fft_execute(HEAP32[i41 + 40 >> 2] | 0);
 i43 = (HEAP32[i38 >> 2] | 0) + -1 | 0;
 i17 = i41 + 28 | 0;
 i21 = HEAP32[i17 >> 2] | 0;
 i44 = HEAP32[i21 + (i43 << 3) + 4 >> 2] | 0;
 HEAP32[i22 >> 2] = HEAP32[i21 + (i43 << 3) >> 2];
 HEAP32[i22 + 4 >> 2] = i44;
 HEAP32[i39 >> 2] = HEAP32[i22 >> 2];
 HEAP32[i39 + 4 >> 2] = HEAP32[i22 + 4 >> 2];
 d12 = +Math_sqrt(+(+_cabsf(i39)));
 i44 = HEAP32[i17 >> 2] | 0;
 i43 = HEAP32[i44 + 4 >> 2] | 0;
 HEAP32[i23 >> 2] = HEAP32[i44 >> 2];
 HEAP32[i23 + 4 >> 2] = i43;
 HEAP32[i39 >> 2] = HEAP32[i23 >> 2];
 HEAP32[i39 + 4 >> 2] = HEAP32[i23 + 4 >> 2];
 d11 = +Math_sqrt(+(+_cabsf(i39)));
 i43 = HEAP32[i17 >> 2] | 0;
 i44 = HEAP32[i43 + 12 >> 2] | 0;
 HEAP32[i24 >> 2] = HEAP32[i43 + 8 >> 2];
 HEAP32[i24 + 4 >> 2] = i44;
 HEAP32[i39 >> 2] = HEAP32[i24 >> 2];
 HEAP32[i39 + 4 >> 2] = HEAP32[i24 + 4 >> 2];
 d15 = +Math_sqrt(+(+_cabsf(i39)));
 d14 = (d12 + d15) * .5 - d11;
 d12 = (d15 - d12) * .5;
 d15 = -d12 / (d14 * 2.0);
 HEAPF32[i41 + 72 >> 2] = d15;
 d15 = d11 + (d12 * d15 + d15 * (d14 * d15));
 i44 = HEAP32[i38 >> 2] | 0;
 HEAPF32[i41 + 76 >> 2] = d15 * d15 / (+(i44 >>> 0) * +HEAPF32[i41 + 12 >> 2]);
 _memmove(HEAP32[i17 >> 2] | 0, HEAP32[i37 >> 2] | 0, i44 << 3 | 0) | 0;
 if (HEAP32[i38 >> 2] | 0) {
  i3 = i41 + 4 | 0;
  i4 = i27 + 4 | 0;
  i5 = i26 + 4 | 0;
  i8 = i28 + 4 | 0;
  i16 = 0;
  do {
   if (i16 >>> 0 < (HEAP32[i41 >> 2] | 0) >>> 0) {
    i43 = HEAP32[i3 >> 2] | 0;
    i44 = HEAP32[i43 + (i16 << 3) + 4 >> 2] | 0;
    HEAP32[i27 >> 2] = HEAP32[i43 + (i16 << 3) >> 2];
    HEAP32[i4 >> 2] = i44;
    HEAP32[i39 >> 2] = HEAP32[i27 >> 2];
    HEAP32[i39 + 4 >> 2] = HEAP32[i27 + 4 >> 2];
    _conjf(i26, i39);
    d10 = +HEAPF32[i26 >> 2];
    d11 = +HEAPF32[i5 >> 2];
   } else {
    d10 = 0.0;
    d11 = 0.0;
   }
   i13 = HEAP32[i37 >> 2] | 0;
   i9 = i13 + (i16 << 3) | 0;
   d6 = +HEAPF32[i9 >> 2];
   i13 = i13 + (i16 << 3) + 4 | 0;
   d7 = +HEAPF32[i13 >> 2];
   d2 = d10 * d6 - d11 * d7;
   d1 = d11 * d6 + d10 * d7;
   if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
    ___mulsc3(i28, d6, d7, d10, d11);
    d2 = +HEAPF32[i28 >> 2];
    d1 = +HEAPF32[i8 >> 2];
   }
   HEAPF32[i9 >> 2] = d2;
   HEAPF32[i13 >> 2] = d1;
   i16 = i16 + 1 | 0;
  } while (i16 >>> 0 < (HEAP32[i38 >> 2] | 0) >>> 0);
 }
 _fft_execute(HEAP32[i25 >> 2] | 0);
 i9 = i41 + 20 | 0;
 if (!(HEAP32[i38 >> 2] | 0)) {
  i4 = 0;
  i3 = 0;
  d1 = 0.0;
 } else {
  i5 = i29 + 4 | 0;
  i8 = 0;
  i3 = 0;
  d1 = 0.0;
  do {
   i44 = HEAP32[i9 >> 2] | 0;
   i4 = HEAP32[i44 + (i8 << 3) + 4 >> 2] | 0;
   HEAP32[i29 >> 2] = HEAP32[i44 + (i8 << 3) >> 2];
   HEAP32[i5 >> 2] = i4;
   HEAP32[i39 >> 2] = HEAP32[i29 >> 2];
   HEAP32[i39 + 4 >> 2] = HEAP32[i29 + 4 >> 2];
   d15 = +_cabsf(i39);
   i4 = d15 > d1;
   i3 = i4 ? i8 : i3;
   d1 = i4 ? d15 : d1;
   i8 = i8 + 1 | 0;
   i4 = HEAP32[i38 >> 2] | 0;
  } while (i8 >>> 0 < i4 >>> 0);
 }
 i29 = ((i3 + -1 + i4 | 0) >>> 0) % (i4 >>> 0) | 0;
 i44 = ((i3 + 1 | 0) >>> 0) % (i4 >>> 0) | 0;
 i4 = HEAP32[i9 >> 2] | 0;
 i43 = HEAP32[i4 + (i29 << 3) + 4 >> 2] | 0;
 HEAP32[i30 >> 2] = HEAP32[i4 + (i29 << 3) >> 2];
 HEAP32[i30 + 4 >> 2] = i43;
 HEAP32[i39 >> 2] = HEAP32[i30 >> 2];
 HEAP32[i39 + 4 >> 2] = HEAP32[i30 + 4 >> 2];
 d14 = +_cabsf(i39);
 i43 = HEAP32[i9 >> 2] | 0;
 i4 = HEAP32[i43 + (i44 << 3) + 4 >> 2] | 0;
 HEAP32[i31 >> 2] = HEAP32[i43 + (i44 << 3) >> 2];
 HEAP32[i31 + 4 >> 2] = i4;
 HEAP32[i39 >> 2] = HEAP32[i31 >> 2];
 HEAP32[i39 + 4 >> 2] = HEAP32[i31 + 4 >> 2];
 d15 = +_cabsf(i39);
 d15 = +(i3 >>> 0) + -((d15 - d14) * .5) / (((d14 + d15) * .5 - d1) * 2.0);
 i4 = HEAP32[i38 >> 2] | 0;
 d1 = +(i4 >>> 0);
 d1 = (i3 >>> 0 > i4 >>> 1 >>> 0 ? d15 - d1 : d15) * 2.0 * 3.141592653589793 / d1;
 i4 = i41 + 80 | 0;
 HEAPF32[i4 >> 2] = d1;
 L28 : do if (!(HEAP32[i41 >> 2] | 0)) {
  d2 = 0.0;
  d1 = 0.0;
 } else {
  i5 = i32 + 4 | 0;
  i8 = i34 + 4 | 0;
  i9 = i33 + 4 | 0;
  i13 = i35 + 4 | 0;
  d6 = d1;
  i3 = 0;
  d2 = 0.0;
  d1 = 0.0;
  while (1) {
   i44 = HEAP32[i37 >> 2] | 0;
   d14 = +HEAPF32[i44 + (i3 << 3) >> 2];
   d15 = +HEAPF32[i44 + (i3 << 3) + 4 >> 2];
   d12 = d6 * -0.0;
   d10 = -d6;
   d11 = +(i3 >>> 0);
   d7 = d11 * d12 - d12;
   d6 = d11 * d10 + d12 * 0.0;
   if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
    ___mulsc3(i32, d12, d10, d11, 0.0);
    d7 = +HEAPF32[i32 >> 2];
    d6 = +HEAPF32[i5 >> 2];
   }
   HEAPF32[i34 >> 2] = d7;
   HEAPF32[i8 >> 2] = d6;
   HEAP32[i39 >> 2] = HEAP32[i34 >> 2];
   HEAP32[i39 + 4 >> 2] = HEAP32[i34 + 4 >> 2];
   _cexpf(i33, i39);
   d10 = +HEAPF32[i33 >> 2];
   d11 = +HEAPF32[i9 >> 2];
   d6 = d14 * d10 - d15 * d11;
   d7 = d15 * d10 + d14 * d11;
   if ((d6 != d6 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
    ___mulsc3(i35, d14, d15, d10, d11);
    d6 = +HEAPF32[i35 >> 2];
    d7 = +HEAPF32[i13 >> 2];
   }
   d2 = d2 + d6;
   d1 = d1 + d7;
   i3 = i3 + 1 | 0;
   if (i3 >>> 0 >= (HEAP32[i41 >> 2] | 0) >>> 0) break L28;
   d6 = +HEAPF32[i4 >> 2];
  }
 } while (0);
 HEAPF32[i40 >> 2] = d2;
 HEAPF32[i40 + 4 >> 2] = d1;
 HEAP32[i39 >> 2] = HEAP32[i40 >> 2];
 HEAP32[i39 + 4 >> 2] = HEAP32[i40 + 4 >> 2];
 HEAPF32[i41 + 84 >> 2] = +_cargf(i39);
 HEAP32[i41 + 92 >> 2] = 1;
 i44 = (HEAP32[i38 >> 2] | 0) >>> 1;
 _memmove(HEAP32[i37 >> 2] | 0, (HEAP32[i17 >> 2] | 0) + (i44 << 3) | 0, i44 << 3 | 0) | 0;
 HEAP32[i41 + 88 >> 2] = 0;
 HEAPF32[i41 + 60 >> 2] = +_liquid_sumsqcf(HEAP32[i37 >> 2] | 0, (HEAP32[i38 >> 2] | 0) >>> 1);
 HEAPF32[i41 + 64 >> 2] = 0.0;
 HEAP32[i36 >> 2] = (HEAP32[i38 >> 2] | 0) >>> 1;
 STACKTOP = i42;
 return;
}

function _fft_execute_dft_5(i14) {
 i14 = i14 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, d22 = 0.0, d23 = 0.0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, d35 = 0.0, i36 = 0, d37 = 0.0, i38 = 0, i39 = 0, d40 = 0.0, i41 = 0, d42 = 0.0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, d47 = 0.0, i48 = 0, d49 = 0.0, i50 = 0, i51 = 0, i52 = 0, d53 = 0.0, d54 = 0.0, i55 = 0, i56 = 0, i57 = 0, i58 = 0;
 i58 = STACKTOP;
 STACKTOP = STACKTOP + 208 | 0;
 i18 = i58 + 192 | 0;
 i11 = i58 + 184 | 0;
 i12 = i58 + 176 | 0;
 i15 = i58 + 168 | 0;
 i13 = i58 + 160 | 0;
 i17 = i58 + 152 | 0;
 i16 = i58 + 144 | 0;
 i20 = i58 + 136 | 0;
 i19 = i58 + 128 | 0;
 i21 = i58 + 120 | 0;
 i24 = i58 + 112 | 0;
 i25 = i58 + 104 | 0;
 i26 = i58 + 96 | 0;
 i27 = i58 + 88 | 0;
 i28 = i58 + 80 | 0;
 i29 = i58 + 72 | 0;
 i30 = i58 + 64 | 0;
 i31 = i58 + 56 | 0;
 i32 = i58 + 48 | 0;
 i33 = i58 + 40 | 0;
 i34 = i58 + 32 | 0;
 i43 = i58 + 24 | 0;
 i46 = i58 + 16 | 0;
 i51 = i58 + 8 | 0;
 i56 = i58;
 i36 = HEAP32[i14 + 4 >> 2] | 0;
 i57 = HEAP32[i14 + 8 >> 2] | 0;
 i38 = i36 + 4 | 0;
 i39 = i36 + 8 | 0;
 i41 = i36 + 12 | 0;
 i44 = i36 + 16 | 0;
 i45 = i36 + 20 | 0;
 i48 = i36 + 24 | 0;
 i50 = i36 + 28 | 0;
 i52 = i36 + 32 | 0;
 i55 = i36 + 36 | 0;
 d54 = +HEAPF32[i38 >> 2] + +HEAPF32[i41 >> 2] + +HEAPF32[i45 >> 2] + +HEAPF32[i50 >> 2] + +HEAPF32[i55 >> 2];
 HEAPF32[i57 >> 2] = +HEAPF32[i36 >> 2] + +HEAPF32[i39 >> 2] + +HEAPF32[i44 >> 2] + +HEAPF32[i48 >> 2] + +HEAPF32[i52 >> 2];
 HEAPF32[i57 + 4 >> 2] = d54;
 if ((HEAP32[i14 + 12 >> 2] | 0) == -1) {
  HEAPF32[i12 >> 2] = .30901700258255005;
  HEAPF32[i12 + 4 >> 2] = -.9510565400123596;
  HEAP32[i18 >> 2] = HEAP32[i12 >> 2];
  HEAP32[i18 + 4 >> 2] = HEAP32[i12 + 4 >> 2];
  _conjf(i11, i18);
  d53 = +HEAPF32[i11 >> 2];
  d54 = +HEAPF32[i11 + 4 >> 2];
  HEAPF32[i13 >> 2] = -.80901700258255;
  HEAPF32[i13 + 4 >> 2] = -.5877852439880371;
  HEAP32[i18 >> 2] = HEAP32[i13 >> 2];
  HEAP32[i18 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
  _conjf(i15, i18);
  d49 = +HEAPF32[i15 >> 2];
  d47 = +HEAPF32[i15 + 4 >> 2];
 } else {
  d53 = .30901700258255005;
  d54 = -.9510565400123596;
  d49 = -.80901700258255;
  d47 = -.5877852439880371;
 }
 HEAPF32[i16 >> 2] = d53;
 HEAPF32[i16 + 4 >> 2] = d54;
 HEAP32[i18 >> 2] = HEAP32[i16 >> 2];
 HEAP32[i18 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
 _conjf(i17, i18);
 d37 = +HEAPF32[i17 >> 2];
 d35 = +HEAPF32[i17 + 4 >> 2];
 HEAPF32[i19 >> 2] = d49;
 HEAPF32[i19 + 4 >> 2] = d47;
 HEAP32[i18 >> 2] = HEAP32[i19 >> 2];
 HEAP32[i18 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
 _conjf(i20, i18);
 d42 = +HEAPF32[i20 >> 2];
 d40 = +HEAPF32[i20 + 4 >> 2];
 d22 = +HEAPF32[i36 >> 2];
 d23 = +HEAPF32[i38 >> 2];
 d1 = +HEAPF32[i39 >> 2];
 d2 = +HEAPF32[i41 >> 2];
 d3 = d53 * d1 - d54 * d2;
 d4 = d54 * d1 + d53 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i21, d1, d2, d53, d54);
  d3 = +HEAPF32[i21 >> 2];
  d4 = +HEAPF32[i21 + 4 >> 2];
 }
 d2 = +HEAPF32[i44 >> 2];
 d5 = +HEAPF32[i45 >> 2];
 d1 = d49 * d2 - d47 * d5;
 d6 = d47 * d2 + d49 * d5;
 if ((d1 != d1 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i24, d2, d5, d49, d47);
  d10 = +HEAPF32[i24 >> 2];
  d6 = +HEAPF32[i24 + 4 >> 2];
 } else d10 = d1;
 d1 = +HEAPF32[i48 >> 2];
 d2 = +HEAPF32[i50 >> 2];
 d5 = d42 * d1 - d40 * d2;
 d7 = d40 * d1 + d42 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
  ___mulsc3(i25, d1, d2, d42, d40);
  d5 = +HEAPF32[i25 >> 2];
  d7 = +HEAPF32[i25 + 4 >> 2];
 }
 d8 = +HEAPF32[i52 >> 2];
 d9 = +HEAPF32[i55 >> 2];
 d2 = d37 * d8 - d35 * d9;
 d1 = d35 * d8 + d37 * d9;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i26, d8, d9, d37, d35);
  d2 = +HEAPF32[i26 >> 2];
  d1 = +HEAPF32[i26 + 4 >> 2];
 }
 HEAPF32[i57 + 8 >> 2] = d22 + d3 + d10 + d5 + d2;
 HEAPF32[i57 + 12 >> 2] = d23 + d4 + d6 + d7 + d1;
 d22 = +HEAPF32[i36 >> 2];
 d23 = +HEAPF32[i38 >> 2];
 d1 = +HEAPF32[i39 >> 2];
 d2 = +HEAPF32[i41 >> 2];
 d3 = d49 * d1 - d47 * d2;
 d4 = d47 * d1 + d49 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i27, d1, d2, d49, d47);
  d3 = +HEAPF32[i27 >> 2];
  d4 = +HEAPF32[i27 + 4 >> 2];
 }
 d1 = +HEAPF32[i44 >> 2];
 d2 = +HEAPF32[i45 >> 2];
 d5 = d37 * d1 - d35 * d2;
 d6 = d35 * d1 + d37 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i28, d1, d2, d37, d35);
  d5 = +HEAPF32[i28 >> 2];
  d6 = +HEAPF32[i28 + 4 >> 2];
 }
 d1 = +HEAPF32[i48 >> 2];
 d2 = +HEAPF32[i50 >> 2];
 d7 = d53 * d1 - d54 * d2;
 d8 = d54 * d1 + d53 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i29, d1, d2, d53, d54);
  d7 = +HEAPF32[i29 >> 2];
  d8 = +HEAPF32[i29 + 4 >> 2];
 }
 d9 = +HEAPF32[i52 >> 2];
 d10 = +HEAPF32[i55 >> 2];
 d2 = d42 * d9 - d40 * d10;
 d1 = d40 * d9 + d42 * d10;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i30, d9, d10, d42, d40);
  d2 = +HEAPF32[i30 >> 2];
  d1 = +HEAPF32[i30 + 4 >> 2];
 }
 HEAPF32[i57 + 16 >> 2] = d22 + d3 + d5 + d7 + d2;
 HEAPF32[i57 + 20 >> 2] = d23 + d4 + d6 + d8 + d1;
 d22 = +HEAPF32[i36 >> 2];
 d23 = +HEAPF32[i38 >> 2];
 d1 = +HEAPF32[i39 >> 2];
 d2 = +HEAPF32[i41 >> 2];
 d3 = d42 * d1 - d40 * d2;
 d4 = d40 * d1 + d42 * d2;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i31, d1, d2, d42, d40);
  d3 = +HEAPF32[i31 >> 2];
  d4 = +HEAPF32[i31 + 4 >> 2];
 }
 d1 = +HEAPF32[i44 >> 2];
 d2 = +HEAPF32[i45 >> 2];
 d5 = d53 * d1 - d54 * d2;
 d6 = d54 * d1 + d53 * d2;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i32, d1, d2, d53, d54);
  d5 = +HEAPF32[i32 >> 2];
  d6 = +HEAPF32[i32 + 4 >> 2];
 }
 d1 = +HEAPF32[i48 >> 2];
 d2 = +HEAPF32[i50 >> 2];
 d7 = d37 * d1 - d35 * d2;
 d8 = d35 * d1 + d37 * d2;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i33, d1, d2, d37, d35);
  d7 = +HEAPF32[i33 >> 2];
  d8 = +HEAPF32[i33 + 4 >> 2];
 }
 d9 = +HEAPF32[i52 >> 2];
 d10 = +HEAPF32[i55 >> 2];
 d2 = d49 * d9 - d47 * d10;
 d1 = d47 * d9 + d49 * d10;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i34, d9, d10, d49, d47);
  d2 = +HEAPF32[i34 >> 2];
  d1 = +HEAPF32[i34 + 4 >> 2];
 }
 HEAPF32[i57 + 24 >> 2] = d22 + d3 + d5 + d7 + d2;
 HEAPF32[i57 + 28 >> 2] = d23 + d4 + d6 + d8 + d1;
 d9 = +HEAPF32[i36 >> 2];
 d10 = +HEAPF32[i38 >> 2];
 d3 = +HEAPF32[i39 >> 2];
 d1 = +HEAPF32[i41 >> 2];
 d2 = d37 * d3 - d35 * d1;
 d4 = d35 * d3 + d37 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i43, d3, d1, d37, d35);
  d8 = +HEAPF32[i43 >> 2];
  d7 = +HEAPF32[i43 + 4 >> 2];
 } else {
  d8 = d2;
  d7 = d4;
 }
 d3 = +HEAPF32[i44 >> 2];
 d1 = +HEAPF32[i45 >> 2];
 d2 = d42 * d3 - d40 * d1;
 d4 = d40 * d3 + d42 * d1;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i46, d3, d1, d42, d40);
  d6 = +HEAPF32[i46 >> 2];
  d5 = +HEAPF32[i46 + 4 >> 2];
 } else {
  d6 = d2;
  d5 = d4;
 }
 d4 = +HEAPF32[i48 >> 2];
 d3 = +HEAPF32[i50 >> 2];
 d2 = d49 * d4 - d47 * d3;
 d1 = d47 * d4 + d49 * d3;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i51, d4, d3, d49, d47);
  d2 = +HEAPF32[i51 >> 2];
  d1 = +HEAPF32[i51 + 4 >> 2];
 }
 d6 = d9 + d8 + d6 + d2;
 d5 = d10 + d7 + d5 + d1;
 d4 = +HEAPF32[i52 >> 2];
 d1 = +HEAPF32[i55 >> 2];
 d2 = d53 * d4 - d54 * d1;
 d3 = d54 * d4 + d53 * d1;
 if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
  d53 = d2;
  d54 = d3;
  d53 = d6 + d53;
  d54 = d5 + d54;
  i56 = i57 + 32 | 0;
  i57 = i57 + 36 | 0;
  HEAPF32[i56 >> 2] = d53;
  HEAPF32[i57 >> 2] = d54;
  STACKTOP = i58;
  return;
 }
 ___mulsc3(i56, d4, d1, d53, d54);
 d53 = +HEAPF32[i56 >> 2];
 d54 = +HEAPF32[i56 + 4 >> 2];
 d53 = d6 + d53;
 d54 = d5 + d54;
 i56 = i57 + 32 | 0;
 i57 = i57 + 36 | 0;
 HEAPF32[i56 >> 2] = d53;
 HEAPF32[i57 >> 2] = d54;
 STACKTOP = i58;
 return;
}

function ___intscan(i13, i3, i6, i1, i2) {
 i13 = i13 | 0;
 i3 = i3 | 0;
 i6 = i6 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, i15 = 0;
 L1 : do if (i3 >>> 0 > 36) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  i2 = 0;
  i1 = 0;
 } else {
  i15 = i13 + 4 | 0;
  i14 = i13 + 100 | 0;
  do {
   i4 = HEAP32[i15 >> 2] | 0;
   if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
    HEAP32[i15 >> 2] = i4 + 1;
    i4 = HEAPU8[i4 >> 0] | 0;
   } else i4 = ___shgetc(i13) | 0;
  } while ((_isspace(i4) | 0) != 0);
  L11 : do switch (i4 | 0) {
  case 43:
  case 45:
   {
    i5 = ((i4 | 0) == 45) << 31 >> 31;
    i4 = HEAP32[i15 >> 2] | 0;
    if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
     HEAP32[i15 >> 2] = i4 + 1;
     i4 = HEAPU8[i4 >> 0] | 0;
     i12 = i5;
     break L11;
    } else {
     i4 = ___shgetc(i13) | 0;
     i12 = i5;
     break L11;
    }
   }
  default:
   i12 = 0;
  } while (0);
  i5 = (i3 | 0) == 0;
  do if ((i3 | 16 | 0) == 16 & (i4 | 0) == 48) {
   i4 = HEAP32[i15 >> 2] | 0;
   if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
    HEAP32[i15 >> 2] = i4 + 1;
    i4 = HEAPU8[i4 >> 0] | 0;
   } else i4 = ___shgetc(i13) | 0;
   if ((i4 | 32 | 0) != 120) if (i5) {
    i3 = 8;
    i10 = 46;
    break;
   } else {
    i10 = 32;
    break;
   }
   i3 = HEAP32[i15 >> 2] | 0;
   if (i3 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
    HEAP32[i15 >> 2] = i3 + 1;
    i4 = HEAPU8[i3 >> 0] | 0;
   } else i4 = ___shgetc(i13) | 0;
   if ((HEAPU8[gb + 41442 + 1 + i4 >> 0] | 0) > 15) {
    i1 = (HEAP32[i14 >> 2] | 0) == 0;
    if (!i1) HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + -1;
    if (!i6) {
     ___shlim(i13, 0);
     i2 = 0;
     i1 = 0;
     break L1;
    }
    if (i1) {
     i2 = 0;
     i1 = 0;
     break L1;
    }
    HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + -1;
    i2 = 0;
    i1 = 0;
    break L1;
   } else {
    i3 = 16;
    i10 = 46;
   }
  } else {
   i3 = i5 ? 10 : i3;
   if ((HEAPU8[gb + 41442 + 1 + i4 >> 0] | 0) >>> 0 < i3 >>> 0) i10 = 32; else {
    if (HEAP32[i14 >> 2] | 0) HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + -1;
    ___shlim(i13, 0);
    HEAP32[(___errno_location() | 0) >> 2] = 22;
    i2 = 0;
    i1 = 0;
    break L1;
   }
  } while (0);
  if ((i10 | 0) == 32) if ((i3 | 0) == 10) {
   i3 = i4 + -48 | 0;
   if (i3 >>> 0 < 10) {
    i4 = 0;
    while (1) {
     i5 = (i4 * 10 | 0) + i3 | 0;
     i3 = HEAP32[i15 >> 2] | 0;
     if (i3 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
      HEAP32[i15 >> 2] = i3 + 1;
      i4 = HEAPU8[i3 >> 0] | 0;
     } else i4 = ___shgetc(i13) | 0;
     i3 = i4 + -48 | 0;
     if (!(i3 >>> 0 < 10 & i5 >>> 0 < 429496729)) {
      i3 = i5;
      break;
     } else i4 = i5;
    }
    i5 = 0;
   } else {
    i3 = 0;
    i5 = 0;
   }
   i6 = i4 + -48 | 0;
   if (i6 >>> 0 < 10) {
    while (1) {
     i7 = ___muldi3(i3 | 0, i5 | 0, 10, 0) | 0;
     i8 = getTempRet0() | 0;
     i9 = ((i6 | 0) < 0) << 31 >> 31;
     i11 = ~i9;
     if (i8 >>> 0 > i11 >>> 0 | (i8 | 0) == (i11 | 0) & i7 >>> 0 > ~i6 >>> 0) {
      i7 = i3;
      break;
     }
     i3 = _i64Add(i7 | 0, i8 | 0, i6 | 0, i9 | 0) | 0;
     i5 = getTempRet0() | 0;
     i4 = HEAP32[i15 >> 2] | 0;
     if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
      HEAP32[i15 >> 2] = i4 + 1;
      i4 = HEAPU8[i4 >> 0] | 0;
     } else i4 = ___shgetc(i13) | 0;
     i6 = i4 + -48 | 0;
     if (!(i6 >>> 0 < 10 & (i5 >>> 0 < 429496729 | (i5 | 0) == 429496729 & i3 >>> 0 < 2576980378))) {
      i7 = i3;
      break;
     }
    }
    if (i6 >>> 0 > 9) {
     i4 = i7;
     i3 = i12;
    } else {
     i3 = 10;
     i10 = 72;
    }
   } else {
    i4 = i3;
    i3 = i12;
   }
  } else i10 = 46;
  L63 : do if ((i10 | 0) == 46) {
   if (!(i3 + -1 & i3)) {
    i10 = HEAP8[((i3 * 23 | 0) >>> 5 & 7) + (gb + 41699) >> 0] | 0;
    i5 = HEAP8[gb + 41442 + 1 + i4 >> 0] | 0;
    i6 = i5 & 255;
    if (i6 >>> 0 < i3 >>> 0) {
     i4 = 0;
     while (1) {
      i7 = i6 | i4 << i10;
      i4 = HEAP32[i15 >> 2] | 0;
      if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
       HEAP32[i15 >> 2] = i4 + 1;
       i4 = HEAPU8[i4 >> 0] | 0;
      } else i4 = ___shgetc(i13) | 0;
      i5 = HEAP8[gb + 41442 + 1 + i4 >> 0] | 0;
      i6 = i5 & 255;
      if (!(i7 >>> 0 < 134217728 & i6 >>> 0 < i3 >>> 0)) break; else i4 = i7;
     }
     i6 = 0;
    } else {
     i6 = 0;
     i7 = 0;
    }
    i8 = _bitshift64Lshr(-1, -1, i10 | 0) | 0;
    i9 = getTempRet0() | 0;
    if ((i5 & 255) >>> 0 >= i3 >>> 0 | (i6 >>> 0 > i9 >>> 0 | (i6 | 0) == (i9 | 0) & i7 >>> 0 > i8 >>> 0)) {
     i5 = i6;
     i10 = 72;
     break;
    } else i4 = i6;
    while (1) {
     i7 = _bitshift64Shl(i7 | 0, i4 | 0, i10 | 0) | 0;
     i6 = getTempRet0() | 0;
     i7 = i5 & 255 | i7;
     i4 = HEAP32[i15 >> 2] | 0;
     if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
      HEAP32[i15 >> 2] = i4 + 1;
      i4 = HEAPU8[i4 >> 0] | 0;
     } else i4 = ___shgetc(i13) | 0;
     i5 = HEAP8[gb + 41442 + 1 + i4 >> 0] | 0;
     if ((i5 & 255) >>> 0 >= i3 >>> 0 | (i6 >>> 0 > i9 >>> 0 | (i6 | 0) == (i9 | 0) & i7 >>> 0 > i8 >>> 0)) {
      i5 = i6;
      i10 = 72;
      break L63;
     } else i4 = i6;
    }
   }
   i5 = HEAP8[gb + 41442 + 1 + i4 >> 0] | 0;
   i6 = i5 & 255;
   if (i6 >>> 0 < i3 >>> 0) {
    i4 = 0;
    while (1) {
     i7 = i6 + (Math_imul(i4, i3) | 0) | 0;
     i4 = HEAP32[i15 >> 2] | 0;
     if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
      HEAP32[i15 >> 2] = i4 + 1;
      i4 = HEAPU8[i4 >> 0] | 0;
     } else i4 = ___shgetc(i13) | 0;
     i5 = HEAP8[gb + 41442 + 1 + i4 >> 0] | 0;
     i6 = i5 & 255;
     if (!(i7 >>> 0 < 119304647 & i6 >>> 0 < i3 >>> 0)) break; else i4 = i7;
    }
    i6 = 0;
   } else {
    i7 = 0;
    i6 = 0;
   }
   if ((i5 & 255) >>> 0 < i3 >>> 0) {
    i10 = ___udivdi3(-1, -1, i3 | 0, 0) | 0;
    i11 = getTempRet0() | 0;
    i9 = i6;
    while (1) {
     if (i9 >>> 0 > i11 >>> 0 | (i9 | 0) == (i11 | 0) & i7 >>> 0 > i10 >>> 0) {
      i5 = i9;
      i10 = 72;
      break L63;
     }
     i6 = ___muldi3(i7 | 0, i9 | 0, i3 | 0, 0) | 0;
     i8 = getTempRet0() | 0;
     i5 = i5 & 255;
     if (i8 >>> 0 > 4294967295 | (i8 | 0) == -1 & i6 >>> 0 > ~i5 >>> 0) {
      i5 = i9;
      i10 = 72;
      break L63;
     }
     i7 = _i64Add(i5 | 0, 0, i6 | 0, i8 | 0) | 0;
     i6 = getTempRet0() | 0;
     i4 = HEAP32[i15 >> 2] | 0;
     if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
      HEAP32[i15 >> 2] = i4 + 1;
      i4 = HEAPU8[i4 >> 0] | 0;
     } else i4 = ___shgetc(i13) | 0;
     i5 = HEAP8[gb + 41442 + 1 + i4 >> 0] | 0;
     if ((i5 & 255) >>> 0 >= i3 >>> 0) {
      i5 = i6;
      i10 = 72;
      break;
     } else i9 = i6;
    }
   } else {
    i5 = i6;
    i10 = 72;
   }
  } while (0);
  if ((i10 | 0) == 72) if ((HEAPU8[gb + 41442 + 1 + i4 >> 0] | 0) >>> 0 < i3 >>> 0) {
   do {
    i4 = HEAP32[i15 >> 2] | 0;
    if (i4 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0) {
     HEAP32[i15 >> 2] = i4 + 1;
     i4 = HEAPU8[i4 >> 0] | 0;
    } else i4 = ___shgetc(i13) | 0;
   } while ((HEAPU8[gb + 41442 + 1 + i4 >> 0] | 0) >>> 0 < i3 >>> 0);
   HEAP32[(___errno_location() | 0) >> 2] = 34;
   i5 = i2;
   i4 = i1;
   i3 = (i1 & 1 | 0) == 0 & 0 == 0 ? i12 : 0;
  } else {
   i4 = i7;
   i3 = i12;
  }
  if (HEAP32[i14 >> 2] | 0) HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + -1;
  if (!(i5 >>> 0 < i2 >>> 0 | (i5 | 0) == (i2 | 0) & i4 >>> 0 < i1 >>> 0)) {
   if (!((i1 & 1 | 0) != 0 | 0 != 0 | (i3 | 0) != 0)) {
    HEAP32[(___errno_location() | 0) >> 2] = 34;
    i1 = _i64Add(i1 | 0, i2 | 0, -1, -1) | 0;
    i2 = getTempRet0() | 0;
    break;
   }
   if (i5 >>> 0 > i2 >>> 0 | (i5 | 0) == (i2 | 0) & i4 >>> 0 > i1 >>> 0) {
    HEAP32[(___errno_location() | 0) >> 2] = 34;
    break;
   }
  }
  i1 = ((i3 | 0) < 0) << 31 >> 31;
  i1 = _i64Subtract(i4 ^ i3 | 0, i5 ^ i1 | 0, i3 | 0, i1 | 0) | 0;
  i2 = getTempRet0() | 0;
 } while (0);
 setTempRet0(i2 | 0);
 return i1 | 0;
}

function runPostSets1() {
 HEAP32[gb + 820 >> 2] = (HEAP32[gb + 820 >> 2] | 0) + (gb + 32372 | 0);
 HEAP32[gb + 824 >> 2] = (HEAP32[gb + 824 >> 2] | 0) + (gb + 32380 | 0);
 HEAP32[gb + 836 >> 2] = (HEAP32[gb + 836 >> 2] | 0) + (gb + 32418 | 0);
 HEAP32[gb + 840 >> 2] = (HEAP32[gb + 840 >> 2] | 0) + (gb + 32426 | 0);
 HEAP32[gb + 852 >> 2] = (HEAP32[gb + 852 >> 2] | 0) + (gb + 32464 | 0);
 HEAP32[gb + 856 >> 2] = (HEAP32[gb + 856 >> 2] | 0) + (gb + 32469 | 0);
 HEAP32[gb + 868 >> 2] = (HEAP32[gb + 868 >> 2] | 0) + (gb + 32496 | 0);
 HEAP32[gb + 872 >> 2] = (HEAP32[gb + 872 >> 2] | 0) + (gb + 32501 | 0);
 HEAP32[gb + 884 >> 2] = (HEAP32[gb + 884 >> 2] | 0) + (gb + 32528 | 0);
 HEAP32[gb + 888 >> 2] = (HEAP32[gb + 888 >> 2] | 0) + (gb + 32533 | 0);
 HEAP32[gb + 900 >> 2] = (HEAP32[gb + 900 >> 2] | 0) + (gb + 32560 | 0);
 HEAP32[gb + 904 >> 2] = (HEAP32[gb + 904 >> 2] | 0) + (gb + 32566 | 0);
 HEAP32[gb + 916 >> 2] = (HEAP32[gb + 916 >> 2] | 0) + (gb + 32594 | 0);
 HEAP32[gb + 920 >> 2] = (HEAP32[gb + 920 >> 2] | 0) + (gb + 32600 | 0);
 HEAP32[gb + 932 >> 2] = (HEAP32[gb + 932 >> 2] | 0) + (gb + 32628 | 0);
 HEAP32[gb + 936 >> 2] = (HEAP32[gb + 936 >> 2] | 0) + (gb + 32634 | 0);
 HEAP32[gb + 948 >> 2] = (HEAP32[gb + 948 >> 2] | 0) + (gb + 32662 | 0);
 HEAP32[gb + 952 >> 2] = (HEAP32[gb + 952 >> 2] | 0) + (gb + 32669 | 0);
 HEAP32[gb + 964 >> 2] = (HEAP32[gb + 964 >> 2] | 0) + (gb + 32698 | 0);
 HEAP32[gb + 968 >> 2] = (HEAP32[gb + 968 >> 2] | 0) + (gb + 32705 | 0);
 HEAP32[gb + 980 >> 2] = (HEAP32[gb + 980 >> 2] | 0) + (gb + 32734 | 0);
 HEAP32[gb + 984 >> 2] = (HEAP32[gb + 984 >> 2] | 0) + (gb + 32739 | 0);
 HEAP32[gb + 996 >> 2] = (HEAP32[gb + 996 >> 2] | 0) + (gb + 32777 | 0);
 HEAP32[gb + 1e3 >> 2] = (HEAP32[gb + 1e3 >> 2] | 0) + (gb + 32782 | 0);
 HEAP32[gb + 1012 >> 2] = (HEAP32[gb + 1012 >> 2] | 0) + (gb + 32820 | 0);
 HEAP32[gb + 1016 >> 2] = (HEAP32[gb + 1016 >> 2] | 0) + (gb + 32826 | 0);
 HEAP32[gb + 1028 >> 2] = (HEAP32[gb + 1028 >> 2] | 0) + (gb + 32865 | 0);
 HEAP32[gb + 1032 >> 2] = (HEAP32[gb + 1032 >> 2] | 0) + (gb + 32871 | 0);
 HEAP32[gb + 1044 >> 2] = (HEAP32[gb + 1044 >> 2] | 0) + (gb + 32910 | 0);
 HEAP32[gb + 1048 >> 2] = (HEAP32[gb + 1048 >> 2] | 0) + (gb + 32916 | 0);
 HEAP32[gb + 1060 >> 2] = (HEAP32[gb + 1060 >> 2] | 0) + (gb + 32955 | 0);
 HEAP32[gb + 1064 >> 2] = (HEAP32[gb + 1064 >> 2] | 0) + (gb + 32962 | 0);
 HEAP32[gb + 1076 >> 2] = (HEAP32[gb + 1076 >> 2] | 0) + (gb + 33002 | 0);
 HEAP32[gb + 1080 >> 2] = (HEAP32[gb + 1080 >> 2] | 0) + (gb + 33009 | 0);
 HEAP32[gb + 1092 >> 2] = (HEAP32[gb + 1092 >> 2] | 0) + (gb + 33049 | 0);
 HEAP32[gb + 1096 >> 2] = (HEAP32[gb + 1096 >> 2] | 0) + (gb + 33056 | 0);
 HEAP32[gb + 1108 >> 2] = (HEAP32[gb + 1108 >> 2] | 0) + (gb + 33096 | 0);
 HEAP32[gb + 1112 >> 2] = (HEAP32[gb + 1112 >> 2] | 0) + (gb + 33104 | 0);
 HEAP32[gb + 1124 >> 2] = (HEAP32[gb + 1124 >> 2] | 0) + (gb + 33145 | 0);
 HEAP32[gb + 1128 >> 2] = (HEAP32[gb + 1128 >> 2] | 0) + (gb + 33153 | 0);
 HEAP32[gb + 1140 >> 2] = (HEAP32[gb + 1140 >> 2] | 0) + (gb + 33194 | 0);
 HEAP32[gb + 1144 >> 2] = (HEAP32[gb + 1144 >> 2] | 0) + (gb + 33202 | 0);
 HEAP32[gb + 1156 >> 2] = (HEAP32[gb + 1156 >> 2] | 0) + (gb + 33243 | 0);
 HEAP32[gb + 1160 >> 2] = (HEAP32[gb + 1160 >> 2] | 0) + (gb + 33251 | 0);
 HEAP32[gb + 1172 >> 2] = (HEAP32[gb + 1172 >> 2] | 0) + (gb + 33292 | 0);
 HEAP32[gb + 1176 >> 2] = (HEAP32[gb + 1176 >> 2] | 0) + (gb + 33301 | 0);
 HEAP32[gb + 1188 >> 2] = (HEAP32[gb + 1188 >> 2] | 0) + (gb + 33343 | 0);
 HEAP32[gb + 1192 >> 2] = (HEAP32[gb + 1192 >> 2] | 0) + (gb + 33352 | 0);
 HEAP32[gb + 1204 >> 2] = (HEAP32[gb + 1204 >> 2] | 0) + (gb + 33394 | 0);
 HEAP32[gb + 1208 >> 2] = (HEAP32[gb + 1208 >> 2] | 0) + (gb + 33403 | 0);
 HEAP32[gb + 1220 >> 2] = (HEAP32[gb + 1220 >> 2] | 0) + (gb + 33445 | 0);
 HEAP32[gb + 1224 >> 2] = (HEAP32[gb + 1224 >> 2] | 0) + (gb + 33451 | 0);
 HEAP32[gb + 1236 >> 2] = (HEAP32[gb + 1236 >> 2] | 0) + (gb + 33484 | 0);
 HEAP32[gb + 1240 >> 2] = (HEAP32[gb + 1240 >> 2] | 0) + (gb + 33490 | 0);
 HEAP32[gb + 1252 >> 2] = (HEAP32[gb + 1252 >> 2] | 0) + (gb + 33523 | 0);
 HEAP32[gb + 1256 >> 2] = (HEAP32[gb + 1256 >> 2] | 0) + (gb + 33530 | 0);
 HEAP32[gb + 1268 >> 2] = (HEAP32[gb + 1268 >> 2] | 0) + (gb + 33564 | 0);
 HEAP32[gb + 1272 >> 2] = (HEAP32[gb + 1272 >> 2] | 0) + (gb + 33571 | 0);
 HEAP32[gb + 1284 >> 2] = (HEAP32[gb + 1284 >> 2] | 0) + (gb + 33605 | 0);
 HEAP32[gb + 1288 >> 2] = (HEAP32[gb + 1288 >> 2] | 0) + (gb + 33612 | 0);
 HEAP32[gb + 1300 >> 2] = (HEAP32[gb + 1300 >> 2] | 0) + (gb + 33646 | 0);
 HEAP32[gb + 1304 >> 2] = (HEAP32[gb + 1304 >> 2] | 0) + (gb + 33654 | 0);
 HEAP32[gb + 1316 >> 2] = (HEAP32[gb + 1316 >> 2] | 0) + (gb + 33689 | 0);
 HEAP32[gb + 1320 >> 2] = (HEAP32[gb + 1320 >> 2] | 0) + (gb + 33697 | 0);
 HEAP32[gb + 1332 >> 2] = (HEAP32[gb + 1332 >> 2] | 0) + (gb + 33732 | 0);
 HEAP32[gb + 1336 >> 2] = (HEAP32[gb + 1336 >> 2] | 0) + (gb + 33737 | 0);
 HEAP32[gb + 1348 >> 2] = (HEAP32[gb + 1348 >> 2] | 0) + (gb + 33763 | 0);
 HEAP32[gb + 1352 >> 2] = (HEAP32[gb + 1352 >> 2] | 0) + (gb + 33768 | 0);
 HEAP32[gb + 1364 >> 2] = (HEAP32[gb + 1364 >> 2] | 0) + (gb + 33798 | 0);
 HEAP32[gb + 1368 >> 2] = (HEAP32[gb + 1368 >> 2] | 0) + (gb + 33802 | 0);
 HEAP32[gb + 1380 >> 2] = (HEAP32[gb + 1380 >> 2] | 0) + (gb + 33822 | 0);
 HEAP32[gb + 1384 >> 2] = (HEAP32[gb + 1384 >> 2] | 0) + (gb + 33829 | 0);
 HEAP32[gb + 1396 >> 2] = (HEAP32[gb + 1396 >> 2] | 0) + (gb + 33845 | 0);
 HEAP32[gb + 1400 >> 2] = (HEAP32[gb + 1400 >> 2] | 0) + (gb + 33853 | 0);
 HEAP32[gb + 1412 >> 2] = (HEAP32[gb + 1412 >> 2] | 0) + (gb + 33870 | 0);
 HEAP32[gb + 1416 >> 2] = (HEAP32[gb + 1416 >> 2] | 0) + (gb + 33874 | 0);
 HEAP32[gb + 1428 >> 2] = (HEAP32[gb + 1428 >> 2] | 0) + (gb + 33879 | 0);
 HEAP32[gb + 1432 >> 2] = (HEAP32[gb + 1432 >> 2] | 0) + (gb + 33888 | 0);
 HEAP32[gb + 1444 >> 2] = (HEAP32[gb + 1444 >> 2] | 0) + (gb + 33914 | 0);
 HEAP32[gb + 1448 >> 2] = (HEAP32[gb + 1448 >> 2] | 0) + (gb + 33923 | 0);
 HEAP32[gb + 1460 >> 2] = (HEAP32[gb + 1460 >> 2] | 0) + (gb + 33949 | 0);
 HEAP32[gb + 1464 >> 2] = (HEAP32[gb + 1464 >> 2] | 0) + (gb + 33958 | 0);
 HEAP32[gb + 1476 >> 2] = (HEAP32[gb + 1476 >> 2] | 0) + (gb + 33984 | 0);
 HEAP32[gb + 1480 >> 2] = (HEAP32[gb + 1480 >> 2] | 0) + (gb + 33994 | 0);
 HEAP32[gb + 1492 >> 2] = (HEAP32[gb + 1492 >> 2] | 0) + (gb + 34022 | 0);
 HEAP32[gb + 1496 >> 2] = (HEAP32[gb + 1496 >> 2] | 0) + (gb + 34032 | 0);
 HEAP32[gb + 1508 >> 2] = (HEAP32[gb + 1508 >> 2] | 0) + (gb + 34060 | 0);
 HEAP32[gb + 1512 >> 2] = (HEAP32[gb + 1512 >> 2] | 0) + (gb + 34068 | 0);
 HEAP32[gb + 1524 >> 2] = (HEAP32[gb + 1524 >> 2] | 0) + (gb + 34093 | 0);
 HEAP32[gb + 1528 >> 2] = (HEAP32[gb + 1528 >> 2] | 0) + (gb + 34097 | 0);
 HEAP32[gb + 1568 >> 2] = (HEAP32[gb + 1568 >> 2] | 0) + (gb + 1540 | 0);
 HEAP32[gb + 1572 >> 2] = (HEAP32[gb + 1572 >> 2] | 0) + (gb + 1548 | 0);
 HEAP32[gb + 1576 >> 2] = (HEAP32[gb + 1576 >> 2] | 0) + (gb + 44160 | 0);
 HEAP32[gb + 1580 >> 2] = (HEAP32[gb + 1580 >> 2] | 0) + (gb + 1556 | 0);
 HEAP32[gb + 1584 >> 2] = (HEAP32[gb + 1584 >> 2] | 0) + (gb + 34192 | 0);
 HEAP32[gb + 1616 >> 2] = (HEAP32[gb + 1616 >> 2] | 0) + (gb + 1588 | 0);
 HEAP32[gb + 1620 >> 2] = (HEAP32[gb + 1620 >> 2] | 0) + (gb + 1596 | 0);
 HEAP32[gb + 1624 >> 2] = (HEAP32[gb + 1624 >> 2] | 0) + (gb + 44168 | 0);
 HEAP32[gb + 1628 >> 2] = (HEAP32[gb + 1628 >> 2] | 0) + (gb + 1604 | 0);
 HEAP32[gb + 1632 >> 2] = (HEAP32[gb + 1632 >> 2] | 0) + (gb + 34196 | 0);
 runPostSets2();
}

function runPostSets() {
 HEAP32[gb + 0 >> 2] = (HEAP32[gb + 0 >> 2] | 0) + (gb + 31861 | 0);
 HEAP32[gb + 4 >> 2] = (HEAP32[gb + 4 >> 2] | 0) + (gb + 31861 | 0);
 HEAP32[gb + 8 >> 2] = (HEAP32[gb + 8 >> 2] | 0) + (gb + 10936 | 0);
 HEAP32[gb + 12 >> 2] = (HEAP32[gb + 12 >> 2] | 0) + (gb + 10936 | 0);
 HEAP32[gb + 16 >> 2] = (HEAP32[gb + 16 >> 2] | 0) + (gb + 10505 | 0);
 HEAP32[gb + 20 >> 2] = (HEAP32[gb + 20 >> 2] | 0) + (gb + 10514 | 0);
 HEAP32[gb + 24 >> 2] = (HEAP32[gb + 24 >> 2] | 0) + (gb + 10531 | 0);
 HEAP32[gb + 28 >> 2] = (HEAP32[gb + 28 >> 2] | 0) + (gb + 10536 | 0);
 HEAP32[gb + 32 >> 2] = (HEAP32[gb + 32 >> 2] | 0) + (gb + 10548 | 0);
 HEAP32[gb + 36 >> 2] = (HEAP32[gb + 36 >> 2] | 0) + (gb + 10554 | 0);
 HEAP32[gb + 40 >> 2] = (HEAP32[gb + 40 >> 2] | 0) + (gb + 10567 | 0);
 HEAP32[gb + 44 >> 2] = (HEAP32[gb + 44 >> 2] | 0) + (gb + 10573 | 0);
 HEAP32[gb + 48 >> 2] = (HEAP32[gb + 48 >> 2] | 0) + (gb + 10586 | 0);
 HEAP32[gb + 52 >> 2] = (HEAP32[gb + 52 >> 2] | 0) + (gb + 10592 | 0);
 HEAP32[gb + 56 >> 2] = (HEAP32[gb + 56 >> 2] | 0) + (gb + 31861 | 0);
 HEAP32[gb + 60 >> 2] = (HEAP32[gb + 60 >> 2] | 0) + (gb + 31861 | 0);
 HEAP32[gb + 64 >> 2] = (HEAP32[gb + 64 >> 2] | 0) + (gb + 10936 | 0);
 HEAP32[gb + 68 >> 2] = (HEAP32[gb + 68 >> 2] | 0) + (gb + 10936 | 0);
 HEAP32[gb + 72 >> 2] = (HEAP32[gb + 72 >> 2] | 0) + (gb + 10941 | 0);
 HEAP32[gb + 76 >> 2] = (HEAP32[gb + 76 >> 2] | 0) + (gb + 10946 | 0);
 HEAP32[gb + 80 >> 2] = (HEAP32[gb + 80 >> 2] | 0) + (gb + 10956 | 0);
 HEAP32[gb + 84 >> 2] = (HEAP32[gb + 84 >> 2] | 0) + (gb + 10961 | 0);
 HEAP32[gb + 88 >> 2] = (HEAP32[gb + 88 >> 2] | 0) + (gb + 10971 | 0);
 HEAP32[gb + 92 >> 2] = (HEAP32[gb + 92 >> 2] | 0) + (gb + 10975 | 0);
 HEAP32[gb + 96 >> 2] = (HEAP32[gb + 96 >> 2] | 0) + (gb + 10988 | 0);
 HEAP32[gb + 100 >> 2] = (HEAP32[gb + 100 >> 2] | 0) + (gb + 10992 | 0);
 HEAP32[gb + 104 >> 2] = (HEAP32[gb + 104 >> 2] | 0) + (gb + 11005 | 0);
 HEAP32[gb + 108 >> 2] = (HEAP32[gb + 108 >> 2] | 0) + (gb + 11010 | 0);
 HEAP32[gb + 112 >> 2] = (HEAP32[gb + 112 >> 2] | 0) + (gb + 11024 | 0);
 HEAP32[gb + 116 >> 2] = (HEAP32[gb + 116 >> 2] | 0) + (gb + 11030 | 0);
 HEAP32[gb + 120 >> 2] = (HEAP32[gb + 120 >> 2] | 0) + (gb + 11043 | 0);
 HEAP32[gb + 124 >> 2] = (HEAP32[gb + 124 >> 2] | 0) + (gb + 11054 | 0);
 HEAP32[gb + 128 >> 2] = (HEAP32[gb + 128 >> 2] | 0) + (gb + 11069 | 0);
 HEAP32[gb + 132 >> 2] = (HEAP32[gb + 132 >> 2] | 0) + (gb + 11080 | 0);
 HEAP32[gb + 136 >> 2] = (HEAP32[gb + 136 >> 2] | 0) + (gb + 11095 | 0);
 HEAP32[gb + 140 >> 2] = (HEAP32[gb + 140 >> 2] | 0) + (gb + 11106 | 0);
 HEAP32[gb + 144 >> 2] = (HEAP32[gb + 144 >> 2] | 0) + (gb + 11121 | 0);
 HEAP32[gb + 148 >> 2] = (HEAP32[gb + 148 >> 2] | 0) + (gb + 11125 | 0);
 HEAP32[gb + 152 >> 2] = (HEAP32[gb + 152 >> 2] | 0) + (gb + 11148 | 0);
 HEAP32[gb + 156 >> 2] = (HEAP32[gb + 156 >> 2] | 0) + (gb + 11152 | 0);
 HEAP32[gb + 160 >> 2] = (HEAP32[gb + 160 >> 2] | 0) + (gb + 11175 | 0);
 HEAP32[gb + 164 >> 2] = (HEAP32[gb + 164 >> 2] | 0) + (gb + 11179 | 0);
 HEAP32[gb + 168 >> 2] = (HEAP32[gb + 168 >> 2] | 0) + (gb + 11202 | 0);
 HEAP32[gb + 172 >> 2] = (HEAP32[gb + 172 >> 2] | 0) + (gb + 11207 | 0);
 HEAP32[gb + 176 >> 2] = (HEAP32[gb + 176 >> 2] | 0) + (gb + 11231 | 0);
 HEAP32[gb + 180 >> 2] = (HEAP32[gb + 180 >> 2] | 0) + (gb + 11238 | 0);
 HEAP32[gb + 184 >> 2] = (HEAP32[gb + 184 >> 2] | 0) + (gb + 11273 | 0);
 HEAP32[gb + 188 >> 2] = (HEAP32[gb + 188 >> 2] | 0) + (gb + 11280 | 0);
 HEAP32[gb + 192 >> 2] = (HEAP32[gb + 192 >> 2] | 0) + (gb + 11315 | 0);
 HEAP32[gb + 196 >> 2] = (HEAP32[gb + 196 >> 2] | 0) + (gb + 11322 | 0);
 HEAP32[gb + 200 >> 2] = (HEAP32[gb + 200 >> 2] | 0) + (gb + 11357 | 0);
 HEAP32[gb + 204 >> 2] = (HEAP32[gb + 204 >> 2] | 0) + (gb + 11364 | 0);
 HEAP32[gb + 208 >> 2] = (HEAP32[gb + 208 >> 2] | 0) + (gb + 11399 | 0);
 HEAP32[gb + 212 >> 2] = (HEAP32[gb + 212 >> 2] | 0) + (gb + 11406 | 0);
 HEAP32[gb + 216 >> 2] = (HEAP32[gb + 216 >> 2] | 0) + (gb + 11441 | 0);
 HEAP32[gb + 220 >> 2] = (HEAP32[gb + 220 >> 2] | 0) + (gb + 11448 | 0);
 HEAP32[gb + 224 >> 2] = (HEAP32[gb + 224 >> 2] | 0) + (gb + 11483 | 0);
 HEAP32[gb + 228 >> 2] = (HEAP32[gb + 228 >> 2] | 0) + (gb + 11490 | 0);
 HEAP32[gb + 232 >> 2] = (HEAP32[gb + 232 >> 2] | 0) + (gb + 11525 | 0);
 HEAP32[gb + 236 >> 2] = (HEAP32[gb + 236 >> 2] | 0) + (gb + 11532 | 0);
 HEAP32[gb + 240 >> 2] = (HEAP32[gb + 240 >> 2] | 0) + (gb + 11567 | 0);
 HEAP32[gb + 244 >> 2] = (HEAP32[gb + 244 >> 2] | 0) + (gb + 11574 | 0);
 HEAP32[gb + 248 >> 2] = (HEAP32[gb + 248 >> 2] | 0) + (gb + 11609 | 0);
 HEAP32[gb + 252 >> 2] = (HEAP32[gb + 252 >> 2] | 0) + (gb + 11616 | 0);
 HEAP32[gb + 256 >> 2] = (HEAP32[gb + 256 >> 2] | 0) + (gb + 11651 | 0);
 HEAP32[gb + 260 >> 2] = (HEAP32[gb + 260 >> 2] | 0) + (gb + 11658 | 0);
 HEAP32[gb + 264 >> 2] = (HEAP32[gb + 264 >> 2] | 0) + (gb + 11693 | 0);
 HEAP32[gb + 268 >> 2] = (HEAP32[gb + 268 >> 2] | 0) + (gb + 11700 | 0);
 HEAP32[gb + 272 >> 2] = (HEAP32[gb + 272 >> 2] | 0) + (gb + 11735 | 0);
 HEAP32[gb + 276 >> 2] = (HEAP32[gb + 276 >> 2] | 0) + (gb + 11739 | 0);
 HEAP32[gb + 580 >> 2] = (HEAP32[gb + 580 >> 2] | 0) + (gb + 31861 | 0);
 HEAP32[gb + 584 >> 2] = (HEAP32[gb + 584 >> 2] | 0) + (gb + 31869 | 0);
 HEAP32[gb + 596 >> 2] = (HEAP32[gb + 596 >> 2] | 0) + (gb + 31876 | 0);
 HEAP32[gb + 600 >> 2] = (HEAP32[gb + 600 >> 2] | 0) + (gb + 31881 | 0);
 HEAP32[gb + 612 >> 2] = (HEAP32[gb + 612 >> 2] | 0) + (gb + 31904 | 0);
 HEAP32[gb + 616 >> 2] = (HEAP32[gb + 616 >> 2] | 0) + (gb + 31909 | 0);
 HEAP32[gb + 628 >> 2] = (HEAP32[gb + 628 >> 2] | 0) + (gb + 31932 | 0);
 HEAP32[gb + 632 >> 2] = (HEAP32[gb + 632 >> 2] | 0) + (gb + 31937 | 0);
 HEAP32[gb + 644 >> 2] = (HEAP32[gb + 644 >> 2] | 0) + (gb + 31960 | 0);
 HEAP32[gb + 648 >> 2] = (HEAP32[gb + 648 >> 2] | 0) + (gb + 31966 | 0);
 HEAP32[gb + 660 >> 2] = (HEAP32[gb + 660 >> 2] | 0) + (gb + 31990 | 0);
 HEAP32[gb + 664 >> 2] = (HEAP32[gb + 664 >> 2] | 0) + (gb + 31996 | 0);
 HEAP32[gb + 676 >> 2] = (HEAP32[gb + 676 >> 2] | 0) + (gb + 32020 | 0);
 HEAP32[gb + 680 >> 2] = (HEAP32[gb + 680 >> 2] | 0) + (gb + 32026 | 0);
 HEAP32[gb + 692 >> 2] = (HEAP32[gb + 692 >> 2] | 0) + (gb + 32050 | 0);
 HEAP32[gb + 696 >> 2] = (HEAP32[gb + 696 >> 2] | 0) + (gb + 32057 | 0);
 HEAP32[gb + 708 >> 2] = (HEAP32[gb + 708 >> 2] | 0) + (gb + 32082 | 0);
 HEAP32[gb + 712 >> 2] = (HEAP32[gb + 712 >> 2] | 0) + (gb + 32089 | 0);
 HEAP32[gb + 724 >> 2] = (HEAP32[gb + 724 >> 2] | 0) + (gb + 32114 | 0);
 HEAP32[gb + 728 >> 2] = (HEAP32[gb + 728 >> 2] | 0) + (gb + 32120 | 0);
 HEAP32[gb + 740 >> 2] = (HEAP32[gb + 740 >> 2] | 0) + (gb + 32156 | 0);
 HEAP32[gb + 744 >> 2] = (HEAP32[gb + 744 >> 2] | 0) + (gb + 32162 | 0);
 HEAP32[gb + 756 >> 2] = (HEAP32[gb + 756 >> 2] | 0) + (gb + 32198 | 0);
 HEAP32[gb + 760 >> 2] = (HEAP32[gb + 760 >> 2] | 0) + (gb + 32204 | 0);
 HEAP32[gb + 772 >> 2] = (HEAP32[gb + 772 >> 2] | 0) + (gb + 32240 | 0);
 HEAP32[gb + 776 >> 2] = (HEAP32[gb + 776 >> 2] | 0) + (gb + 32247 | 0);
 HEAP32[gb + 788 >> 2] = (HEAP32[gb + 788 >> 2] | 0) + (gb + 32284 | 0);
 HEAP32[gb + 792 >> 2] = (HEAP32[gb + 792 >> 2] | 0) + (gb + 32291 | 0);
 HEAP32[gb + 804 >> 2] = (HEAP32[gb + 804 >> 2] | 0) + (gb + 32328 | 0);
 HEAP32[gb + 808 >> 2] = (HEAP32[gb + 808 >> 2] | 0) + (gb + 32335 | 0);
 runPostSets1();
}

function _lex_scan_string(i3, i1) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i23 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i18 = i23 + 72 | 0;
 i17 = i23 + 64 | 0;
 i16 = i23 + 56 | 0;
 i15 = i23 + 48 | 0;
 i14 = i23 + 40 | 0;
 i6 = i23 + 32 | 0;
 i5 = i23 + 24 | 0;
 i21 = i23 + 16 | 0;
 i20 = i23 + 8 | 0;
 i4 = i23;
 i22 = i23 + 108 | 0;
 i8 = i23 + 104 | 0;
 i19 = i23 + 100 | 0;
 i10 = i23 + 96 | 0;
 i11 = i23 + 92 | 0;
 i2 = i23 + 88 | 0;
 i9 = i23 + 84 | 0;
 i12 = i23 + 80 | 0;
 i13 = i23 + 76 | 0;
 HEAP32[i22 >> 2] = i3;
 HEAP32[i8 >> 2] = i1;
 HEAP32[(HEAP32[i22 >> 2] | 0) + 64 >> 2] = 0;
 HEAP32[(HEAP32[i22 >> 2] | 0) + 56 >> 2] = -1;
 HEAP32[i19 >> 2] = _lex_get_save(HEAP32[i22 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
 L1 : while (1) {
  if ((HEAP32[i19 >> 2] | 0) == 34) {
   i7 = 22;
   break;
  }
  if ((HEAP32[i19 >> 2] | 0) == -2) break;
  if ((HEAP32[i19 >> 2] | 0) == -1) {
   i7 = 5;
   break;
  }
  if (0 <= (HEAP32[i19 >> 2] | 0) & (HEAP32[i19 >> 2] | 0) <= 31) {
   i7 = 7;
   break;
  }
  i3 = (HEAP32[i19 >> 2] | 0) == 92;
  HEAP32[i19 >> 2] = _lex_get_save(HEAP32[i22 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  if (!i3) continue;
  if ((HEAP32[i19 >> 2] | 0) != 117) {
   if (!((HEAP32[i19 >> 2] | 0) == 34 | (HEAP32[i19 >> 2] | 0) == 92 | (HEAP32[i19 >> 2] | 0) == 47 | (HEAP32[i19 >> 2] | 0) == 98 | (HEAP32[i19 >> 2] | 0) == 102 | (HEAP32[i19 >> 2] | 0) == 110 | (HEAP32[i19 >> 2] | 0) == 114 | (HEAP32[i19 >> 2] | 0) == 116)) {
    i7 = 21;
    break;
   }
   HEAP32[i19 >> 2] = _lex_get_save(HEAP32[i22 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   continue;
  }
  HEAP32[i19 >> 2] = _lex_get_save(HEAP32[i22 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  HEAP32[i2 >> 2] = 0;
  while (1) {
   if ((HEAP32[i2 >> 2] | 0) >= 4) continue L1;
   if ((!(48 <= (HEAP32[i19 >> 2] | 0) & (HEAP32[i19 >> 2] | 0) <= 57) ? !(65 <= (HEAP32[i19 >> 2] | 0) & (HEAP32[i19 >> 2] | 0) <= 70) : 0) ? !(97 <= (HEAP32[i19 >> 2] | 0) & (HEAP32[i19 >> 2] | 0) <= 102) : 0) {
    i7 = 17;
    break L1;
   }
   HEAP32[i19 >> 2] = _lex_get_save(HEAP32[i22 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + 1;
  }
 }
 do if ((i7 | 0) == 5) _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i22 >> 2] | 0, gb + 40664 | 0, i4); else if ((i7 | 0) == 7) {
  _lex_unget_unsave(HEAP32[i22 >> 2] | 0, HEAP32[i19 >> 2] | 0);
  i1 = HEAP32[i8 >> 2] | 0;
  i2 = HEAP32[i22 >> 2] | 0;
  i3 = HEAP32[i19 >> 2] | 0;
  if ((HEAP32[i19 >> 2] | 0) == 10) {
   HEAP32[i20 >> 2] = i3;
   _error_set(i1, i2, gb + 40787 | 0, i20);
   break;
  } else {
   HEAP32[i21 >> 2] = i3;
   _error_set(i1, i2, gb + 40806 | 0, i21);
   break;
  }
 } else if ((i7 | 0) == 17) _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i22 >> 2] | 0, gb + 40829 | 0, i5); else if ((i7 | 0) == 21) _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i22 >> 2] | 0, gb + 40829 | 0, i6); else if ((i7 | 0) == 22 ? (HEAP32[i11 >> 2] = _jsonp_malloc((HEAP32[(HEAP32[i22 >> 2] | 0) + 40 + 4 >> 2] | 0) + 1 | 0) | 0, HEAP32[i11 >> 2] | 0) : 0) {
  HEAP32[(HEAP32[i22 >> 2] | 0) + 64 >> 2] = HEAP32[i11 >> 2];
  HEAP32[i10 >> 2] = (_strbuffer_value((HEAP32[i22 >> 2] | 0) + 40 | 0) | 0) + 1;
  L22 : while (1) {
   if ((HEAP8[HEAP32[i10 >> 2] >> 0] | 0) == 34) {
    i7 = 53;
    break;
   }
   i21 = (HEAP8[HEAP32[i10 >> 2] >> 0] | 0) == 92;
   i1 = HEAP32[i10 >> 2] | 0;
   HEAP32[i10 >> 2] = i1 + 1;
   if (!i21) {
    i20 = HEAP8[i1 >> 0] | 0;
    i21 = HEAP32[i11 >> 2] | 0;
    HEAP32[i11 >> 2] = i21 + 1;
    HEAP8[i21 >> 0] = i20;
    continue;
   }
   i1 = HEAP32[i10 >> 2] | 0;
   if ((HEAP8[HEAP32[i10 >> 2] >> 0] | 0) != 117) {
    switch (HEAP8[i1 >> 0] | 0) {
    case 47:
    case 92:
    case 34:
     {
      HEAP8[HEAP32[i11 >> 2] >> 0] = HEAP8[HEAP32[i10 >> 2] >> 0] | 0;
      break;
     }
    case 98:
     {
      HEAP8[HEAP32[i11 >> 2] >> 0] = 8;
      break;
     }
    case 102:
     {
      HEAP8[HEAP32[i11 >> 2] >> 0] = 12;
      break;
     }
    case 110:
     {
      HEAP8[HEAP32[i11 >> 2] >> 0] = 10;
      break;
     }
    case 114:
     {
      HEAP8[HEAP32[i11 >> 2] >> 0] = 13;
      break;
     }
    case 116:
     {
      HEAP8[HEAP32[i11 >> 2] >> 0] = 9;
      break;
     }
    default:
     {
      i7 = 50;
      break L22;
     }
    }
    HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + 1;
    HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + 1;
    continue;
   }
   HEAP32[i12 >> 2] = _decode_unicode_escape(i1) | 0;
   if ((HEAP32[i12 >> 2] | 0) < 0) {
    i7 = 28;
    break;
   }
   HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + 5;
   if (!(55296 <= (HEAP32[i12 >> 2] | 0) & (HEAP32[i12 >> 2] | 0) <= 56319)) {
    if (56320 <= (HEAP32[i12 >> 2] | 0) & (HEAP32[i12 >> 2] | 0) <= 57343) {
     i7 = 39;
     break;
    }
   } else {
    if ((HEAP8[HEAP32[i10 >> 2] >> 0] | 0) != 92) {
     i7 = 37;
     break;
    }
    if ((HEAP8[(HEAP32[i10 >> 2] | 0) + 1 >> 0] | 0) != 117) {
     i7 = 37;
     break;
    }
    i21 = (HEAP32[i10 >> 2] | 0) + 1 | 0;
    HEAP32[i10 >> 2] = i21;
    HEAP32[i13 >> 2] = _decode_unicode_escape(i21) | 0;
    if ((HEAP32[i13 >> 2] | 0) < 0) {
     i7 = 33;
     break;
    }
    HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + 5;
    if (!(56320 <= (HEAP32[i13 >> 2] | 0) & (HEAP32[i13 >> 2] | 0) <= 57343)) {
     i7 = 36;
     break;
    }
    HEAP32[i12 >> 2] = ((HEAP32[i12 >> 2] | 0) - 55296 << 10) + ((HEAP32[i13 >> 2] | 0) - 56320) + 65536;
   }
   if (_utf8_encode(HEAP32[i12 >> 2] | 0, HEAP32[i11 >> 2] | 0, i9) | 0) {
    i7 = 41;
    break;
   }
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i9 >> 2] | 0);
  }
  if ((i7 | 0) == 28) {
   i20 = HEAP32[i8 >> 2] | 0;
   i21 = HEAP32[i22 >> 2] | 0;
   HEAP32[i14 >> 2] = (HEAP32[i10 >> 2] | 0) + -1;
   _error_set(i20, i21, gb + 40880 | 0, i14);
   break;
  } else if ((i7 | 0) == 33) {
   i20 = HEAP32[i8 >> 2] | 0;
   i21 = HEAP32[i22 >> 2] | 0;
   HEAP32[i15 >> 2] = (HEAP32[i10 >> 2] | 0) + -1;
   _error_set(i20, i21, gb + 40880 | 0, i15);
   break;
  } else if ((i7 | 0) == 36) {
   i20 = HEAP32[i8 >> 2] | 0;
   i21 = HEAP32[i22 >> 2] | 0;
   i19 = HEAP32[i13 >> 2] | 0;
   HEAP32[i16 >> 2] = HEAP32[i12 >> 2];
   HEAP32[i16 + 4 >> 2] = i19;
   _error_set(i20, i21, gb + 40910 | 0, i16);
   break;
  } else if ((i7 | 0) == 37) {
   i20 = HEAP32[i8 >> 2] | 0;
   i21 = HEAP32[i22 >> 2] | 0;
   HEAP32[i17 >> 2] = HEAP32[i12 >> 2];
   _error_set(i20, i21, gb + 40941 | 0, i17);
   break;
  } else if ((i7 | 0) == 39) {
   i20 = HEAP32[i8 >> 2] | 0;
   i21 = HEAP32[i22 >> 2] | 0;
   HEAP32[i18 >> 2] = HEAP32[i12 >> 2];
   _error_set(i20, i21, gb + 40941 | 0, i18);
   break;
  } else if ((i7 | 0) == 41) ___assert_fail(gb + 40966 | 0, gb + 40619 | 0, 441, gb + 40968 | 0); else if ((i7 | 0) == 50) ___assert_fail(gb + 40966 | 0, gb + 40619 | 0, 453, gb + 40968 | 0); else if ((i7 | 0) == 53) {
   HEAP8[HEAP32[i11 >> 2] >> 0] = 0;
   HEAP32[(HEAP32[i22 >> 2] | 0) + 64 + 4 >> 2] = (HEAP32[i11 >> 2] | 0) - (HEAP32[(HEAP32[i22 >> 2] | 0) + 64 >> 2] | 0);
   HEAP32[(HEAP32[i22 >> 2] | 0) + 56 >> 2] = 256;
   STACKTOP = i23;
   return;
  }
 } while (0);
 _lex_free_string(HEAP32[i22 >> 2] | 0);
 STACKTOP = i23;
 return;
}

function _fft_execute_dft_8(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, i6 = 0, i7 = 0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, d26 = 0.0, i27 = 0, i28 = 0, d29 = 0.0, d30 = 0.0, d31 = 0.0, d32 = 0.0, d33 = 0.0, d34 = 0.0, d35 = 0.0, d36 = 0.0, d37 = 0.0, d38 = 0.0, d39 = 0.0, d40 = 0.0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0;
 i23 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i6 = i23 + 48 | 0;
 i7 = i23 + 32 | 0;
 i17 = i23 + 16 | 0;
 i18 = i23;
 i21 = HEAP32[i1 + 4 >> 2] | 0;
 i25 = HEAP32[i1 + 8 >> 2] | 0;
 i16 = (HEAP32[i1 + 12 >> 2] | 0) == 1;
 i52 = HEAP32[i21 >> 2] | 0;
 i51 = HEAP32[i21 + 4 >> 2] | 0;
 i24 = i25 + 4 | 0;
 HEAP32[i25 >> 2] = i52;
 HEAP32[i24 >> 2] = i51;
 i54 = HEAP32[i21 + 32 >> 2] | 0;
 i53 = HEAP32[i21 + 36 >> 2] | 0;
 i1 = i25 + 8 | 0;
 i9 = i25 + 12 | 0;
 HEAP32[i1 >> 2] = i54;
 HEAP32[i9 >> 2] = i53;
 i48 = HEAP32[i21 + 16 >> 2] | 0;
 i47 = HEAP32[i21 + 20 >> 2] | 0;
 i10 = i25 + 16 | 0;
 i11 = i25 + 20 | 0;
 HEAP32[i10 >> 2] = i48;
 HEAP32[i11 >> 2] = i47;
 i50 = HEAP32[i21 + 48 >> 2] | 0;
 i49 = HEAP32[i21 + 52 >> 2] | 0;
 i19 = i25 + 24 | 0;
 i20 = i25 + 28 | 0;
 HEAP32[i19 >> 2] = i50;
 HEAP32[i20 >> 2] = i49;
 i44 = HEAP32[i21 + 8 >> 2] | 0;
 i43 = HEAP32[i21 + 12 >> 2] | 0;
 i28 = i25 + 32 | 0;
 i27 = i25 + 36 | 0;
 HEAP32[i28 >> 2] = i44;
 HEAP32[i27 >> 2] = i43;
 i46 = HEAP32[i21 + 40 >> 2] | 0;
 i45 = HEAP32[i21 + 44 >> 2] | 0;
 i12 = i25 + 40 | 0;
 i13 = i25 + 44 | 0;
 HEAP32[i12 >> 2] = i46;
 HEAP32[i13 >> 2] = i45;
 i42 = HEAP32[i21 + 24 >> 2] | 0;
 i41 = HEAP32[i21 + 28 >> 2] | 0;
 i14 = i25 + 48 | 0;
 i15 = i25 + 52 | 0;
 HEAP32[i14 >> 2] = i42;
 HEAP32[i15 >> 2] = i41;
 d40 = +HEAPF32[i21 + 56 >> 2];
 d39 = +HEAPF32[i21 + 60 >> 2];
 i21 = i25 + 56 | 0;
 i22 = i25 + 60 | 0;
 d35 = (HEAP32[tempDoublePtr >> 2] = i54, +HEAPF32[tempDoublePtr >> 2]);
 d36 = (HEAP32[tempDoublePtr >> 2] = i53, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i52, +HEAPF32[tempDoublePtr >> 2]);
 d2 = (HEAP32[tempDoublePtr >> 2] = i51, +HEAPF32[tempDoublePtr >> 2]);
 d34 = d3 - d35;
 d31 = d2 - d36;
 d3 = d35 + d3;
 d2 = d36 + d2;
 d36 = (HEAP32[tempDoublePtr >> 2] = i50, +HEAPF32[tempDoublePtr >> 2]);
 d35 = (HEAP32[tempDoublePtr >> 2] = i49, +HEAPF32[tempDoublePtr >> 2]);
 d38 = (HEAP32[tempDoublePtr >> 2] = i48, +HEAPF32[tempDoublePtr >> 2]);
 d37 = (HEAP32[tempDoublePtr >> 2] = i47, +HEAPF32[tempDoublePtr >> 2]);
 d32 = d38 - d36;
 d33 = d37 - d35;
 d38 = d36 + d38;
 d37 = d35 + d37;
 d35 = (HEAP32[tempDoublePtr >> 2] = i46, +HEAPF32[tempDoublePtr >> 2]);
 d36 = (HEAP32[tempDoublePtr >> 2] = i45, +HEAPF32[tempDoublePtr >> 2]);
 d26 = (HEAP32[tempDoublePtr >> 2] = i44, +HEAPF32[tempDoublePtr >> 2]);
 d4 = (HEAP32[tempDoublePtr >> 2] = i43, +HEAPF32[tempDoublePtr >> 2]);
 d30 = d26 - d35;
 d8 = d4 - d36;
 d26 = d35 + d26;
 d4 = d36 + d4;
 d36 = (HEAP32[tempDoublePtr >> 2] = i42, +HEAPF32[tempDoublePtr >> 2]);
 d35 = (HEAP32[tempDoublePtr >> 2] = i41, +HEAPF32[tempDoublePtr >> 2]);
 d29 = d36 - d40;
 d5 = d35 - d39;
 d36 = d40 + d36;
 d35 = d39 + d35;
 HEAPF32[i10 >> 2] = d3 - d38;
 HEAPF32[i11 >> 2] = d2 - d37;
 d3 = d38 + d3;
 d2 = d37 + d2;
 HEAPF32[i14 >> 2] = d26 - d36;
 HEAPF32[i15 >> 2] = d4 - d35;
 d26 = d36 + d26;
 d4 = d35 + d4;
 d35 = d32 * 0.0;
 d33 = i16 ? d33 - d35 : d35 - d33;
 d32 = i16 ? -d32 : d32;
 HEAPF32[i19 >> 2] = d34 - d33;
 HEAPF32[i20 >> 2] = d31 - d32;
 HEAPF32[i1 >> 2] = d34 + d33;
 HEAPF32[i9 >> 2] = d32 + d31;
 d31 = d29 * 0.0;
 d5 = i16 ? d5 - d31 : d31 - d5;
 d29 = i16 ? -d29 : d29;
 HEAPF32[i21 >> 2] = d30 - d5;
 HEAPF32[i22 >> 2] = d8 - d29;
 d5 = d30 + d5;
 d8 = d29 + d8;
 HEAPF32[i12 >> 2] = d5;
 HEAPF32[i13 >> 2] = d8;
 HEAPF32[i28 >> 2] = d3 - d26;
 HEAPF32[i27 >> 2] = d2 - d4;
 HEAPF32[i25 >> 2] = d26 + d3;
 HEAPF32[i24 >> 2] = d4 + d2;
 d2 = d5 * .7071067811865476;
 d4 = d8 * .7071067811865476;
 if (i16) {
  d3 = d2 + d4;
  d2 = d4 - d2;
  if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___muldc3(i6, d5, d8, .7071067811865476, -.7071067811865476);
   d3 = +HEAPF64[i6 >> 3];
   d2 = +HEAPF64[i6 + 8 >> 3];
  }
 } else {
  d3 = d2 - d4;
  d2 = d2 + d4;
  if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___muldc3(i7, d5, d8, .7071067811865476, .7071067811865476);
   d3 = +HEAPF64[i7 >> 3];
   d2 = +HEAPF64[i7 + 8 >> 3];
  }
 }
 d5 = d2;
 d4 = d3;
 d40 = +HEAPF32[i1 >> 2];
 d2 = +HEAPF32[i9 >> 2];
 HEAPF32[i12 >> 2] = d40 - d4;
 HEAPF32[i13 >> 2] = d2 - d5;
 HEAPF32[i1 >> 2] = d4 + d40;
 HEAPF32[i9 >> 2] = d5 + d2;
 d2 = +HEAPF32[i15 >> 2];
 d5 = +HEAPF32[i14 >> 2];
 d40 = d5 * 0.0;
 d2 = i16 ? d2 - d40 : d40 - d2;
 d5 = i16 ? -d5 : d5;
 d40 = +HEAPF32[i10 >> 2];
 d4 = +HEAPF32[i11 >> 2];
 HEAPF32[i14 >> 2] = d40 - d2;
 HEAPF32[i15 >> 2] = d4 - d5;
 HEAPF32[i10 >> 2] = d40 + d2;
 HEAPF32[i11 >> 2] = d5 + d4;
 d4 = +HEAPF32[i21 >> 2];
 d5 = +HEAPF32[i22 >> 2];
 d2 = d4 * -.7071067811865476;
 if (i16) {
  d40 = d5 * -.7071067811865476;
  d3 = d2 - d40;
  d2 = d2 + d40;
  if (!((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0))) {
   d37 = d3;
   d38 = d2;
   d39 = +HEAPF32[i19 >> 2];
   d40 = +HEAPF32[i20 >> 2];
   d35 = d39 - d37;
   d36 = d40 - d38;
   HEAPF32[i21 >> 2] = d35;
   HEAPF32[i22 >> 2] = d36;
   d39 = d37 + d39;
   d40 = d38 + d40;
   HEAPF32[i19 >> 2] = d39;
   HEAPF32[i20 >> 2] = d40;
   STACKTOP = i23;
   return;
  }
  ___muldc3(i17, d4, d5, -.7071067811865476, -.7071067811865476);
  d37 = +HEAPF64[i17 >> 3];
  d38 = +HEAPF64[i17 + 8 >> 3];
  d39 = +HEAPF32[i19 >> 2];
  d40 = +HEAPF32[i20 >> 2];
  d35 = d39 - d37;
  d36 = d40 - d38;
  HEAPF32[i21 >> 2] = d35;
  HEAPF32[i22 >> 2] = d36;
  d39 = d37 + d39;
  d40 = d38 + d40;
  HEAPF32[i19 >> 2] = d39;
  HEAPF32[i20 >> 2] = d40;
  STACKTOP = i23;
  return;
 } else {
  d3 = d5 * .7071067811865476;
  d2 = d2 - d3;
  d3 = d4 * .7071067811865476 - d3;
  if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
   d37 = d2;
   d38 = d3;
   d39 = +HEAPF32[i19 >> 2];
   d40 = +HEAPF32[i20 >> 2];
   d35 = d39 - d37;
   d36 = d40 - d38;
   HEAPF32[i21 >> 2] = d35;
   HEAPF32[i22 >> 2] = d36;
   d39 = d37 + d39;
   d40 = d38 + d40;
   HEAPF32[i19 >> 2] = d39;
   HEAPF32[i20 >> 2] = d40;
   STACKTOP = i23;
   return;
  }
  ___muldc3(i18, d4, d5, -.7071067811865476, .7071067811865476);
  d37 = +HEAPF64[i18 >> 3];
  d38 = +HEAPF64[i18 + 8 >> 3];
  d39 = +HEAPF32[i19 >> 2];
  d40 = +HEAPF32[i20 >> 2];
  d35 = d39 - d37;
  d36 = d40 - d38;
  HEAPF32[i21 >> 2] = d35;
  HEAPF32[i22 >> 2] = d36;
  d39 = d37 + d39;
  d40 = d38 + d40;
  HEAPF32[i19 >> 2] = d39;
  HEAPF32[i20 >> 2] = d40;
  STACKTOP = i23;
  return;
 }
}

function _qpilotsync_execute(i31, i36, i37) {
 i31 = i31 | 0;
 i36 = i36 | 0;
 i37 = i37 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, d18 = 0.0, d19 = 0.0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i38 = 0, i39 = 0, i40 = 0;
 i38 = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 i32 = i38 + 128 | 0;
 i1 = i38 + 120 | 0;
 i4 = i38 + 112 | 0;
 i10 = i38 + 104 | 0;
 i20 = i38 + 96 | 0;
 i21 = i38 + 88 | 0;
 i22 = i38 + 80 | 0;
 i23 = i38 + 72 | 0;
 i25 = i38 + 64 | 0;
 i26 = i38 + 56 | 0;
 i27 = i38 + 48 | 0;
 i24 = i38 + 40 | 0;
 i28 = i38 + 32 | 0;
 i29 = i38 + 24 | 0;
 i33 = i38 + 16 | 0;
 i34 = i38 + 8 | 0;
 i35 = i38;
 i30 = i31 + 8 | 0;
 if (HEAP32[i30 >> 2] | 0) {
  i9 = i31 + 4 | 0;
  i11 = i31 + 16 | 0;
  i12 = i4 + 4 | 0;
  i13 = i1 + 4 | 0;
  i15 = i10 + 4 | 0;
  i16 = i31 + 24 | 0;
  i17 = 0;
  do {
   i40 = Math_imul(HEAP32[i9 >> 2] | 0, i17) | 0;
   d5 = +HEAPF32[i36 + (i40 << 3) >> 2];
   d6 = +HEAPF32[i36 + (i40 << 3) + 4 >> 2];
   i40 = HEAP32[i11 >> 2] | 0;
   i39 = HEAP32[i40 + (i17 << 3) + 4 >> 2] | 0;
   HEAP32[i4 >> 2] = HEAP32[i40 + (i17 << 3) >> 2];
   HEAP32[i12 >> 2] = i39;
   HEAP32[i32 >> 2] = HEAP32[i4 >> 2];
   HEAP32[i32 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   _conjf(i1, i32);
   d7 = +HEAPF32[i1 >> 2];
   d8 = +HEAPF32[i13 >> 2];
   d3 = d5 * d7 - d6 * d8;
   d2 = d6 * d7 + d5 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i10, d5, d6, d7, d8);
    d3 = +HEAPF32[i10 >> 2];
    d2 = +HEAPF32[i15 >> 2];
   }
   i40 = HEAP32[i16 >> 2] | 0;
   HEAPF32[i40 + (i17 << 3) >> 2] = d3;
   HEAPF32[i40 + (i17 << 3) + 4 >> 2] = d2;
   i17 = i17 + 1 | 0;
  } while (i17 >>> 0 < (HEAP32[i30 >> 2] | 0) >>> 0);
 }
 _fft_execute(HEAP32[i31 + 32 >> 2] | 0);
 i13 = i31 + 20 | 0;
 i12 = i31 + 28 | 0;
 if (!(HEAP32[i13 >> 2] | 0)) {
  i1 = 0;
  i4 = 0;
  d2 = 0.0;
 } else {
  i9 = i21 + 4 | 0;
  i10 = i20 + 4 | 0;
  i11 = 0;
  i4 = 0;
  d2 = 0.0;
  do {
   if (!((i11 | 0) != 0 ? (i39 = HEAP32[i12 >> 2] | 0, i40 = HEAP32[i39 + (i11 << 3) + 4 >> 2] | 0, HEAP32[i20 >> 2] = HEAP32[i39 + (i11 << 3) >> 2], HEAP32[i10 >> 2] = i40, HEAP32[i32 >> 2] = HEAP32[i20 >> 2], HEAP32[i32 + 4 >> 2] = HEAP32[i20 + 4 >> 2], !(+_cabsf(i32) > d2)) : 0)) {
    i40 = HEAP32[i12 >> 2] | 0;
    i4 = HEAP32[i40 + (i11 << 3) + 4 >> 2] | 0;
    HEAP32[i21 >> 2] = HEAP32[i40 + (i11 << 3) >> 2];
    HEAP32[i9 >> 2] = i4;
    HEAP32[i32 >> 2] = HEAP32[i21 >> 2];
    HEAP32[i32 + 4 >> 2] = HEAP32[i21 + 4 >> 2];
    i4 = i11;
    d2 = +_cabsf(i32);
   }
   i11 = i11 + 1 | 0;
   i1 = HEAP32[i13 >> 2] | 0;
  } while (i11 >>> 0 < i1 >>> 0);
 }
 i17 = ((i4 + -1 + i1 | 0) >>> 0) % (i1 >>> 0) | 0;
 i16 = ((i4 + 1 | 0) >>> 0) % (i1 >>> 0) | 0;
 i39 = HEAP32[i12 >> 2] | 0;
 i40 = HEAP32[i39 + (i16 << 3) + 4 >> 2] | 0;
 HEAP32[i22 >> 2] = HEAP32[i39 + (i16 << 3) >> 2];
 HEAP32[i22 + 4 >> 2] = i40;
 HEAP32[i32 >> 2] = HEAP32[i22 >> 2];
 HEAP32[i32 + 4 >> 2] = HEAP32[i22 + 4 >> 2];
 d18 = +_cabsf(i32);
 i40 = HEAP32[i12 >> 2] | 0;
 i16 = HEAP32[i40 + (i17 << 3) + 4 >> 2] | 0;
 HEAP32[i23 >> 2] = HEAP32[i40 + (i17 << 3) >> 2];
 HEAP32[i23 + 4 >> 2] = i16;
 HEAP32[i32 >> 2] = HEAP32[i23 >> 2];
 HEAP32[i32 + 4 >> 2] = HEAP32[i23 + 4 >> 2];
 d19 = +_cabsf(i32);
 d2 = +(i4 >>> 0) + -((d18 - d19) * .5) / (((d18 + d19) * .5 - d2) * 2.0);
 i16 = HEAP32[i13 >> 2] | 0;
 i17 = i31 + 4 | 0;
 d2 = (i4 >>> 0 > i16 >>> 1 >>> 0 ? d2 - +(i16 >>> 0) : d2) * 2.0 * 3.141592653589793 / +((Math_imul(HEAP32[i17 >> 2] | 0, i16) | 0) >>> 0);
 i16 = i31 + 36 | 0;
 HEAPF32[i16 >> 2] = d2;
 L19 : do if (!(HEAP32[i30 >> 2] | 0)) {
  d3 = 0.0;
  d2 = 0.0;
 } else {
  i4 = i31 + 24 | 0;
  i9 = i25 + 4 | 0;
  i10 = i27 + 4 | 0;
  i11 = i26 + 4 | 0;
  i12 = i24 + 4 | 0;
  d5 = d2;
  i1 = 0;
  d3 = 0.0;
  d2 = 0.0;
  while (1) {
   i40 = HEAP32[i4 >> 2] | 0;
   d18 = +HEAPF32[i40 + (i1 << 3) >> 2];
   d19 = +HEAPF32[i40 + (i1 << 3) + 4 >> 2];
   d14 = d5 * -0.0;
   d7 = -d5;
   d8 = +(i1 >>> 0);
   d6 = d8 * d14 - d14;
   d5 = d8 * d7 + d14 * 0.0;
   if ((d6 != d6 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
    ___mulsc3(i25, d14, d7, d8, 0.0);
    d6 = +HEAPF32[i25 >> 2];
    d5 = +HEAPF32[i9 >> 2];
   }
   d7 = +((HEAP32[i17 >> 2] | 0) >>> 0);
   HEAPF32[i27 >> 2] = d6 * d7;
   HEAPF32[i10 >> 2] = d5 * d7;
   HEAP32[i32 >> 2] = HEAP32[i27 >> 2];
   HEAP32[i32 + 4 >> 2] = HEAP32[i27 + 4 >> 2];
   _cexpf(i26, i32);
   d7 = +HEAPF32[i26 >> 2];
   d8 = +HEAPF32[i11 >> 2];
   d5 = d18 * d7 - d19 * d8;
   d6 = d19 * d7 + d18 * d8;
   if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
    ___mulsc3(i24, d18, d19, d7, d8);
    d5 = +HEAPF32[i24 >> 2];
    d6 = +HEAPF32[i12 >> 2];
   }
   d3 = d3 + d5;
   d2 = d2 + d6;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= (HEAP32[i30 >> 2] | 0) >>> 0) break L19;
   d5 = +HEAPF32[i16 >> 2];
  }
 } while (0);
 HEAPF32[i28 >> 2] = d3;
 HEAPF32[i28 + 4 >> 2] = d2;
 HEAP32[i32 >> 2] = HEAP32[i28 >> 2];
 HEAP32[i32 + 4 >> 2] = HEAP32[i28 + 4 >> 2];
 i15 = i31 + 40 | 0;
 HEAPF32[i15 >> 2] = +_cargf(i32);
 HEAPF32[i29 >> 2] = d3;
 HEAPF32[i29 + 4 >> 2] = d2;
 HEAP32[i32 >> 2] = HEAP32[i29 >> 2];
 HEAP32[i32 + 4 >> 2] = HEAP32[i29 + 4 >> 2];
 d14 = +_cabsf(i32);
 d14 = d14 / +((HEAP32[i30 >> 2] | 0) >>> 0);
 HEAPF32[i31 + 44 >> 2] = d14;
 d14 = 1.0 / d14;
 i10 = i31 + 12 | 0;
 i1 = HEAP32[i10 >> 2] | 0;
 if (!i1) {
  STACKTOP = i38;
  return;
 }
 i11 = i34 + 4 | 0;
 i12 = i33 + 4 | 0;
 i13 = i35 + 4 | 0;
 i9 = 0;
 i4 = 0;
 do {
  if ((i9 >>> 0) % ((HEAP32[i17 >> 2] | 0) >>> 0) | 0) {
   d5 = d14 * +HEAPF32[i36 + (i9 << 3) >> 2];
   d6 = d14 * +HEAPF32[i36 + (i9 << 3) + 4 >> 2];
   d7 = +(i9 >>> 0) * +HEAPF32[i16 >> 2] + +HEAPF32[i15 >> 2];
   HEAPF32[i34 >> 2] = d7 * -0.0;
   HEAPF32[i11 >> 2] = -d7;
   HEAP32[i32 >> 2] = HEAP32[i34 >> 2];
   HEAP32[i32 + 4 >> 2] = HEAP32[i34 + 4 >> 2];
   _cexpf(i33, i32);
   d7 = +HEAPF32[i33 >> 2];
   d8 = +HEAPF32[i12 >> 2];
   d3 = d5 * d7 - d6 * d8;
   d2 = d6 * d7 + d5 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i35, d5, d6, d7, d8);
    d3 = +HEAPF32[i35 >> 2];
    d2 = +HEAPF32[i13 >> 2];
   }
   HEAPF32[i37 + (i4 << 3) >> 2] = d3;
   HEAPF32[i37 + (i4 << 3) + 4 >> 2] = d2;
   i1 = HEAP32[i10 >> 2] | 0;
   i4 = i4 + 1 | 0;
  }
  i9 = i9 + 1 | 0;
 } while (i9 >>> 0 < i1 >>> 0);
 STACKTOP = i38;
 return;
}

function _ofdmframesync_rxsymbol(i29) {
 i29 = i29 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i30 = 0, i31 = 0, i32 = 0;
 i31 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i19 = i31 + 56 | 0;
 i5 = i31 + 48 | 0;
 i30 = i31 + 40 | 0;
 i20 = i31 + 32 | 0;
 i21 = i31 + 24 | 0;
 i22 = i31 + 16 | 0;
 i23 = i31 + 8 | 0;
 i28 = i31;
 if (!(HEAP32[i29 >> 2] | 0)) i2 = 0; else {
  i11 = i29 + 100 | 0;
  i12 = i29 + 52 | 0;
  i10 = i5 + 4 | 0;
  i13 = 0;
  do {
   i2 = HEAP32[i11 >> 2] | 0;
   d6 = +HEAPF32[i2 + (i13 << 3) >> 2];
   d7 = +HEAPF32[i2 + (i13 << 3) + 4 >> 2];
   i2 = HEAP32[i12 >> 2] | 0;
   i1 = i2 + (i13 << 3) | 0;
   d8 = +HEAPF32[i1 >> 2];
   i2 = i2 + (i13 << 3) + 4 | 0;
   d9 = +HEAPF32[i2 >> 2];
   d4 = d6 * d8 - d7 * d9;
   d3 = d7 * d8 + d6 * d9;
   if ((d4 != d4 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
    ___mulsc3(i5, d8, d9, d6, d7);
    d4 = +HEAPF32[i5 >> 2];
    d3 = +HEAPF32[i10 >> 2];
   }
   HEAPF32[i1 >> 2] = d4;
   HEAPF32[i2 >> 2] = d3;
   i13 = i13 + 1 | 0;
   i1 = HEAP32[i29 >> 2] | 0;
  } while (i13 >>> 0 < i1 >>> 0);
  i2 = i1;
 }
 i25 = i29 + 20 | 0;
 i1 = HEAP32[i25 >> 2] | 0;
 i26 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 i27 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 do if (!i2) {
  i10 = i1;
  i1 = 0;
 } else {
  i11 = i29 + 4 | 0;
  i12 = i29 + 12 | 0;
  i13 = i29 + 112 | 0;
  i14 = i29 + 52 | 0;
  i15 = i21 + 4 | 0;
  i16 = i20 + 4 | 0;
  i17 = i22 + 4 | 0;
  i18 = i23 + 4 | 0;
  i10 = 0;
  i1 = 0;
  while (1) {
   i5 = (((HEAP32[i11 >> 2] | 0) + i10 | 0) >>> 0) % (i2 >>> 0) | 0;
   if ((HEAP8[(HEAP32[i12 >> 2] | 0) + i5 >> 0] | 0) == 1) {
    if ((i1 | 0) == (HEAP32[i25 >> 2] | 0)) break;
    i2 = (_msequence_advance(HEAP32[i13 >> 2] | 0) | 0) != 0;
    d3 = +(i5 >>> 0);
    if (i5 >>> 0 > (HEAP32[i11 >> 2] | 0) >>> 0) d3 = d3 - +((HEAP32[i29 >> 2] | 0) >>> 0);
    HEAPF32[i26 + (i1 << 2) >> 2] = d3;
    i32 = HEAP32[i14 >> 2] | 0;
    d9 = +HEAPF32[i32 + (i5 << 3) >> 2];
    d8 = +HEAPF32[i32 + (i5 << 3) + 4 >> 2];
    HEAPF32[i21 >> 2] = i2 ? 1.0 : -1.0;
    HEAPF32[i15 >> 2] = 0.0;
    HEAP32[i19 >> 2] = HEAP32[i21 >> 2];
    HEAP32[i19 + 4 >> 2] = HEAP32[i21 + 4 >> 2];
    _conjf(i20, i19);
    d6 = +HEAPF32[i20 >> 2];
    d7 = +HEAPF32[i16 >> 2];
    d4 = d9 * d6 - d8 * d7;
    d3 = d8 * d6 + d9 * d7;
    if ((d4 != d4 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
     ___mulsc3(i22, d9, d8, d6, d7);
     d4 = +HEAPF32[i22 >> 2];
     d3 = +HEAPF32[i17 >> 2];
    }
    HEAPF32[i23 >> 2] = d4;
    HEAPF32[i18 >> 2] = d3;
    HEAP32[i19 >> 2] = HEAP32[i23 >> 2];
    HEAP32[i19 + 4 >> 2] = HEAP32[i23 + 4 >> 2];
    HEAPF32[i27 + (i1 << 2) >> 2] = +_cargf(i19);
    i2 = HEAP32[i29 >> 2] | 0;
    i1 = i1 + 1 | 0;
   }
   i10 = i10 + 1 | 0;
   if (i10 >>> 0 >= i2 >>> 0) {
    i24 = 17;
    break;
   }
  }
  if ((i24 | 0) == 17) {
   i10 = HEAP32[i25 >> 2] | 0;
   break;
  }
  _fwrite(gb + 35977 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  STACKTOP = i31;
  return;
 } while (0);
 if ((i1 | 0) != (i10 | 0)) {
  _fwrite(gb + 35977 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  STACKTOP = i31;
  return;
 }
 if (i10 >>> 0 > 1) {
  d4 = +HEAPF32[i27 >> 2];
  i5 = 1;
  while (1) {
   i2 = i27 + (i5 << 2) | 0;
   d3 = +HEAPF32[i2 >> 2];
   i1 = i27 + (i5 + -1 << 2) | 0;
   if (d3 - d4 > 3.141592653589793) {
    do d3 = d3 + -6.283185307179586; while (d3 - d4 > 3.141592653589793);
    HEAPF32[i2 >> 2] = d3;
   }
   d4 = +HEAPF32[i1 >> 2];
   if (d3 - d4 < -3.141592653589793) {
    do d3 = d3 + 6.283185307179586; while (d3 - d4 < -3.141592653589793);
    HEAPF32[i2 >> 2] = d3;
   }
   i5 = i5 + 1 | 0;
   if (i5 >>> 0 >= i10 >>> 0) break; else d4 = d3;
  }
 }
 _polyf_fit(i26, i27, i10, i30, 2);
 i1 = i30 + 4 | 0;
 i32 = i29 + 120 | 0;
 d9 = +HEAPF32[i1 >> 2] * .30000001192092896 + +HEAPF32[i32 >> 2] * .699999988079071;
 HEAPF32[i1 >> 2] = d9;
 HEAPF32[i32 >> 2] = d9;
 if (HEAP32[i29 + 168 >> 2] | 0) {
  _memmove(HEAP32[i29 + 192 >> 2] | 0, i26 | 0, HEAP32[i25 >> 2] << 2 | 0) | 0;
  _memmove(HEAP32[i29 + 196 >> 2] | 0, i27 | 0, HEAP32[i25 >> 2] << 2 | 0) | 0;
  HEAP32[i29 + 200 >> 2] = HEAP32[i1 >> 2];
  i32 = HEAP32[i30 >> 2] | 0;
  HEAP32[i29 + 204 >> 2] = i32;
  _windowf_push(HEAP32[i29 + 208 >> 2] | 0, (HEAP32[tempDoublePtr >> 2] = i32, +HEAPF32[tempDoublePtr >> 2]));
  _windowf_push(HEAP32[i29 + 212 >> 2] | 0, +HEAPF32[i1 >> 2]);
 }
 i1 = HEAP32[i29 >> 2] | 0;
 if (i1 | 0) {
  i10 = i29 + 12 | 0;
  i11 = i29 + 52 | 0;
  i12 = i29 + 4 | 0;
  i13 = i28 + 4 | 0;
  i5 = 0;
  do {
   if (!(HEAP8[(HEAP32[i10 >> 2] | 0) + i5 >> 0] | 0)) {
    i32 = HEAP32[i11 >> 2] | 0;
    HEAPF32[i32 + (i5 << 3) >> 2] = 0.0;
    HEAPF32[i32 + (i5 << 3) + 4 >> 2] = 0.0;
   } else {
    d7 = +(i5 >>> 0);
    d7 = +_polyf_val(i30, 2, i5 >>> 0 > (HEAP32[i12 >> 2] | 0) >>> 0 ? d7 - +(i1 >>> 0) : d7);
    d6 = +Math_sin(+-d7);
    d7 = +Math_cos(+d7) + d6 * 0.0;
    i2 = HEAP32[i11 >> 2] | 0;
    i1 = i2 + (i5 << 3) | 0;
    d8 = +HEAPF32[i1 >> 2];
    i2 = i2 + (i5 << 3) + 4 | 0;
    d9 = +HEAPF32[i2 >> 2];
    d4 = d8 * d7 - d6 * d9;
    d3 = d6 * d8 + d7 * d9;
    if ((d4 != d4 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
     ___mulsc3(i28, d8, d9, d7, d6);
     d4 = +HEAPF32[i28 >> 2];
     d3 = +HEAPF32[i13 >> 2];
    }
    HEAPF32[i1 >> 2] = d4;
    HEAPF32[i2 >> 2] = d3;
   }
   i5 = i5 + 1 | 0;
   i1 = HEAP32[i29 >> 2] | 0;
  } while (i5 >>> 0 < i1 >>> 0);
 }
 i5 = i29 + 128 | 0;
 if (!(HEAP32[i5 >> 2] | 0)) {
  i1 = i29 + 116 | 0;
  i2 = 1;
 } else {
  i1 = i29 + 116 | 0;
  d3 = +HEAPF32[i30 >> 2] - +HEAPF32[i1 >> 2];
  d4 = d3;
  if (d4 > 3.141592653589793) do {
   d3 = d4 + -.6366197723675814;
   d4 = d3;
  } while (d4 > 3.141592653589793);
  d4 = d3;
  if (d4 < -3.141592653589793) do {
   d3 = d4 + .6366197723675814;
   d4 = d3;
  } while (d4 < -3.141592653589793);
  _nco_crcf_adjust_frequency(HEAP32[i29 + 108 >> 2] | 0, d3 * 1.0000000474974513e-03);
  i2 = (HEAP32[i5 >> 2] | 0) + 1 | 0;
 }
 HEAP32[i1 >> 2] = HEAP32[i30 >> 2];
 HEAP32[i5 >> 2] = i2;
 STACKTOP = i31;
 return;
}

function _quiet_encoder_emit(i33, i5, i36) {
 i33 = i33 | 0;
 i5 = i5 | 0;
 i36 = i36 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i34 = 0, i35 = 0, i37 = 0;
 i37 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i34 = i37 + 4 | 0;
 i35 = i37;
 if ((i33 | 0) == 0 | (i36 | 0) == 0) {
  i36 = 0;
  STACKTOP = i37;
  return i36 | 0;
 }
 i20 = i33 + 124 | 0;
 i26 = i33 + 128 | 0;
 i27 = i33 + 60 | 0;
 i28 = i33 + 92 | 0;
 i29 = i33 + 136 | 0;
 i30 = i33 + 140 | 0;
 i31 = i33 + 104 | 0;
 i32 = i33 + 116 | 0;
 i10 = i33 + 152 | 0;
 i11 = i33 + 44 | 0;
 i12 = i33 + 80 | 0;
 i13 = i33 + 132 | 0;
 i14 = i33 + 96 | 0;
 i15 = i33 + 96 | 0;
 i16 = i33 + 100 | 0;
 i17 = i33 + 64 | 0;
 i18 = i33 + 68 | 0;
 i19 = i33 + 72 | 0;
 i21 = i33 + 148 | 0;
 i22 = i33 + 120 | 0;
 i23 = i33 + 108 | 0;
 i24 = i33 + 4 | 0;
 i25 = i33 + 112 | 0;
 i1 = 0;
 L4 : while (1) {
  i9 = i36 - i1 | 0;
  i2 = (i1 | 0) != 0;
  d8 = +(i9 >>> 0);
  i3 = HEAP32[i20 >> 2] | 0;
  L6 : do if (!i3) while (1) {
   HEAP32[i26 >> 2] = 0;
   switch (HEAP32[i27 >> 2] | 0) {
   case 0:
    {
     i3 = _ofdmflexframegen_is_assembled(HEAP32[i14 >> 2] | 0) | 0;
     i6 = 12;
     break;
    }
   case 1:
    {
     i3 = _flexframegen_is_assembled(HEAP32[i15 >> 2] | 0) | 0;
     i6 = 12;
     break;
    }
   case 2:
    {
     i3 = _gmskframegen_is_assembled(HEAP32[i14 >> 2] | 0) | 0;
     i6 = 12;
     break;
    }
   default:
    i6 = 13;
   }
   if ((i6 | 0) == 12) {
    i6 = 0;
    if (!i3) i6 = 13; else {
     i7 = ~~+Math_ceil(+(d8 / +HEAPF32[i21 >> 2])) >>> 0;
     i3 = _modulator_symbol_len(HEAP32[i31 >> 2] | 0, i7) | 0;
     i3 = (((i7 >>> 0) % ((HEAP32[HEAP32[i31 >> 2] >> 2] | 0) >>> 0) | 0 | 0) != 0 & 1) + i3 | 0;
     L16 : do switch (HEAP32[i27 >> 2] | 0) {
     case 0:
      {
       _ofdmflexframegen_writesymbol(HEAP32[i14 >> 2] | 0, HEAP32[i23 >> 2] | 0) | 0;
       i3 = (HEAP32[i24 >> 2] | 0) + (HEAP32[i33 >> 2] | 0) | 0;
       break;
      }
     case 1:
      {
       i7 = HEAP32[i16 >> 2] | 0;
       i3 = i7 >>> 0 < i3 >>> 0 ? i7 : i3;
       if (i3 >>> 0 > (HEAP32[i25 >> 2] | 0) >>> 0) {
        i4 = _realloc(HEAP32[i23 >> 2] | 0, i3 << 3) | 0;
        HEAP32[i23 >> 2] = i4;
        HEAP32[i25 >> 2] = i3;
       } else i4 = HEAP32[i23 >> 2] | 0;
       _flexframegen_write_samples(HEAP32[i15 >> 2] | 0, i4, i3) | 0;
       HEAP32[i16 >> 2] = (HEAP32[i16 >> 2] | 0) - i3;
       break;
      }
     case 2:
      {
       i7 = HEAP32[i16 >> 2] | 0;
       i4 = (i3 >>> 0) % (i7 >>> 0) | 0;
       i4 = ((i4 | 0) == 0 ? 0 : i7 - i4 | 0) + i3 | 0;
       if (i4 >>> 0 > (HEAP32[i25 >> 2] | 0) >>> 0) {
        HEAP32[i23 >> 2] = _realloc(HEAP32[i23 >> 2] | 0, i4 << 3) | 0;
        HEAP32[i25 >> 2] = i4;
       }
       if (!i4) i3 = 0; else {
        i3 = 0;
        do {
         if (_gmskframegen_write_samples(HEAP32[i14 >> 2] | 0, (HEAP32[i23 >> 2] | 0) + (i3 << 3) | 0) | 0) break L16;
         i3 = (HEAP32[i16 >> 2] | 0) + i3 | 0;
        } while (i3 >>> 0 < i4 >>> 0);
       }
       break;
      }
     default:
      i3 = 0;
     } while (0);
     i4 = _modulator_sample_len(HEAP32[i31 >> 2] | 0, i3) | 0;
     if (i4 >>> 0 > (HEAP32[i22 >> 2] | 0) >>> 0) {
      i7 = _realloc(HEAP32[i32 >> 2] | 0, i4 << 2) | 0;
      HEAP32[i32 >> 2] = i7;
      HEAP32[i22 >> 2] = i4;
      i4 = i7;
     } else i4 = HEAP32[i32 >> 2] | 0;
     HEAP32[i20 >> 2] = _modulator_emit(HEAP32[i31 >> 2] | 0, HEAP32[i23 >> 2] | 0, i3, i4) | 0;
     HEAP8[i30 >> 0] = 0;
    }
   }
   do if ((i6 | 0) == 13) {
    i6 = 0;
    i4 = (HEAP8[i28 >> 0] | 0) != 0;
    i7 = HEAP32[i29 >> 2] | 0;
    i3 = (i7 | 0) == 0;
    if (!(i3 | i2 & i4)) {
     i4 = HEAP32[i12 >> 2] | 0;
     i4 = i4 >>> 0 < i7 >>> 0 ? i4 : i7;
     i6 = HEAP32[i13 >> 2] | 0;
     HEAP32[i13 >> 2] = i6 + i4;
     HEAP32[i29 >> 2] = i7 - i4;
     i3 = _calloc(1, 1) | 0;
     switch (HEAP32[i27 >> 2] | 0) {
     case 0:
      {
       _ofdmflexframegen_assemble(HEAP32[i14 >> 2] | 0, i3, i6, i4);
       break;
      }
     case 1:
      {
       _flexframegen_assemble(HEAP32[i15 >> 2] | 0, i3, i6, i4);
       HEAP32[i16 >> 2] = _flexframegen_getframelen(HEAP32[i15 >> 2] | 0) | 0;
       break;
      }
     case 2:
      {
       _gmskframegen_assemble(HEAP32[i14 >> 2] | 0, i3, i6, i4, HEAP32[i17 >> 2] | 0, HEAP32[i18 >> 2] | 0, HEAP32[i19 >> 2] | 0);
       break;
      }
     default:
      {}
     }
     _free(i3);
     break;
    }
    if (HEAP8[i30 >> 0] | 0) break L4;
    i7 = _modulator_flush(HEAP32[i31 >> 2] | 0, HEAP32[i32 >> 2] | 0) | 0;
    HEAP32[i20 >> 2] = i7;
    if (HEAP32[i10 >> 2] | 0) {
     i3 = HEAP32[i11 >> 2] | 0;
     if (!i3) i3 = 0; else {
      i4 = HEAP32[i32 >> 2] | 0;
      i6 = 0;
      do {
       HEAPF32[i4 + (i7 + i6 << 2) >> 2] = 0.0;
       i6 = i6 + 1 | 0;
      } while (i6 >>> 0 < i3 >>> 0);
     }
     HEAP32[i20 >> 2] = i7 + i3;
    }
    HEAP8[i30 >> 0] = 1;
   } while (0);
   i3 = HEAP32[i20 >> 2] | 0;
   if (i3 | 0) {
    i2 = i3;
    break L6;
   }
  } else i2 = i3; while (0);
  i3 = HEAP32[i10 >> 2] | 0;
  if (!i3) {
   i2 = _constrained_write((HEAP32[i32 >> 2] | 0) + (HEAP32[i26 >> 2] << 2) | 0, i2, i5, i9) | 0;
   HEAP32[i26 >> 2] = (HEAP32[i26 >> 2] | 0) + i2;
   HEAP32[i20 >> 2] = (HEAP32[i20 >> 2] | 0) - i2;
  } else {
   _resamp_rrrf_execute_output_block(i3, (HEAP32[i32 >> 2] | 0) + (HEAP32[i26 >> 2] << 2) | 0, i2, i34, i5, i9, i35) | 0;
   i2 = HEAP32[i35 >> 2] | 0;
   i9 = HEAP32[i34 >> 2] | 0;
   HEAP32[i26 >> 2] = (HEAP32[i26 >> 2] | 0) + i9;
   HEAP32[i20 >> 2] = (HEAP32[i20 >> 2] | 0) - i9;
  }
  i1 = i2 + i1 | 0;
  if (i1 >>> 0 < i36 >>> 0) i5 = i5 + (i2 << 2) | 0; else {
   i6 = 45;
   break;
  }
 }
 if ((i6 | 0) == 45) {
  STACKTOP = i37;
  return i1 | 0;
 }
 if (i3 | i2 & i4 ^ 1) {
  i36 = i1;
  STACKTOP = i37;
  return i36 | 0;
 }
 if ((i1 | 0) == (i36 | 0)) {
  STACKTOP = i37;
  return i36 | 0;
 }
 _memset(i5 | 0, 0, i36 - i1 << 2 | 0) | 0;
 STACKTOP = i37;
 return i36 | 0;
}

function _ofdmframesync_execute_S1(i28) {
 i28 = i28 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, d13 = 0.0, i14 = 0, d15 = 0.0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i29 = 0, i30 = 0, i31 = 0;
 i29 = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 i20 = i29 + 80 | 0;
 i1 = i29 + 64 | 0;
 i12 = i29 + 72 | 0;
 i14 = i29 + 56 | 0;
 i16 = i29 + 48 | 0;
 i17 = i29 + 40 | 0;
 i18 = i29 + 32 | 0;
 i19 = i29 + 24 | 0;
 i23 = i29 + 16 | 0;
 i25 = i29 + 8 | 0;
 i27 = i29;
 i24 = i28 + 124 | 0;
 i26 = (HEAP32[i24 >> 2] | 0) + -1 | 0;
 HEAP32[i24 >> 2] = i26;
 if (i26 | 0) {
  STACKTOP = i29;
  return;
 }
 i21 = i28 + 128 | 0;
 HEAP32[i21 >> 2] = (HEAP32[i21 >> 2] | 0) + 1;
 _windowcf_read(HEAP32[i28 + 60 >> 2] | 0, i1);
 i22 = i28 + 8 | 0;
 i26 = i28 + 92 | 0;
 _ofdmframesync_estimate_gain_S1(i28, (HEAP32[i1 >> 2] | 0) + (HEAP32[i22 >> 2] << 3) | 0, HEAP32[i26 >> 2] | 0);
 i1 = HEAP32[i28 >> 2] | 0;
 if (!i1) {
  d3 = 0.0;
  d2 = 0.0;
 } else {
  i5 = i14 + 4 | 0;
  i6 = i12 + 4 | 0;
  i11 = i16 + 4 | 0;
  d3 = 0.0;
  d2 = 0.0;
  i4 = 0;
  do {
   i30 = i4;
   i4 = i4 + 1 | 0;
   i1 = (i4 >>> 0) % (i1 >>> 0) | 0;
   i31 = HEAP32[i26 >> 2] | 0;
   d9 = +HEAPF32[i31 + (i1 << 3) >> 2];
   d10 = +HEAPF32[i31 + (i1 << 3) + 4 >> 2];
   i1 = HEAP32[i31 + (i30 << 3) + 4 >> 2] | 0;
   HEAP32[i14 >> 2] = HEAP32[i31 + (i30 << 3) >> 2];
   HEAP32[i5 >> 2] = i1;
   HEAP32[i20 >> 2] = HEAP32[i14 >> 2];
   HEAP32[i20 + 4 >> 2] = HEAP32[i14 + 4 >> 2];
   _conjf(i12, i20);
   d13 = +HEAPF32[i12 >> 2];
   d15 = +HEAPF32[i6 >> 2];
   d7 = d9 * d13 - d10 * d15;
   d8 = d10 * d13 + d9 * d15;
   if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
    ___mulsc3(i16, d9, d10, d13, d15);
    d7 = +HEAPF32[i16 >> 2];
    d8 = +HEAPF32[i11 >> 2];
   }
   d3 = d3 + d7;
   d2 = d2 + d8;
   i1 = HEAP32[i28 >> 2] | 0;
  } while (i4 >>> 0 < i1 >>> 0);
 }
 ___divsc3(i17, d3, d2, +((HEAP32[i28 + 32 >> 2] | 0) >>> 0), 0.0);
 d7 = +HEAPF32[i28 + 80 >> 2];
 d10 = +HEAPF32[i17 >> 2] * d7;
 d7 = +HEAPF32[i17 + 4 >> 2] * d7;
 i1 = i28 + 132 | 0;
 d9 = +((HEAP32[i1 >> 2] | 0) >>> 0) * 2.0 * 3.141592653589793 / +((HEAP32[i28 >> 2] | 0) >>> 0);
 d8 = +Math_sin(+d9);
 d9 = +Math_cos(+d9) + d8 * 0.0;
 d3 = d10 * d9 - d7 * d8;
 d2 = d10 * d8 + d7 * d9;
 if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
  ___mulsc3(i18, d10, d7, d9, d8);
  d3 = +HEAPF32[i18 >> 2];
  d2 = +HEAPF32[i18 + 4 >> 2];
 }
 HEAPF32[i19 >> 2] = d3;
 HEAPF32[i19 + 4 >> 2] = d2;
 HEAP32[i20 >> 2] = HEAP32[i19 >> 2];
 HEAP32[i20 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
 d15 = +_cabsf(i20);
 i4 = i28 + 156 | 0;
 if (d15 > +HEAPF32[i4 >> 2] ? (HEAPF32[i23 >> 2] = d3, HEAPF32[i23 + 4 >> 2] = d2, HEAP32[i20 >> 2] = HEAP32[i23 >> 2], HEAP32[i20 + 4 >> 2] = HEAP32[i23 + 4 >> 2], +Math_abs(+(+_cargf(i20))) < .3141592700403172) : 0) {
  HEAP32[i28 + 104 >> 2] = 4;
  i31 = HEAP32[i28 >> 2] | 0;
  HEAP32[i24 >> 2] = (HEAP32[i22 >> 2] | 0) + i31 + (HEAP32[i1 >> 2] | 0);
  HEAP32[i21 >> 2] = 0;
  i14 = i28 + 20 | 0;
  i1 = HEAP32[i14 >> 2] | 0;
  i12 = i28 + 24 | 0;
  i4 = HEAP32[i12 >> 2] | 0;
  d13 = +(i31 >>> 0) / +Math_sqrt(+(+((i4 + i1 | 0) >>> 0)));
  if (i31) {
   i1 = i28 + 96 | 0;
   i4 = i25 + 4 | 0;
   i11 = 0;
   do {
    i6 = HEAP32[i26 >> 2] | 0;
    i5 = i6 + (i11 << 3) | 0;
    i6 = i6 + (i11 << 3) + 4 | 0;
    d7 = d13 * +HEAPF32[i6 >> 2];
    HEAPF32[i5 >> 2] = d13 * +HEAPF32[i5 >> 2];
    HEAPF32[i6 >> 2] = d7;
    i6 = HEAP32[i1 >> 2] | 0;
    d7 = +HEAPF32[i6 + (i11 << 3) >> 2];
    d8 = +HEAPF32[i6 + (i11 << 3) + 4 >> 2];
    i6 = HEAP32[i26 >> 2] | 0;
    i5 = i6 + (i11 << 3) | 0;
    d9 = +HEAPF32[i5 >> 2];
    i6 = i6 + (i11 << 3) + 4 | 0;
    d10 = +HEAPF32[i6 >> 2];
    d3 = d7 * d9 - d8 * d10;
    d2 = d8 * d9 + d7 * d10;
    if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
     ___mulsc3(i25, d9, d10, d7, d8);
     d3 = +HEAPF32[i25 >> 2];
     d2 = +HEAPF32[i4 >> 2];
    }
    HEAPF32[i5 >> 2] = d3;
    HEAPF32[i6 >> 2] = d2;
    i11 = i11 + 1 | 0;
   } while (i11 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
   i4 = HEAP32[i12 >> 2] | 0;
   i1 = HEAP32[i14 >> 2] | 0;
  }
  i31 = i4 + i1 | 0;
  _ofdmframesync_estimate_eqgain_poly(i28, i31 >>> 0 < 5 ? i31 + -1 | 0 : 4);
  if (HEAP32[i28 >> 2] | 0) {
   i1 = i28 + 96 | 0;
   i4 = i27 + 4 | 0;
   i5 = i28 + 100 | 0;
   i6 = 0;
   do {
    i31 = HEAP32[i1 >> 2] | 0;
    i30 = HEAP32[i26 >> 2] | 0;
    ___divsc3(i27, +HEAPF32[i31 + (i6 << 3) >> 2], +HEAPF32[i31 + (i6 << 3) + 4 >> 2], +HEAPF32[i30 + (i6 << 3) >> 2], +HEAPF32[i30 + (i6 << 3) + 4 >> 2]);
    i30 = HEAP32[i4 >> 2] | 0;
    i31 = HEAP32[i5 >> 2] | 0;
    HEAP32[i31 + (i6 << 3) >> 2] = HEAP32[i27 >> 2];
    HEAP32[i31 + (i6 << 3) + 4 >> 2] = i30;
    i6 = i6 + 1 | 0;
   } while (i6 >>> 0 < (HEAP32[i28 >> 2] | 0) >>> 0);
  }
 } else {
  if ((HEAP32[i21 >> 2] | 0) == 16) {
   _nco_crcf_reset(HEAP32[i28 + 108 >> 2] | 0);
   _msequence_reset(HEAP32[i28 + 112 >> 2] | 0);
   i1 = i28 + 136 | 0;
   i31 = i28 + 116 | 0;
   HEAP32[i31 >> 2] = 0;
   HEAP32[i31 + 4 >> 2] = 0;
   HEAP32[i31 + 8 >> 2] = 0;
   HEAP32[i31 + 12 >> 2] = 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   i1 = HEAP32[i28 >> 2] | 0;
   if (i1 >>> 0 > 44) {
    d2 = .3499999940395355;
    d3 = .30000001192092896;
   } else {
    d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
    d2 = d3 + .3499999940395355;
    d3 = d3 + .30000001192092896;
   }
   HEAPF32[i28 + 152 >> 2] = d2;
   HEAPF32[i4 >> 2] = d3;
   HEAP32[i28 + 104 >> 2] = 0;
  }
  HEAP32[i24 >> 2] = HEAP32[i28 + 4 >> 2];
 }
 STACKTOP = i29;
 return;
}

function _modem_demodulate_sqam32(i20, i3, i12) {
 i20 = i20 | 0;
 i3 = i3 | 0;
 i12 = i12 | 0;
 var d1 = 0.0, d2 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, d11 = 0.0, d13 = 0.0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0, i21 = 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i14 = i21 + 72 | 0;
 i15 = i21 + 24 | 0;
 i16 = i21 + 16 | 0;
 i17 = i21 + 8 | 0;
 i18 = i21;
 i4 = i21 + 64 | 0;
 i5 = i21 + 56 | 0;
 i6 = i21 + 48 | 0;
 i7 = i21 + 40 | 0;
 i9 = i21 + 32 | 0;
 d19 = +HEAPF32[i3 >> 2];
 d13 = +HEAPF32[i3 + 4 >> 2];
 i8 = (d19 < 0.0 & 1) << 1 | d13 < 0.0;
 switch (i8 | 0) {
 case 0:
  {
   d10 = d19;
   d11 = d13;
   break;
  }
 case 1:
  {
   HEAPF32[i5 >> 2] = d19;
   HEAPF32[i5 + 4 >> 2] = d13;
   HEAP32[i14 >> 2] = HEAP32[i5 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   _conjf(i4, i14);
   d10 = +HEAPF32[i4 >> 2];
   d11 = +HEAPF32[i4 + 4 >> 2];
   break;
  }
 case 2:
  {
   HEAPF32[i7 >> 2] = d19;
   HEAPF32[i7 + 4 >> 2] = d13;
   HEAP32[i14 >> 2] = HEAP32[i7 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   _conjf(i6, i14);
   d10 = -+HEAPF32[i6 >> 2];
   d11 = -+HEAPF32[i6 + 4 >> 2];
   break;
  }
 case 3:
  {
   d10 = -d19;
   d11 = -d13;
   break;
  }
 default:
  {}
 }
 if (!(d10 >= 0.0)) ___assert_fail(gb + 31371 | 0, gb + 31395 | 0, 98, gb + 31424 | 0);
 if (!(d11 >= 0.0)) ___assert_fail(gb + 31448 | 0, gb + 31395 | 0, 99, gb + 31424 | 0);
 i5 = i20 + 100 | 0;
 i3 = i9 + 4 | 0;
 i7 = HEAP32[i5 >> 2] | 0;
 d1 = d11 - +HEAPF32[i7 + 4 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 >> 2];
 HEAPF32[i3 >> 2] = d1;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d1 = +_cabsf(i14);
 HEAP32[i12 >> 2] = 0;
 i7 = HEAP32[i5 >> 2] | 0;
 d2 = d11 - +HEAPF32[i7 + 12 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 8 >> 2];
 HEAPF32[i3 >> 2] = d2;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d2 = +_cabsf(i14);
 if (d2 < d1) {
  HEAP32[i12 >> 2] = 1;
  d1 = d2;
 }
 i7 = HEAP32[i5 >> 2] | 0;
 d2 = d11 - +HEAPF32[i7 + 20 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 16 >> 2];
 HEAPF32[i3 >> 2] = d2;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d2 = +_cabsf(i14);
 if (d2 < d1) {
  HEAP32[i12 >> 2] = 2;
  d1 = d2;
 }
 i7 = HEAP32[i5 >> 2] | 0;
 d2 = d11 - +HEAPF32[i7 + 28 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 24 >> 2];
 HEAPF32[i3 >> 2] = d2;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d2 = +_cabsf(i14);
 if (d2 < d1) {
  HEAP32[i12 >> 2] = 3;
  d1 = d2;
 }
 i7 = HEAP32[i5 >> 2] | 0;
 d2 = d11 - +HEAPF32[i7 + 36 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 32 >> 2];
 HEAPF32[i3 >> 2] = d2;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d2 = +_cabsf(i14);
 if (d2 < d1) HEAP32[i12 >> 2] = 4; else d2 = d1;
 i7 = HEAP32[i5 >> 2] | 0;
 d1 = d11 - +HEAPF32[i7 + 44 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 40 >> 2];
 HEAPF32[i3 >> 2] = d1;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d1 = +_cabsf(i14);
 if (d1 < d2) {
  HEAP32[i12 >> 2] = 5;
  d2 = d1;
 }
 i7 = HEAP32[i5 >> 2] | 0;
 d1 = d11 - +HEAPF32[i7 + 52 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 48 >> 2];
 HEAPF32[i3 >> 2] = d1;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d1 = +_cabsf(i14);
 if (d1 < d2) HEAP32[i12 >> 2] = 6; else d1 = d2;
 i7 = HEAP32[i5 >> 2] | 0;
 d11 = d11 - +HEAPF32[i7 + 60 >> 2];
 HEAPF32[i9 >> 2] = d10 - +HEAPF32[i7 + 56 >> 2];
 HEAPF32[i3 >> 2] = d11;
 HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 if (+_cabsf(i14) < d1) {
  HEAP32[i12 >> 2] = 7;
  i3 = 7;
 } else i3 = HEAP32[i12 >> 2] | 0;
 i9 = i3 | i8 << 3;
 HEAP32[i12 >> 2] = i9;
 i4 = i20 + 92 | 0;
 i12 = i3 & 7;
 i8 = HEAP32[i5 >> 2] | 0;
 d1 = +HEAPF32[i8 + (i12 << 3) >> 2];
 d2 = +HEAPF32[i8 + (i12 << 3) + 4 >> 2];
 switch (i9 >>> 3 & 3 | 0) {
 case 0:
  {
   HEAPF32[i4 >> 2] = d1;
   HEAPF32[i20 + 96 >> 2] = d2;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 case 1:
  {
   HEAPF32[i16 >> 2] = d1;
   HEAPF32[i16 + 4 >> 2] = d2;
   HEAP32[i14 >> 2] = HEAP32[i16 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
   _conjf(i15, i14);
   i18 = HEAP32[i15 + 4 >> 2] | 0;
   HEAP32[i4 >> 2] = HEAP32[i15 >> 2];
   HEAP32[i20 + 96 >> 2] = i18;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 case 2:
  {
   HEAPF32[i18 >> 2] = d1;
   HEAPF32[i18 + 4 >> 2] = d2;
   HEAP32[i14 >> 2] = HEAP32[i18 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i18 + 4 >> 2];
   _conjf(i17, i14);
   d11 = -+HEAPF32[i17 + 4 >> 2];
   HEAPF32[i4 >> 2] = -+HEAPF32[i17 >> 2];
   HEAPF32[i20 + 96 >> 2] = d11;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 case 3:
  {
   HEAPF32[i4 >> 2] = -d1;
   HEAPF32[i20 + 96 >> 2] = -d2;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 default:
  {}
 }
}

function _iirdes_dzpk_lp2bp(i59, i57, i56, d1, i60, i58) {
 i59 = i59 | 0;
 i57 = i57 | 0;
 i56 = i56 | 0;
 d1 = +d1;
 i60 = i60 | 0;
 i58 = i58 | 0;
 var d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, d16 = 0.0, d17 = 0.0, i18 = 0, i19 = 0, d20 = 0.0, d21 = 0.0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i61 = 0;
 i61 = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 i39 = i61 + 128 | 0;
 i40 = i61 + 120 | 0;
 i41 = i61 + 112 | 0;
 i48 = i61 + 104 | 0;
 i49 = i61 + 96 | 0;
 i50 = i61 + 88 | 0;
 i51 = i61 + 80 | 0;
 i52 = i61 + 72 | 0;
 i53 = i61 + 64 | 0;
 i54 = i61 + 56 | 0;
 i55 = i61 + 48 | 0;
 i42 = i61 + 40 | 0;
 i43 = i61 + 32 | 0;
 i44 = i61 + 24 | 0;
 i45 = i61 + 16 | 0;
 i46 = i61 + 8 | 0;
 i47 = i61;
 d20 = +Math_cos(+(d1 * 6.283185307179586));
 if (!i56) {
  STACKTOP = i61;
  return;
 }
 d21 = d20 * d20;
 i22 = i40 + 4 | 0;
 i23 = i41 + 4 | 0;
 i24 = i49 + 4 | 0;
 i25 = i48 + 4 | 0;
 i26 = i50 + 4 | 0;
 i27 = i51 + 4 | 0;
 i28 = i53 + 4 | 0;
 i29 = i52 + 4 | 0;
 i30 = i54 + 4 | 0;
 i31 = i55 + 4 | 0;
 i32 = i43 + 4 | 0;
 i33 = i42 + 4 | 0;
 i34 = i44 + 4 | 0;
 i35 = i45 + 4 | 0;
 i36 = i47 + 4 | 0;
 i37 = i46 + 4 | 0;
 i38 = 0;
 do {
  i14 = i59 + (i38 << 3) | 0;
  d1 = +HEAPF32[i14 >> 2];
  i15 = i59 + (i38 << 3) + 4 | 0;
  d2 = +HEAPF32[i15 >> 2];
  d9 = d1 + 1.0;
  d10 = d2 + 0.0;
  d17 = d20 * d9;
  d16 = d20 * d10;
  d11 = d21 * d9;
  d12 = d21 * d10;
  d6 = d9 * d11 - d10 * d12;
  d5 = d11 * d10 + d9 * d12;
  i13 = (d6 != d6 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0);
  if (i13) {
   ___mulsc3(i40, d11, d12, d9, d10);
   d1 = +HEAPF32[i14 >> 2];
   d2 = +HEAPF32[i15 >> 2];
   d7 = +HEAPF32[i40 >> 2];
   d8 = +HEAPF32[i22 >> 2];
  } else {
   d7 = d6;
   d8 = d5;
  }
  d3 = d1 * 4.0 - d2 * 0.0;
  d4 = d1 * 0.0 + d2 * 4.0;
  if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
   ___mulsc3(i41, 4.0, 0.0, d1, d2);
   d2 = +HEAPF32[i41 >> 2];
   d1 = +HEAPF32[i23 >> 2];
  } else {
   d2 = d3;
   d1 = d4;
  }
  HEAPF32[i49 >> 2] = d7 - d2;
  HEAPF32[i24 >> 2] = d8 - d1;
  HEAP32[i39 >> 2] = HEAP32[i49 >> 2];
  HEAP32[i39 + 4 >> 2] = HEAP32[i49 + 4 >> 2];
  _csqrtf(i48, i39);
  d8 = (d16 + +HEAPF32[i25 >> 2]) * .5;
  i19 = i38 << 1;
  HEAPF32[i60 + (i19 << 3) >> 2] = (d17 + +HEAPF32[i48 >> 2]) * .5;
  HEAPF32[i60 + (i19 << 3) + 4 >> 2] = d8;
  if (i13) {
   ___mulsc3(i50, d11, d12, d9, d10);
   d6 = +HEAPF32[i50 >> 2];
   d5 = +HEAPF32[i26 >> 2];
  }
  d4 = +HEAPF32[i14 >> 2];
  d3 = +HEAPF32[i15 >> 2];
  d2 = d4 * 4.0 - d3 * 0.0;
  d1 = d4 * 0.0 + d3 * 4.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i51, 4.0, 0.0, d4, d3);
   d2 = +HEAPF32[i51 >> 2];
   d1 = +HEAPF32[i27 >> 2];
  }
  HEAPF32[i53 >> 2] = d6 - d2;
  HEAPF32[i28 >> 2] = d5 - d1;
  HEAP32[i39 >> 2] = HEAP32[i53 >> 2];
  HEAP32[i39 + 4 >> 2] = HEAP32[i53 + 4 >> 2];
  _csqrtf(i52, i39);
  d1 = (d16 - +HEAPF32[i29 >> 2]) * .5;
  i18 = i19 | 1;
  HEAPF32[i60 + (i18 << 3) >> 2] = (d17 - +HEAPF32[i52 >> 2]) * .5;
  HEAPF32[i60 + (i18 << 3) + 4 >> 2] = d1;
  i14 = i57 + (i38 << 3) | 0;
  d1 = +HEAPF32[i14 >> 2];
  i15 = i57 + (i38 << 3) + 4 | 0;
  d2 = +HEAPF32[i15 >> 2];
  d9 = d1 + 1.0;
  d10 = d2 + 0.0;
  d16 = d20 * d9;
  d17 = d20 * d10;
  d11 = d21 * d9;
  d12 = d21 * d10;
  d6 = d9 * d11 - d10 * d12;
  d5 = d11 * d10 + d9 * d12;
  i13 = (d6 != d6 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0);
  if (i13) {
   ___mulsc3(i54, d11, d12, d9, d10);
   d1 = +HEAPF32[i14 >> 2];
   d2 = +HEAPF32[i15 >> 2];
   d7 = +HEAPF32[i54 >> 2];
   d8 = +HEAPF32[i30 >> 2];
  } else {
   d7 = d6;
   d8 = d5;
  }
  d3 = d1 * 4.0 - d2 * 0.0;
  d4 = d1 * 0.0 + d2 * 4.0;
  if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
   ___mulsc3(i55, 4.0, 0.0, d1, d2);
   d2 = +HEAPF32[i55 >> 2];
   d1 = +HEAPF32[i31 >> 2];
  } else {
   d2 = d3;
   d1 = d4;
  }
  HEAPF32[i43 >> 2] = d7 - d2;
  HEAPF32[i32 >> 2] = d8 - d1;
  HEAP32[i39 >> 2] = HEAP32[i43 >> 2];
  HEAP32[i39 + 4 >> 2] = HEAP32[i43 + 4 >> 2];
  _csqrtf(i42, i39);
  d8 = (d17 + +HEAPF32[i33 >> 2]) * .5;
  HEAPF32[i58 + (i19 << 3) >> 2] = (d16 + +HEAPF32[i42 >> 2]) * .5;
  HEAPF32[i58 + (i19 << 3) + 4 >> 2] = d8;
  if (i13) {
   ___mulsc3(i44, d11, d12, d9, d10);
   d6 = +HEAPF32[i44 >> 2];
   d5 = +HEAPF32[i34 >> 2];
  }
  d4 = +HEAPF32[i14 >> 2];
  d3 = +HEAPF32[i15 >> 2];
  d2 = d4 * 4.0 - d3 * 0.0;
  d1 = d4 * 0.0 + d3 * 4.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i45, 4.0, 0.0, d4, d3);
   d2 = +HEAPF32[i45 >> 2];
   d1 = +HEAPF32[i35 >> 2];
  }
  HEAPF32[i47 >> 2] = d6 - d2;
  HEAPF32[i36 >> 2] = d5 - d1;
  HEAP32[i39 >> 2] = HEAP32[i47 >> 2];
  HEAP32[i39 + 4 >> 2] = HEAP32[i47 + 4 >> 2];
  _csqrtf(i46, i39);
  d17 = (d17 - +HEAPF32[i37 >> 2]) * .5;
  HEAPF32[i58 + (i18 << 3) >> 2] = (d16 - +HEAPF32[i46 >> 2]) * .5;
  HEAPF32[i58 + (i18 << 3) + 4 >> 2] = d17;
  i38 = i38 + 1 | 0;
 } while ((i38 | 0) != (i56 | 0));
 STACKTOP = i61;
 return;
}

function _ofdmframesync_create(i5, i3, i1, i4, i9, i10) {
 i5 = i5 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 i4 = i4 | 0;
 i9 = i9 | 0;
 i10 = i10 | 0;
 var d2 = 0.0, i6 = 0, i7 = 0, i8 = 0, i11 = 0, i12 = 0, d13 = 0.0, i14 = 0, i15 = 0, d16 = 0.0;
 i8 = _malloc(216) | 0;
 if (i5 >>> 0 >= 8) {
  if (i5 & 1 | 0) {
   _fwrite(gb + 35530 | 0, 66, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
  if (i3 >>> 0 > i5 >>> 0) {
   _fwrite(gb + 35597 | 0, 88, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 } else _fwrite(gb + 35472 | 0, 57, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
 HEAP32[i8 >> 2] = i5;
 i7 = i8 + 8 | 0;
 HEAP32[i7 >> 2] = i3;
 HEAP32[i8 + 4 >> 2] = i5 >>> 1;
 i1 = _malloc(i5) | 0;
 i6 = i8 + 12 | 0;
 HEAP32[i6 >> 2] = i1;
 if (!i4) {
  _ofdmframe_init_default_sctype(i5, i1);
  i1 = HEAP32[i6 >> 2] | 0;
  i3 = HEAP32[i8 >> 2] | 0;
 } else {
  _memcpy(i1 | 0, i4 | 0, i5 | 0) | 0;
  i3 = i5;
 }
 i4 = i8 + 20 | 0;
 i5 = i8 + 24 | 0;
 _ofdmframe_validate_sctype(i1, i3, i8 + 16 | 0, i4, i5);
 i1 = HEAP32[i4 >> 2] | 0;
 i3 = HEAP32[i5 >> 2] | 0;
 if ((i1 | 0) == (0 - i3 | 0)) {
  _fwrite(gb + 35686 | 0, 73, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i3) {
  _fwrite(gb + 35760 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i1 >>> 0 < 2) {
  _fwrite(gb + 35832 | 0, 72, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i14 = HEAP32[i8 >> 2] | 0;
 i11 = i14 << 3;
 i15 = _malloc(i11) | 0;
 HEAP32[i8 + 52 >> 2] = i15;
 i11 = _malloc(i11) | 0;
 HEAP32[i8 + 56 >> 2] = i11;
 HEAP32[i8 + 48 >> 2] = _fft_create_plan(i14, i11, i15, 1, 0) | 0;
 HEAP32[i8 + 60 >> 2] = _windowcf_create((HEAP32[i7 >> 2] | 0) + (HEAP32[i8 >> 2] | 0) | 0) | 0;
 i15 = HEAP32[i8 >> 2] | 0;
 i11 = i15 << 3;
 i14 = _malloc(i11) | 0;
 HEAP32[i8 + 64 >> 2] = i14;
 i12 = _malloc(i11) | 0;
 HEAP32[i8 + 68 >> 2] = i12;
 i3 = i8 + 72 | 0;
 HEAP32[i3 >> 2] = _malloc(i11) | 0;
 i1 = i8 + 76 | 0;
 HEAP32[i1 >> 2] = _malloc(i11) | 0;
 i11 = i8 + 28 | 0;
 _ofdmframe_init_S0(HEAP32[i6 >> 2] | 0, i15, i14, i12, i11);
 i12 = i8 + 32 | 0;
 _ofdmframe_init_S1(HEAP32[i6 >> 2] | 0, HEAP32[i8 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i1 >> 2] | 0, i12);
 i6 = HEAP32[i8 >> 2] | 0;
 d2 = +(i6 >>> 0);
 d13 = +Math_sqrt(+d2);
 HEAPF32[i8 + 36 >> 2] = d13 / +Math_sqrt(+(+(((HEAP32[i5 >> 2] | 0) + (HEAP32[i4 >> 2] | 0) | 0) >>> 0)));
 HEAPF32[i8 + 40 >> 2] = d13 / +Math_sqrt(+(+((HEAP32[i11 >> 2] | 0) >>> 0)));
 HEAPF32[i8 + 44 >> 2] = d13 / +Math_sqrt(+(+((HEAP32[i12 >> 2] | 0) >>> 0)));
 HEAPF32[i8 + 80 >> 2] = 1.0;
 i5 = i6 << 3;
 i12 = _malloc(i5) | 0;
 HEAP32[i8 + 84 >> 2] = i12;
 i11 = _malloc(i5) | 0;
 HEAP32[i8 + 88 >> 2] = i11;
 i4 = _malloc(i5) | 0;
 HEAP32[i8 + 92 >> 2] = i4;
 i1 = _malloc(i5) | 0;
 i3 = i8 + 96 | 0;
 HEAP32[i3 >> 2] = i1;
 HEAP32[i8 + 100 >> 2] = _malloc(i5) | 0;
 _memset(i12 | 0, 0, i5 | 0) | 0;
 _memset(i11 | 0, 0, i5 | 0) | 0;
 _memset(i4 | 0, 0, i5 | 0) | 0;
 _memset(i1 | 0, 0, i5 | 0) | 0;
 i7 = HEAP32[i7 >> 2] | 0;
 i7 = i7 >>> 0 < 2 ? i7 : 2;
 HEAP32[i8 + 132 >> 2] = i7;
 d2 = +(i7 >>> 0) * 2.0 * 3.141592653589793 / d2;
 if (i6 | 0 ? (d16 = d2 * 0.0, d13 = +Math_sin(+d16), HEAPF32[i1 >> 2] = +Math_cos(+d16) + d13 * 0.0, HEAPF32[i1 + 4 >> 2] = d13, (HEAP32[i8 >> 2] | 0) >>> 0 > 1) : 0) {
  i1 = 1;
  do {
   i15 = HEAP32[i3 >> 2] | 0;
   d13 = d2 * +(i1 >>> 0);
   d16 = +Math_sin(+d13);
   HEAPF32[i15 + (i1 << 3) >> 2] = +Math_cos(+d13) + d16 * 0.0;
   HEAPF32[i15 + (i1 << 3) + 4 >> 2] = d16;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < (HEAP32[i8 >> 2] | 0) >>> 0);
 }
 HEAP32[i8 + 160 >> 2] = i9;
 HEAP32[i8 + 164 >> 2] = i10;
 i15 = i8 + 108 | 0;
 HEAP32[i15 >> 2] = _nco_crcf_create(0) | 0;
 i1 = i8 + 112 | 0;
 HEAP32[i1 >> 2] = _msequence_create_default(8) | 0;
 _nco_crcf_reset(HEAP32[i15 >> 2] | 0);
 _msequence_reset(HEAP32[i1 >> 2] | 0);
 i1 = i8 + 136 | 0;
 i15 = i8 + 116 | 0;
 HEAP32[i15 >> 2] = 0;
 HEAP32[i15 + 4 >> 2] = 0;
 HEAP32[i15 + 8 >> 2] = 0;
 HEAP32[i15 + 12 >> 2] = 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 i1 = HEAP32[i8 >> 2] | 0;
 if (i1 >>> 0 > 44) {
  HEAPF32[i8 + 152 >> 2] = .3499999940395355;
  d16 = .30000001192092896;
  i15 = i8 + 156 | 0;
  HEAPF32[i15 >> 2] = d16;
  i15 = i8 + 104 | 0;
  HEAP32[i15 >> 2] = 0;
  i15 = i8 + 168 | 0;
  i14 = i8 + 208 | 0;
  HEAP32[i14 >> 2] = 0;
  i14 = i8 + 212 | 0;
  HEAP32[i14 >> 2] = 0;
  HEAP32[i15 >> 2] = 0;
  HEAP32[i15 + 4 >> 2] = 0;
  HEAP32[i15 + 8 >> 2] = 0;
  HEAP32[i15 + 12 >> 2] = 0;
  HEAP32[i15 + 16 >> 2] = 0;
  HEAP32[i15 + 20 >> 2] = 0;
  HEAP32[i15 + 24 >> 2] = 0;
  HEAP32[i15 + 28 >> 2] = 0;
  return i8 | 0;
 } else {
  d16 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
  HEAPF32[i8 + 152 >> 2] = d16 + .3499999940395355;
  d16 = d16 + .30000001192092896;
  i15 = i8 + 156 | 0;
  HEAPF32[i15 >> 2] = d16;
  i15 = i8 + 104 | 0;
  HEAP32[i15 >> 2] = 0;
  i15 = i8 + 168 | 0;
  i14 = i8 + 208 | 0;
  HEAP32[i14 >> 2] = 0;
  i14 = i8 + 212 | 0;
  HEAP32[i14 >> 2] = 0;
  HEAP32[i15 >> 2] = 0;
  HEAP32[i15 + 4 >> 2] = 0;
  HEAP32[i15 + 8 >> 2] = 0;
  HEAP32[i15 + 12 >> 2] = 0;
  HEAP32[i15 + 16 >> 2] = 0;
  HEAP32[i15 + 20 >> 2] = 0;
  HEAP32[i15 + 24 >> 2] = 0;
  HEAP32[i15 + 28 >> 2] = 0;
  return i8 | 0;
 }
 return 0;
}

function _try_realloc_chunk(i14, i13) {
 i14 = i14 | 0;
 i13 = i13 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i11 = i14 + 4 | 0;
 i12 = HEAP32[i11 >> 2] | 0;
 i1 = i12 & -8;
 i8 = i14 + i1 | 0;
 i6 = HEAP32[gb + 44352 + 16 >> 2] | 0;
 i2 = i12 & 3;
 if (!((i2 | 0) != 1 & i14 >>> 0 >= i6 >>> 0 & i14 >>> 0 < i8 >>> 0)) _abort();
 i3 = HEAP32[i8 + 4 >> 2] | 0;
 if (!(i3 & 1)) _abort();
 if (!i2) {
  if (i13 >>> 0 < 256) {
   i14 = 0;
   return i14 | 0;
  }
  if (i1 >>> 0 >= (i13 + 4 | 0) >>> 0 ? (i1 - i13 | 0) >>> 0 <= HEAP32[gb + 44824 + 8 >> 2] << 1 >>> 0 : 0) return i14 | 0;
  i14 = 0;
  return i14 | 0;
 }
 if (i1 >>> 0 >= i13 >>> 0) {
  i1 = i1 - i13 | 0;
  if (i1 >>> 0 <= 15) return i14 | 0;
  i10 = i14 + i13 | 0;
  HEAP32[i11 >> 2] = i12 & 1 | i13 | 2;
  HEAP32[i10 + 4 >> 2] = i1 | 3;
  i13 = i10 + i1 + 4 | 0;
  HEAP32[i13 >> 2] = HEAP32[i13 >> 2] | 1;
  _dispose_chunk(i10, i1);
  return i14 | 0;
 }
 if ((i8 | 0) == (HEAP32[gb + 44352 + 24 >> 2] | 0)) {
  i1 = (HEAP32[gb + 44352 + 12 >> 2] | 0) + i1 | 0;
  if (i1 >>> 0 <= i13 >>> 0) {
   i14 = 0;
   return i14 | 0;
  }
  i10 = i1 - i13 | 0;
  i9 = i14 + i13 | 0;
  HEAP32[i11 >> 2] = i12 & 1 | i13 | 2;
  HEAP32[i9 + 4 >> 2] = i10 | 1;
  HEAP32[gb + 44352 + 24 >> 2] = i9;
  HEAP32[gb + 44352 + 12 >> 2] = i10;
  return i14 | 0;
 }
 if ((i8 | 0) == (HEAP32[gb + 44352 + 20 >> 2] | 0)) {
  i2 = (HEAP32[gb + 44352 + 8 >> 2] | 0) + i1 | 0;
  if (i2 >>> 0 < i13 >>> 0) {
   i14 = 0;
   return i14 | 0;
  }
  i1 = i2 - i13 | 0;
  if (i1 >>> 0 > 15) {
   i2 = i14 + i13 | 0;
   i10 = i2 + i1 | 0;
   HEAP32[i11 >> 2] = i12 & 1 | i13 | 2;
   HEAP32[i2 + 4 >> 2] = i1 | 1;
   HEAP32[i10 >> 2] = i1;
   i13 = i10 + 4 | 0;
   HEAP32[i13 >> 2] = HEAP32[i13 >> 2] & -2;
  } else {
   HEAP32[i11 >> 2] = i12 & 1 | i2 | 2;
   i2 = i14 + i2 + 4 | 0;
   HEAP32[i2 >> 2] = HEAP32[i2 >> 2] | 1;
   i2 = 0;
   i1 = 0;
  }
  HEAP32[gb + 44352 + 8 >> 2] = i1;
  HEAP32[gb + 44352 + 20 >> 2] = i2;
  return i14 | 0;
 }
 if (i3 & 2 | 0) {
  i14 = 0;
  return i14 | 0;
 }
 i9 = (i3 & -8) + i1 | 0;
 if (i9 >>> 0 < i13 >>> 0) {
  i14 = 0;
  return i14 | 0;
 }
 i10 = i9 - i13 | 0;
 i4 = i3 >>> 3;
 do if (i3 >>> 0 >= 256) {
  i5 = HEAP32[i8 + 24 >> 2] | 0;
  i3 = HEAP32[i8 + 12 >> 2] | 0;
  do if ((i3 | 0) == (i8 | 0)) {
   i2 = i8 + 16 | 0;
   i3 = i2 + 4 | 0;
   i1 = HEAP32[i3 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i2 >> 2] | 0;
    if (!i1) {
     i7 = 0;
     break;
    }
   } else i2 = i3;
   while (1) {
    i3 = i1 + 20 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i2 = i3;
     continue;
    }
    i3 = i1 + 16 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (!i4) break; else {
     i1 = i4;
     i2 = i3;
    }
   }
   if (i2 >>> 0 < i6 >>> 0) _abort(); else {
    HEAP32[i2 >> 2] = 0;
    i7 = i1;
    break;
   }
  } else {
   i4 = HEAP32[i8 + 8 >> 2] | 0;
   if (i4 >>> 0 < i6 >>> 0) _abort();
   i1 = i4 + 12 | 0;
   if ((HEAP32[i1 >> 2] | 0) != (i8 | 0)) _abort();
   i2 = i3 + 8 | 0;
   if ((HEAP32[i2 >> 2] | 0) == (i8 | 0)) {
    HEAP32[i1 >> 2] = i3;
    HEAP32[i2 >> 2] = i4;
    i7 = i3;
    break;
   } else _abort();
  } while (0);
  if (i5 | 0) {
   i1 = HEAP32[i8 + 28 >> 2] | 0;
   i2 = gb + 44352 + 304 + (i1 << 2) | 0;
   if ((i8 | 0) == (HEAP32[i2 >> 2] | 0)) {
    HEAP32[i2 >> 2] = i7;
    if (!i7) {
     HEAP32[gb + 44352 + 4 >> 2] = HEAP32[gb + 44352 + 4 >> 2] & ~(1 << i1);
     break;
    }
   } else {
    if (i5 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i5 + 16 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i8 | 0)) HEAP32[i1 >> 2] = i7; else HEAP32[i5 + 20 >> 2] = i7;
    if (!i7) break;
   }
   i3 = HEAP32[gb + 44352 + 16 >> 2] | 0;
   if (i7 >>> 0 < i3 >>> 0) _abort();
   HEAP32[i7 + 24 >> 2] = i5;
   i1 = i8 + 16 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
    HEAP32[i7 + 16 >> 2] = i2;
    HEAP32[i2 + 24 >> 2] = i7;
    break;
   } while (0);
   i1 = HEAP32[i1 + 4 >> 2] | 0;
   if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 44352 + 16 >> 2] | 0) >>> 0) _abort(); else {
    HEAP32[i7 + 20 >> 2] = i1;
    HEAP32[i1 + 24 >> 2] = i7;
    break;
   }
  }
 } else {
  i2 = HEAP32[i8 + 8 >> 2] | 0;
  i3 = HEAP32[i8 + 12 >> 2] | 0;
  i1 = gb + 44352 + 40 + (i4 << 1 << 2) | 0;
  if ((i2 | 0) != (i1 | 0)) {
   if (i2 >>> 0 < i6 >>> 0) _abort();
   if ((HEAP32[i2 + 12 >> 2] | 0) != (i8 | 0)) _abort();
  }
  if ((i3 | 0) == (i2 | 0)) {
   HEAP32[gb + 44352 >> 2] = HEAP32[gb + 44352 >> 2] & ~(1 << i4);
   break;
  }
  if ((i3 | 0) != (i1 | 0)) {
   if (i3 >>> 0 < i6 >>> 0) _abort();
   i1 = i3 + 8 | 0;
   if ((HEAP32[i1 >> 2] | 0) == (i8 | 0)) i5 = i1; else _abort();
  } else i5 = i3 + 8 | 0;
  HEAP32[i2 + 12 >> 2] = i3;
  HEAP32[i5 >> 2] = i2;
 } while (0);
 if (i10 >>> 0 < 16) {
  HEAP32[i11 >> 2] = i9 | i12 & 1 | 2;
  i13 = i14 + i9 + 4 | 0;
  HEAP32[i13 >> 2] = HEAP32[i13 >> 2] | 1;
  return i14 | 0;
 } else {
  i9 = i14 + i13 | 0;
  HEAP32[i11 >> 2] = i12 & 1 | i13 | 2;
  HEAP32[i9 + 4 >> 2] = i10 | 3;
  i13 = i9 + i10 + 4 | 0;
  HEAP32[i13 >> 2] = HEAP32[i13 >> 2] | 1;
  _dispose_chunk(i9, i10);
  return i14 | 0;
 }
 return 0;
}
function _flexframesync_debug_print(i11, i15) {
 i11 = i11 | 0;
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, d20 = 0.0, d21 = 0.0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 i18 = i19 + 248 | 0;
 i17 = i19 + 224 | 0;
 i13 = i19 + 200 | 0;
 i12 = i19 + 192 | 0;
 i10 = i19 + 168 | 0;
 i9 = i19 + 144 | 0;
 i8 = i19 + 136 | 0;
 i7 = i19 + 112 | 0;
 i6 = i19 + 88 | 0;
 i5 = i19 + 64 | 0;
 i4 = i19 + 40 | 0;
 i3 = i19 + 16 | 0;
 i2 = i19 + 8 | 0;
 i1 = i19;
 i16 = i19 + 252 | 0;
 if (!(HEAP32[i11 + 208 >> 2] | 0)) {
  _fwrite(gb + 25809 | 0, 90, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  STACKTOP = i19;
  return;
 }
 i14 = _fopen(i15, gb + 36126 | 0) | 0;
 HEAP32[i1 >> 2] = i15;
 _fprintf(i14, gb + 27423 | 0, i1) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i14) | 0;
 _fwrite(gb + 36265 | 0, 11, 1, i14) | 0;
 _fwrite(gb + 27450 | 0, 12, 1, i14) | 0;
 HEAP32[i2 >> 2] = 2e3;
 _fprintf(i14, gb + 36277 | 0, i2) | 0;
 _fwrite(gb + 25900 | 0, 54, 1, i14) | 0;
 _fwrite(gb + 36503 | 0, 16, 1, i14) | 0;
 _windowcf_read(HEAP32[i11 + 216 >> 2] | 0, i16);
 i1 = 0;
 do {
  i2 = HEAP32[i16 >> 2] | 0;
  d21 = +HEAPF32[i2 + (i1 << 3) >> 2];
  d20 = +HEAPF32[i2 + (i1 << 3) + 4 >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i3 >> 2] = i1;
  HEAPF64[i3 + 8 >> 3] = d21;
  HEAPF64[i3 + 16 >> 3] = d20;
  _fprintf(i14, gb + 36520 | 0, i3) | 0;
 } while ((i1 | 0) != 2e3);
 _fwrite(gb + 36694 | 0, 2, 1, i14) | 0;
 _fwrite(gb + 25955 | 0, 18, 1, i14) | 0;
 _fwrite(gb + 27533 | 0, 48, 1, i14) | 0;
 _fwrite(gb + 38298 | 0, 9, 1, i14) | 0;
 _fwrite(gb + 36598 | 0, 24, 1, i14) | 0;
 _fwrite(gb + 36623 | 0, 30, 1, i14) | 0;
 _fwrite(gb + 25974 | 0, 27, 1, i14) | 0;
 i1 = HEAP32[i11 + 116 >> 2] | 0;
 HEAP32[i16 >> 2] = i1;
 d20 = +HEAPF32[i1 >> 2];
 d21 = +HEAPF32[i1 + 4 >> 2];
 HEAP32[i4 >> 2] = 1;
 HEAPF64[i4 + 8 >> 3] = d20;
 HEAPF64[i4 + 16 >> 3] = d21;
 _fprintf(i14, gb + 26002 | 0, i4) | 0;
 i1 = 1;
 do {
  i4 = HEAP32[i16 >> 2] | 0;
  d20 = +HEAPF32[i4 + (i1 << 3) >> 2];
  d21 = +HEAPF32[i4 + (i1 << 3) + 4 >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i5 >> 2] = i1;
  HEAPF64[i5 + 8 >> 3] = d20;
  HEAPF64[i5 + 16 >> 3] = d21;
  _fprintf(i14, gb + 26002 | 0, i5) | 0;
 } while ((i1 | 0) != 64);
 _fwrite(gb + 26042 | 0, 27, 1, i14) | 0;
 i1 = HEAP32[i11 + 120 >> 2] | 0;
 HEAP32[i16 >> 2] = i1;
 d20 = +HEAPF32[i1 >> 2];
 d21 = +HEAPF32[i1 + 4 >> 2];
 HEAP32[i6 >> 2] = 1;
 HEAPF64[i6 + 8 >> 3] = d20;
 HEAPF64[i6 + 16 >> 3] = d21;
 _fprintf(i14, gb + 26070 | 0, i6) | 0;
 i1 = 1;
 do {
  i6 = HEAP32[i16 >> 2] | 0;
  d20 = +HEAPF32[i6 + (i1 << 3) >> 2];
  d21 = +HEAPF32[i6 + (i1 << 3) + 4 >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i7 >> 2] = i1;
  HEAPF64[i7 + 8 >> 3] = d20;
  HEAPF64[i7 + 16 >> 3] = d21;
  _fprintf(i14, gb + 26070 | 0, i7) | 0;
 } while ((i1 | 0) != 64);
 i2 = i11 + 140 | 0;
 HEAP32[i8 >> 2] = HEAP32[i2 >> 2];
 _fprintf(i14, gb + 26110 | 0, i8) | 0;
 i1 = HEAP32[i11 + 136 >> 2] | 0;
 HEAP32[i16 >> 2] = i1;
 if (HEAP32[i2 >> 2] | 0 ? (i8 = i1, d20 = +HEAPF32[i8 >> 2], d21 = +HEAPF32[i8 + 4 >> 2], HEAP32[i9 >> 2] = 1, HEAPF64[i9 + 8 >> 3] = d20, HEAPF64[i9 + 16 >> 3] = d21, _fprintf(i14, gb + 26137 | 0, i9) | 0, (HEAP32[i2 >> 2] | 0) >>> 0 > 1) : 0) {
  i1 = 1;
  do {
   i9 = HEAP32[i16 >> 2] | 0;
   d20 = +HEAPF32[i9 + (i1 << 3) >> 2];
   d21 = +HEAPF32[i9 + (i1 << 3) + 4 >> 2];
   i1 = i1 + 1 | 0;
   HEAP32[i10 >> 2] = i1;
   HEAPF64[i10 + 8 >> 3] = d20;
   HEAPF64[i10 + 16 >> 3] = d21;
   _fprintf(i14, gb + 26137 | 0, i10) | 0;
  } while (i1 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 i2 = i11 + 172 | 0;
 HEAP32[i12 >> 2] = HEAP32[i2 >> 2];
 _fprintf(i14, gb + 26175 | 0, i12) | 0;
 i1 = HEAP32[i11 + 168 >> 2] | 0;
 HEAP32[i16 >> 2] = i1;
 if (HEAP32[i2 >> 2] | 0 ? (i12 = i1, d20 = +HEAPF32[i12 >> 2], d21 = +HEAPF32[i12 + 4 >> 2], HEAP32[i13 >> 2] = 1, HEAPF64[i13 + 8 >> 3] = d20, HEAPF64[i13 + 16 >> 3] = d21, _fprintf(i14, gb + 26203 | 0, i13) | 0, (HEAP32[i2 >> 2] | 0) >>> 0 > 1) : 0) {
  i1 = 1;
  do {
   i13 = HEAP32[i16 >> 2] | 0;
   d20 = +HEAPF32[i13 + (i1 << 3) >> 2];
   d21 = +HEAPF32[i13 + (i1 << 3) + 4 >> 2];
   i1 = i1 + 1 | 0;
   HEAP32[i17 >> 2] = i1;
   HEAPF64[i17 + 8 >> 3] = d20;
   HEAPF64[i17 + 16 >> 3] = d21;
   _fprintf(i14, gb + 26203 | 0, i17) | 0;
  } while (i1 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _fwrite(gb + 26242 | 0, 20, 1, i14) | 0;
 _fwrite(gb + 26263 | 0, 45, 1, i14) | 0;
 _fwrite(gb + 26309 | 0, 20, 1, i14) | 0;
 _fwrite(gb + 26330 | 0, 28, 1, i14) | 0;
 _fwrite(gb + 38298 | 0, 9, 1, i14) | 0;
 _fwrite(gb + 26359 | 0, 23, 1, i14) | 0;
 _fwrite(gb + 38284 | 0, 13, 1, i14) | 0;
 _fwrite(gb + 26383 | 0, 34, 1, i14) | 0;
 _fwrite(gb + 26418 | 0, 20, 1, i14) | 0;
 _fwrite(gb + 26439 | 0, 47, 1, i14) | 0;
 _fwrite(gb + 26309 | 0, 20, 1, i14) | 0;
 _fwrite(gb + 26330 | 0, 28, 1, i14) | 0;
 _fwrite(gb + 38298 | 0, 9, 1, i14) | 0;
 _fwrite(gb + 26359 | 0, 23, 1, i14) | 0;
 _fwrite(gb + 38284 | 0, 13, 1, i14) | 0;
 _fwrite(gb + 26487 | 0, 35, 1, i14) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i14) | 0;
 _fclose(i14) | 0;
 HEAP32[i18 >> 2] = i15;
 _printf(gb + 26523 | 0, i18) | 0;
 STACKTOP = i19;
 return;
}

function _modem_create_qam(i5) {
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 if (!i5) {
  _fwrite(gb + 30930 | 0, 66, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i13 = _malloc(252) | 0;
 if (i5 >>> 0 > 16) {
  _fwrite(gb + 30997 | 0, 64, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i8 = i13 + 76 | 0;
 HEAP32[i8 >> 2] = 0;
 i9 = i13 + 80 | 0;
 HEAP32[i9 >> 2] = 0;
 i10 = i13 + 4 | 0;
 HEAP32[i10 >> 2] = i5;
 i4 = 1 << i5;
 i11 = i13 + 8 | 0;
 HEAP32[i11 >> 2] = i4;
 i7 = i13 + 236 | 0;
 HEAP32[i7 >> 2] = 0;
 HEAP32[i7 + 4 >> 2] = 0;
 HEAP32[i7 + 8 >> 2] = 0;
 HEAP32[i7 + 12 >> 2] = 0;
 if (!(i5 & 1)) {
  i3 = i5 >>> 1;
  HEAP32[i13 + 100 >> 2] = i3;
  i12 = i13 + 104 | 0;
  HEAP32[i12 >> 2] = i3;
  i2 = i3;
 } else {
  i2 = (i5 + 1 | 0) >>> 1;
  HEAP32[i13 + 100 >> 2] = i2;
  i3 = (i5 + -1 | 0) >>> 1;
  i12 = i13 + 104 | 0;
  HEAP32[i12 >> 2] = i3;
 }
 i1 = 1 << i2;
 HEAP32[i13 + 108 >> 2] = i1;
 HEAP32[i13 + 112 >> 2] = 1 << i3;
 if ((i2 + i3 | 0) != (i5 | 0)) ___assert_fail(gb + 31062 | 0, gb + 31104 | 0, 54, gb + 31130 | 0);
 if ((i1 << i3 | 0) != (i4 | 0)) ___assert_fail(gb + 31147 | 0, gb + 31104 | 0, 55, gb + 31130 | 0);
 L17 : do if ((i4 | 0) >= 512) {
  if ((i4 | 0) < 8192) switch (i4 | 0) {
  case 512:
   {
    HEAPF32[i13 + 116 >> 2] = .048450157046318054;
    HEAP32[i13 >> 2] = 32;
    d6 = .048450157046318054;
    break L17;
   }
  case 1024:
   {
    HEAPF32[i13 + 116 >> 2] = .03829197958111763;
    HEAP32[i13 >> 2] = 33;
    d6 = .03829197958111763;
    break L17;
   }
  case 2048:
   {
    HEAPF32[i13 + 116 >> 2] = .02421087585389614;
    HEAP32[i13 >> 2] = 34;
    d6 = .02421087585389614;
    break L17;
   }
  case 4096:
   {
    HEAPF32[i13 + 116 >> 2] = .01913897506892681;
    HEAP32[i13 >> 2] = 35;
    d6 = .01913897506892681;
    break L17;
   }
  default:
   {
    i5 = HEAP32[gb + 8808 >> 2] | 0;
    _fwrite(gb + 31189 | 0, 58, 1, i5) | 0;
    _exit(1);
   }
  }
  if ((i4 | 0) < 32768) if ((i4 | 0) < 16384) switch (i4 | 0) {
  case 8192:
   {
    HEAPF32[i13 + 116 >> 2] = .012103663757443428;
    HEAP32[i13 >> 2] = 36;
    d6 = .012103663757443428;
    break L17;
   }
  default:
   {
    i5 = HEAP32[gb + 8808 >> 2] | 0;
    _fwrite(gb + 31189 | 0, 58, 1, i5) | 0;
    _exit(1);
   }
  } else switch (i4 | 0) {
  case 16384:
   {
    HEAPF32[i13 + 116 >> 2] = .009568611159920692;
    HEAP32[i13 >> 2] = 37;
    d6 = .009568611159920692;
    break L17;
   }
  default:
   {
    i5 = HEAP32[gb + 8808 >> 2] | 0;
    _fwrite(gb + 31189 | 0, 58, 1, i5) | 0;
    _exit(1);
   }
  } else if ((i4 | 0) < 65536) switch (i4 | 0) {
  case 32768:
   {
    HEAPF32[i13 + 116 >> 2] = 6.0516102239489555e-03;
    HEAP32[i13 >> 2] = 38;
    d6 = 6.0516102239489555e-03;
    break L17;
   }
  default:
   {
    i5 = HEAP32[gb + 8808 >> 2] | 0;
    _fwrite(gb + 31189 | 0, 58, 1, i5) | 0;
    _exit(1);
   }
  } else switch (i4 | 0) {
  case 65536:
   {
    HEAPF32[i13 + 116 >> 2] = .004784196149557829;
    HEAP32[i13 >> 2] = 39;
    d6 = .004784196149557829;
    break L17;
   }
  default:
   {
    i5 = HEAP32[gb + 8808 >> 2] | 0;
    _fwrite(gb + 31189 | 0, 58, 1, i5) | 0;
    _exit(1);
   }
  }
 } else switch (i4 | 0) {
 case 4:
  {
   HEAPF32[i13 + 116 >> 2] = .7071067690849304;
   HEAP32[i13 >> 2] = 25;
   d6 = .7071067690849304;
   break L17;
  }
 case 8:
  {
   HEAPF32[i13 + 116 >> 2] = .40824830532073975;
   HEAP32[i13 >> 2] = 26;
   d6 = .40824830532073975;
   break L17;
  }
 case 16:
  {
   HEAPF32[i13 + 116 >> 2] = .3162277638912201;
   HEAP32[i13 >> 2] = 27;
   d6 = .3162277638912201;
   break L17;
  }
 case 32:
  {
   HEAPF32[i13 + 116 >> 2] = .1961161345243454;
   HEAP32[i13 >> 2] = 28;
   d6 = .1961161345243454;
   break L17;
  }
 case 64:
  {
   HEAPF32[i13 + 116 >> 2] = .15430335700511932;
   HEAP32[i13 >> 2] = 29;
   d6 = .15430335700511932;
   break L17;
  }
 case 128:
  {
   HEAPF32[i13 + 116 >> 2] = .09712858498096466;
   HEAP32[i13 >> 2] = 30;
   d6 = .09712858498096466;
   break L17;
  }
 case 256:
  {
   HEAPF32[i13 + 116 >> 2] = .0766965001821518;
   HEAP32[i13 >> 2] = 31;
   d6 = .0766965001821518;
   break L17;
  }
 default:
  {
   i5 = HEAP32[gb + 8808 >> 2] | 0;
   _fwrite(gb + 31189 | 0, 58, 1, i5) | 0;
   _exit(1);
  }
 } while (0);
 i2 = i13 + 116 | 0;
 i3 = i13 + 12 | 0;
 HEAPF32[i3 >> 2] = d6;
 if ((HEAP32[i10 >> 2] | 0) >>> 0 > 1) {
  i1 = 1;
  do {
   HEAPF32[i3 + (i1 << 2) >> 2] = +(1 << i1 | 0) * +HEAPF32[i2 >> 2];
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < (HEAP32[i10 >> 2] | 0) >>> 0);
 }
 i1 = HEAP32[i11 >> 2] | 0;
 HEAP32[i7 >> 2] = fb + 19;
 HEAP32[i13 + 240 >> 2] = fb + 20;
 HEAP32[i8 >> 2] = _malloc(i1 << 3) | 0;
 _modem_init_map(i13);
 HEAP32[i9 >> 2] = 1;
 i1 = HEAP32[i10 >> 2] | 0;
 if ((i1 | 0) != 3) {
  if (i1 >>> 0 > 3) _modem_demodsoft_gentab(i13, 4);
 } else _modem_demodsoft_gentab(i13, 3);
 HEAPF32[i13 + 84 >> 2] = 1.0;
 HEAPF32[i13 + 88 >> 2] = 0.0;
 HEAP32[i13 + 92 >> 2] = 1065353216;
 HEAPF32[i13 + 96 >> 2] = 0.0;
 if (!(_liquid_modem_is_dpsk(HEAP32[i13 >> 2] | 0) | 0)) return i13 | 0;
 HEAPF32[i12 >> 2] = 0.0;
 return i13 | 0;
}

function _resamp_rrrf_execute_output_block(i1, i15, i21, i25, i16, i14, i26) {
 i1 = i1 | 0;
 i15 = i15 | 0;
 i21 = i21 | 0;
 i25 = i25 | 0;
 i16 = i16 | 0;
 i14 = i14 | 0;
 i26 = i26 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i22 = 0, i23 = 0, i24 = 0, i27 = 0, d28 = 0.0, d29 = 0.0;
 i27 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i20 = i27 + 24 | 0;
 i23 = i27 + 16 | 0;
 i22 = i27 + 8 | 0;
 i19 = i27;
 i18 = i27 + 28 | 0;
 i24 = i1 + 28 | 0;
 if (!i14) {
  i23 = i1 + 44 | 0;
  i21 = 0;
  i22 = 0;
  HEAP32[i25 >> 2] = i21;
  HEAP32[i26 >> 2] = i22;
  i25 = HEAP32[i24 >> 2] | 0;
  i26 = HEAP32[i23 >> 2] | 0;
  i26 = i25 >>> 0 < i26 >>> 0;
  i26 = i26 & 1;
  STACKTOP = i27;
  return i26 | 0;
 }
 i7 = i1 + 32 | 0;
 i8 = i1 + 48 | 0;
 i3 = i1 + 44 | 0;
 i9 = i1 + 52 | 0;
 i10 = i1 + 36 | 0;
 i11 = i1 + 20 | 0;
 i12 = i1 + 24 | 0;
 i13 = i1 + 40 | 0;
 i6 = i1 + 16 | 0;
 i4 = 0;
 i17 = 0;
 L5 : while (1) {
  i2 = HEAP32[i24 >> 2] | 0;
  L7 : while (1) {
   if (!i2) if (+HEAPF32[i7 >> 2] == 0.0) {
    if ((i4 | 0) == (i21 | 0)) {
     i2 = i21;
     i1 = i17;
     i5 = 25;
     break L5;
    }
    _windowf_push(HEAP32[(HEAP32[i8 >> 2] | 0) + 16 >> 2] | 0, +HEAPF32[i15 + (i4 << 2) >> 2]);
    i2 = HEAP32[i24 >> 2] | 0;
    i4 = i4 + 1 | 0;
   } else i2 = 0;
   i1 = HEAP32[i3 >> 2] | 0;
   if (i2 >>> 0 >= i1 >>> 0) do {
    if ((i4 | 0) == (i21 | 0)) {
     i2 = i21;
     i1 = i17;
     i5 = 25;
     break L5;
    }
    HEAPF32[i11 >> 2] = +HEAPF32[i11 >> 2] + -1.0;
    HEAPF32[i12 >> 2] = +HEAPF32[i12 >> 2] - +(i1 >>> 0);
    HEAP32[i24 >> 2] = i2 - i1;
    _windowf_push(HEAP32[(HEAP32[i8 >> 2] | 0) + 16 >> 2] | 0, +HEAPF32[i15 + (i4 << 2) >> 2]);
    i4 = i4 + 1 | 0;
    i2 = HEAP32[i24 >> 2] | 0;
    i1 = HEAP32[i3 >> 2] | 0;
   } while (i2 >>> 0 >= i1 >>> 0);
   switch (HEAP32[i9 >> 2] | 0) {
   case 0:
    {
     i2 = i4;
     i5 = 16;
     break L7;
    }
   case 1:
    break;
   default:
    {
     i5 = 24;
     break L5;
    }
   }
   i5 = HEAP32[i8 >> 2] | 0;
   i1 = HEAP32[i5 + 12 >> 2] | 0;
   if (i1 >>> 0 <= i2 >>> 0) {
    i5 = 19;
    break L5;
   }
   _windowf_read(HEAP32[i5 + 16 >> 2] | 0, i18);
   _dotprod_rrrf_execute(HEAP32[(HEAP32[i5 + 20 >> 2] | 0) + (i2 << 2) >> 2] | 0, HEAP32[i18 >> 2] | 0, i10);
   HEAPF32[i10 >> 2] = +HEAPF32[i5 + 24 >> 2] * +HEAPF32[i10 >> 2];
   i1 = HEAP32[i24 >> 2] | 0;
   i2 = HEAP32[i3 >> 2] | 0;
   if ((i1 | 0) != (i2 + -1 | 0)) {
    i2 = i1;
    i5 = 20;
    break;
   }
   HEAP32[i9 >> 2] = 0;
   HEAP32[i24 >> 2] = i2;
  }
  if ((i5 | 0) == 16) {
   i1 = HEAP32[i8 >> 2] | 0;
   if (!(HEAP32[i1 + 12 >> 2] | 0)) {
    i5 = 17;
    break;
   }
   _windowf_read(HEAP32[i1 + 16 >> 2] | 0, i18);
   _dotprod_rrrf_execute(HEAP32[HEAP32[i1 + 20 >> 2] >> 2] | 0, HEAP32[i18 >> 2] | 0, i13);
   d28 = +HEAPF32[i1 + 24 >> 2] * +HEAPF32[i13 >> 2];
   HEAPF32[i13 >> 2] = d28;
   d29 = +HEAPF32[i7 >> 2];
   HEAPF32[i16 + (i17 << 2) >> 2] = (1.0 - d29) * +HEAPF32[i10 >> 2] + d29 * d28;
   d28 = +HEAPF32[i6 >> 2] + +HEAPF32[i11 >> 2];
   HEAPF32[i11 >> 2] = d28;
   d28 = d28 * +((HEAP32[i3 >> 2] | 0) >>> 0);
   HEAPF32[i12 >> 2] = d28;
   i5 = ~~+Math_floor(+d28);
   HEAP32[i24 >> 2] = i5;
   HEAPF32[i7 >> 2] = d28 - +(i5 | 0);
   HEAP32[i9 >> 2] = 1;
  } else if ((i5 | 0) == 20) {
   i5 = HEAP32[i8 >> 2] | 0;
   i1 = HEAP32[i5 + 12 >> 2] | 0;
   i2 = i2 + 1 | 0;
   if (i1 >>> 0 <= i2 >>> 0) {
    i5 = 21;
    break;
   }
   _windowf_read(HEAP32[i5 + 16 >> 2] | 0, i18);
   _dotprod_rrrf_execute(HEAP32[(HEAP32[i5 + 20 >> 2] | 0) + (i2 << 2) >> 2] | 0, HEAP32[i18 >> 2] | 0, i13);
   d29 = +HEAPF32[i5 + 24 >> 2] * +HEAPF32[i13 >> 2];
   HEAPF32[i13 >> 2] = d29;
   d28 = +HEAPF32[i7 >> 2];
   HEAPF32[i16 + (i17 << 2) >> 2] = (1.0 - d28) * +HEAPF32[i10 >> 2] + d28 * d29;
   d29 = +HEAPF32[i6 >> 2] + +HEAPF32[i11 >> 2];
   HEAPF32[i11 >> 2] = d29;
   d29 = d29 * +((HEAP32[i3 >> 2] | 0) >>> 0);
   HEAPF32[i12 >> 2] = d29;
   i2 = ~~+Math_floor(+d29);
   HEAP32[i24 >> 2] = i2;
   HEAPF32[i7 >> 2] = d29 - +(i2 | 0);
   i2 = i4;
  }
  i1 = i17 + 1 | 0;
  if (i1 >>> 0 < i14 >>> 0) {
   i4 = i2;
   i17 = i1;
  } else {
   i5 = 25;
   break;
  }
 }
 if ((i5 | 0) == 17) {
  i27 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i19 >> 2] = 0;
  HEAP32[i19 + 4 >> 2] = 0;
  _fprintf(i27, gb + 20859 | 0, i19) | 0;
  _exit(1);
 } else if ((i5 | 0) == 19) {
  i27 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i22 >> 2] = i2;
  HEAP32[i22 + 4 >> 2] = i1;
  _fprintf(i27, gb + 20859 | 0, i22) | 0;
  _exit(1);
 } else if ((i5 | 0) == 21) {
  i27 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i23 >> 2] = i2;
  HEAP32[i23 + 4 >> 2] = i1;
  _fprintf(i27, gb + 20859 | 0, i23) | 0;
  _exit(1);
 } else if ((i5 | 0) == 24) {
  i27 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i20 >> 2] = gb + 18911;
  _fprintf(i27, gb + 19605 | 0, i20) | 0;
  _exit(1);
 } else if ((i5 | 0) == 25) {
  HEAP32[i25 >> 2] = i2;
  HEAP32[i26 >> 2] = i1;
  i25 = HEAP32[i24 >> 2] | 0;
  i26 = HEAP32[i3 >> 2] | 0;
  i26 = i25 >>> 0 < i26 >>> 0;
  i26 = i26 & 1;
  STACKTOP = i27;
  return i26 | 0;
 }
 return 0;
}

function _ofdmframesync_execute_S0b(i30) {
 i30 = i30 | 0;
 var d1 = 0.0, d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, d13 = 0.0, d14 = 0.0, d15 = 0.0, d16 = 0.0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i31 = 0, i32 = 0, i33 = 0;
 i31 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i27 = i31 + 112 | 0;
 i26 = i31 + 88 | 0;
 i4 = i31 + 64 | 0;
 i3 = i31 + 104 | 0;
 i9 = i31 + 96 | 0;
 i10 = i31 + 80 | 0;
 i11 = i31 + 72 | 0;
 i20 = i31 + 56 | 0;
 i21 = i31 + 48 | 0;
 i22 = i31 + 40 | 0;
 i23 = i31 + 32 | 0;
 i24 = i31 + 24 | 0;
 i25 = i31 + 16 | 0;
 i19 = i31 + 8 | 0;
 i28 = i31;
 i5 = i30 + 124 | 0;
 i18 = (HEAP32[i5 >> 2] | 0) + 1 | 0;
 HEAP32[i5 >> 2] = i18;
 i29 = i30 + 4 | 0;
 if (i18 >>> 0 < (HEAP32[i29 >> 2] | 0) >>> 0) {
  STACKTOP = i31;
  return;
 }
 i18 = i30 + 8 | 0;
 HEAP32[i5 >> 2] = (HEAP32[i18 >> 2] | 0) + (HEAP32[i30 >> 2] | 0) - (HEAP32[i30 + 132 >> 2] | 0);
 _windowcf_read(HEAP32[i30 + 60 >> 2] | 0, i26);
 i12 = i30 + 88 | 0;
 _ofdmframesync_estimate_gain_S0(i30, (HEAP32[i26 >> 2] | 0) + (HEAP32[i18 >> 2] << 3) | 0, HEAP32[i12 >> 2] | 0);
 _ofdmframesync_S0_metrics(i30, HEAP32[i12 >> 2] | 0, i4);
 d16 = +HEAPF32[i30 + 80 >> 2];
 i18 = i4 + 4 | 0;
 d15 = d16 * +HEAPF32[i4 >> 2];
 d16 = d16 * +HEAPF32[i18 >> 2];
 HEAPF32[i4 >> 2] = d15;
 HEAPF32[i18 >> 2] = d16;
 HEAPF32[i30 + 144 >> 2] = d15;
 HEAPF32[i30 + 148 >> 2] = d16;
 d16 = d16 + +HEAPF32[i30 + 140 >> 2];
 HEAPF32[i3 >> 2] = d15 + +HEAPF32[i30 + 136 >> 2];
 HEAPF32[i3 + 4 >> 2] = d16;
 HEAP32[i27 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i27 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
 d16 = +_cargf(i27);
 i3 = HEAP32[i29 >> 2] | 0;
 i18 = ~~+_roundf(+(d16 * +(i3 >>> 0) / 6.283185307179586));
 HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) - i18;
 if (HEAP32[i30 >> 2] | 0) {
  i3 = i30 + 84 | 0;
  i4 = i10 + 4 | 0;
  i5 = i9 + 4 | 0;
  i8 = 0;
  do {
   i17 = HEAP32[i12 >> 2] | 0;
   d1 = +HEAPF32[i17 + (i8 << 3) >> 2];
   d2 = +HEAPF32[i17 + (i8 << 3) + 4 >> 2];
   i17 = HEAP32[i3 >> 2] | 0;
   i18 = HEAP32[i17 + (i8 << 3) + 4 >> 2] | 0;
   HEAP32[i10 >> 2] = HEAP32[i17 + (i8 << 3) >> 2];
   HEAP32[i4 >> 2] = i18;
   HEAP32[i27 >> 2] = HEAP32[i10 >> 2];
   HEAP32[i27 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
   _conjf(i9, i27);
   d6 = +HEAPF32[i9 >> 2];
   d7 = +HEAPF32[i5 >> 2];
   d15 = d1 * d6 - d2 * d7;
   d16 = d2 * d6 + d1 * d7;
   if ((d15 != d15 | 0.0 != 0.0) & (d16 != d16 | 0.0 != 0.0)) ___mulsc3(i11, d1, d2, d6, d7);
   i8 = i8 + 1 | 0;
  } while (i8 >>> 0 < (HEAP32[i30 >> 2] | 0) >>> 0);
  i3 = HEAP32[i29 >> 2] | 0;
 }
 if (!i3) {
  d2 = 0.0;
  d1 = 0.0;
 } else {
  i4 = i21 + 4 | 0;
  i5 = i20 + 4 | 0;
  i8 = i30 + 68 | 0;
  i9 = i22 + 4 | 0;
  i10 = i23 + 4 | 0;
  i11 = i25 + 4 | 0;
  i12 = i24 + 4 | 0;
  i17 = i19 + 4 | 0;
  i18 = 0;
  d2 = 0.0;
  d1 = 0.0;
  do {
   i32 = HEAP32[i26 >> 2] | 0;
   i3 = HEAP32[i32 + (i18 << 3) + 4 >> 2] | 0;
   HEAP32[i21 >> 2] = HEAP32[i32 + (i18 << 3) >> 2];
   HEAP32[i4 >> 2] = i3;
   HEAP32[i27 >> 2] = HEAP32[i21 >> 2];
   HEAP32[i27 + 4 >> 2] = HEAP32[i21 + 4 >> 2];
   _conjf(i20, i27);
   d6 = +HEAPF32[i20 >> 2];
   d7 = +HEAPF32[i5 >> 2];
   i3 = HEAP32[i8 >> 2] | 0;
   d13 = +HEAPF32[i3 + (i18 << 3) >> 2];
   d14 = +HEAPF32[i3 + (i18 << 3) + 4 >> 2];
   d15 = d6 * d13 - d7 * d14;
   d16 = d7 * d13 + d6 * d14;
   if ((d15 != d15 | 0.0 != 0.0) & (d16 != d16 | 0.0 != 0.0)) {
    ___mulsc3(i22, d6, d7, d13, d14);
    d15 = +HEAPF32[i22 >> 2];
    d16 = +HEAPF32[i9 >> 2];
   }
   i3 = HEAP32[i29 >> 2] | 0;
   i32 = i3 + i18 | 0;
   i33 = HEAP32[i26 >> 2] | 0;
   d6 = +HEAPF32[i33 + (i32 << 3) >> 2];
   d7 = +HEAPF32[i33 + (i32 << 3) + 4 >> 2];
   d13 = d15 * d6 - d16 * d7;
   d14 = d16 * d6 + d15 * d7;
   if ((d13 != d13 | 0.0 != 0.0) & (d14 != d14 | 0.0 != 0.0)) {
    ___mulsc3(i23, d15, d16, d6, d7);
    i3 = HEAP32[i29 >> 2] | 0;
    d16 = +HEAPF32[i23 >> 2];
    d15 = +HEAPF32[i10 >> 2];
   } else {
    d16 = d13;
    d15 = d14;
   }
   i32 = i3 + i18 | 0;
   i3 = HEAP32[i8 >> 2] | 0;
   i33 = HEAP32[i3 + (i32 << 3) + 4 >> 2] | 0;
   HEAP32[i25 >> 2] = HEAP32[i3 + (i32 << 3) >> 2];
   HEAP32[i11 >> 2] = i33;
   HEAP32[i27 >> 2] = HEAP32[i25 >> 2];
   HEAP32[i27 + 4 >> 2] = HEAP32[i25 + 4 >> 2];
   _conjf(i24, i27);
   d13 = +HEAPF32[i24 >> 2];
   d14 = +HEAPF32[i12 >> 2];
   d6 = d16 * d13 - d15 * d14;
   d7 = d15 * d13 + d16 * d14;
   if ((d6 != d6 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
    ___mulsc3(i19, d16, d15, d13, d14);
    d6 = +HEAPF32[i19 >> 2];
    d7 = +HEAPF32[i17 >> 2];
   }
   d2 = d2 + d6;
   d1 = d1 + d7;
   i18 = i18 + 1 | 0;
  } while (i18 >>> 0 < (HEAP32[i29 >> 2] | 0) >>> 0);
 }
 HEAPF32[i28 >> 2] = d2;
 HEAPF32[i28 + 4 >> 2] = d1;
 HEAP32[i27 >> 2] = HEAP32[i28 >> 2];
 HEAP32[i27 + 4 >> 2] = HEAP32[i28 + 4 >> 2];
 d16 = +_cargf(i27);
 _nco_crcf_set_frequency(HEAP32[i30 + 108 >> 2] | 0, d16 / +((HEAP32[i29 >> 2] | 0) >>> 0));
 HEAP32[i30 + 104 >> 2] = 3;
 STACKTOP = i31;
 return;
}

function _detector_cccf_create(i3, i4, d1, d2) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 d1 = +d1;
 d2 = +d2;
 var i5 = 0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0;
 i36 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i27 = i36 + 48 | 0;
 i28 = i36 + 40 | 0;
 i29 = i36 + 32 | 0;
 i32 = i36 + 24 | 0;
 i33 = i36 + 16 | 0;
 i34 = i36 + 8 | 0;
 i35 = i36;
 if (!i4) {
  _fwrite(gb + 40269 | 0, 62, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d1 <= 0.0) {
  _fwrite(gb + 40332 | 0, 85, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i30 = _malloc(80) | 0;
 i31 = i30 + 4 | 0;
 HEAP32[i31 >> 2] = i4;
 HEAPF32[i30 + 8 >> 2] = d1;
 d11 = +(i4 >>> 0);
 HEAPF32[i30 + 12 >> 2] = 1.0 / d11;
 d11 = 2.5132741603225375 / d11;
 i26 = i30 + 28 | 0;
 HEAPF32[i26 >> 2] = d11;
 i24 = ~~+Math_ceil(+(+Math_abs(+(d2 / d11))));
 i25 = i30 + 24 | 0;
 i24 = i24 >>> 0 < 2 ? 2 : i24;
 HEAP32[i25 >> 2] = i24;
 HEAPF32[i30 + 32 >> 2] = d11 * +(i24 >>> 0);
 i24 = i4 << 3;
 i12 = _malloc(i24) | 0;
 HEAP32[i30 >> 2] = i12;
 _memcpy(i12 | 0, i3 | 0, i24 | 0) | 0;
 i24 = i30 + 16 | 0;
 HEAP32[i24 >> 2] = _windowcf_create(i4) | 0;
 i12 = i30 + 60 | 0;
 HEAP32[i12 >> 2] = _wdelayf_create(HEAP32[i31 >> 2] | 0) | 0;
 i3 = HEAP32[i25 >> 2] | 0;
 i5 = i3 << 2;
 i13 = i30 + 20 | 0;
 HEAP32[i13 >> 2] = _malloc(i5) | 0;
 i4 = _malloc(i5) | 0;
 i14 = i30 + 36 | 0;
 HEAP32[i14 >> 2] = i4;
 i15 = i30 + 44 | 0;
 HEAP32[i15 >> 2] = _malloc(i5) | 0;
 i16 = i30 + 48 | 0;
 HEAP32[i16 >> 2] = _malloc(i5) | 0;
 HEAP32[i30 + 40 >> 2] = _malloc(i5) | 0;
 i5 = HEAP32[i31 >> 2] | 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 3) | 0) + 15 & -16) | 0;
 if (!i3) {
  i34 = HEAP32[i24 >> 2] | 0;
  _windowcf_clear(i34);
  i34 = HEAP32[i12 >> 2] | 0;
  _wdelayf_clear(i34);
  i34 = HEAP32[i31 >> 2] | 0;
  i35 = i30 + 76 | 0;
  HEAP32[i35 >> 2] = i34;
  i35 = i30 + 72 | 0;
  HEAP32[i35 >> 2] = 0;
  i35 = i30 + 52 | 0;
  HEAP32[i35 >> 2] = 0;
  i35 = i30 + 56 | 0;
  HEAP32[i35 >> 2] = 0;
  i35 = i30 + 64 | 0;
  HEAPF32[i35 >> 2] = 0.0;
  i35 = HEAP32[i15 >> 2] | 0;
  i34 = HEAP32[i25 >> 2] | 0;
  i34 = i34 << 2;
  _memset(i35 | 0, 0, i34 | 0) | 0;
  i34 = HEAP32[i16 >> 2] | 0;
  i35 = HEAP32[i25 >> 2] | 0;
  i35 = i35 << 2;
  _memset(i34 | 0, 0, i35 | 0) | 0;
  STACKTOP = i36;
  return i30 | 0;
 }
 i18 = i29 + 4 | 0;
 i19 = i28 + 4 | 0;
 i20 = i32 + 4 | 0;
 i21 = i34 + 4 | 0;
 i22 = i33 + 4 | 0;
 i23 = i35 + 4 | 0;
 i6 = i5;
 i5 = 0;
 while (1) {
  HEAPF32[i4 + (i5 << 2) >> 2] = (+(i5 >>> 0) - +((i3 + -1 | 0) >>> 0) * .5) * +HEAPF32[i26 >> 2];
  if (!i6) i3 = 0; else {
   i4 = 0;
   do {
    i3 = HEAP32[i30 >> 2] | 0;
    i6 = HEAP32[i3 + (i4 << 3) + 4 >> 2] | 0;
    HEAP32[i29 >> 2] = HEAP32[i3 + (i4 << 3) >> 2];
    HEAP32[i18 >> 2] = i6;
    HEAP32[i27 >> 2] = HEAP32[i29 >> 2];
    HEAP32[i27 + 4 >> 2] = HEAP32[i29 + 4 >> 2];
    _conjf(i28, i27);
    d10 = +HEAPF32[i28 >> 2];
    d11 = +HEAPF32[i19 >> 2];
    d8 = +HEAPF32[(HEAP32[i14 >> 2] | 0) + (i5 << 2) >> 2];
    d7 = d8 * -0.0;
    d8 = -d8;
    d9 = +(i4 >>> 0);
    d2 = d9 * d7 - d7;
    d1 = d9 * d8 + d7 * 0.0;
    if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
     ___mulsc3(i32, d7, d8, d9, 0.0);
     d2 = +HEAPF32[i32 >> 2];
     d1 = +HEAPF32[i20 >> 2];
    }
    HEAPF32[i34 >> 2] = d2;
    HEAPF32[i21 >> 2] = d1;
    HEAP32[i27 >> 2] = HEAP32[i34 >> 2];
    HEAP32[i27 + 4 >> 2] = HEAP32[i34 + 4 >> 2];
    _cexpf(i33, i27);
    d7 = +HEAPF32[i33 >> 2];
    d8 = +HEAPF32[i22 >> 2];
    d2 = d10 * d7 - d11 * d8;
    d1 = d11 * d7 + d10 * d8;
    if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
     ___mulsc3(i35, d10, d11, d7, d8);
     d2 = +HEAPF32[i35 >> 2];
     d1 = +HEAPF32[i23 >> 2];
    }
    HEAPF32[i17 + (i4 << 3) >> 2] = d2;
    HEAPF32[i17 + (i4 << 3) + 4 >> 2] = d1;
    i4 = i4 + 1 | 0;
    i3 = HEAP32[i31 >> 2] | 0;
   } while (i4 >>> 0 < i3 >>> 0);
  }
  i3 = _dotprod_cccf_create(i17, i3) | 0;
  HEAP32[(HEAP32[i13 >> 2] | 0) + (i5 << 2) >> 2] = i3;
  i5 = i5 + 1 | 0;
  i3 = HEAP32[i25 >> 2] | 0;
  if (i5 >>> 0 >= i3 >>> 0) break;
  i4 = HEAP32[i14 >> 2] | 0;
  i6 = HEAP32[i31 >> 2] | 0;
 }
 i34 = HEAP32[i24 >> 2] | 0;
 _windowcf_clear(i34);
 i34 = HEAP32[i12 >> 2] | 0;
 _wdelayf_clear(i34);
 i34 = HEAP32[i31 >> 2] | 0;
 i35 = i30 + 76 | 0;
 HEAP32[i35 >> 2] = i34;
 i35 = i30 + 72 | 0;
 HEAP32[i35 >> 2] = 0;
 i35 = i30 + 52 | 0;
 HEAP32[i35 >> 2] = 0;
 i35 = i30 + 56 | 0;
 HEAP32[i35 >> 2] = 0;
 i35 = i30 + 64 | 0;
 HEAPF32[i35 >> 2] = 0.0;
 i35 = HEAP32[i15 >> 2] | 0;
 i34 = HEAP32[i25 >> 2] | 0;
 i34 = i34 << 2;
 _memset(i35 | 0, 0, i34 | 0) | 0;
 i34 = HEAP32[i16 >> 2] | 0;
 i35 = HEAP32[i25 >> 2] | 0;
 i35 = i35 << 2;
 _memset(i34 | 0, 0, i35 | 0) | 0;
 STACKTOP = i36;
 return i30 | 0;
}

function _flexframesync_execute_rxpayload(i18, i1) {
 i18 = i18 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0, d20 = 0.0, d21 = 0.0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 i16 = i19 + 48 | 0;
 i6 = i19 + 32 | 0;
 i2 = i19 + 16 | 0;
 i3 = i19 + 8 | 0;
 i8 = i19;
 i4 = i19 + 40 | 0;
 i5 = i19 + 24 | 0;
 i7 = i8 + 4 | 0;
 HEAPF32[i8 >> 2] = 0.0;
 HEAPF32[i7 >> 2] = 0.0;
 i14 = HEAP32[i1 + 4 >> 2] | 0;
 i17 = i18 + 92 | 0;
 i15 = HEAP32[i17 >> 2] | 0;
 HEAP32[i2 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i2 + 4 >> 2] = i14;
 HEAP32[i16 >> 2] = HEAP32[i2 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
 _nco_crcf_mix_down(i15, i16, i6);
 _nco_crcf_step(HEAP32[i17 >> 2] | 0);
 i15 = i18 + 100 | 0;
 i2 = HEAP32[i15 >> 2] | 0;
 i1 = i6 + 4 | 0;
 i14 = HEAP32[i1 >> 2] | 0;
 HEAP32[i3 >> 2] = HEAP32[i6 >> 2];
 HEAP32[i3 + 4 >> 2] = i14;
 HEAP32[i16 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
 _firpfb_crcf_push(i2, i16);
 _firpfb_crcf_execute(HEAP32[i15 >> 2] | 0, HEAP32[i18 + 112 >> 2] | 0, i6);
 i2 = i18 + 108 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 HEAP32[i2 >> 2] = i3 + 1;
 if ((i3 | 0) > -1) {
  i13 = HEAP32[i6 >> 2] | 0;
  i14 = HEAP32[i1 >> 2] | 0;
  HEAP32[i8 >> 2] = i13;
  HEAP32[i7 >> 2] = i14;
  HEAP32[i2 >> 2] = i3 + -1;
  i1 = i13;
  i2 = i14;
 } else {
  i1 = 0;
  i2 = 0;
 }
 if ((i3 | 0) < 0) {
  STACKTOP = i19;
  return;
 }
 i14 = i18 + 96 | 0;
 i12 = HEAP32[i14 >> 2] | 0;
 HEAP32[i4 >> 2] = i1;
 HEAP32[i4 + 4 >> 2] = i2;
 HEAP32[i16 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 _nco_crcf_mix_down(i12, i16, i8);
 i12 = i18 + 164 | 0;
 i10 = HEAP32[i12 >> 2] | 0;
 i13 = HEAP32[i7 >> 2] | 0;
 HEAP32[i5 >> 2] = HEAP32[i8 >> 2];
 HEAP32[i5 + 4 >> 2] = i13;
 HEAP32[i16 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 _modem_demodulate(i10, i16, i6);
 d21 = +_modem_get_demodulator_phase_error(HEAP32[i12 >> 2] | 0);
 d20 = +_modem_get_demodulator_evm(HEAP32[i12 >> 2] | 0);
 _nco_crcf_pll_step(HEAP32[i14 >> 2] | 0, d21);
 _nco_crcf_step(HEAP32[i14 >> 2] | 0);
 i12 = i18 + 8 | 0;
 HEAPF32[i12 >> 2] = d20 * d20 + +HEAPF32[i12 >> 2];
 i10 = HEAP32[i7 >> 2] | 0;
 i13 = i18 + 196 | 0;
 i11 = HEAP32[i13 >> 2] | 0;
 i3 = i18 + 168 | 0;
 i1 = HEAP32[i3 >> 2] | 0;
 HEAP32[i1 + (i11 << 3) >> 2] = HEAP32[i8 >> 2];
 HEAP32[i1 + (i11 << 3) + 4 >> 2] = i10;
 i11 = (HEAP32[i13 >> 2] | 0) + 1 | 0;
 HEAP32[i13 >> 2] = i11;
 i1 = i18 + 172 | 0;
 if ((i11 | 0) != (HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i19;
  return;
 }
 i2 = i18 + 176 | 0;
 i4 = i18 + 180 | 0;
 i11 = _qpacketmodem_decode(HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
 i7 = i18 + 188 | 0;
 HEAP32[i7 >> 2] = i11;
 i5 = i18 + 48 | 0;
 HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) + 1;
 i5 = i18 + 52 | 0;
 HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) + 1;
 i5 = i18 + 56 | 0;
 HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) + i11;
 i5 = i18 + 184 | 0;
 i11 = i18 + 60 | 0;
 HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + (HEAP32[i5 >> 2] | 0);
 if (HEAP32[i18 >> 2] | 0) {
  i9 = _qpacketmodem_get_modscheme(HEAP32[i2 >> 2] | 0) | 0;
  HEAPF32[i12 >> 2] = +_log10f(+HEAPF32[i12 >> 2] / +((HEAP32[i1 >> 2] | 0) >>> 0)) * 10.0;
  HEAPF32[i18 + 12 >> 2] = +_log10f(+HEAPF32[i18 + 88 >> 2]) * 20.0;
  HEAPF32[i18 + 16 >> 2] = +_nco_crcf_get_frequency(HEAP32[i17 >> 2] | 0);
  HEAP32[i18 + 20 >> 2] = HEAP32[i3 >> 2];
  HEAP32[i18 + 24 >> 2] = HEAP32[i1 >> 2];
  HEAP32[i18 + 28 >> 2] = i9;
  HEAP32[i18 + 32 >> 2] = HEAP32[gb + 580 + (i9 << 4) + 12 >> 2];
  HEAP32[i18 + 36 >> 2] = _qpacketmodem_get_crc(HEAP32[i2 >> 2] | 0) | 0;
  HEAP32[i18 + 40 >> 2] = _qpacketmodem_get_fec0(HEAP32[i2 >> 2] | 0) | 0;
  HEAP32[i18 + 44 >> 2] = _qpacketmodem_get_fec1(HEAP32[i2 >> 2] | 0) | 0;
  i9 = HEAP32[i18 >> 2] | 0;
  i10 = HEAP32[i18 + 156 >> 2] | 0;
  i11 = HEAP32[i18 + 160 >> 2] | 0;
  i8 = HEAP32[i4 >> 2] | 0;
  i6 = HEAP32[i5 >> 2] | 0;
  i3 = HEAP32[i7 >> 2] | 0;
  i4 = HEAP32[i18 + 4 >> 2] | 0;
  i5 = i16;
  i1 = i12;
  i2 = i5 + 40 | 0;
  do {
   HEAP32[i5 >> 2] = HEAP32[i1 >> 2];
   i5 = i5 + 4 | 0;
   i1 = i1 + 4 | 0;
  } while ((i5 | 0) < (i2 | 0));
  mftCall_iiiiiiii(i9 | 0, i10 | 0, i11 | 0, i8 | 0, i6 | 0, i3 | 0, i16 | 0, i4 | 0) | 0;
 }
 _nco_crcf_reset(HEAP32[i17 >> 2] | 0);
 _nco_crcf_reset(HEAP32[i14 >> 2] | 0);
 _firpfb_crcf_reset(HEAP32[i15 >> 2] | 0);
 HEAP32[i18 + 200 >> 2] = 0;
 HEAP32[i18 + 192 >> 2] = 0;
 HEAP32[i13 >> 2] = 0;
 HEAPF32[i18 + 8 >> 2] = 0.0;
 STACKTOP = i19;
 return;
}

function _qdetector_cccf_execute_seek(i36, i1) {
 i36 = i36 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, d13 = 0.0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i37 = 0, i38 = 0, i39 = 0;
 i37 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i25 = i37 + 40 | 0;
 i26 = i37 + 32 | 0;
 i27 = i37 + 24 | 0;
 i28 = i37 + 16 | 0;
 i29 = i37 + 8 | 0;
 i30 = i37;
 i34 = HEAP32[i1 >> 2] | 0;
 i33 = HEAP32[i1 + 4 >> 2] | 0;
 i35 = i36 + 44 | 0;
 i1 = HEAP32[i35 >> 2] | 0;
 HEAP32[i35 >> 2] = i1 + 1;
 i32 = i36 + 16 | 0;
 i31 = HEAP32[i32 >> 2] | 0;
 HEAP32[i31 + (i1 << 3) >> 2] = i34;
 HEAP32[i31 + (i1 << 3) + 4 >> 2] = i33;
 d10 = (HEAP32[tempDoublePtr >> 2] = i34, +HEAPF32[tempDoublePtr >> 2]);
 d13 = (HEAP32[tempDoublePtr >> 2] = i33, +HEAPF32[tempDoublePtr >> 2]);
 i33 = i36 + 64 | 0;
 HEAPF32[i33 >> 2] = +HEAPF32[i33 >> 2] + (d10 * d10 + d13 * d13);
 i34 = i36 + 32 | 0;
 i1 = HEAP32[i34 >> 2] | 0;
 if ((HEAP32[i35 >> 2] | 0) >>> 0 < i1 >>> 0) {
  STACKTOP = i37;
  return;
 }
 HEAP32[i35 >> 2] = i1 >>> 1;
 _fft_execute(HEAP32[i36 + 36 >> 2] | 0);
 i31 = i36 + 60 | 0;
 d10 = +Math_sqrt(+(+HEAPF32[i31 >> 2] + +HEAPF32[i33 >> 2]));
 i4 = HEAP32[i34 >> 2] | 0;
 d13 = +(i4 >>> 0);
 d13 = d13 * (d10 * +Math_sqrt(+(+((HEAP32[i36 >> 2] | 0) >>> 0) / d13)));
 d13 = 1.0 / (d13 * +Math_sqrt(+(+HEAPF32[i36 + 12 >> 2])));
 i14 = i36 + 52 | 0;
 i24 = HEAP32[i14 >> 2] | 0;
 i1 = 0 - i24 | 0;
 if ((i24 | 0) < (i1 | 0)) {
  i3 = 0;
  i1 = 0;
  d2 = 0.0;
 } else {
  i15 = i36 + 40 | 0;
  i16 = i36 + 28 | 0;
  i17 = i29 + 4 | 0;
  i18 = i30 + 4 | 0;
  i19 = i36 + 20 | 0;
  i20 = i36 + 8 | 0;
  i21 = i27 + 4 | 0;
  i22 = i26 + 4 | 0;
  i23 = i28 + 4 | 0;
  i24 = i36 + 24 | 0;
  i12 = i1;
  i3 = 0;
  i1 = 0;
  d2 = 0.0;
  while (1) {
   if (i4 | 0) {
    i11 = 0;
    do {
     i38 = ((i11 - i12 + i4 | 0) >>> 0) % (i4 >>> 0) | 0;
     i39 = HEAP32[i19 >> 2] | 0;
     d7 = +HEAPF32[i39 + (i11 << 3) >> 2];
     d8 = +HEAPF32[i39 + (i11 << 3) + 4 >> 2];
     i39 = HEAP32[i20 >> 2] | 0;
     i4 = HEAP32[i39 + (i38 << 3) + 4 >> 2] | 0;
     HEAP32[i27 >> 2] = HEAP32[i39 + (i38 << 3) >> 2];
     HEAP32[i21 >> 2] = i4;
     HEAP32[i25 >> 2] = HEAP32[i27 >> 2];
     HEAP32[i25 + 4 >> 2] = HEAP32[i27 + 4 >> 2];
     _conjf(i26, i25);
     d9 = +HEAPF32[i26 >> 2];
     d10 = +HEAPF32[i22 >> 2];
     d6 = d7 * d9 - d8 * d10;
     d5 = d8 * d9 + d7 * d10;
     if ((d6 != d6 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
      ___mulsc3(i28, d7, d8, d9, d10);
      d6 = +HEAPF32[i28 >> 2];
      d5 = +HEAPF32[i23 >> 2];
     }
     i4 = HEAP32[i24 >> 2] | 0;
     HEAPF32[i4 + (i11 << 3) >> 2] = d6;
     HEAPF32[i4 + (i11 << 3) + 4 >> 2] = d5;
     i11 = i11 + 1 | 0;
     i4 = HEAP32[i34 >> 2] | 0;
    } while (i11 >>> 0 < i4 >>> 0);
   }
   _fft_execute(HEAP32[i15 >> 2] | 0);
   i39 = HEAP32[i16 >> 2] | 0;
   i38 = HEAP32[i34 >> 2] | 0;
   HEAPF32[i29 >> 2] = d13;
   HEAPF32[i17 >> 2] = 0.0;
   HEAP32[i25 >> 2] = HEAP32[i29 >> 2];
   HEAP32[i25 + 4 >> 2] = HEAP32[i29 + 4 >> 2];
   _liquid_vectorcf_mulscalar(i39, i38, i25, i39);
   if (!(HEAP32[i34 >> 2] | 0)) i4 = 0; else {
    i11 = 0;
    do {
     i39 = HEAP32[i16 >> 2] | 0;
     i4 = HEAP32[i39 + (i11 << 3) + 4 >> 2] | 0;
     HEAP32[i30 >> 2] = HEAP32[i39 + (i11 << 3) >> 2];
     HEAP32[i18 >> 2] = i4;
     HEAP32[i25 >> 2] = HEAP32[i30 >> 2];
     HEAP32[i25 + 4 >> 2] = HEAP32[i30 + 4 >> 2];
     d10 = +_cabsf(i25);
     i4 = d10 > d2;
     d2 = i4 ? d10 : d2;
     i3 = i4 ? i11 : i3;
     i1 = i4 ? i12 : i1;
     i11 = i11 + 1 | 0;
     i4 = HEAP32[i34 >> 2] | 0;
    } while (i11 >>> 0 < i4 >>> 0);
   }
   if ((i12 | 0) < (HEAP32[i14 >> 2] | 0)) i12 = i12 + 1 | 0; else break;
  }
 }
 i39 = i36 + 56 | 0;
 HEAP32[i39 >> 2] = (HEAP32[i39 >> 2] | 0) + 1;
 if (d2 > +HEAPF32[i36 + 48 >> 2] ? i3 >>> 0 < (i4 - (HEAP32[i36 >> 2] | 0) | 0) >>> 0 : 0) {
  HEAP32[i36 + 88 >> 2] = 1;
  HEAP32[i36 + 68 >> 2] = i1;
  i39 = HEAP32[i32 >> 2] | 0;
  _memmove(i39 | 0, i39 + (i3 << 3) | 0, i4 - i3 << 3 | 0) | 0;
  HEAP32[i35 >> 2] = (HEAP32[i34 >> 2] | 0) - i3;
  STACKTOP = i37;
  return;
 }
 i38 = HEAP32[i32 >> 2] | 0;
 i39 = i4 >>> 1;
 _memmove(i38 | 0, i38 + (i39 << 3) | 0, i39 << 3 | 0) | 0;
 HEAP32[i31 >> 2] = HEAP32[i33 >> 2];
 HEAPF32[i33 >> 2] = 0.0;
 STACKTOP = i37;
 return;
}

function _fpoly_bessel_roots_orchard(i29, i30) {
 i29 = i29 | 0;
 i30 = i30 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i31 = 0, i32 = 0, i33 = 0;
 i31 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i25 = i31 + 56 | 0;
 i2 = i31 + 48 | 0;
 i3 = i31 + 40 | 0;
 i16 = i31 + 24 | 0;
 i19 = i31 + 16 | 0;
 i24 = i31 + 32 | 0;
 i26 = i31 + 8 | 0;
 i27 = i31;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i29 << 3) | 0) + 15 & -16) | 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i29 << 3) | 0) + 15 & -16) | 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i29 << 3) | 0) + 15 & -16) | 0;
 L1 : do if (i29 >>> 0 > 1) {
  i4 = i21 + 4 | 0;
  i5 = i2 + 4 | 0;
  i6 = i20 + 4 | 0;
  i11 = i16 + 4 | 0;
  i12 = i3 + 4 | 0;
  i13 = i28 + 4 | 0;
  i14 = i19 + 4 | 0;
  i22 = 1;
  i23 = 1;
  while (1) {
   i15 = (i22 + (i23 & 1) | 0) >>> 1;
   i17 = i22 & 1;
   i1 = i17 + i22 | 0;
   i18 = i1 >>> 1;
   switch (i22 | 0) {
   case 1:
    {
     HEAPF32[i21 >> 2] = -1.0;
     HEAPF32[i4 >> 2] = 0.0;
     HEAPF32[i28 >> 2] = -1.0;
     HEAPF32[i13 >> 2] = 0.0;
     break;
    }
   case 2:
    {
     HEAPF32[i21 >> 2] = -1.0;
     HEAPF32[i4 >> 2] = 0.0;
     HEAPF32[i28 >> 2] = -1.5;
     HEAPF32[i13 >> 2] = .8660253882408142;
     break;
    }
   default:
    {
     d10 = +HEAPF32[i21 >> 2];
     if (!i17) {
      d8 = +HEAPF32[i4 >> 2];
      d9 = d10 * 2.0 - d8 * 0.0;
      d7 = d10 * 0.0 + d8 * 2.0;
      if ((d9 != d9 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
       ___mulsc3(i2, 2.0, 0.0, d10, d8);
       d9 = +HEAPF32[i2 >> 2];
       d7 = +HEAPF32[i5 >> 2];
      }
      i32 = HEAP32[i6 >> 2] | 0;
      HEAP32[i16 >> 2] = HEAP32[i20 >> 2];
      HEAP32[i11 >> 2] = i32;
      HEAP32[i25 >> 2] = HEAP32[i16 >> 2];
      HEAP32[i25 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
      _conjf(i3, i25);
      d8 = d7 - +HEAPF32[i12 >> 2];
      d7 = d9 - +HEAPF32[i3 >> 2];
     } else {
      d8 = 0.0;
      d7 = d10 * 2.0 - +HEAPF32[i20 >> 2];
     }
     HEAPF32[i28 >> 2] = d7;
     HEAPF32[i13 >> 2] = d8;
     if (i1 >>> 0 > 3) {
      i1 = 1;
      do {
       i32 = i1 - i17 | 0;
       d9 = +HEAPF32[i21 + (i32 << 3) >> 2];
       d10 = +HEAPF32[i21 + (i32 << 3) + 4 >> 2];
       d8 = d9 * 2.0 - d10 * 0.0;
       d7 = d9 * 0.0 + d10 * 2.0;
       if ((d8 != d8 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
        ___mulsc3(i19, 2.0, 0.0, d9, d10);
        d8 = +HEAPF32[i19 >> 2];
        d7 = +HEAPF32[i14 >> 2];
       }
       i32 = i1 + -1 | 0;
       d10 = d7 - +HEAPF32[i20 + (i32 << 3) + 4 >> 2];
       HEAPF32[i28 + (i1 << 3) >> 2] = d8 - +HEAPF32[i20 + (i32 << 3) >> 2];
       HEAPF32[i28 + (i1 << 3) + 4 >> 2] = d10;
       i1 = i1 + 1 | 0;
      } while (i1 >>> 0 < i18 >>> 0);
     }
     if (i18 | 0) {
      i1 = 0;
      do {
       i33 = i28 + (i1 << 3) | 0;
       i32 = i28 + (i1 << 3) + 4 | 0;
       _fpoly_bessel_roots_orchard_recursion(i22, +HEAPF32[i33 >> 2], +HEAPF32[i32 >> 2], i25, i24);
       d10 = +HEAPF32[i24 >> 2];
       HEAPF32[i33 >> 2] = +HEAPF32[i25 >> 2] + d10 * 0.0;
       HEAPF32[i32 >> 2] = d10;
       i1 = i1 + 1 | 0;
      } while ((i1 | 0) != (i15 | 0));
     }
    }
   }
   _memcpy(i20 | 0, i21 | 0, i18 - i17 << 3 | 0) | 0;
   _memcpy(i21 | 0, i28 | 0, i18 << 3 | 0) | 0;
   i22 = i22 + 1 | 0;
   if ((i22 | 0) == (i29 | 0)) break L1; else i23 = i23 ^ 1;
  }
 } while (0);
 i1 = i29 & 1;
 i2 = (i29 - i1 | 0) >>> 1;
 if (i2 | 0) {
  i3 = i27 + 4 | 0;
  i4 = i26 + 4 | 0;
  i5 = i29 >>> 1;
  i6 = 0;
  do {
   i32 = i2 - i6 + -1 | 0;
   i24 = HEAP32[i28 + (i32 << 3) >> 2] | 0;
   i32 = HEAP32[i28 + (i32 << 3) + 4 >> 2] | 0;
   i33 = i6 << 1;
   HEAP32[i30 + (i33 << 3) >> 2] = i24;
   HEAP32[i30 + (i33 << 3) + 4 >> 2] = i32;
   HEAP32[i27 >> 2] = i24;
   HEAP32[i3 >> 2] = i32;
   HEAP32[i25 >> 2] = HEAP32[i27 >> 2];
   HEAP32[i25 + 4 >> 2] = HEAP32[i27 + 4 >> 2];
   _conjf(i26, i25);
   i32 = HEAP32[i4 >> 2] | 0;
   i33 = i33 | 1;
   HEAP32[i30 + (i33 << 3) >> 2] = HEAP32[i26 >> 2];
   HEAP32[i30 + (i33 << 3) + 4 >> 2] = i32;
   i6 = i6 + 1 | 0;
  } while ((i6 | 0) != (i5 | 0));
 }
 if (!i1) {
  STACKTOP = i31;
  return;
 }
 i32 = HEAP32[i28 + 4 >> 2] | 0;
 i33 = i29 + -1 | 0;
 HEAP32[i30 + (i33 << 3) >> 2] = HEAP32[i28 >> 2];
 HEAP32[i30 + (i33 << 3) + 4 >> 2] = i32;
 STACKTOP = i31;
 return;
}

function _liquid_iirdes(i1, i14, i23, i16, d10, d15, d5, d6, i22, i21) {
 i1 = i1 | 0;
 i14 = i14 | 0;
 i23 = i23 | 0;
 i16 = i16 | 0;
 d10 = +d10;
 d15 = +d15;
 d5 = +d5;
 d6 = +d6;
 i22 = i22 | 0;
 i21 = i21 | 0;
 var i2 = 0, i3 = 0, d4 = 0.0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i12 = 0, i13 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i24 = 0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i18 = i24 + 40 | 0;
 i7 = i24 + 24 | 0;
 i17 = i24 + 8 | 0;
 i11 = i24 + 32 | 0;
 i19 = i24 + 16 | 0;
 i20 = i24;
 if (!(!(d10 <= 0.0) & !(d10 >= .5))) {
  _fwrite(gb + 23298 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d15 < 0.0 | d15 > .5) {
  _fwrite(gb + 23353 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d5 <= 0.0) {
  _fwrite(gb + 23408 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d6 <= 0.0) {
  _fwrite(gb + 23463 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i16) {
  _fwrite(gb + 23518 | 0, 49, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i12 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i16 << 3) | 0) + 15 & -16) | 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i16 << 3) | 0) + 15 & -16) | 0;
 i2 = i16 & 1;
 i3 = (i16 - i2 | 0) >>> 1;
 switch (i1 | 0) {
 case 0:
  {
   _butter_azpkf(i16, i13, i12, i7);
   d4 = 1.0;
   i9 = 0;
   break;
  }
 case 1:
  {
   d5 = +Math_sqrt(+(+Math_pow(10.0, +(d5 / 10.0)) + -1.0));
   if (!i2) d4 = 1.0 / +Math_sqrt(+(d5 * d5 + 1.0)); else d4 = 1.0;
   _cheby1_azpkf(i16, d5, i13, i12, i7);
   i9 = 0;
   break;
  }
 case 2:
  {
   _cheby2_azpkf(i16, +Math_pow(10.0, +(-d6 / 20.0)), i13, i12, i7);
   d4 = 1.0;
   i9 = i3 << 1;
   break;
  }
 case 3:
  {
   d5 = +Math_pow(10.0, +(-d5 / 20.0));
   d6 = +Math_pow(10.0, +(-d6 / 20.0));
   d5 = +Math_sqrt(+(1.0 / (d5 * d5) + -1.0));
   d6 = +Math_sqrt(+(1.0 / (d6 * d6) + -1.0));
   if (!i2) d4 = 1.0 / +Math_sqrt(+(d5 * d5 + 1.0)); else d4 = 1.0;
   _ellip_azpkf(i16, d5, d6, i13, i12, i7);
   i9 = i3 << 1;
   break;
  }
 case 4:
  {
   _bessel_azpkf(i16, i13, i12, i7);
   d4 = 1.0;
   i9 = 0;
   break;
  }
 default:
  {
   _fwrite(gb + 23568 | 0, 44, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 i2 = i16 << 1;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i2 << 3) | 0) + 15 & -16) | 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i2 << 3) | 0) + 15 & -16) | 0;
 switch (i14 | 0) {
 case 0:
  {
   d5 = +Math_tan(+(d10 * 3.141592653589793));
   break;
  }
 case 1:
  {
   d5 = d10 * 3.141592653589793;
   d5 = -+Math_cos(+d5) / +Math_sin(+d5);
   break;
  }
 case 2:
  {
   d5 = d10 * 6.283185307179586;
   d5 = (+Math_cos(+d5) - +Math_cos(+(d15 * 6.283185307179586))) / +Math_sin(+d5);
   break;
  }
 case 3:
  {
   d5 = d10 * 6.283185307179586;
   d5 = +Math_sin(+d5) / (+Math_cos(+d5) - +Math_cos(+(d15 * 6.283185307179586)));
   break;
  }
 default:
  d5 = 0.0;
 }
 d10 = +Math_abs(+d5);
 HEAPF32[i11 >> 2] = d4;
 HEAPF32[i11 + 4 >> 2] = 0.0;
 HEAP32[i18 >> 2] = HEAP32[i11 >> 2];
 HEAP32[i18 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
 _bilinear_zpkf(i13, i9, i12, i16, i18, d10, i7, i8, i17);
 if ((i14 | 2 | 0) == 3) {
  i1 = 0;
  do {
   i13 = i7 + (i1 << 3) | 0;
   i12 = i7 + (i1 << 3) + 4 | 0;
   d10 = -+HEAPF32[i12 >> 2];
   HEAPF32[i13 >> 2] = -+HEAPF32[i13 >> 2];
   HEAPF32[i12 >> 2] = d10;
   i12 = i8 + (i1 << 3) | 0;
   i13 = i8 + (i1 << 3) + 4 | 0;
   d10 = -+HEAPF32[i13 >> 2];
   HEAPF32[i12 >> 2] = -+HEAPF32[i12 >> 2];
   HEAPF32[i13 >> 2] = d10;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i16 | 0));
 }
 if ((i14 | 1 | 0) == 3) {
  i14 = _llvm_stacksave() | 0;
  i12 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i2 << 3) | 0) + 15 & -16) | 0;
  i13 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i2 << 3) | 0) + 15 & -16) | 0;
  _iirdes_dzpk_lp2bp(i7, i8, i16, d15, i12, i13);
  i16 = i16 << 4;
  _memcpy(i7 | 0, i12 | 0, i16 | 0) | 0;
  _memcpy(i8 | 0, i13 | 0, i16 | 0) | 0;
  _llvm_stackrestore(i14 | 0);
 } else i2 = i16;
 i3 = HEAP32[i17 >> 2] | 0;
 i1 = HEAP32[i17 + 4 >> 2] | 0;
 if ((i23 | 0) == 1) {
  HEAP32[i19 >> 2] = i3;
  HEAP32[i19 + 4 >> 2] = i1;
  HEAP32[i18 >> 2] = HEAP32[i19 >> 2];
  HEAP32[i18 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
  _iirdes_dzpk2tff(i7, i8, i2, i18, i22, i21);
  STACKTOP = i24;
  return;
 } else {
  HEAP32[i20 >> 2] = i3;
  HEAP32[i20 + 4 >> 2] = i1;
  HEAP32[i18 >> 2] = HEAP32[i20 >> 2];
  HEAP32[i18 + 4 >> 2] = HEAP32[i20 + 4 >> 2];
  _iirdes_dzpk2sosf(i7, i8, i2, i18, i22, i21);
  STACKTOP = i24;
  return;
 }
}

function _firdespm_create(i6, i11, i15, i16, i14, i12, i7) {
 i6 = i6 | 0;
 i11 = i11 | 0;
 i15 = i15 | 0;
 i16 = i16 | 0;
 i14 = i14 | 0;
 i12 = i12 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i8 = 0, i9 = 0, i10 = 0, i13 = 0, d17 = 0.0;
 i3 = i11 << 1;
 if (i3) {
  i1 = 1;
  i2 = 0;
  do {
   d5 = +HEAPF32[i15 + (i2 << 2) >> 2];
   i1 = d5 <= .5 & d5 >= 0.0 & 1 & i1;
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i3 | 0));
  if (i3 >>> 0 > 1) {
   d5 = +HEAPF32[i15 >> 2];
   i2 = 1;
   do {
    d17 = d5;
    d5 = +HEAPF32[i15 + (i2 << 2) >> 2];
    i1 = d5 >= d17 & i1;
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i3 | 0));
  }
 } else i1 = 1;
 i4 = (i11 | 0) == 0;
 if (i4) i2 = 1; else {
  i3 = 0;
  i2 = 1;
  do {
   i2 = +HEAPF32[i14 + (i3 << 2) >> 2] > 0.0 & i2;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i11 | 0));
 }
 if (!i1) {
  _fwrite(gb + 21876 | 0, 40, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i2) {
  _fwrite(gb + 21917 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i4) {
  _fwrite(gb + 21979 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i13 = _malloc(96) | 0;
 HEAP32[i13 >> 2] = i6;
 i9 = i6 & 1;
 HEAP32[i13 + 4 >> 2] = i9;
 i8 = (i6 - i9 | 0) >>> 1;
 HEAP32[i13 + 8 >> 2] = i8;
 i9 = i8 + i9 | 0;
 i8 = i13 + 12 | 0;
 HEAP32[i8 >> 2] = i9;
 HEAP32[i13 + 28 >> 2] = i7;
 HEAP32[i13 + 88 >> 2] = _malloc((i9 << 2) + 4 | 0) | 0;
 i9 = (i9 << 3) + 8 | 0;
 HEAP32[i13 + 64 >> 2] = _malloc(i9) | 0;
 HEAP32[i13 + 68 >> 2] = _malloc(i9) | 0;
 HEAP32[i13 + 72 >> 2] = _malloc(i9) | 0;
 i9 = i13 + 16 | 0;
 HEAP32[i9 >> 2] = i11;
 i10 = i13 + 32 | 0;
 HEAP32[i10 >> 2] = _malloc(i11 << 4) | 0;
 i1 = i11 << 3;
 i4 = i13 + 36 | 0;
 HEAP32[i4 >> 2] = _malloc(i1) | 0;
 i7 = i13 + 40 | 0;
 HEAP32[i7 >> 2] = _malloc(i1) | 0;
 i1 = _malloc(i11 << 2) | 0;
 i3 = i13 + 44 | 0;
 HEAP32[i3 >> 2] = i1;
 if (!i12) {
  HEAP32[i1 >> 2] = 0;
  i1 = HEAP32[i9 >> 2] | 0;
  if (i1 >>> 0 > 1) {
   i2 = 1;
   do {
    HEAP32[(HEAP32[i3 >> 2] | 0) + (i2 << 2) >> 2] = 0;
    i2 = i2 + 1 | 0;
    i1 = HEAP32[i9 >> 2] | 0;
   } while (i2 >>> 0 < i1 >>> 0);
  }
 } else {
  HEAP32[i1 >> 2] = HEAP32[i12 >> 2];
  i1 = HEAP32[i9 >> 2] | 0;
  if (i1 >>> 0 > 1) {
   i2 = 1;
   do {
    HEAP32[(HEAP32[i3 >> 2] | 0) + (i2 << 2) >> 2] = HEAP32[i12 + (i2 << 2) >> 2];
    i2 = i2 + 1 | 0;
    i1 = HEAP32[i9 >> 2] | 0;
   } while (i2 >>> 0 < i1 >>> 0);
  }
 }
 if (i1 | 0) {
  i6 = HEAP32[i10 >> 2] | 0;
  i4 = HEAP32[i4 >> 2] | 0;
  i3 = HEAP32[i7 >> 2] | 0;
  if (!i14) {
   i2 = 0;
   do {
    i14 = i2 << 1;
    HEAPF64[i6 + (i14 << 3) >> 3] = +HEAPF32[i15 + (i14 << 2) >> 2];
    i14 = i14 | 1;
    HEAPF64[i6 + (i14 << 3) >> 3] = +HEAPF32[i15 + (i14 << 2) >> 2];
    HEAPF64[i4 + (i2 << 3) >> 3] = +HEAPF32[i16 + (i2 << 2) >> 2];
    HEAPF64[i3 + (i2 << 3) >> 3] = 1.0;
    i2 = i2 + 1 | 0;
   } while (i2 >>> 0 < i1 >>> 0);
  } else {
   i2 = 0;
   do {
    i12 = i2 << 1;
    HEAPF64[i6 + (i12 << 3) >> 3] = +HEAPF32[i15 + (i12 << 2) >> 2];
    i12 = i12 | 1;
    HEAPF64[i6 + (i12 << 3) >> 3] = +HEAPF32[i15 + (i12 << 2) >> 2];
    HEAPF64[i4 + (i2 << 3) >> 3] = +HEAPF32[i16 + (i2 << 2) >> 2];
    HEAPF64[i3 + (i2 << 3) >> 3] = +HEAPF32[i14 + (i2 << 2) >> 2];
    i2 = i2 + 1 | 0;
   } while (i2 >>> 0 < i1 >>> 0);
  }
 }
 HEAP32[i13 + 24 >> 2] = 20;
 i6 = i13 + 20 | 0;
 HEAP32[i6 >> 2] = 0;
 d5 = .5 / +(((HEAP32[i8 >> 2] | 0) * 20 | 0) >>> 0);
 i4 = HEAP32[i9 >> 2] | 0;
 if (!i4) {
  i15 = 0;
  i14 = _malloc(i15) | 0;
  i16 = i13 + 48 | 0;
  HEAP32[i16 >> 2] = i14;
  i16 = _malloc(i15) | 0;
  i14 = i13 + 52 | 0;
  HEAP32[i14 >> 2] = i16;
  i14 = _malloc(i15) | 0;
  i16 = i13 + 56 | 0;
  HEAP32[i16 >> 2] = i14;
  i15 = _malloc(i15) | 0;
  i16 = i13 + 60 | 0;
  HEAP32[i16 >> 2] = i15;
  _firdespm_init_grid(i13);
  return i13 | 0;
 }
 i2 = HEAP32[i10 >> 2] | 0;
 i1 = 0;
 i3 = 0;
 do {
  i16 = i3 << 1;
  i1 = (~~((+HEAPF64[i2 + ((i16 | 1) << 3) >> 3] - +HEAPF64[i2 + (i16 << 3) >> 3]) / d5 + 1.0) >>> 0) + i1 | 0;
  i3 = i3 + 1 | 0;
 } while (i3 >>> 0 < i4 >>> 0);
 HEAP32[i6 >> 2] = i1;
 i15 = i1 << 3;
 i14 = _malloc(i15) | 0;
 i16 = i13 + 48 | 0;
 HEAP32[i16 >> 2] = i14;
 i16 = _malloc(i15) | 0;
 i14 = i13 + 52 | 0;
 HEAP32[i14 >> 2] = i16;
 i14 = _malloc(i15) | 0;
 i16 = i13 + 56 | 0;
 HEAP32[i16 >> 2] = i14;
 i15 = _malloc(i15) | 0;
 i16 = i13 + 60 | 0;
 HEAP32[i16 >> 2] = i15;
 _firdespm_init_grid(i13);
 return i13 | 0;
}

function ___udivmoddi4(i5, i6, i8, i11, i13) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 i8 = i8 | 0;
 i11 = i11 | 0;
 i13 = i13 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i9 = 0, i10 = 0, i12 = 0, i14 = 0, i15 = 0;
 i9 = i5;
 i4 = i6;
 i7 = i4;
 i2 = i8;
 i12 = i11;
 i3 = i12;
 if (!i7) {
  i1 = (i13 | 0) != 0;
  if (!i3) {
   if (i1) {
    HEAP32[i13 >> 2] = (i9 >>> 0) % (i2 >>> 0);
    HEAP32[i13 + 4 >> 2] = 0;
   }
   i12 = 0;
   i13 = (i9 >>> 0) / (i2 >>> 0) >>> 0;
   return (setTempRet0(i12 | 0), i13) | 0;
  } else {
   if (!i1) {
    i12 = 0;
    i13 = 0;
    return (setTempRet0(i12 | 0), i13) | 0;
   }
   HEAP32[i13 >> 2] = i5 | 0;
   HEAP32[i13 + 4 >> 2] = i6 & 0;
   i12 = 0;
   i13 = 0;
   return (setTempRet0(i12 | 0), i13) | 0;
  }
 }
 i1 = (i3 | 0) == 0;
 do if (i2) {
  if (!i1) {
   i1 = (Math_clz32(i3 | 0) | 0) - (Math_clz32(i7 | 0) | 0) | 0;
   if (i1 >>> 0 <= 31) {
    i10 = i1 + 1 | 0;
    i3 = 31 - i1 | 0;
    i6 = i1 - 31 >> 31;
    i2 = i10;
    i5 = i9 >>> (i10 >>> 0) & i6 | i7 << i3;
    i6 = i7 >>> (i10 >>> 0) & i6;
    i1 = 0;
    i3 = i9 << i3;
    break;
   }
   if (!i13) {
    i12 = 0;
    i13 = 0;
    return (setTempRet0(i12 | 0), i13) | 0;
   }
   HEAP32[i13 >> 2] = i5 | 0;
   HEAP32[i13 + 4 >> 2] = i4 | i6 & 0;
   i12 = 0;
   i13 = 0;
   return (setTempRet0(i12 | 0), i13) | 0;
  }
  i1 = i2 - 1 | 0;
  if (i1 & i2 | 0) {
   i3 = (Math_clz32(i2 | 0) | 0) + 33 - (Math_clz32(i7 | 0) | 0) | 0;
   i15 = 64 - i3 | 0;
   i10 = 32 - i3 | 0;
   i4 = i10 >> 31;
   i14 = i3 - 32 | 0;
   i6 = i14 >> 31;
   i2 = i3;
   i5 = i10 - 1 >> 31 & i7 >>> (i14 >>> 0) | (i7 << i10 | i9 >>> (i3 >>> 0)) & i6;
   i6 = i6 & i7 >>> (i3 >>> 0);
   i1 = i9 << i15 & i4;
   i3 = (i7 << i15 | i9 >>> (i14 >>> 0)) & i4 | i9 << i10 & i3 - 33 >> 31;
   break;
  }
  if (i13 | 0) {
   HEAP32[i13 >> 2] = i1 & i9;
   HEAP32[i13 + 4 >> 2] = 0;
  }
  if ((i2 | 0) == 1) {
   i14 = i4 | i6 & 0;
   i15 = i5 | 0 | 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  } else {
   i15 = _llvm_cttz_i32(i2 | 0) | 0;
   i14 = i7 >>> (i15 >>> 0) | 0;
   i15 = i7 << 32 - i15 | i9 >>> (i15 >>> 0) | 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
 } else {
  if (i1) {
   if (i13 | 0) {
    HEAP32[i13 >> 2] = (i7 >>> 0) % (i2 >>> 0);
    HEAP32[i13 + 4 >> 2] = 0;
   }
   i14 = 0;
   i15 = (i7 >>> 0) / (i2 >>> 0) >>> 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  if (!i9) {
   if (i13 | 0) {
    HEAP32[i13 >> 2] = 0;
    HEAP32[i13 + 4 >> 2] = (i7 >>> 0) % (i3 >>> 0);
   }
   i14 = 0;
   i15 = (i7 >>> 0) / (i3 >>> 0) >>> 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  i1 = i3 - 1 | 0;
  if (!(i1 & i3)) {
   if (i13 | 0) {
    HEAP32[i13 >> 2] = i5 | 0;
    HEAP32[i13 + 4 >> 2] = i1 & i7 | i6 & 0;
   }
   i14 = 0;
   i15 = i7 >>> ((_llvm_cttz_i32(i3 | 0) | 0) >>> 0);
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  i1 = (Math_clz32(i3 | 0) | 0) - (Math_clz32(i7 | 0) | 0) | 0;
  if (i1 >>> 0 <= 30) {
   i6 = i1 + 1 | 0;
   i3 = 31 - i1 | 0;
   i2 = i6;
   i5 = i7 << i3 | i9 >>> (i6 >>> 0);
   i6 = i7 >>> (i6 >>> 0);
   i1 = 0;
   i3 = i9 << i3;
   break;
  }
  if (!i13) {
   i14 = 0;
   i15 = 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  HEAP32[i13 >> 2] = i5 | 0;
  HEAP32[i13 + 4 >> 2] = i4 | i6 & 0;
  i14 = 0;
  i15 = 0;
  return (setTempRet0(i14 | 0), i15) | 0;
 } while (0);
 if (!i2) {
  i7 = i3;
  i4 = 0;
  i3 = 0;
 } else {
  i10 = i8 | 0 | 0;
  i9 = i12 | i11 & 0;
  i7 = _i64Add(i10 | 0, i9 | 0, -1, -1) | 0;
  i8 = getTempRet0() | 0;
  i4 = i3;
  i3 = 0;
  do {
   i11 = i4;
   i4 = i1 >>> 31 | i4 << 1;
   i1 = i3 | i1 << 1;
   i11 = i5 << 1 | i11 >>> 31 | 0;
   i12 = i5 >>> 31 | i6 << 1 | 0;
   _i64Subtract(i7 | 0, i8 | 0, i11 | 0, i12 | 0) | 0;
   i15 = getTempRet0() | 0;
   i14 = i15 >> 31 | ((i15 | 0) < 0 ? -1 : 0) << 1;
   i3 = i14 & 1;
   i5 = _i64Subtract(i11 | 0, i12 | 0, i14 & i10 | 0, (((i15 | 0) < 0 ? -1 : 0) >> 31 | ((i15 | 0) < 0 ? -1 : 0) << 1) & i9 | 0) | 0;
   i6 = getTempRet0() | 0;
   i2 = i2 - 1 | 0;
  } while ((i2 | 0) != 0);
  i7 = i4;
  i4 = 0;
 }
 i2 = 0;
 if (i13 | 0) {
  HEAP32[i13 >> 2] = i5;
  HEAP32[i13 + 4 >> 2] = i6;
 }
 i14 = (i1 | 0) >>> 31 | (i7 | i2) << 1 | (i2 << 1 | i1 >>> 31) & 0 | i4;
 i15 = (i1 << 1 | 0 >>> 31) & -2 | i3;
 return (setTempRet0(i14 | 0), i15) | 0;
}

function _fft_create_plan_rader2(i5, i1, i2, i3, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, i15 = 0, d16 = 0.0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i23 = i28 + 40 | 0;
 i21 = i28 + 32 | 0;
 i24 = i28;
 i25 = i28 + 24 | 0;
 i26 = i28 + 16 | 0;
 i27 = _malloc(72) | 0;
 HEAP32[i27 >> 2] = i5;
 HEAP32[i27 + 4 >> 2] = i1;
 HEAP32[i27 + 8 >> 2] = i2;
 i10 = i27 + 16 | 0;
 HEAP32[i10 >> 2] = i4;
 i1 = (i3 | 0) == 1 ? 1 : -1;
 HEAP32[i27 + 20 >> 2] = i1;
 i9 = i27 + 12 | 0;
 HEAP32[i9 >> 2] = i1;
 HEAP32[i27 + 24 >> 2] = 4;
 HEAP32[i27 + 28 >> 2] = fb + 11;
 i1 = _liquid_primitive_root_prime(i5) | 0;
 i2 = _malloc((i5 << 2) + -4 | 0) | 0;
 i22 = i27 + 40 | 0;
 i15 = i27 + 44 | 0;
 HEAP32[i15 >> 2] = i2;
 if ((i5 | 0) == 1) i1 = -3; else {
  i3 = i5 + -1 | 0;
  i4 = 0;
  do {
   i20 = i4;
   i4 = i4 + 1 | 0;
   HEAP32[i2 + (i20 << 2) >> 2] = _liquid_modpow(i1, i4, i5) | 0;
  } while (i4 >>> 0 < i3 >>> 0);
  i1 = (i5 << 1) + -5 | 0;
 }
 HEAP32[i22 >> 2] = i1;
 i2 = 0;
 do {
  i1 = i1 >>> 1;
  i2 = i2 + 1 | 0;
 } while ((i1 | 0) != 0);
 i1 = i2;
 i18 = 1 << i1;
 HEAP32[i22 >> 2] = i18;
 i5 = i18 << 3;
 i19 = _malloc(i5) | 0;
 HEAP32[i27 + 52 >> 2] = i19;
 i5 = _malloc(i5) | 0;
 i20 = i27 + 56 | 0;
 HEAP32[i20 >> 2] = i5;
 i2 = HEAP32[i10 >> 2] | 0;
 i17 = i27 + 60 | 0;
 HEAP32[i17 >> 2] = _fft_create_plan(i18, i19, i5, 1, i2) | 0;
 HEAP32[i27 + 64 >> 2] = _fft_create_plan(i18, i5, i19, -1, i2) | 0;
 d13 = (HEAP32[i9 >> 2] | 0) == 1 ? -1.0 : 1.0;
 d14 = d13 * 0.0;
 d6 = d14 * 2.0 - d14;
 d7 = d13 * 2.0 + d14 * 0.0;
 i2 = i21 + 4 | 0;
 i5 = HEAP32[i27 >> 2] | 0;
 i10 = i5 + -1 | 0;
 i3 = HEAP32[i15 >> 2] | 0;
 i4 = i24 + 8 | 0;
 d16 = +(i5 >>> 0);
 i5 = i26 + 4 | 0;
 i9 = i25 + 4 | 0;
 if ((d6 != d6 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
  i1 = 0;
  do {
   ___mulsc3(i21, d14, d13, 2.0, 0.0);
   d8 = +HEAPF32[i21 >> 2] * 3.141592653589793;
   d11 = +HEAPF32[i2 >> 2] * 3.141592653589793;
   d12 = +((HEAP32[i3 + (((i1 >>> 0) % (i10 >>> 0) | 0) << 2) >> 2] | 0) >>> 0);
   d7 = d8 * d12 - d11 * 0.0;
   d6 = d8 * 0.0 + d11 * d12;
   if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
    ___muldc3(i24, d8, d11, d12, 0.0);
    d7 = +HEAPF64[i24 >> 3];
    d6 = +HEAPF64[i4 >> 3];
   }
   HEAPF32[i26 >> 2] = d7 / d16;
   HEAPF32[i5 >> 2] = d6 / d16;
   HEAP32[i23 >> 2] = HEAP32[i26 >> 2];
   HEAP32[i23 + 4 >> 2] = HEAP32[i26 + 4 >> 2];
   _cexpf(i25, i23);
   i15 = HEAP32[i9 >> 2] | 0;
   HEAP32[i19 + (i1 << 3) >> 2] = HEAP32[i25 >> 2];
   HEAP32[i19 + (i1 << 3) + 4 >> 2] = i15;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i18 >>> 0);
  i26 = HEAP32[i17 >> 2] | 0;
  i24 = i26 + 28 | 0;
  i24 = HEAP32[i24 >> 2] | 0;
  mftCall_vi(i24 | 0, i26 | 0);
  i26 = HEAP32[i22 >> 2] | 0;
  i26 = i26 << 3;
  i24 = _malloc(i26) | 0;
  i25 = i27 + 48 | 0;
  HEAP32[i25 >> 2] = i24;
  i25 = HEAP32[i20 >> 2] | 0;
  _memmove(i24 | 0, i25 | 0, i26 | 0) | 0;
  STACKTOP = i28;
  return i27 | 0;
 }
 d14 = d6 * 3.141592653589793;
 d11 = d7 * 3.141592653589793;
 d12 = d11 * 0.0;
 d13 = d14 * 0.0;
 i1 = 0;
 do {
  d7 = +((HEAP32[i3 + (((i1 >>> 0) % (i10 >>> 0) | 0) << 2) >> 2] | 0) >>> 0);
  d8 = d14 * d7 - d12;
  d6 = d13 + d11 * d7;
  if ((d8 != d8 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
   ___muldc3(i24, d14, d11, d7, 0.0);
   d8 = +HEAPF64[i24 >> 3];
   d6 = +HEAPF64[i4 >> 3];
  }
  HEAPF32[i26 >> 2] = d8 / d16;
  HEAPF32[i5 >> 2] = d6 / d16;
  HEAP32[i23 >> 2] = HEAP32[i26 >> 2];
  HEAP32[i23 + 4 >> 2] = HEAP32[i26 + 4 >> 2];
  _cexpf(i25, i23);
  i21 = HEAP32[i9 >> 2] | 0;
  HEAP32[i19 + (i1 << 3) >> 2] = HEAP32[i25 >> 2];
  HEAP32[i19 + (i1 << 3) + 4 >> 2] = i21;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i18 >>> 0);
 i26 = HEAP32[i17 >> 2] | 0;
 i24 = i26 + 28 | 0;
 i24 = HEAP32[i24 >> 2] | 0;
 mftCall_vi(i24 | 0, i26 | 0);
 i26 = HEAP32[i22 >> 2] | 0;
 i26 = i26 << 3;
 i24 = _malloc(i26) | 0;
 i25 = i27 + 48 | 0;
 HEAP32[i25 >> 2] = i24;
 i25 = HEAP32[i20 >> 2] | 0;
 _memmove(i24 | 0, i25 | 0, i26 | 0) | 0;
 STACKTOP = i28;
 return i27 | 0;
}

function _lex_scan_number(i4, i1, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i2 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i13 = i16 + 32 | 0;
 i12 = i16 + 24 | 0;
 i11 = i16 + 16 | 0;
 i15 = i16 + 56 | 0;
 i14 = i16 + 52 | 0;
 i7 = i16 + 48 | 0;
 i8 = i16 + 44 | 0;
 i5 = i16 + 40 | 0;
 i2 = i16 + 36 | 0;
 i9 = i16 + 8 | 0;
 i10 = i16;
 HEAP32[i14 >> 2] = i4;
 HEAP32[i7 >> 2] = i1;
 HEAP32[i8 >> 2] = i3;
 HEAP32[(HEAP32[i14 >> 2] | 0) + 56 >> 2] = -1;
 if ((HEAP32[i7 >> 2] | 0) == 45) HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
 do if ((HEAP32[i7 >> 2] | 0) == 48) {
  HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  if (48 <= (HEAP32[i7 >> 2] | 0) & (HEAP32[i7 >> 2] | 0) <= 57) _lex_unget_unsave(HEAP32[i14 >> 2] | 0, HEAP32[i7 >> 2] | 0); else i6 = 9;
 } else if (48 <= (HEAP32[i7 >> 2] | 0) & (HEAP32[i7 >> 2] | 0) <= 57) {
  do HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0; while (48 <= (HEAP32[i7 >> 2] | 0) ? (HEAP32[i7 >> 2] | 0) <= 57 : 0);
  i6 = 9;
 } else {
  _lex_unget_unsave(HEAP32[i14 >> 2] | 0, HEAP32[i7 >> 2] | 0);
  break;
 } while (0);
 do if ((i6 | 0) == 9) {
  if (((HEAP32[i7 >> 2] | 0) != 46 ? (HEAP32[(HEAP32[i14 >> 2] | 0) + 52 >> 2] & 8 | 0) == 0 : 0) & (HEAP32[i7 >> 2] | 0) != 69 & (HEAP32[i7 >> 2] | 0) != 101) {
   _lex_unget_unsave(HEAP32[i14 >> 2] | 0, HEAP32[i7 >> 2] | 0);
   HEAP32[i5 >> 2] = _strbuffer_value((HEAP32[i14 >> 2] | 0) + 40 | 0) | 0;
   HEAP32[(___errno_location() | 0) >> 2] = 0;
   i7 = _strtoll(HEAP32[i5 >> 2] | 0, i2, 10) | 0;
   i9 = getTempRet0() | 0;
   i13 = i10;
   HEAP32[i13 >> 2] = i7;
   HEAP32[i13 + 4 >> 2] = i9;
   if ((HEAP32[(___errno_location() | 0) >> 2] | 0) == 34) {
    i2 = HEAP32[i8 >> 2] | 0;
    i1 = HEAP32[i14 >> 2] | 0;
    if ((HEAP32[i10 + 4 >> 2] | 0) < 0) {
     _error_set(i2, i1, gb + 40984 | 0, i11);
     break;
    } else {
     _error_set(i2, i1, gb + 41009 | 0, i12);
     break;
    }
   }
   if ((HEAP32[i2 >> 2] | 0) != ((HEAP32[i5 >> 2] | 0) + (HEAP32[(HEAP32[i14 >> 2] | 0) + 40 + 4 >> 2] | 0) | 0)) ___assert_fail(gb + 41025 | 0, gb + 40619 | 0, 530, gb + 41068 | 0);
   HEAP32[(HEAP32[i14 >> 2] | 0) + 56 >> 2] = 257;
   i12 = i10;
   i13 = HEAP32[i12 + 4 >> 2] | 0;
   i14 = (HEAP32[i14 >> 2] | 0) + 64 | 0;
   HEAP32[i14 >> 2] = HEAP32[i12 >> 2];
   HEAP32[i14 + 4 >> 2] = i13;
   HEAP32[i15 >> 2] = 0;
   i15 = HEAP32[i15 >> 2] | 0;
   STACKTOP = i16;
   return i15 | 0;
  }
  if ((HEAP32[i7 >> 2] | 0) == 46) {
   HEAP32[i7 >> 2] = _lex_get(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   i1 = HEAP32[i14 >> 2] | 0;
   i2 = HEAP32[i7 >> 2] | 0;
   if (!(48 <= (HEAP32[i7 >> 2] | 0) & (HEAP32[i7 >> 2] | 0) <= 57)) {
    _lex_unget(i1, i2);
    break;
   }
   _lex_save(i1, i2);
   do HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0; while (48 <= (HEAP32[i7 >> 2] | 0) ? (HEAP32[i7 >> 2] | 0) <= 57 : 0);
  }
  if ((HEAP32[i7 >> 2] | 0) == 69 | (HEAP32[i7 >> 2] | 0) == 101) {
   HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   if ((HEAP32[i7 >> 2] | 0) == 43 | (HEAP32[i7 >> 2] | 0) == 45) HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   if (48 <= (HEAP32[i7 >> 2] | 0) & (HEAP32[i7 >> 2] | 0) <= 57) do HEAP32[i7 >> 2] = _lex_get_save(HEAP32[i14 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0; while (48 <= (HEAP32[i7 >> 2] | 0) ? (HEAP32[i7 >> 2] | 0) <= 57 : 0); else {
    _lex_unget_unsave(HEAP32[i14 >> 2] | 0, HEAP32[i7 >> 2] | 0);
    break;
   }
  }
  _lex_unget_unsave(HEAP32[i14 >> 2] | 0, HEAP32[i7 >> 2] | 0);
  if (_jsonp_strtod((HEAP32[i14 >> 2] | 0) + 40 | 0, i9) | 0) {
   _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i14 >> 2] | 0, gb + 41084 | 0, i13);
   break;
  }
  HEAP32[(HEAP32[i14 >> 2] | 0) + 56 >> 2] = 258;
  HEAPF64[(HEAP32[i14 >> 2] | 0) + 64 >> 3] = +HEAPF64[i9 >> 3];
  HEAP32[i15 >> 2] = 0;
  i15 = HEAP32[i15 >> 2] | 0;
  STACKTOP = i16;
  return i15 | 0;
 } while (0);
 HEAP32[i15 >> 2] = -1;
 i15 = HEAP32[i15 >> 2] | 0;
 STACKTOP = i16;
 return i15 | 0;
}

function _firdespm_iext_search(i17) {
 i17 = i17 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i18 = 0, i19 = 0, d20 = 0.0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i19;
 i6 = HEAP32[i17 + 12 >> 2] | 0;
 i7 = (HEAP32[i17 + 16 >> 2] | 0) + i6 << 1;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i7 << 2) | 0) + 15 & -16) | 0;
 HEAP32[i18 >> 2] = 0;
 i4 = (HEAP32[i17 + 20 >> 2] | 0) + -1 | 0;
 L1 : do if (i4 >>> 0 > 1) {
  i2 = HEAP32[i17 + 60 >> 2] | 0;
  i3 = 1;
  i1 = 1;
  while (1) {
   d5 = +HEAPF64[i2 + (i3 << 3) >> 3];
   if ((d5 >= 0.0 ? +HEAPF64[i2 + (i3 + -1 << 3) >> 3] <= d5 : 0) ? +HEAPF64[i2 + (i3 + 1 << 3) >> 3] <= d5 : 0) i16 = 9; else if ((d5 < 0.0 ? +HEAPF64[i2 + (i3 + -1 << 3) >> 3] >= d5 : 0) ? +HEAPF64[i2 + (i3 + 1 << 3) >> 3] >= d5 : 0) i16 = 9;
   if ((i16 | 0) == 9) {
    i16 = 0;
    if (i1 >>> 0 >= i7 >>> 0) break;
    HEAP32[i18 + (i1 << 2) >> 2] = i3;
    i1 = i1 + 1 | 0;
   }
   i3 = i3 + 1 | 0;
   if (i3 >>> 0 >= i4 >>> 0) {
    i9 = i1;
    break L1;
   }
  }
  ___assert_fail(gb + 22096 | 0, gb + 22113 | 0, 544, gb + 22139 | 0);
 } else i9 = 1; while (0);
 if (i9 >>> 0 >= i7 >>> 0) ___assert_fail(gb + 22096 | 0, gb + 22113 | 0, 558, gb + 22139 | 0);
 i2 = i9 + 1 | 0;
 HEAP32[i18 + (i9 << 2) >> 2] = i4;
 i13 = i6 + 1 | 0;
 if (i2 >>> 0 < i13 >>> 0) {
  i18 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = i13;
  HEAP32[i8 + 4 >> 2] = i2;
  _fprintf(i18, gb + 22160 | 0, i8) | 0;
  HEAP32[i17 + 92 >> 2] = 0;
  STACKTOP = i19;
  return;
 }
 if (i2 >>> 0 > i7 >>> 0) ___assert_fail(gb + 22261 | 0, gb + 22113 | 0, 575, gb + 22139 | 0);
 i1 = i2 - i6 + -1 | 0;
 if (i1 | 0) {
  i12 = HEAP32[i17 + 60 >> 2] | 0;
  i10 = i9 + 1 | 0;
  i11 = 0;
  i9 = i2;
  i8 = i1;
  while (1) {
   i7 = i10 - i11 | 0;
   L32 : do if (i9 >>> 0 > 1) {
    i3 = HEAP32[i18 >> 2] | 0;
    i4 = i3;
    i6 = 1;
    i1 = 0;
    i3 = +HEAPF64[i12 + (i3 << 3) >> 3] > 0.0 & 1;
    while (1) {
     i2 = HEAP32[i18 + (i6 << 2) >> 2] | 0;
     d5 = +HEAPF64[i12 + (i2 << 3) >> 3];
     d20 = +Math_abs(+d5);
     i4 = d20 < +Math_abs(+(+HEAPF64[i12 + (i4 << 3) >> 3]));
     i1 = i4 ? i6 : i1;
     if (!i3) if (!(d5 >= 0.0)) {
      i1 = i6;
      break;
     } else i3 = 1; else if (d5 < 0.0) i3 = 0; else {
      i1 = i6;
      break;
     }
     i2 = i6 + 1 | 0;
     if (i2 >>> 0 >= i9 >>> 0) {
      i16 = 29;
      break L32;
     }
     i4 = HEAP32[i18 + (i1 << 2) >> 2] | 0;
     i6 = i2;
    }
    d20 = +Math_abs(+(+HEAPF64[i12 + (i2 << 3) >> 3]));
    i6 = i1 + -1 | 0;
    i4 = d20 < +Math_abs(+(+HEAPF64[i12 + (HEAP32[i18 + (i6 << 2) >> 2] << 3) >> 3]));
    i1 = i4 ? i1 : i6;
   } else {
    i1 = 0;
    i16 = 29;
   } while (0);
   if ((i16 | 0) == 29) {
    i16 = 0;
    if ((i8 | 0) == 1) {
     d20 = +Math_abs(+(+HEAPF64[i12 + (HEAP32[i18 >> 2] << 3) >> 3]));
     i1 = i9 + -1 | 0;
     i6 = d20 < +Math_abs(+(+HEAPF64[i12 + (HEAP32[i18 + (i1 << 2) >> 2] << 3) >> 3]));
     i1 = i6 ? 0 : i1;
    }
   }
   do if (i1 >>> 0 < i9 >>> 0) {
    i2 = i7 - i1 | 0;
    if (i2 >>> 0 >= 4 ? (i15 = i2 & -4, i14 = i1 + i15 | 0, (i15 | 0) != 0) : 0) {
     i3 = 0;
     do {
      i7 = i1 + i3 | 0;
      SIMD_Int32x4_store(HEAPU8, i18 + (i7 << 2) | 0, SIMD_Int32x4_load(HEAPU8, i18 + (i7 + 1 << 2) | 0));
      i3 = i3 + 4 | 0;
     } while ((i3 | 0) != (i15 | 0));
     if ((i2 | 0) == (i15 | 0)) break; else i1 = i14;
    }
    do {
     i7 = i1;
     i1 = i1 + 1 | 0;
     HEAP32[i18 + (i7 << 2) >> 2] = HEAP32[i18 + (i1 << 2) >> 2];
    } while ((i1 | 0) != (i9 | 0));
   } while (0);
   i8 = i8 + -1 | 0;
   if (!i8) break; else {
    i11 = i11 + 1 | 0;
    i9 = i9 + -1 | 0;
   }
  }
 }
 i4 = i17 + 92 | 0;
 HEAP32[i4 >> 2] = 0;
 i1 = i17 + 88 | 0;
 if (!i13) {
  i2 = 0;
  i1 = HEAP32[i1 >> 2] | 0;
 } else {
  i1 = HEAP32[i1 >> 2] | 0;
  i2 = 0;
  i3 = 0;
  do {
   i2 = ((HEAP32[i1 + (i3 << 2) >> 2] | 0) != (HEAP32[i18 + (i3 << 2) >> 2] | 0) & 1) + i2 | 0;
   HEAP32[i4 >> 2] = i2;
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < i13 >>> 0);
  i2 = i13 << 2;
 }
 _memmove(i1 | 0, i18 | 0, i2 | 0) | 0;
 STACKTOP = i19;
 return;
}

function _fec_get_enc_msg_length(i4, i3) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i6;
 i1 = i6 + 16 | 0;
 i2 = i6 + 8 | 0;
 do switch (i4 | 0) {
 case 1:
  {
   i5 = i3;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 2:
  {
   i5 = i3 * 3 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 3:
  {
   i5 = i3 * 5 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 4:
  {
   i5 = (i3 << 1 & 1073741822) * 7 | 0;
   i5 = ((i5 & 6 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 5:
  {
   i5 = i3 << 1 & 536870910;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 6:
  {
   i5 = (i3 & 536870911) * 12 | 0;
   i5 = (i5 >>> 2 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 7:
  {
   i5 = i3 << 3;
   i5 = (((((i5 >>> 0) % 12 | 0 | 0) != 0 & 1) + ((i5 >>> 0) / 12 | 0) | 0) * 24 | 0) >>> 3;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 8:
  {
   i5 = (i3 >>> 1) + i3 + (i3 & 1) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 9:
  {
   i5 = (i3 >>> 2) + i3 + ((i3 & 3 | 0) != 0 & 1) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 10:
  {
   i5 = (i3 >>> 3) + i3 + ((i3 & 7 | 0) != 0 & 1) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 11:
  {
   i5 = (i3 << 1) + 2 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 12:
  {
   i5 = (i3 << 1) + 2 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 13:
  {
   i5 = (i3 * 3 | 0) + 3 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 14:
  {
   i5 = (i3 * 6 | 0) + 11 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 15:
  {
   i5 = (((i3 << 2 & 2147483644 | 3) + (i3 << 3 | 6) | 0) >>> 3) + 1 | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 16:
  {
   i5 = i3 << 3 | 6;
   i5 = (((i5 + 2 | 0) >>> 0) / 3 | 0) + i5 | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 17:
  {
   i5 = i3 << 3 | 6;
   i5 = ((i5 + 3 | 0) >>> 2) + i5 | 0;
   i5 = ((i5 & 6 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 18:
  {
   i5 = i3 << 3 | 6;
   i5 = (((i5 + 4 | 0) >>> 0) / 5 | 0) + i5 | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 19:
  {
   i5 = i3 << 3 | 6;
   i5 = (((i5 + 5 | 0) >>> 0) / 6 | 0) + i5 | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 20:
  {
   i5 = i3 << 3 | 6;
   i5 = (((i5 + 6 | 0) >>> 0) / 7 | 0) + i5 | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 21:
  {
   i5 = i3 << 3;
   i5 = i5 + 8 + ((i5 + 9 | 0) >>> 1) | 0;
   i5 = (i5 >>> 2 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 22:
  {
   i5 = i3 << 3;
   i5 = i5 + 8 + (((i5 + 10 | 0) >>> 0) / 3 | 0) | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 23:
  {
   i5 = i3 << 3;
   i5 = i5 + 8 + ((i5 + 11 | 0) >>> 2) | 0;
   i5 = ((i5 & 6 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 24:
  {
   i5 = i3 << 3;
   i5 = i5 + 8 + (((i5 + 12 | 0) >>> 0) / 5 | 0) | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 25:
  {
   i5 = i3 << 3;
   i5 = i5 + 8 + (((i5 + 13 | 0) >>> 0) / 6 | 0) | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 26:
  {
   i5 = i3 << 3;
   i5 = i5 + 8 + (((i5 + 14 | 0) >>> 0) / 7 | 0) | 0;
   i5 = ((i5 & 7 | 0) != 0 & 1) + (i5 >>> 3) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 27:
  {
   if (!i3) {
    _fwrite(gb + 11832 | 0, 69, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
    _exit(1);
   }
   _div(i1, i3, 223);
   i5 = ((HEAP32[i1 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i1 >> 2] | 0) | 0;
   _div(i2, i3, i5);
   i5 = Math_imul((HEAP32[i2 >> 2] | 0) + 32 + ((HEAP32[i2 + 4 >> 2] | 0) != 0 & 1) | 0, i5) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 0:
  {
   i5 = 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 default:
  {
   HEAP32[i5 >> 2] = i4;
   _printf(gb + 11902 | 0, i5) | 0;
   _exit(-1);
  }
 } while (0);
 return 0;
}

function _firdespm_init_grid(i26) {
 i26 = i26 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, d20 = 0.0, d21 = 0.0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i27 = 0, i28 = 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i24 = i28;
 d21 = .5 / +((Math_imul(HEAP32[i26 + 12 >> 2] | 0, HEAP32[i26 + 24 >> 2] | 0) | 0) >>> 0);
 i22 = HEAP32[i26 + 16 >> 2] | 0;
 L1 : do if (!i22) {
  i25 = i26 + 28 | 0;
  i27 = 0;
 } else {
  i13 = i26 + 28 | 0;
  i14 = i26 + 48 | 0;
  i15 = i26 + 36 | 0;
  i16 = i26 + 52 | 0;
  i17 = i26 + 44 | 0;
  i18 = i26 + 40 | 0;
  i19 = i26 + 56 | 0;
  i12 = HEAP32[i26 + 32 >> 2] | 0;
  i23 = 0;
  i2 = 0;
  L4 : while (1) {
   i11 = i23 << 1;
   d5 = +HEAPF64[i12 + (i11 << 3) >> 3];
   d20 = +HEAPF64[i12 + ((i11 | 1) << 3) >> 3];
   if ((i23 | 0) == 0 ? (HEAP32[i13 >> 2] | 0) != 0 : 0) d5 = d5 < d21 ? d21 : d5;
   i3 = ~~((d20 - d5) / d21 + .5) >>> 0;
   i3 = (i3 | 0) == 0 ? 1 : i3;
   i11 = HEAP32[i14 >> 2] | 0;
   i4 = HEAP32[i16 >> 2] | 0;
   i7 = (HEAP32[i15 >> 2] | 0) + (i23 << 3) | 0;
   i8 = (HEAP32[i17 >> 2] | 0) + (i23 << 2) | 0;
   i9 = 0;
   i10 = i2;
   while (1) {
    HEAPF64[i11 + (i10 << 3) >> 3] = d5 + d21 * +(i9 >>> 0);
    HEAPF64[i4 + (i10 << 3) >> 3] = +HEAPF64[i7 >> 3];
    i1 = HEAP32[i8 >> 2] | 0;
    switch (i1 | 0) {
    case 0:
     {
      d6 = 1.0;
      break;
     }
    case 1:
     {
      d6 = +Math_exp(+(d21 * (+(i9 >>> 0) * 2.0)));
      break;
     }
    case 2:
     {
      d6 = d21 * (+(i9 >>> 0) * 2.700000047683716) + 1.0;
      break;
     }
    default:
     break L4;
    }
    HEAPF64[(HEAP32[i19 >> 2] | 0) + (i10 << 3) >> 3] = d6 * +HEAPF64[(HEAP32[i18 >> 2] | 0) + (i23 << 3) >> 3];
    i2 = i10 + 1 | 0;
    i9 = i9 + 1 | 0;
    if (i9 >>> 0 >= i3 >>> 0) {
     i1 = i10;
     break;
    } else i10 = i2;
   }
   HEAPF64[i11 + (i1 << 3) >> 3] = d20;
   i23 = i23 + 1 | 0;
   if (i23 >>> 0 >= i22 >>> 0) {
    i25 = i13;
    i27 = i2;
    break L1;
   }
  }
  i23 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i24 >> 2] = i1;
  _fprintf(i23, gb + 22034 | 0, i24) | 0;
  _exit(1);
 } while (0);
 HEAP32[i26 + 20 >> 2] = i27;
 i2 = (HEAP32[i26 + 4 >> 2] | 0) == 0;
 if (!(HEAP32[i25 >> 2] | 0)) {
  if ((i27 | 0) == 0 | i2 ^ 1) {
   STACKTOP = i28;
   return;
  }
  i3 = HEAP32[i26 + 48 >> 2] | 0;
  i4 = HEAP32[i26 + 52 >> 2] | 0;
  i1 = HEAP32[i26 + 56 >> 2] | 0;
  i2 = 0;
  do {
   i26 = i3 + (i2 << 3) | 0;
   d21 = +Math_cos(+(+HEAPF64[i26 >> 3] * 3.141592653589793));
   i25 = i4 + (i2 << 3) | 0;
   HEAPF64[i25 >> 3] = +HEAPF64[i25 >> 3] / d21;
   d21 = +Math_cos(+(+HEAPF64[i26 >> 3] * 3.141592653589793));
   i26 = i1 + (i2 << 3) | 0;
   HEAPF64[i26 >> 3] = d21 * +HEAPF64[i26 >> 3];
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < i27 >>> 0);
  STACKTOP = i28;
  return;
 }
 i1 = (i27 | 0) != 0;
 if (i2) {
  if (!i1) {
   STACKTOP = i28;
   return;
  }
  i3 = HEAP32[i26 + 48 >> 2] | 0;
  i4 = HEAP32[i26 + 52 >> 2] | 0;
  i1 = HEAP32[i26 + 56 >> 2] | 0;
  i2 = 0;
  do {
   i26 = i3 + (i2 << 3) | 0;
   d21 = +Math_sin(+(+HEAPF64[i26 >> 3] * 3.141592653589793));
   i25 = i4 + (i2 << 3) | 0;
   HEAPF64[i25 >> 3] = +HEAPF64[i25 >> 3] / d21;
   d21 = +Math_sin(+(+HEAPF64[i26 >> 3] * 3.141592653589793));
   i26 = i1 + (i2 << 3) | 0;
   HEAPF64[i26 >> 3] = d21 * +HEAPF64[i26 >> 3];
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < i27 >>> 0);
  STACKTOP = i28;
  return;
 } else {
  if (!i1) {
   STACKTOP = i28;
   return;
  }
  i4 = HEAP32[i26 + 48 >> 2] | 0;
  i3 = HEAP32[i26 + 52 >> 2] | 0;
  i1 = HEAP32[i26 + 56 >> 2] | 0;
  i2 = 0;
  do {
   i26 = i4 + (i2 << 3) | 0;
   d21 = +Math_sin(+(+HEAPF64[i26 >> 3] * 6.283185307179586));
   i25 = i3 + (i2 << 3) | 0;
   HEAPF64[i25 >> 3] = +HEAPF64[i25 >> 3] / d21;
   d21 = +Math_sin(+(+HEAPF64[i26 >> 3] * 6.283185307179586));
   i26 = i1 + (i2 << 3) | 0;
   HEAPF64[i26 >> 3] = d21 * +HEAPF64[i26 >> 3];
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < i27 >>> 0);
  STACKTOP = i28;
  return;
 }
}

function _encoder_profile(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i6;
 i4 = _json_object_get(i1, i2) | 0;
 if (!i4) {
  HEAP32[i3 >> 2] = i2;
  _printf(gb + 9993 | 0, i3) | 0;
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 i3 = _calloc(1, 96) | 0;
 if (!i3) {
  _puts(gb + 10022 | 0) | 0;
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 i1 = _json_object_get(i4, gb + 10059 | 0) | 0;
 if (i1 | 0) HEAP32[i3 + 64 >> 2] = _liquid_getopt_str2crc(_json_string_value(i1) | 0) | 0;
 i1 = _json_object_get(i4, gb + 10075 | 0) | 0;
 if (i1 | 0) HEAP32[i3 + 68 >> 2] = _liquid_getopt_str2fec(_json_string_value(i1) | 0) | 0;
 i1 = _json_object_get(i4, gb + 10092 | 0) | 0;
 if (i1 | 0) HEAP32[i3 + 72 >> 2] = _liquid_getopt_str2fec(_json_string_value(i1) | 0) | 0;
 i1 = _json_object_get(i4, gb + 10109 | 0) | 0;
 do if (i1 | 0) {
  i1 = _json_string_value(i1) | 0;
  i2 = i3 + 60 | 0;
  if (!(_strcmp(i1, gb + 10120 | 0) | 0)) {
   HEAP32[i2 >> 2] = 2;
   break;
  } else {
   HEAP32[i2 >> 2] = 1;
   HEAP32[i3 + 76 >> 2] = _liquid_getopt_str2mod(i1) | 0;
   break;
  }
 } while (0);
 i1 = _json_object_get(i4, gb + 10125 | 0) | 0;
 if (i1 | 0) {
  i2 = _json_integer_value(i1) | 0;
  getTempRet0() | 0;
  HEAP32[i3 + 80 >> 2] = i2;
 }
 i2 = _json_object_get(i4, gb + 10138 | 0) | 0;
 if (i2 | 0) {
  i1 = i3 + 60 | 0;
  if ((HEAP32[i1 >> 2] | 0) == 2) {
   _puts(gb + 10143 | 0) | 0;
   i5 = 0;
   STACKTOP = i6;
   return i5 | 0;
  }
  HEAP32[i1 >> 2] = 0;
  i1 = _json_object_get(i2, gb + 10190 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10206 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 4 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10227 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 8 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10240 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 12 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10250 | 0) | 0;
  if (i1 | 0) {
   i2 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 16 >> 2] = i2;
  }
 }
 i1 = _json_object_get(i4, gb + 10261 | 0) | 0;
 if (i1 | 0) {
  i2 = _json_object_get(i1, gb + 10272 | 0) | 0;
  if (i2 | 0) HEAPF32[i3 + 32 >> 2] = +_json_number_value(i2) / 44100.0 * 3.141592653589793 * 2.0;
  i1 = _json_object_get(i1, gb + 10289 | 0) | 0;
  if (i1 | 0) HEAPF32[i3 + 36 >> 2] = +_json_number_value(i1);
 }
 i2 = _json_object_get(i4, gb + 10294 | 0) | 0;
 if (i2) {
  i1 = _json_object_get(i2, gb + 10308 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 20 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10327 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 24 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10340 | 0) | 0;
  if (i1 | 0) HEAPF32[i3 + 28 >> 2] = +_json_number_value(i1);
 } else HEAP32[i3 + 20 >> 2] = 1;
 i1 = _json_object_get(i4, gb + 10357 | 0) | 0;
 if (i1 | 0 ? (i5 = _json_object_get(i1, gb + 10373 | 0) | 0, i5 | 0) : 0) HEAPF32[i3 + 40 >> 2] = +_json_number_value(i5);
 i2 = _json_object_get(i4, gb + 10389 | 0) | 0;
 if (!i2) {
  i5 = i3;
  STACKTOP = i6;
  return i5 | 0;
 }
 i1 = _json_object_get(i2, gb + 10399 | 0) | 0;
 if (i1 | 0) {
  i5 = _json_integer_value(i1) | 0;
  getTempRet0() | 0;
  HEAP32[i3 + 44 >> 2] = i5;
 }
 i1 = _json_object_get(i2, gb + 10405 | 0) | 0;
 if (i1 | 0) HEAPF32[i3 + 48 >> 2] = +_json_number_value(i1);
 i1 = _json_object_get(i2, gb + 10415 | 0) | 0;
 if (i1 | 0) HEAPF32[i3 + 52 >> 2] = +_json_number_value(i1);
 i1 = _json_object_get(i2, gb + 10427 | 0) | 0;
 if (!i1) {
  i5 = i3;
  STACKTOP = i6;
  return i5 | 0;
 }
 HEAP32[i3 + 56 >> 2] = ~~+_json_number_value(i1) >>> 0;
 i5 = i3;
 STACKTOP = i6;
 return i5 | 0;
}

function _ofdmframesync_estimate_eqgain_poly(i22, i1) {
 i22 = i22 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, d3 = 0.0, d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, d28 = 0.0;
 i27 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i14 = i27 + 16 | 0;
 i15 = i27 + 8 | 0;
 i16 = i27;
 if (!(HEAP32[i22 + 168 >> 2] | 0)) i26 = i22; else {
  _memmove(HEAP32[i22 + 188 >> 2] | 0, HEAP32[i22 + 92 >> 2] | 0, HEAP32[i22 >> 2] << 3 | 0) | 0;
  i26 = i22;
 }
 i21 = (HEAP32[i22 + 24 >> 2] | 0) + (HEAP32[i22 + 20 >> 2] | 0) | 0;
 i23 = i21 + -1 | 0;
 i23 = i23 >>> 0 < i1 >>> 0 ? i23 : i1;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
 i23 = (i23 >>> 0 > 10 ? 10 : i23) + 1 | 0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i23 << 2) | 0) + 15 & -16) | 0;
 i25 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i23 << 2) | 0) + 15 & -16) | 0;
 i1 = HEAP32[i26 >> 2] | 0;
 L5 : do if (!i1) i17 = 0; else {
  i9 = i22 + 4 | 0;
  i10 = i22 + 12 | 0;
  i11 = i22 + 92 | 0;
  i12 = i15 + 4 | 0;
  i13 = i16 + 4 | 0;
  i8 = 0;
  i5 = 0;
  while (1) {
   i6 = HEAP32[i9 >> 2] | 0;
   i7 = ((i6 + i8 | 0) >>> 0) % (i1 >>> 0) | 0;
   if (HEAP8[(HEAP32[i10 >> 2] | 0) + i7 >> 0] | 0) {
    if ((i5 | 0) == (i21 | 0)) break;
    d3 = +(i7 >>> 0);
    d4 = +(i1 >>> 0);
    HEAPF32[i18 + (i5 << 2) >> 2] = (i7 >>> 0 > i6 >>> 0 ? d3 - d4 : d3) / d4;
    i1 = HEAP32[i11 >> 2] | 0;
    i6 = HEAP32[i1 + (i7 << 3) + 4 >> 2] | 0;
    HEAP32[i15 >> 2] = HEAP32[i1 + (i7 << 3) >> 2];
    HEAP32[i12 >> 2] = i6;
    HEAP32[i14 >> 2] = HEAP32[i15 >> 2];
    HEAP32[i14 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
    HEAPF32[i19 + (i5 << 2) >> 2] = +_cabsf(i14);
    i6 = HEAP32[i11 >> 2] | 0;
    i1 = HEAP32[i6 + (i7 << 3) + 4 >> 2] | 0;
    HEAP32[i16 >> 2] = HEAP32[i6 + (i7 << 3) >> 2];
    HEAP32[i13 >> 2] = i1;
    HEAP32[i14 >> 2] = HEAP32[i16 >> 2];
    HEAP32[i14 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
    HEAPF32[i20 + (i5 << 2) >> 2] = +_cargf(i14);
    i1 = HEAP32[i26 >> 2] | 0;
    i5 = i5 + 1 | 0;
   }
   i8 = i8 + 1 | 0;
   if (i8 >>> 0 >= i1 >>> 0) {
    i17 = i5;
    break L5;
   }
  }
  _fwrite(gb + 35905 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } while (0);
 if ((i17 | 0) != (i21 | 0)) {
  _fwrite(gb + 35905 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i21 >>> 0 > 1) {
  d3 = +HEAPF32[i20 >> 2];
  i6 = 1;
  while (1) {
   i5 = i20 + (i6 << 2) | 0;
   d2 = +HEAPF32[i5 >> 2];
   i1 = i20 + (i6 + -1 << 2) | 0;
   if (d2 - d3 > 3.141592653589793) {
    do d2 = d2 + -6.283185307179586; while (d2 - d3 > 3.141592653589793);
    HEAPF32[i5 >> 2] = d2;
   }
   d3 = +HEAPF32[i1 >> 2];
   if (d2 - d3 < -3.141592653589793) {
    do d2 = d2 + 6.283185307179586; while (d2 - d3 < -3.141592653589793);
    HEAPF32[i5 >> 2] = d2;
   }
   i6 = i6 + 1 | 0;
   if ((i6 | 0) == (i21 | 0)) break; else d3 = d2;
  }
 }
 _polyf_fit(i18, i19, i21, i24, i23);
 _polyf_fit(i18, i20, i21, i25, i23);
 i1 = HEAP32[i26 >> 2] | 0;
 if (!i1) {
  STACKTOP = i27;
  return;
 }
 i7 = i22 + 4 | 0;
 i8 = i22 + 12 | 0;
 i6 = i22 + 92 | 0;
 i5 = 0;
 do {
  d3 = +(i5 >>> 0);
  d2 = +(i1 >>> 0);
  d2 = (i5 >>> 0 > (HEAP32[i7 >> 2] | 0) >>> 0 ? d3 - d2 : d3) / d2;
  d3 = +_polyf_val(i24, i23, d2);
  d2 = +_polyf_val(i25, i23, d2);
  if (!(HEAP8[(HEAP32[i8 >> 2] | 0) + i5 >> 0] | 0)) {
   d4 = 0.0;
   d2 = 0.0;
  } else {
   d28 = +Math_sin(+d2);
   d4 = d3 * (+Math_cos(+d2) + d28 * 0.0);
   d2 = d3 * d28;
  }
  i1 = HEAP32[i6 >> 2] | 0;
  HEAPF32[i1 + (i5 << 3) >> 2] = d4;
  HEAPF32[i1 + (i5 << 3) + 4 >> 2] = d2;
  i5 = i5 + 1 | 0;
  i1 = HEAP32[i26 >> 2] | 0;
 } while (i5 >>> 0 < i1 >>> 0);
 STACKTOP = i27;
 return;
}

function _detector_cccf_correlate(i23, i2, i24, i21, i22) {
 i23 = i23 | 0;
 i2 = i2 | 0;
 i24 = i24 | 0;
 i21 = i21 | 0;
 i22 = i22 | 0;
 var d1 = 0.0, i3 = 0, d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i25 = 0, d26 = 0.0, d27 = 0.0, d28 = 0.0;
 i25 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i14 = i25 + 40 | 0;
 i16 = i25 + 32 | 0;
 i17 = i25 + 16 | 0;
 i15 = i25;
 i13 = i25 + 24 | 0;
 i20 = i25 + 8 | 0;
 i3 = i23 + 16 | 0;
 i18 = HEAP32[i3 >> 2] | 0;
 i19 = HEAP32[i2 >> 2] | 0;
 i2 = HEAP32[i2 + 4 >> 2] | 0;
 HEAP32[i13 >> 2] = i19;
 HEAP32[i13 + 4 >> 2] = i2;
 HEAP32[i14 >> 2] = HEAP32[i13 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
 _windowcf_push(i18, i14);
 HEAP32[i20 >> 2] = i19;
 HEAP32[i20 + 4 >> 2] = i2;
 HEAP32[i14 >> 2] = HEAP32[i20 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i20 + 4 >> 2];
 _detector_cccf_update_sumsq(i23, i14);
 i20 = i23 + 76 | 0;
 i2 = HEAP32[i20 >> 2] | 0;
 if (i2 | 0) {
  HEAP32[i20 >> 2] = i2 + -1;
  i24 = 0;
  STACKTOP = i25;
  return i24 | 0;
 }
 i19 = i23 + 44 | 0;
 i18 = i23 + 48 | 0;
 i12 = i23 + 24 | 0;
 _memmove(HEAP32[i19 >> 2] | 0, HEAP32[i18 >> 2] | 0, HEAP32[i12 >> 2] << 2 | 0) | 0;
 i13 = i23 + 40 | 0;
 _memmove(HEAP32[i18 >> 2] | 0, HEAP32[i13 >> 2] | 0, HEAP32[i12 >> 2] << 2 | 0) | 0;
 _windowcf_read(HEAP32[i3 >> 2] | 0, i16);
 if (!(HEAP32[i12 >> 2] | 0)) {
  i2 = i23 + 52 | 0;
  i9 = HEAP32[i13 >> 2] | 0;
  i8 = 0;
 } else {
  i3 = i23 + 20 | 0;
  i5 = i17 + 4 | 0;
  i6 = i15 + 4 | 0;
  i7 = i23 + 12 | 0;
  i10 = i23 + 68 | 0;
  i2 = i23 + 52 | 0;
  i11 = 0;
  d4 = 0.0;
  while (1) {
   _dotprod_cccf_execute(HEAP32[(HEAP32[i3 >> 2] | 0) + (i11 << 2) >> 2] | 0, HEAP32[i16 >> 2] | 0, i17);
   i9 = HEAP32[i5 >> 2] | 0;
   HEAP32[i15 >> 2] = HEAP32[i17 >> 2];
   HEAP32[i6 >> 2] = i9;
   HEAP32[i14 >> 2] = HEAP32[i15 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
   d1 = +_cabsf(i14);
   d1 = d1 * +HEAPF32[i7 >> 2] / +Math_sqrt(+(+HEAPF32[i10 >> 2]));
   i9 = HEAP32[i13 >> 2] | 0;
   HEAPF32[i9 + (i11 << 2) >> 2] = d1;
   if (d1 > d4) HEAP32[i2 >> 2] = i11; else d1 = d4;
   i11 = i11 + 1 | 0;
   i8 = HEAP32[i12 >> 2] | 0;
   if (i11 >>> 0 >= i8 >>> 0) break; else d4 = d1;
  }
 }
 i3 = HEAP32[i2 >> 2] | 0;
 d4 = +HEAPF32[i9 + (i3 << 2) >> 2];
 i7 = i23 + 72 | 0;
 switch (HEAP32[i7 >> 2] | 0) {
 case 0:
  {
   if (!(d4 > +HEAPF32[i23 + 8 >> 2])) {
    i24 = 0;
    STACKTOP = i25;
    return i24 | 0;
   }
   HEAP32[i23 + 56 >> 2] = i3;
   HEAP32[i7 >> 2] = 1;
   i24 = 0;
   STACKTOP = i25;
   return i24 | 0;
  }
 case 1:
  {
   i5 = i23 + 56 | 0;
   i6 = HEAP32[i5 >> 2] | 0;
   i2 = HEAP32[i18 >> 2] | 0;
   d1 = +HEAPF32[i2 + (i6 << 2) >> 2];
   if (d4 > d1) {
    HEAP32[i5 >> 2] = i3;
    i24 = 0;
    STACKTOP = i25;
    return i24 | 0;
   }
   if ((i8 | 0) == 1) {
    HEAPF32[i21 >> 2] = 0.0;
    d1 = 0.0;
   } else {
    d26 = +HEAPF32[(HEAP32[i19 >> 2] | 0) + (i6 << 2) >> 2];
    d28 = +HEAPF32[((i6 | 0) == 0 ? i2 + 4 | 0 : i2 + (i6 + -1 << 2) | 0) >> 2];
    d27 = +HEAPF32[i2 + (((i6 | 0) == (i8 + -1 | 0) ? -1 : 1) + i6 << 2) >> 2];
    d4 = +HEAPF32[i9 + (i6 << 2) >> 2];
    d1 = d1 * 2.0;
    HEAPF32[i21 >> 2] = +HEAPF32[(HEAP32[i23 + 36 >> 2] | 0) + (i6 << 2) >> 2] - (d27 - d28) * (+HEAPF32[i23 + 28 >> 2] * .5) / (d28 + d27 - d1);
    d1 = (d4 - d26) * .5 / (d26 + d4 - d1);
    d1 = d1 < -.49900001287460327 ? -.49900001287460327 : d1;
    d1 = d1 > .49900001287460327 ? .49900001287460327 : d1;
   }
   HEAPF32[i24 >> 2] = d1;
   HEAPF32[i22 >> 2] = +Math_sqrt(+(+HEAPF32[i23 + 68 >> 2]));
   HEAP32[i7 >> 2] = 0;
   HEAP32[i20 >> 2] = (HEAP32[i23 + 4 >> 2] | 0) >>> 2;
   i24 = 1;
   STACKTOP = i25;
   return i24 | 0;
  }
 default:
  {
   _fwrite(gb + 40418 | 0, 69, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 return 0;
}

function _gmskframesync_execute_rxheader(i18, i1) {
 i18 = i18 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, d13 = 0.0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i19 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 i16 = i19 + 48 | 0;
 i5 = i19 + 40 | 0;
 i12 = i19 + 32 | 0;
 i3 = i19 + 16 | 0;
 i4 = i19 + 8 | 0;
 i15 = i19;
 i7 = i19 + 24 | 0;
 i17 = i18 + 128 | 0;
 i8 = HEAP32[i17 >> 2] | 0;
 i6 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i7 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i7 + 4 >> 2] = i6;
 HEAP32[i16 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 _nco_crcf_mix_down(i8, i16, i15);
 _nco_crcf_step(HEAP32[i17 >> 2] | 0);
 d13 = +HEAPF32[i15 >> 2];
 d14 = +HEAPF32[i15 + 4 >> 2];
 i1 = i18 + 64 | 0;
 i15 = i18 + 68 | 0;
 i8 = HEAP32[i15 >> 2] | 0;
 HEAP32[i12 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i12 + 4 >> 2] = i8;
 HEAP32[i16 >> 2] = HEAP32[i12 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i12 + 4 >> 2];
 _conjf(i5, i16);
 d10 = +HEAPF32[i5 >> 2];
 d11 = +HEAPF32[i5 + 4 >> 2];
 d9 = d13 * d10 - d14 * d11;
 d2 = d14 * d10 + d13 * d11;
 if ((d9 != d9 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
  ___mulsc3(i3, d10, d11, d13, d14);
  d9 = +HEAPF32[i3 >> 2];
  d2 = +HEAPF32[i3 + 4 >> 2];
 }
 HEAPF32[i4 >> 2] = d9;
 HEAPF32[i4 + 4 >> 2] = d2;
 HEAP32[i16 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i16 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 d11 = +_cargf(i16);
 d11 = d11 * +((HEAP32[i18 + 4 >> 2] | 0) >>> 0);
 i12 = i18 + 72 | 0;
 HEAPF32[i12 >> 2] = d11;
 HEAPF32[i1 >> 2] = d13;
 HEAPF32[i15 >> 2] = d14;
 HEAPF32[i5 >> 2] = 0.0;
 if (!(_gmskframesync_update_symsync(i18, d11, i5) | 0)) {
  STACKTOP = i19;
  return;
 }
 i7 = i18 + 224 | 0;
 HEAP8[(HEAP32[i18 + 156 >> 2] | 0) + (HEAP32[i7 >> 2] | 0) >> 0] = +HEAPF32[i5 >> 2] > 0.0 & 1;
 i8 = (HEAP32[i7 >> 2] | 0) + 1 | 0;
 HEAP32[i7 >> 2] = i8;
 if ((i8 | 0) != (HEAP32[i18 + 152 >> 2] | 0)) {
  STACKTOP = i19;
  return;
 }
 _gmskframesync_decode_header(i18);
 i1 = i18 + 172 | 0;
 do if (!(HEAP32[i1 >> 2] | 0)) {
  i3 = HEAP32[i18 + 16 >> 2] | 0;
  if (i3 | 0) {
   i7 = i18 + 24 | 0;
   HEAPF32[i18 + 28 >> 2] = +_log10f(+HEAPF32[i18 + 120 >> 2]) * 20.0;
   HEAPF32[i7 >> 2] = 0.0;
   HEAP32[i18 + 36 >> 2] = 0;
   SIMD_Int32x4_store(HEAPU8, i18 + 40 | 0, SIMD_Int32x4(0, 0, 1, 0));
   HEAP32[i18 + 56 >> 2] = 0;
   HEAP32[i18 + 60 >> 2] = 0;
   i4 = HEAP32[i18 + 164 >> 2] | 0;
   i5 = HEAP32[i18 + 20 >> 2] | 0;
   i6 = i16;
   i8 = i6 + 40 | 0;
   do {
    HEAP32[i6 >> 2] = HEAP32[i7 >> 2];
    i6 = i6 + 4 | 0;
    i7 = i7 + 4 | 0;
   } while ((i6 | 0) < (i8 | 0));
   mftCall_iiiiiiii(i3 | 0, i4 | 0, 0, 0, 0, 0, i16 | 0, i5 | 0) | 0;
   i16 = i18 + 216 | 0;
   HEAP32[i16 >> 2] = 0;
   HEAP32[i16 + 4 >> 2] = 0;
   HEAP32[i16 + 8 >> 2] = 0;
   HEAP32[i16 + 12 >> 2] = 0;
   _windowcf_clear(HEAP32[i18 + 124 >> 2] | 0);
   _detector_cccf_reset(HEAP32[i18 + 108 >> 2] | 0);
   _nco_crcf_reset(HEAP32[i17 >> 2] | 0);
   HEAPF32[i18 + 64 >> 2] = 0.0;
   HEAPF32[i15 >> 2] = 0.0;
   HEAPF32[i12 >> 2] = 0.0;
   _firpfb_rrrf_reset(HEAP32[i18 + 76 >> 2] | 0);
   _firpfb_rrrf_reset(HEAP32[i18 + 80 >> 2] | 0);
   HEAPF32[i18 + 88 >> 2] = 0.0;
   if (HEAP32[i1 >> 2] | 0) break;
  }
  i16 = i18 + 216 | 0;
  HEAP32[i16 >> 2] = 0;
  HEAP32[i16 + 4 >> 2] = 0;
  HEAP32[i16 + 8 >> 2] = 0;
  HEAP32[i16 + 12 >> 2] = 0;
  _windowcf_clear(HEAP32[i18 + 124 >> 2] | 0);
  _detector_cccf_reset(HEAP32[i18 + 108 >> 2] | 0);
  _nco_crcf_reset(HEAP32[i17 >> 2] | 0);
  HEAPF32[i18 + 64 >> 2] = 0.0;
  HEAPF32[i15 >> 2] = 0.0;
  HEAPF32[i12 >> 2] = 0.0;
  _firpfb_rrrf_reset(HEAP32[i18 + 76 >> 2] | 0);
  _firpfb_rrrf_reset(HEAP32[i18 + 80 >> 2] | 0);
  HEAPF32[i18 + 88 >> 2] = 0.0;
  STACKTOP = i19;
  return;
 } while (0);
 HEAP32[i18 + 216 >> 2] = 3;
 STACKTOP = i19;
 return;
}

function _liquid_firdes_gmskrx(i22, i2, d4, d1, i28) {
 i22 = i22 | 0;
 i2 = i2 | 0;
 d4 = +d4;
 d1 = +d1;
 i28 = i28 | 0;
 var i3 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, d13 = 0.0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i23 = 0, i24 = 0, i25 = 0, d26 = 0.0, i27 = 0, i29 = 0;
 i27 = STACKTOP;
 if (!i22) {
  _fwrite(gb + 22807 | 0, 56, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i2) {
  _fwrite(gb + 22864 | 0, 56, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d4 < 0.0 | d4 > 1.0) {
  _fwrite(gb + 22921 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i24 = Math_imul(i22 << 1, i2) | 0 | 1;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 2) | 0) + 15 & -16) | 0;
 i25 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 2) | 0) + 15 & -16) | 0;
 _liquid_firdes_gmsktx(i22, i2, d4, 0.0, i3);
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 2) | 0) + 15 & -16) | 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 2) | 0) + 15 & -16) | 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i23 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 _liquid_firdes_prototype(1, i22, i2, d4, 0.0, i8);
 d26 = +(i22 >>> 0);
 _liquid_firdes_kaiser(i24, (d4 * .1 + .699999988079071) / d26, 60.0, 0.0, i9);
 i16 = Math_imul(i2, i22) | 0;
 i21 = i16 << 1 | 1;
 i2 = 0;
 do {
  i29 = ((i2 + i16 | 0) >>> 0) % (i24 >>> 0) | 0;
  HEAP32[i11 + (i2 << 3) >> 2] = HEAP32[i8 + (i29 << 2) >> 2];
  HEAPF32[i11 + (i2 << 3) + 4 >> 2] = 0.0;
  HEAP32[i12 + (i2 << 3) >> 2] = HEAP32[i9 + (i29 << 2) >> 2];
  HEAPF32[i12 + (i2 << 3) + 4 >> 2] = 0.0;
  HEAP32[i10 + (i2 << 3) >> 2] = HEAP32[i3 + (i29 << 2) >> 2];
  HEAPF32[i10 + (i2 << 3) + 4 >> 2] = 0.0;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i21 | 0));
 _fft_run(i24, i11, i18, 1, 0);
 _fft_run(i24, i12, i19, 1, 0);
 _fft_run(i24, i10, i17, 1, 0);
 d14 = +HEAPF32[i18 >> 2];
 d13 = +HEAPF32[i19 >> 2];
 d7 = 0.0;
 d6 = 0.0;
 d5 = 0.0;
 i2 = 0;
 while (1) {
  d4 = +HEAPF32[i17 + (i2 << 3) >> 2];
  if (i2) {
   d5 = d4 < d5 ? d4 : d5;
   d1 = +HEAPF32[i18 + (i2 << 3) >> 2];
   d6 = d1 < d6 ? d1 : d6;
   d1 = +HEAPF32[i19 + (i2 << 3) >> 2];
   if (d1 < d7) i15 = 13; else d1 = d7;
  } else {
   d1 = d13;
   d6 = d14;
   d5 = d4;
   i15 = 13;
  }
  if ((i15 | 0) == 13) i15 = 0;
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i21 | 0)) {
   d7 = d1;
   break;
  } else d7 = d1;
 }
 d1 = +HEAPF32[i19 >> 2];
 d4 = d1;
 i2 = 0;
 while (1) {
  d14 = (d4 - d7) / d1;
  HEAPF32[i20 + (i2 << 3) >> 2] = (+HEAPF32[i18 + (i2 << 3) >> 2] - d6 + 1.0000000474974513e-03) / (+HEAPF32[i17 + (i2 << 3) >> 2] - d5 + 1.0000000474974513e-03) * d14;
  HEAPF32[i20 + (i2 << 3) + 4 >> 2] = d14 * 0.0;
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i21 | 0)) break;
  d4 = +HEAPF32[i19 + (i2 << 3) >> 2];
 }
 _fft_run(i24, i20, i23, -1, 0);
 i3 = i16 + 1 | 0;
 d1 = +((Math_imul(i24, i22) | 0) >>> 0);
 i2 = 0;
 do {
  HEAPF32[i25 + (i2 << 2) >> 2] = +HEAPF32[i23 + ((((i3 + i2 | 0) >>> 0) % (i24 >>> 0) | 0) << 3) >> 2] / d1;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i21 | 0));
 i2 = 0;
 do {
  HEAPF32[i28 + (i2 << 2) >> 2] = d26 * (d26 * +HEAPF32[i25 + (i2 << 2) >> 2]);
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i21 | 0));
 STACKTOP = i27;
 return;
}

function _cheby2_azpkf(i20, d1, i25, i21, i24) {
 i20 = i20 | 0;
 d1 = +d1;
 i25 = i25 | 0;
 i21 = i21 | 0;
 i24 = i24 | 0;
 var i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i22 = 0, i23 = 0, i26 = 0, i27 = 0, i28 = 0, d29 = 0.0, d30 = 0.0;
 i26 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i13 = i26 + 40 | 0;
 i14 = i26 + 32 | 0;
 i16 = i26 + 24 | 0;
 i17 = i26 + 16 | 0;
 i19 = i26 + 8 | 0;
 i23 = i26;
 d8 = +Math_sqrt(+(1.0 / (d1 * d1) + 1.0));
 d1 = 1.0 / d1;
 d9 = +(i20 >>> 0);
 d10 = d9;
 d9 = 1.0 / d9;
 d11 = +Math_pow(+(d1 + d8), +d9);
 d9 = +Math_pow(+(d8 - d1), +d9);
 d1 = (d11 + d9) * .5;
 d9 = (d11 - d9) * .5;
 i15 = i20 & 1;
 i18 = (i20 - i15 | 0) >>> 1;
 i22 = (i18 | 0) == 0;
 if (i22) i2 = 0; else {
  i2 = i20 + -1 | 0;
  d3 = +(i20 << 1 >>> 0);
  d8 = d1 * 0.0;
  i4 = i13 + 4 | 0;
  i5 = i14 + 4 | 0;
  i6 = i20 >>> 1;
  i7 = 0;
  i12 = 0;
  while (1) {
   i7 = i7 + 1 | 0;
   d11 = +((i2 + (i7 << 1) | 0) >>> 0) * 3.141592653589793 / d3;
   d30 = d9 * +Math_cos(+d11);
   d11 = +Math_sin(+d11);
   d29 = d8 * d11;
   d11 = d1 * d11;
   ___divsc3(i13, 1.0, 0.0, d30 - d29, -d11);
   i28 = HEAP32[i4 >> 2] | 0;
   i27 = i12 | 1;
   HEAP32[i21 + (i12 << 3) >> 2] = HEAP32[i13 >> 2];
   HEAP32[i21 + (i12 << 3) + 4 >> 2] = i28;
   ___divsc3(i14, 1.0, 0.0, d30 + d29, d11);
   i28 = HEAP32[i5 >> 2] | 0;
   HEAP32[i21 + (i27 << 3) >> 2] = HEAP32[i14 >> 2];
   HEAP32[i21 + (i27 << 3) + 4 >> 2] = i28;
   if ((i7 | 0) == (i6 | 0)) break; else i12 = i12 + 2 | 0;
  }
  i2 = i6 << 1;
 }
 if (i15) {
  HEAPF32[i21 + (i2 << 3) >> 2] = -1.0 / d9;
  HEAPF32[i21 + (i2 << 3) + 4 >> 2] = 0.0;
  i2 = i2 | 1;
 }
 if ((i2 | 0) != (i20 | 0)) ___assert_fail(gb + 40171 | 0, gb + 40177 | 0, 84, gb + 40201 | 0);
 if (i22) i7 = 0; else {
  i2 = i16 + 4 | 0;
  i4 = i17 + 4 | 0;
  i5 = i20 >>> 1;
  i6 = 0;
  i7 = 0;
  while (1) {
   i6 = i6 + 1 | 0;
   d30 = +Math_cos(+(+(((i6 << 1) + -1 | 0) >>> 0) * 1.5707963267948966 / d10));
   d29 = d30 * 0.0;
   ___divsc3(i16, -1.0, 0.0, d29, d30);
   i27 = HEAP32[i2 >> 2] | 0;
   i28 = i7 | 1;
   HEAP32[i25 + (i7 << 3) >> 2] = HEAP32[i16 >> 2];
   HEAP32[i25 + (i7 << 3) + 4 >> 2] = i27;
   ___divsc3(i17, 1.0, 0.0, d29, d30);
   i27 = HEAP32[i4 >> 2] | 0;
   HEAP32[i25 + (i28 << 3) >> 2] = HEAP32[i17 >> 2];
   HEAP32[i25 + (i28 << 3) + 4 >> 2] = i27;
   if ((i6 | 0) == (i5 | 0)) break; else i7 = i7 + 2 | 0;
  }
  i7 = i5 << 1;
 }
 if ((i7 | 0) != (i18 << 1 | 0)) ___assert_fail(gb + 40214 | 0, gb + 40177 | 0, 95, gb + 40201 | 0);
 i6 = i24 + 4 | 0;
 HEAPF32[i24 >> 2] = 1.0;
 HEAPF32[i6 >> 2] = 0.0;
 if (!i20) {
  d1 = 0.0;
  d3 = 1.0;
 } else {
  i2 = i19 + 4 | 0;
  d3 = 1.0;
  d1 = 0.0;
  i4 = 0;
  do {
   d8 = +HEAPF32[i21 + (i4 << 3) >> 2];
   d9 = +HEAPF32[i21 + (i4 << 3) + 4 >> 2];
   d10 = d8 * d3 - d9 * d1;
   d11 = d9 * d3 + d8 * d1;
   if ((d10 != d10 | 0.0 != 0.0) & (d11 != d11 | 0.0 != 0.0)) {
    ___mulsc3(i19, d3, d1, d8, d9);
    d3 = +HEAPF32[i19 >> 2];
    d1 = +HEAPF32[i2 >> 2];
   } else {
    d3 = d10;
    d1 = d11;
   }
   HEAPF32[i24 >> 2] = d3;
   HEAPF32[i6 >> 2] = d1;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i20 | 0));
 }
 if (i22) {
  STACKTOP = i26;
  return;
 }
 i5 = i23 + 4 | 0;
 i4 = 0;
 while (1) {
  ___divsc3(i23, d3, d1, +HEAPF32[i25 + (i4 << 3) >> 2], +HEAPF32[i25 + (i4 << 3) + 4 >> 2]);
  i28 = HEAP32[i23 >> 2] | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  HEAP32[i24 >> 2] = i28;
  HEAP32[i6 >> 2] = i2;
  i4 = i4 + 1 | 0;
  d3 = (HEAP32[tempDoublePtr >> 2] = i28, +HEAPF32[tempDoublePtr >> 2]);
  if (i4 >>> 0 >= i7 >>> 0) break; else d1 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
 }
 STACKTOP = i26;
 return;
}

function _fft_create_plan_rader(i7, i2, i3, i1, i5) {
 i7 = i7 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 i5 = i5 | 0;
 var i4 = 0, i6 = 0, d8 = 0.0, d9 = 0.0, i10 = 0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, d15 = 0.0, i16 = 0, d17 = 0.0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0;
 i27 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i22 = i27 + 40 | 0;
 i19 = i27 + 32 | 0;
 i23 = i27;
 i24 = i27 + 24 | 0;
 i25 = i27 + 16 | 0;
 i26 = _malloc(72) | 0;
 HEAP32[i26 >> 2] = i7;
 HEAP32[i26 + 4 >> 2] = i2;
 HEAP32[i26 + 8 >> 2] = i3;
 HEAP32[i26 + 16 >> 2] = i5;
 i20 = (i1 | 0) == 1 ? 1 : -1;
 HEAP32[i26 + 20 >> 2] = i20;
 i6 = i26 + 12 | 0;
 HEAP32[i6 >> 2] = i20;
 HEAP32[i26 + 24 >> 2] = 3;
 HEAP32[i26 + 28 >> 2] = fb + 10;
 i20 = (i7 << 3) + -8 | 0;
 i1 = _malloc(i20) | 0;
 i10 = i26 + 40 | 0;
 i16 = i26 + 48 | 0;
 HEAP32[i16 >> 2] = i1;
 i20 = _malloc(i20) | 0;
 HEAP32[i26 + 52 >> 2] = i20;
 i4 = i7 + -1 | 0;
 i21 = _fft_create_plan(i4, i1, i20, 1, i5) | 0;
 HEAP32[i26 + 56 >> 2] = i21;
 HEAP32[i26 + 60 >> 2] = _fft_create_plan(i4, i20, i1, -1, i5) | 0;
 i1 = _liquid_primitive_root_prime(i7) | 0;
 i2 = _malloc((i7 << 2) + -4 | 0) | 0;
 HEAP32[i10 >> 2] = i2;
 L1 : do if ((i7 | 0) != 1) {
  i3 = 0;
  do {
   i18 = i3;
   i3 = i3 + 1 | 0;
   HEAP32[i2 + (i18 << 2) >> 2] = _liquid_modpow(i1, i3, i7) | 0;
  } while (i3 >>> 0 < i4 >>> 0);
  i1 = HEAP32[i26 >> 2] | 0;
  d14 = (HEAP32[i6 >> 2] | 0) == 1 ? -1.0 : 1.0;
  if ((i1 | 0) != 1) {
   d15 = d14 * 0.0;
   d8 = d15 * 2.0 - d15;
   d9 = d14 * 2.0 + d15 * 0.0;
   i3 = i19 + 4 | 0;
   i6 = HEAP32[i10 >> 2] | 0;
   i7 = i23 + 8 | 0;
   d17 = +(i1 >>> 0);
   i10 = i25 + 4 | 0;
   i18 = i24 + 4 | 0;
   i4 = HEAP32[i16 >> 2] | 0;
   i5 = i1 + -1 | 0;
   if ((d8 != d8 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
    i2 = 0;
    while (1) {
     ___mulsc3(i19, d15, d14, 2.0, 0.0);
     d11 = +HEAPF32[i19 >> 2] * 3.141592653589793;
     d12 = +HEAPF32[i3 >> 2] * 3.141592653589793;
     d13 = +((HEAP32[i6 + (i2 << 2) >> 2] | 0) >>> 0);
     d9 = d11 * d13 - d12 * 0.0;
     d8 = d11 * 0.0 + d12 * d13;
     if ((d9 != d9 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
      ___muldc3(i23, d11, d12, d13, 0.0);
      d9 = +HEAPF64[i23 >> 3];
      d8 = +HEAPF64[i7 >> 3];
     }
     HEAPF32[i25 >> 2] = d9 / d17;
     HEAPF32[i10 >> 2] = d8 / d17;
     HEAP32[i22 >> 2] = HEAP32[i25 >> 2];
     HEAP32[i22 + 4 >> 2] = HEAP32[i25 + 4 >> 2];
     _cexpf(i24, i22);
     i16 = HEAP32[i18 >> 2] | 0;
     HEAP32[i4 + (i2 << 3) >> 2] = HEAP32[i24 >> 2];
     HEAP32[i4 + (i2 << 3) + 4 >> 2] = i16;
     i2 = i2 + 1 | 0;
     if (i2 >>> 0 >= i5 >>> 0) break L1;
    }
   }
   d15 = d8 * 3.141592653589793;
   d12 = d9 * 3.141592653589793;
   d13 = d12 * 0.0;
   d14 = d15 * 0.0;
   i2 = 0;
   do {
    d11 = +((HEAP32[i6 + (i2 << 2) >> 2] | 0) >>> 0);
    d9 = d15 * d11 - d13;
    d8 = d14 + d12 * d11;
    if ((d9 != d9 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
     ___muldc3(i23, d15, d12, d11, 0.0);
     d9 = +HEAPF64[i23 >> 3];
     d8 = +HEAPF64[i7 >> 3];
    }
    HEAPF32[i25 >> 2] = d9 / d17;
    HEAPF32[i10 >> 2] = d8 / d17;
    HEAP32[i22 >> 2] = HEAP32[i25 >> 2];
    HEAP32[i22 + 4 >> 2] = HEAP32[i25 + 4 >> 2];
    _cexpf(i24, i22);
    i19 = HEAP32[i18 >> 2] | 0;
    HEAP32[i4 + (i2 << 3) >> 2] = HEAP32[i24 >> 2];
    HEAP32[i4 + (i2 << 3) + 4 >> 2] = i19;
    i2 = i2 + 1 | 0;
   } while (i2 >>> 0 < i5 >>> 0);
  } else i1 = 1;
 } else i1 = 1; while (0);
 mftCall_vi(HEAP32[i21 + 28 >> 2] | 0, i21 | 0);
 i25 = (i1 << 3) + -8 | 0;
 i24 = _malloc(i25) | 0;
 HEAP32[i26 + 44 >> 2] = i24;
 _memcpy(i24 | 0, i20 | 0, i25 | 0) | 0;
 STACKTOP = i27;
 return i26 | 0;
}

function _gmskframesync_pushpn(i31) {
 i31 = i31 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, d17 = 0.0, d18 = 0.0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0;
 i34 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i21 = i34 + 64 | 0;
 i22 = i34 + 56 | 0;
 i23 = i34 + 48 | 0;
 i25 = i34 + 40 | 0;
 i26 = i34 + 24 | 0;
 i32 = i34 + 8 | 0;
 i33 = i34;
 i27 = i34 + 32 | 0;
 i28 = i34 + 16 | 0;
 i29 = i31 + 76 | 0;
 _firpfb_rrrf_reset(HEAP32[i29 >> 2] | 0);
 i30 = i31 + 80 | 0;
 _firpfb_rrrf_reset(HEAP32[i30 >> 2] | 0);
 _windowcf_read(HEAP32[i31 + 124 >> 2] | 0, i32);
 d1 = +HEAPF32[i31 + 112 >> 2];
 if (!(d1 < .5 & d1 > -.5)) ___assert_fail(gb + 26785 | 0, gb + 26827 | 0, 496, gb + 26859 | 0);
 i24 = i31 + 4 | 0;
 i8 = i31 + 8 | 0;
 i2 = Math_imul(HEAP32[i24 >> 2] << 1, HEAP32[i8 >> 2] | 0) | 0;
 i4 = HEAP32[i31 + 84 >> 2] | 0;
 d5 = +(i4 >>> 0);
 d1 = -(d1 * d5);
 i6 = i31 + 92 | 0;
 HEAPF32[i6 >> 2] = d1;
 i3 = ~~+_roundf(+d1);
 i7 = i31 + 96 | 0;
 HEAP32[i7 >> 2] = i3;
 i2 = i2 + -1 | 0;
 if ((i3 | 0) < 0) {
  do {
   i3 = i4 + i3 | 0;
   d1 = d5 + d1;
   i2 = i2 + -1 | 0;
  } while ((i3 | 0) < 0);
  HEAP32[i7 >> 2] = i3;
  HEAPF32[i6 >> 2] = d1;
 }
 HEAP32[i31 + 100 >> 2] = 0;
 i20 = i31 + 128 | 0;
 _nco_crcf_set_frequency(HEAP32[i20 >> 2] | 0, +HEAPF32[i31 + 116 >> 2]);
 i3 = Math_imul((HEAP32[i8 >> 2] | 0) + (HEAP32[i31 + 132 >> 2] | 0) | 0, HEAP32[i24 >> 2] | 0) | 0;
 if (!i3) {
  i33 = i31 + 216 | 0;
  HEAP32[i33 >> 2] = 1;
  STACKTOP = i34;
  return;
 }
 i4 = i27 + 4 | 0;
 i6 = i33 + 4 | 0;
 i7 = i31 + 64 | 0;
 i8 = i31 + 68 | 0;
 i11 = i23 + 4 | 0;
 i12 = i22 + 4 | 0;
 i13 = i25 + 4 | 0;
 i14 = i26 + 4 | 0;
 i15 = i31 + 72 | 0;
 i16 = i28 + 4 | 0;
 i19 = 0;
 do {
  if (i19 >>> 0 < i2 >>> 0) {
   i35 = HEAP32[i20 >> 2] | 0;
   i37 = HEAP32[i32 >> 2] | 0;
   i36 = HEAP32[i37 + (i19 << 3) + 4 >> 2] | 0;
   HEAP32[i27 >> 2] = HEAP32[i37 + (i19 << 3) >> 2];
   HEAP32[i4 >> 2] = i36;
   HEAP32[i21 >> 2] = HEAP32[i27 >> 2];
   HEAP32[i21 + 4 >> 2] = HEAP32[i27 + 4 >> 2];
   _nco_crcf_mix_down(i35, i21, i33);
   _nco_crcf_step(HEAP32[i20 >> 2] | 0);
   d17 = +HEAPF32[i33 >> 2];
   d18 = +HEAPF32[i6 >> 2];
   i35 = HEAP32[i8 >> 2] | 0;
   HEAP32[i23 >> 2] = HEAP32[i7 >> 2];
   HEAP32[i11 >> 2] = i35;
   HEAP32[i21 >> 2] = HEAP32[i23 >> 2];
   HEAP32[i21 + 4 >> 2] = HEAP32[i23 + 4 >> 2];
   _conjf(i22, i21);
   d9 = +HEAPF32[i22 >> 2];
   d10 = +HEAPF32[i12 >> 2];
   d5 = d17 * d9 - d18 * d10;
   d1 = d18 * d9 + d17 * d10;
   if ((d5 != d5 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
    ___mulsc3(i25, d9, d10, d17, d18);
    d5 = +HEAPF32[i25 >> 2];
    d1 = +HEAPF32[i13 >> 2];
   }
   HEAPF32[i26 >> 2] = d5;
   HEAPF32[i14 >> 2] = d1;
   HEAP32[i21 >> 2] = HEAP32[i26 >> 2];
   HEAP32[i21 + 4 >> 2] = HEAP32[i26 + 4 >> 2];
   d10 = +_cargf(i21);
   d10 = d10 * +((HEAP32[i24 >> 2] | 0) >>> 0);
   HEAPF32[i15 >> 2] = d10;
   HEAPF32[i7 >> 2] = d17;
   HEAPF32[i8 >> 2] = d18;
   _firpfb_rrrf_push(HEAP32[i29 >> 2] | 0, d10);
   _firpfb_rrrf_push(HEAP32[i30 >> 2] | 0, +HEAPF32[i15 >> 2]);
  } else {
   i36 = HEAP32[i32 >> 2] | 0;
   i37 = HEAP32[i36 + (i19 << 3) + 4 >> 2] | 0;
   HEAP32[i28 >> 2] = HEAP32[i36 + (i19 << 3) >> 2];
   HEAP32[i16 >> 2] = i37;
   HEAP32[i21 >> 2] = HEAP32[i28 >> 2];
   HEAP32[i21 + 4 >> 2] = HEAP32[i28 + 4 >> 2];
   _gmskframesync_execute_rxpreamble(i31, i21);
  }
  i19 = i19 + 1 | 0;
 } while ((i19 | 0) != (i3 | 0));
 i37 = i31 + 216 | 0;
 HEAP32[i37 >> 2] = 1;
 STACKTOP = i34;
 return;
}

function _fmod(d12, d1) {
 d12 = +d12;
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0, d15 = 0.0;
 HEAPF64[tempDoublePtr >> 3] = d12;
 i2 = HEAP32[tempDoublePtr >> 2] | 0;
 i9 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i10 = HEAP32[tempDoublePtr >> 2] | 0;
 i11 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i3 = _bitshift64Lshr(i2 | 0, i9 | 0, 52) | 0;
 getTempRet0() | 0;
 i3 = i3 & 2047;
 i7 = _bitshift64Lshr(i10 | 0, i11 | 0, 52) | 0;
 getTempRet0() | 0;
 i7 = i7 & 2047;
 i13 = i9 & -2147483648;
 i6 = _bitshift64Shl(i10 | 0, i11 | 0, 1) | 0;
 i8 = getTempRet0() | 0;
 L1 : do if (!((i6 | 0) == 0 & (i8 | 0) == 0) ? (d15 = +Math_abs(+d1), HEAPF64[tempDoublePtr >> 3] = d15, i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0, !(i5 >>> 0 > 2146435072 | (i5 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0 | (i3 | 0) == 2047)) : 0) {
  i4 = _bitshift64Shl(i2 | 0, i9 | 0, 1) | 0;
  i5 = getTempRet0() | 0;
  if (!(i5 >>> 0 > i8 >>> 0 | (i5 | 0) == (i8 | 0) & i4 >>> 0 > i6 >>> 0)) return +((i4 | 0) == (i6 | 0) & (i5 | 0) == (i8 | 0) ? d12 * 0.0 : d12);
  if (!i3) {
   i3 = _bitshift64Shl(i2 | 0, i9 | 0, 12) | 0;
   i4 = getTempRet0() | 0;
   if ((i4 | 0) > -1 | (i4 | 0) == -1 & i3 >>> 0 > 4294967295) {
    i5 = i3;
    i3 = 0;
    do {
     i3 = i3 + -1 | 0;
     i5 = _bitshift64Shl(i5 | 0, i4 | 0, 1) | 0;
     i4 = getTempRet0() | 0;
    } while ((i4 | 0) > -1 | (i4 | 0) == -1 & i5 >>> 0 > 4294967295);
   } else i3 = 0;
   i2 = _bitshift64Shl(i2 | 0, i9 | 0, 1 - i3 | 0) | 0;
   i4 = getTempRet0() | 0;
  } else i4 = i9 & 1048575 | 1048576;
  if (!i7) {
   i5 = _bitshift64Shl(i10 | 0, i11 | 0, 12) | 0;
   i6 = getTempRet0() | 0;
   if ((i6 | 0) > -1 | (i6 | 0) == -1 & i5 >>> 0 > 4294967295) {
    i7 = 0;
    do {
     i7 = i7 + -1 | 0;
     i5 = _bitshift64Shl(i5 | 0, i6 | 0, 1) | 0;
     i6 = getTempRet0() | 0;
    } while ((i6 | 0) > -1 | (i6 | 0) == -1 & i5 >>> 0 > 4294967295);
   } else i7 = 0;
   i10 = _bitshift64Shl(i10 | 0, i11 | 0, 1 - i7 | 0) | 0;
   i9 = getTempRet0() | 0;
  } else i9 = i11 & 1048575 | 1048576;
  i8 = _i64Subtract(i2 | 0, i4 | 0, i10 | 0, i9 | 0) | 0;
  i6 = getTempRet0() | 0;
  i5 = (i6 | 0) > -1 | (i6 | 0) == -1 & i8 >>> 0 > 4294967295;
  L23 : do if ((i3 | 0) > (i7 | 0)) {
   while (1) {
    if (i5) if ((i2 | 0) == (i10 | 0) & (i4 | 0) == (i9 | 0)) break; else {
     i2 = i8;
     i4 = i6;
    }
    i2 = _bitshift64Shl(i2 | 0, i4 | 0, 1) | 0;
    i4 = getTempRet0() | 0;
    i3 = i3 + -1 | 0;
    i8 = _i64Subtract(i2 | 0, i4 | 0, i10 | 0, i9 | 0) | 0;
    i6 = getTempRet0() | 0;
    i5 = (i6 | 0) > -1 | (i6 | 0) == -1 & i8 >>> 0 > 4294967295;
    if ((i3 | 0) <= (i7 | 0)) break L23;
   }
   d1 = d12 * 0.0;
   break L1;
  } while (0);
  if (i5) if ((i2 | 0) == (i10 | 0) & (i4 | 0) == (i9 | 0)) {
   d1 = d12 * 0.0;
   break;
  } else {
   i4 = i6;
   i2 = i8;
  }
  if (i4 >>> 0 < 1048576 | (i4 | 0) == 1048576 & i2 >>> 0 < 0) do {
   i2 = _bitshift64Shl(i2 | 0, i4 | 0, 1) | 0;
   i4 = getTempRet0() | 0;
   i3 = i3 + -1 | 0;
  } while (i4 >>> 0 < 1048576 | (i4 | 0) == 1048576 & i2 >>> 0 < 0);
  if ((i3 | 0) > 0) {
   i11 = _i64Add(i2 | 0, i4 | 0, 0, -1048576) | 0;
   i2 = getTempRet0() | 0;
   i3 = _bitshift64Shl(i3 | 0, 0, 52) | 0;
   i2 = i2 | (getTempRet0() | 0);
   i3 = i11 | i3;
  } else {
   i3 = _bitshift64Lshr(i2 | 0, i4 | 0, 1 - i3 | 0) | 0;
   i2 = getTempRet0() | 0;
  }
  HEAP32[tempDoublePtr >> 2] = i3;
  HEAP32[tempDoublePtr + 4 >> 2] = i2 | i13;
  d1 = +HEAPF64[tempDoublePtr >> 3];
 } else i14 = 3; while (0);
 if ((i14 | 0) == 3) {
  d1 = d12 * d1;
  d1 = d1 / d1;
 }
 return +d1;
}

function _fft_create_plan_dft(i23, i3, i4, i1, i2) {
 i23 = i23 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i24 = 0, i25 = 0, i26 = 0, d27 = 0.0, d28 = 0.0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i18 = i24 + 24 | 0;
 i19 = i24 + 16 | 0;
 i20 = i24 + 8 | 0;
 i21 = i24;
 i22 = _malloc(72) | 0;
 HEAP32[i22 >> 2] = i23;
 HEAP32[i22 + 4 >> 2] = i3;
 HEAP32[i22 + 8 >> 2] = i4;
 HEAP32[i22 + 16 >> 2] = i2;
 i3 = (i1 | 0) == 1;
 i17 = i3 ? 1 : -1;
 HEAP32[i22 + 20 >> 2] = i17;
 HEAP32[i22 + 12 >> 2] = i17;
 HEAP32[i22 + 24 >> 2] = 5;
 i17 = i22 + 40 | 0;
 HEAP32[i17 >> 2] = 0;
 i2 = i22 + 44 | 0;
 HEAP32[i2 >> 2] = 0;
 switch (i23 | 0) {
 case 2:
  {
   HEAP32[i22 + 28 >> 2] = fb + 12;
   STACKTOP = i24;
   return i22 | 0;
  }
 case 3:
  {
   HEAP32[i22 + 28 >> 2] = fb + 13;
   STACKTOP = i24;
   return i22 | 0;
  }
 case 4:
  {
   HEAP32[i22 + 28 >> 2] = fb + 14;
   STACKTOP = i24;
   return i22 | 0;
  }
 case 5:
  {
   HEAP32[i22 + 28 >> 2] = fb + 15;
   STACKTOP = i24;
   return i22 | 0;
  }
 case 6:
  {
   HEAP32[i22 + 28 >> 2] = fb + 16;
   STACKTOP = i24;
   return i22 | 0;
  }
 case 7:
  {
   HEAP32[i22 + 28 >> 2] = fb + 17;
   STACKTOP = i24;
   return i22 | 0;
  }
 case 8:
  {
   HEAP32[i22 + 28 >> 2] = fb + 18;
   STACKTOP = i24;
   return i22 | 0;
  }
 default:
  {
   i1 = i22 + 28 | 0;
   if ((i23 | 0) == 16) {
    HEAP32[i1 >> 2] = fb + 19;
    STACKTOP = i24;
    return i22 | 0;
   }
   HEAP32[i1 >> 2] = fb + 20;
   i15 = _malloc(i23 << 3) | 0;
   HEAP32[i17 >> 2] = i15;
   i16 = _malloc(i23 << 2) | 0;
   HEAP32[i2 >> 2] = i16;
   d6 = i3 ? -1.0 : 1.0;
   if (!i23) {
    STACKTOP = i24;
    return i22 | 0;
   }
   i4 = i23 >>> 0 > 1;
   d7 = d6 * 0.0;
   d11 = d7 * 2.0 - d7;
   d12 = d6 * 2.0 + d7 * 0.0;
   i14 = (d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0);
   i8 = i19 + 4 | 0;
   i9 = i21 + 4 | 0;
   i10 = i20 + 4 | 0;
   d11 = d11 * 3.141592653589793;
   d12 = d12 * 3.141592653589793;
   i13 = 0;
   do {
    if (i4) {
     i1 = HEAP32[i22 >> 2] | 0;
     d5 = +(i1 >>> 0);
     i3 = HEAP32[i17 >> 2] | 0;
     if (i14) {
      i2 = 1;
      do {
       ___mulsc3(i19, d7, d6, 2.0, 0.0);
       d28 = +((Math_imul(i2, i13) | 0) >>> 0);
       d27 = d28 * (+HEAPF32[i8 >> 2] * 3.141592653589793) / d5;
       HEAPF32[i21 >> 2] = d28 * (+HEAPF32[i19 >> 2] * 3.141592653589793) / d5;
       HEAPF32[i9 >> 2] = d27;
       HEAP32[i18 >> 2] = HEAP32[i21 >> 2];
       HEAP32[i18 + 4 >> 2] = HEAP32[i21 + 4 >> 2];
       _cexpf(i20, i18);
       i26 = HEAP32[i10 >> 2] | 0;
       i25 = i2 + -1 | 0;
       HEAP32[i3 + (i25 << 3) >> 2] = HEAP32[i20 >> 2];
       HEAP32[i3 + (i25 << 3) + 4 >> 2] = i26;
       i2 = i2 + 1 | 0;
      } while (i2 >>> 0 < i1 >>> 0);
     } else {
      i2 = 1;
      do {
       d28 = +((Math_imul(i2, i13) | 0) >>> 0);
       HEAPF32[i21 >> 2] = d28 * d11 / d5;
       HEAPF32[i9 >> 2] = d28 * d12 / d5;
       HEAP32[i18 >> 2] = HEAP32[i21 >> 2];
       HEAP32[i18 + 4 >> 2] = HEAP32[i21 + 4 >> 2];
       _cexpf(i20, i18);
       i25 = HEAP32[i10 >> 2] | 0;
       i26 = i2 + -1 | 0;
       HEAP32[i3 + (i26 << 3) >> 2] = HEAP32[i20 >> 2];
       HEAP32[i3 + (i26 << 3) + 4 >> 2] = i25;
       i2 = i2 + 1 | 0;
      } while (i2 >>> 0 < i1 >>> 0);
     }
    } else i1 = i23;
    HEAP32[i16 + (i13 << 2) >> 2] = _dotprod_cccf_create(i15, i1 + -1 | 0) | 0;
    i13 = i13 + 1 | 0;
   } while (i13 >>> 0 < i23 >>> 0);
   STACKTOP = i24;
   return i22 | 0;
  }
 }
 return 0;
}

function _gmskframesync_execute_rxpayload(i21, i1) {
 i21 = i21 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, d15 = 0.0, d16 = 0.0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i22 = 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 i19 = i22 + 48 | 0;
 i8 = i22 + 40 | 0;
 i17 = i22 + 32 | 0;
 i3 = i22 + 16 | 0;
 i7 = i22 + 8 | 0;
 i18 = i22;
 i13 = i22 + 24 | 0;
 i20 = i21 + 128 | 0;
 i14 = HEAP32[i20 >> 2] | 0;
 i12 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i13 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i13 + 4 >> 2] = i12;
 HEAP32[i19 >> 2] = HEAP32[i13 >> 2];
 HEAP32[i19 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
 _nco_crcf_mix_down(i14, i19, i18);
 _nco_crcf_step(HEAP32[i20 >> 2] | 0);
 d15 = +HEAPF32[i18 >> 2];
 d16 = +HEAPF32[i18 + 4 >> 2];
 i1 = i21 + 64 | 0;
 i18 = i21 + 68 | 0;
 i14 = HEAP32[i18 >> 2] | 0;
 HEAP32[i17 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i17 + 4 >> 2] = i14;
 HEAP32[i19 >> 2] = HEAP32[i17 >> 2];
 HEAP32[i19 + 4 >> 2] = HEAP32[i17 + 4 >> 2];
 _conjf(i8, i19);
 d5 = +HEAPF32[i8 >> 2];
 d6 = +HEAPF32[i8 + 4 >> 2];
 d4 = d15 * d5 - d16 * d6;
 d2 = d16 * d5 + d15 * d6;
 if ((d4 != d4 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
  ___mulsc3(i3, d5, d6, d15, d16);
  d4 = +HEAPF32[i3 >> 2];
  d2 = +HEAPF32[i3 + 4 >> 2];
 }
 HEAPF32[i7 >> 2] = d4;
 HEAPF32[i7 + 4 >> 2] = d2;
 HEAP32[i19 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i19 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 d6 = +_cargf(i19);
 d6 = d6 * +((HEAP32[i21 + 4 >> 2] | 0) >>> 0);
 i17 = i21 + 72 | 0;
 HEAPF32[i17 >> 2] = d6;
 HEAPF32[i1 >> 2] = d15;
 HEAPF32[i18 >> 2] = d16;
 HEAPF32[i8 >> 2] = 0.0;
 if (!(_gmskframesync_update_symsync(i21, d6, i8) | 0)) {
  STACKTOP = i22;
  return;
 }
 i13 = i21 + 176 | 0;
 i14 = ((HEAPU8[i13 >> 0] | 0) << 1 | +HEAPF32[i8 >> 2] > 0.0) & 255;
 HEAP8[i13 >> 0] = i14;
 i13 = i21 + 228 | 0;
 i1 = i21 + 200 | 0;
 HEAP8[(HEAP32[i1 >> 2] | 0) + ((HEAP32[i13 >> 2] | 0) >>> 3) >> 0] = i14;
 i14 = (HEAP32[i13 >> 2] | 0) + 1 | 0;
 HEAP32[i13 >> 2] = i14;
 if ((i14 | 0) != (HEAP32[i21 + 192 >> 2] << 3 | 0)) {
  STACKTOP = i22;
  return;
 }
 i3 = i21 + 204 | 0;
 i11 = _packetizer_decode(HEAP32[i21 + 208 >> 2] | 0, HEAP32[i1 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
 HEAP32[i21 + 212 >> 2] = i11;
 i12 = HEAP32[i21 + 16 >> 2] | 0;
 if (i12 | 0) {
  i9 = i21 + 24 | 0;
  HEAPF32[i21 + 28 >> 2] = +_log10f(+HEAPF32[i21 + 120 >> 2]) * 20.0;
  HEAPF32[i9 >> 2] = 0.0;
  HEAP32[i21 + 36 >> 2] = 0;
  HEAP32[i21 + 40 >> 2] = 0;
  HEAP32[i21 + 44 >> 2] = 0;
  HEAP32[i21 + 48 >> 2] = 1;
  HEAP32[i21 + 52 >> 2] = HEAP32[i21 + 180 >> 2];
  HEAP32[i21 + 56 >> 2] = HEAP32[i21 + 184 >> 2];
  HEAP32[i21 + 60 >> 2] = HEAP32[i21 + 188 >> 2];
  i13 = HEAP32[i21 + 164 >> 2] | 0;
  i14 = HEAP32[i21 + 172 >> 2] | 0;
  i7 = HEAP32[i3 >> 2] | 0;
  i1 = HEAP32[i21 + 196 >> 2] | 0;
  i3 = HEAP32[i21 + 20 >> 2] | 0;
  i8 = i19;
  i10 = i8 + 40 | 0;
  do {
   HEAP32[i8 >> 2] = HEAP32[i9 >> 2];
   i8 = i8 + 4 | 0;
   i9 = i9 + 4 | 0;
  } while ((i8 | 0) < (i10 | 0));
  mftCall_iiiiiiii(i12 | 0, i13 | 0, i14 | 0, i7 | 0, i1 | 0, i11 | 0, i19 | 0, i3 | 0) | 0;
 }
 i19 = i21 + 216 | 0;
 HEAP32[i19 >> 2] = 0;
 HEAP32[i19 + 4 >> 2] = 0;
 HEAP32[i19 + 8 >> 2] = 0;
 HEAP32[i19 + 12 >> 2] = 0;
 _windowcf_clear(HEAP32[i21 + 124 >> 2] | 0);
 _detector_cccf_reset(HEAP32[i21 + 108 >> 2] | 0);
 _nco_crcf_reset(HEAP32[i20 >> 2] | 0);
 HEAPF32[i21 + 64 >> 2] = 0.0;
 HEAPF32[i18 >> 2] = 0.0;
 HEAPF32[i17 >> 2] = 0.0;
 _firpfb_rrrf_reset(HEAP32[i21 + 76 >> 2] | 0);
 _firpfb_rrrf_reset(HEAP32[i21 + 80 >> 2] | 0);
 HEAPF32[i21 + 88 >> 2] = 0.0;
 STACKTOP = i22;
 return;
}

function _fft_create_plan_mixed_radix(i21, i6, i7, i5, i14) {
 i21 = i21 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 i5 = i5 | 0;
 i14 = i14 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, d8 = 0.0, d9 = 0.0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i22 = 0, i23 = 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 i17 = i22 + 56 | 0;
 i15 = i22 + 16 | 0;
 i13 = i22 + 8 | 0;
 i10 = i22;
 i23 = i22 + 32 | 0;
 i16 = i22 + 48 | 0;
 i18 = i22 + 40 | 0;
 i19 = i22 + 24 | 0;
 i20 = _malloc(72) | 0;
 HEAP32[i20 >> 2] = i21;
 HEAP32[i20 + 4 >> 2] = i6;
 HEAP32[i20 + 8 >> 2] = i7;
 HEAP32[i20 + 16 >> 2] = i14;
 i12 = (i5 | 0) == 1;
 i6 = i12 ? 1 : -1;
 HEAP32[i20 + 20 >> 2] = i6;
 HEAP32[i20 + 12 >> 2] = i6;
 HEAP32[i20 + 24 >> 2] = 2;
 HEAP32[i20 + 28 >> 2] = fb + 9;
 _liquid_factor(i21, i17, i23);
 i5 = HEAP32[i23 >> 2] | 0;
 if (i5 >>> 0 < 2) {
  i23 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i10 >> 2] = i21;
  _fprintf(i23, gb + 39642 | 0, i10) | 0;
  HEAP32[i13 >> 2] = i21;
  _fprintf(i23, gb + 39692 | 0, i13) | 0;
  _exit(1);
 } else i4 = 0;
 while (1) {
  if ((HEAP32[i17 + (i4 << 2) >> 2] | 0) != 2) {
   i5 = 5;
   break;
  }
  i4 = i4 + 1 | 0;
  if (i4 >>> 0 >= i5 >>> 0) {
   i5 = 6;
   break;
  }
 }
 if ((i5 | 0) == 5) if (!i4) {
  i4 = HEAP32[i17 >> 2] | 0;
  if (!i4) {
   i23 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i13 >> 2] = i21;
   _fprintf(i23, gb + 39692 | 0, i13) | 0;
   _exit(1);
  } else i1 = i4;
 } else i5 = 6;
 if ((i5 | 0) == 6) if (i21 & 15) if (!(i21 & 7)) i1 = 8; else i1 = (i21 & 3 | 0) == 0 ? 4 : 2; else i1 = 16;
 if ((i21 >>> 0) % (i1 >>> 0) | 0 | 0) {
  i23 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i15 >> 2] = i21;
  HEAP32[i15 + 4 >> 2] = i1;
  _fprintf(i23, gb + 39749 | 0, i15) | 0;
  _exit(1);
 }
 i13 = (i21 >>> 0) / (i1 >>> 0) | 0;
 HEAP32[i20 + 44 >> 2] = i1;
 HEAP32[i20 + 40 >> 2] = i13;
 i23 = (i1 >>> 0 > i13 >>> 0 ? i1 : i13) << 3;
 i15 = _malloc(i23) | 0;
 HEAP32[i20 + 52 >> 2] = i15;
 i23 = _malloc(i23) | 0;
 HEAP32[i20 + 56 >> 2] = i23;
 i7 = i21 << 3;
 HEAP32[i20 + 48 >> 2] = _malloc(i7) | 0;
 HEAP32[i20 + 64 >> 2] = _fft_create_plan(i13, i15, i23, i6, i14) | 0;
 HEAP32[i20 + 68 >> 2] = _fft_create_plan(i1, i15, i23, i6, i14) | 0;
 i7 = _malloc(i7) | 0;
 HEAP32[i20 + 60 >> 2] = i7;
 d3 = i12 ? -1.0 : 1.0;
 if (!i21) {
  STACKTOP = i22;
  return i20 | 0;
 }
 d8 = d3 * 0.0;
 d2 = d8 * 2.0 - d8;
 d9 = d3 * 2.0 + d8 * 0.0;
 i4 = i16 + 4 | 0;
 d11 = +(i21 >>> 0);
 i5 = i19 + 4 | 0;
 i6 = i18 + 4 | 0;
 if ((d2 != d2 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
  i1 = 0;
  do {
   ___mulsc3(i16, d8, d3, 2.0, 0.0);
   d2 = +(i1 >>> 0);
   d9 = d2 * (+HEAPF32[i4 >> 2] * 3.141592653589793) / d11;
   HEAPF32[i19 >> 2] = d2 * (+HEAPF32[i16 >> 2] * 3.141592653589793) / d11;
   HEAPF32[i5 >> 2] = d9;
   HEAP32[i17 >> 2] = HEAP32[i19 >> 2];
   HEAP32[i17 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
   _cexpf(i18, i17);
   i23 = HEAP32[i6 >> 2] | 0;
   HEAP32[i7 + (i1 << 3) >> 2] = HEAP32[i18 >> 2];
   HEAP32[i7 + (i1 << 3) + 4 >> 2] = i23;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i21 >>> 0);
  STACKTOP = i22;
  return i20 | 0;
 }
 d3 = d2 * 3.141592653589793;
 d2 = d9 * 3.141592653589793;
 i1 = 0;
 do {
  d9 = +(i1 >>> 0);
  HEAPF32[i19 >> 2] = d9 * d3 / d11;
  HEAPF32[i5 >> 2] = d9 * d2 / d11;
  HEAP32[i17 >> 2] = HEAP32[i19 >> 2];
  HEAP32[i17 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
  _cexpf(i18, i17);
  i23 = HEAP32[i6 >> 2] | 0;
  HEAP32[i7 + (i1 << 3) >> 2] = HEAP32[i18 >> 2];
  HEAP32[i7 + (i1 << 3) + 4 >> 2] = i23;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i21 >>> 0);
 STACKTOP = i22;
 return i20 | 0;
}

function _ofdmflexframesync_rxpayload(i18, i10) {
 i18 = i18 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i17 = i19 + 16 | 0;
 i11 = i19;
 i3 = i19 + 8 | 0;
 i1 = HEAP32[i18 >> 2] | 0;
 if (!i1) {
  STACKTOP = i19;
  return;
 }
 i5 = i18 + 12 | 0;
 i6 = i18 + 104 | 0;
 i7 = i3 + 4 | 0;
 i8 = i18 + 200 | 0;
 i16 = i18 + 128 | 0;
 i13 = i18 + 108 | 0;
 i9 = i18 + 116 | 0;
 i4 = i18 + 204 | 0;
 i14 = i18 + 80 | 0;
 i15 = i18 + 120 | 0;
 i2 = 0;
 while (1) {
  if ((HEAP8[(HEAP32[i5 >> 2] | 0) + i2 >> 0] | 0) == 2) {
   i1 = HEAP32[i6 >> 2] | 0;
   i22 = i10 + (i2 << 3) | 0;
   i21 = i10 + (i2 << 3) + 4 | 0;
   i20 = HEAP32[i21 >> 2] | 0;
   HEAP32[i3 >> 2] = HEAP32[i22 >> 2];
   HEAP32[i7 >> 2] = i20;
   HEAP32[i17 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i17 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   _modem_demodulate(i1, i17, i11);
   i21 = HEAP32[i21 >> 2] | 0;
   i1 = HEAP32[i8 >> 2] | 0;
   i20 = HEAP32[i16 >> 2] | 0;
   HEAP32[i20 + (i1 << 3) >> 2] = HEAP32[i22 >> 2];
   HEAP32[i20 + (i1 << 3) + 4 >> 2] = i21;
   _liquid_pack_array(HEAP32[i13 >> 2] | 0, HEAP32[i9 >> 2] | 0, HEAP32[i4 >> 2] | 0, HEAP32[i14 >> 2] | 0, HEAP32[i11 >> 2] | 0);
   HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + (HEAP32[i14 >> 2] | 0);
   i1 = (HEAP32[i8 >> 2] | 0) + 1 | 0;
   HEAP32[i8 >> 2] = i1;
   if ((i1 | 0) == (HEAP32[i15 >> 2] | 0)) break;
   i1 = HEAP32[i18 >> 2] | 0;
  }
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= i1 >>> 0) {
   i12 = 10;
   break;
  }
 }
 if ((i12 | 0) == 10) {
  STACKTOP = i19;
  return;
 }
 i2 = i18 + 112 | 0;
 i3 = i18 + 124 | 0;
 HEAP32[i3 >> 2] = _packetizer_decode(HEAP32[i18 + 100 >> 2] | 0, HEAP32[i13 >> 2] | 0, HEAP32[i2 >> 2] | 0) | 0;
 i1 = i18 + 132 | 0;
 if (!(HEAP32[i1 >> 2] | 0)) {
  i22 = i18 + 188 | 0;
  HEAP32[i22 >> 2] = 0;
  HEAP32[i22 + 4 >> 2] = 0;
  HEAP32[i22 + 8 >> 2] = 0;
  HEAP32[i22 + 12 >> 2] = 0;
  HEAP32[i22 + 16 >> 2] = 0;
  HEAPF32[i18 + 180 >> 2] = 9.999999960041972e-13;
  _framesyncstats_init_default(i18 + 140 | 0);
  _ofdmframesync_reset(HEAP32[i18 + 184 >> 2] | 0);
  STACKTOP = i19;
  return;
 } else {
  i11 = i18 + 184 | 0;
  i12 = i18 + 140 | 0;
  HEAPF32[i18 + 144 >> 2] = +_ofdmframesync_get_rssi(HEAP32[i11 >> 2] | 0);
  HEAPF32[i18 + 148 >> 2] = +_ofdmframesync_get_cfo(HEAP32[i11 >> 2] | 0);
  HEAP32[i18 + 152 >> 2] = HEAP32[i16 >> 2];
  HEAP32[i18 + 156 >> 2] = HEAP32[i15 >> 2];
  HEAP32[i18 + 160 >> 2] = HEAP32[i18 + 76 >> 2];
  HEAP32[i18 + 164 >> 2] = HEAP32[i14 >> 2];
  HEAP32[i18 + 168 >> 2] = HEAP32[i18 + 88 >> 2];
  HEAP32[i18 + 172 >> 2] = HEAP32[i18 + 92 >> 2];
  HEAP32[i18 + 176 >> 2] = HEAP32[i18 + 96 >> 2];
  i8 = HEAP32[i1 >> 2] | 0;
  i9 = HEAP32[i18 + 44 >> 2] | 0;
  i10 = HEAP32[i18 + 72 >> 2] | 0;
  i6 = HEAP32[i2 >> 2] | 0;
  i7 = HEAP32[i18 + 84 >> 2] | 0;
  i1 = HEAP32[i3 >> 2] | 0;
  i2 = HEAP32[i18 + 136 >> 2] | 0;
  i3 = i17;
  i4 = i12;
  i5 = i3 + 40 | 0;
  do {
   HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
   i3 = i3 + 4 | 0;
   i4 = i4 + 4 | 0;
  } while ((i3 | 0) < (i5 | 0));
  mftCall_iiiiiiii(i8 | 0, i9 | 0, i10 | 0, i6 | 0, i7 | 0, i1 | 0, i17 | 0, i2 | 0) | 0;
  i22 = i18 + 188 | 0;
  HEAP32[i22 >> 2] = 0;
  HEAP32[i22 + 4 >> 2] = 0;
  HEAP32[i22 + 8 >> 2] = 0;
  HEAP32[i22 + 12 >> 2] = 0;
  HEAP32[i22 + 16 >> 2] = 0;
  HEAPF32[i18 + 180 >> 2] = 9.999999960041972e-13;
  _framesyncstats_init_default(i12);
  _ofdmframesync_reset(HEAP32[i11 >> 2] | 0);
  STACKTOP = i19;
  return;
 }
}

function _interleaver_decode(i15, i1, i16) {
 i15 = i15 | 0;
 i1 = i1 | 0;
 i16 = i16 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i17 = 0, i18 = 0, i19 = 0;
 _memmove(i16 | 0, i1 | 0, HEAP32[i15 >> 2] | 0) | 0;
 i11 = i15 + 12 | 0;
 i1 = HEAP32[i11 >> 2] | 0;
 if (i1 >>> 0 > 3) {
  i2 = HEAP32[i15 >> 2] | 0;
  i6 = HEAP32[i15 + 4 >> 2] | 0;
  i7 = (HEAP32[i15 + 8 >> 2] | 0) + 8 | 0;
  i5 = i2 >>> 1;
  if (!i5) i2 = 11; else {
   i1 = 0;
   i4 = 0;
   i3 = (i2 >>> 0) / 3 | 0;
   while (1) {
    i2 = i4;
    do {
     i4 = (Math_imul(i2, i7) | 0) + i3 | 0;
     i2 = i2 + 1 | 0;
     if ((i2 | 0) == (i6 | 0)) {
      i2 = 0;
      i3 = ((i3 + 1 | 0) >>> 0) % (i7 >>> 0) | 0;
     }
    } while (i4 >>> 0 >= i5 >>> 0);
    i18 = i16 + (i1 << 1) | 0;
    i17 = HEAP8[i18 >> 0] | 0;
    i8 = i16 + (i4 << 1 | 1) | 0;
    i4 = HEAP8[i8 >> 0] | 0;
    HEAP8[i18 >> 0] = i4 & 51 | i17 & 204;
    HEAP8[i8 >> 0] = i4 & 204 | i17 & 51;
    i1 = i1 + 1 | 0;
    if ((i1 | 0) == (i5 | 0)) break; else i4 = i2;
   }
   i1 = HEAP32[i11 >> 2] | 0;
   i2 = 10;
  }
 } else i2 = 10;
 if ((i2 | 0) == 10) if (i1 >>> 0 > 2) i2 = 11; else i2 = 19;
 if ((i2 | 0) == 11) {
  i1 = HEAP32[i15 >> 2] | 0;
  i6 = HEAP32[i15 + 4 >> 2] | 0;
  i7 = (HEAP32[i15 + 8 >> 2] | 0) + 4 | 0;
  i8 = i1 >>> 1;
  if (!i8) i2 = 20; else {
   i5 = 0;
   i3 = 0;
   i2 = (i1 >>> 0) / 3 | 0;
   while (1) {
    i1 = i3;
    do {
     i4 = (Math_imul(i1, i7) | 0) + i2 | 0;
     i1 = i1 + 1 | 0;
     if ((i1 | 0) == (i6 | 0)) {
      i1 = 0;
      i2 = ((i2 + 1 | 0) >>> 0) % (i7 >>> 0) | 0;
     }
    } while (i4 >>> 0 >= i8 >>> 0);
    i3 = i1;
    i19 = i16 + (i5 << 1) | 0;
    i18 = HEAP8[i19 >> 0] | 0;
    i1 = i16 + (i4 << 1 | 1) | 0;
    i17 = HEAP8[i1 >> 0] | 0;
    HEAP8[i19 >> 0] = i17 & 85 | i18 & 170;
    HEAP8[i1 >> 0] = i17 & 170 | i18 & 85;
    i1 = i5 + 1 | 0;
    if ((i1 | 0) == (i8 | 0)) break; else i5 = i1;
   }
   i1 = HEAP32[i11 >> 2] | 0;
   i2 = 19;
  }
 }
 if ((i2 | 0) == 19) if (i1 >>> 0 > 1) i2 = 20; else {
  i9 = i1;
  i2 = 28;
 }
 if ((i2 | 0) == 20 ? (i10 = HEAP32[i15 >> 2] | 0, i12 = HEAP32[i15 + 4 >> 2] | 0, i13 = (HEAP32[i15 + 8 >> 2] | 0) + 2 | 0, i14 = i10 >>> 1, i14 | 0) : 0) {
  i1 = 0;
  i2 = 0;
  i3 = (i10 >>> 0) / 3 | 0;
  do {
   do {
    i4 = (Math_imul(i2, i13) | 0) + i3 | 0;
    i2 = i2 + 1 | 0;
    if ((i2 | 0) == (i12 | 0)) {
     i2 = 0;
     i3 = ((i3 + 1 | 0) >>> 0) % (i13 >>> 0) | 0;
    }
   } while (i4 >>> 0 >= i14 >>> 0);
   i10 = i16 + (i1 << 1) | 0;
   i18 = HEAP8[i10 >> 0] | 0;
   i19 = i16 + (i4 << 1 | 1) | 0;
   i17 = HEAP8[i19 >> 0] | 0;
   HEAP8[i10 >> 0] = i17 & 15 | i18 & 240;
   HEAP8[i19 >> 0] = i17 & 240 | i18 & 15;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i14 | 0));
  i9 = HEAP32[i11 >> 2] | 0;
  i2 = 28;
 }
 if ((i2 | 0) == 28 ? (i9 | 0) == 0 : 0) return;
 i2 = HEAP32[i15 >> 2] | 0;
 i7 = HEAP32[i15 + 4 >> 2] | 0;
 i5 = HEAP32[i15 + 8 >> 2] | 0;
 i6 = i2 >>> 1;
 if (!i6) return;
 i1 = 0;
 i4 = 0;
 i3 = (i2 >>> 0) / 3 | 0;
 while (1) {
  i2 = i4;
  do {
   i4 = (Math_imul(i2, i5) | 0) + i3 | 0;
   i2 = i2 + 1 | 0;
   if ((i2 | 0) == (i7 | 0)) {
    i2 = 0;
    i3 = ((i3 + 1 | 0) >>> 0) % (i5 >>> 0) | 0;
   }
  } while (i4 >>> 0 >= i6 >>> 0);
  i17 = i16 + (i4 << 1 | 1) | 0;
  i18 = HEAP8[i17 >> 0] | 0;
  i19 = i16 + (i1 << 1) | 0;
  HEAP8[i17 >> 0] = HEAP8[i19 >> 0] | 0;
  HEAP8[i19 >> 0] = i18;
  i1 = i1 + 1 | 0;
  if ((i1 | 0) == (i6 | 0)) break; else i4 = i2;
 }
 return;
}

function _matrixf_gjelim(i23, i25, i24) {
 i23 = i23 | 0;
 i25 = i25 | 0;
 i24 = i24 | 0;
 var i1 = 0, F42 = SIMD_Float32x4(0, 0, 0, 0), d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i26 = 0, i27 = 0, F428 = SIMD_Float32x4(0, 0, 0, 0);
 i14 = (i25 | 0) == 0;
 if (i14) return;
 i15 = HEAP32[gb + 8808 >> 2] | 0;
 i16 = (i24 | 0) == 0;
 i17 = (i24 | 0) != 0;
 i18 = i24 + -1 | 0;
 i21 = i24 >>> 0 < 4;
 i22 = i24 & -4;
 i20 = (i22 | 0) == 0;
 i19 = (i22 | 0) == (i24 | 0);
 i1 = 0;
 i4 = 0;
 d3 = 0.0;
 do {
  i13 = Math_imul(i1, i24) | 0;
  i12 = i23 + (i13 << 2) | 0;
  i13 = i23 + (i18 + i13 << 2) | 0;
  i5 = i1;
  do {
   d11 = +Math_abs(+(+HEAPF32[i23 + ((Math_imul(i5, i24) | 0) + i1 << 2) >> 2]));
   i9 = (i5 | 0) == (i1 | 0) | d11 > d3;
   d3 = i9 ? d11 : d3;
   i4 = i9 ? i5 : i4;
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i25 | 0));
  if (d3 == 0.0) _fwrite(gb + 30253 | 0, 63, 1, i15) | 0;
  i9 = Math_imul(i1, i24) | 0;
  if ((i1 | 0) != (i4 | 0) & i17) {
   i5 = Math_imul(i4, i24) | 0;
   i6 = 0;
   do {
    i27 = i23 + (i6 + i9 << 2) | 0;
    i7 = HEAP32[i27 >> 2] | 0;
    i8 = i23 + (i6 + i5 << 2) | 0;
    HEAP32[i27 >> 2] = HEAP32[i8 >> 2];
    HEAP32[i8 >> 2] = i7;
    i6 = i6 + 1 | 0;
   } while ((i6 | 0) != (i24 | 0));
  }
  d10 = +HEAPF32[i23 + (i9 + i1 << 2) >> 2];
  if (!(d10 == 0.0)) {
   if (!i16) {
    i8 = 0;
    do {
     i6 = Math_imul(i8, i24) | 0;
     i5 = i23 + (i6 << 2) | 0;
     i6 = i23 + (i18 + i6 << 2) | 0;
     do if ((i8 | 0) != (i1 | 0)) {
      i7 = Math_imul(i8, i24) | 0;
      d11 = +HEAPF32[i23 + (i7 + i1 << 2) >> 2] / d10;
      if (!(i21 | i20) ? !(i5 >>> 0 <= i13 >>> 0 & i12 >>> 0 <= i6 >>> 0) : 0) {
       F42 = SIMD_Float32x4_splat(Math_fround(d11));
       i5 = 0;
       do {
        F428 = SIMD_Float32x4_mul(F42, SIMD_Float32x4_load(HEAPU8, i23 + (i5 + i9 << 2) | 0));
        i27 = i23 + (i5 + i7 << 2) | 0;
        i6 = i27;
        SIMD_Float32x4_store(HEAPU8, i6, SIMD_Float32x4_sub(F428, SIMD_Float32x4_load(HEAPU8, i27)));
        i5 = i5 + 4 | 0;
       } while ((i5 | 0) != (i22 | 0));
       if (i19) break; else i5 = i22;
      } else i5 = 0;
      do {
       i27 = i23 + (i5 + i7 << 2) | 0;
       HEAPF32[i27 >> 2] = d11 * +HEAPF32[i23 + (i5 + i9 << 2) >> 2] - +HEAPF32[i27 >> 2];
       i5 = i5 + 1 | 0;
      } while ((i5 | 0) != (i24 | 0));
     } while (0);
     i8 = i8 + 1 | 0;
    } while ((i8 | 0) != (i25 | 0));
   }
  } else _fwrite(gb + 30317 | 0, 42, 1, i15) | 0;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i25 | 0));
 if (i14 | (i24 | 0) == 0) return;
 i7 = i24 >>> 0 < 4;
 i8 = i24 & -4;
 i6 = (i8 | 0) == 0;
 i5 = (i8 | 0) == (i24 | 0);
 i9 = 0;
 do {
  i4 = Math_imul(i9, i24) | 0;
  d3 = 1.0 / +HEAPF32[i23 + (i4 + i9 << 2) >> 2];
  if (!(i7 | i6)) {
   F42 = SIMD_Float32x4_splat(Math_fround(d3));
   i1 = 0;
   do {
    i27 = i23 + (i1 + i4 << 2) | 0;
    i22 = i27;
    SIMD_Float32x4_store(HEAPU8, i22, SIMD_Float32x4_mul(F42, SIMD_Float32x4_load(HEAPU8, i27)));
    i1 = i1 + 4 | 0;
   } while ((i1 | 0) != (i8 | 0));
   if (!i5) {
    i1 = i8;
    i26 = 10;
   }
  } else {
   i1 = 0;
   i26 = 10;
  }
  if ((i26 | 0) == 10) while (1) {
   i26 = 0;
   i27 = i23 + (i1 + i4 << 2) | 0;
   HEAPF32[i27 >> 2] = d3 * +HEAPF32[i27 >> 2];
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i24 | 0)) break; else i26 = 10;
  }
  i9 = i9 + 1 | 0;
 } while ((i9 | 0) != (i25 | 0));
 return;
}

function _liquid_firdes_prototype(i18, i16, i17, d13, d14, i15) {
 i18 = i18 | 0;
 i16 = i16 | 0;
 i17 = i17 | 0;
 d13 = +d13;
 d14 = +d14;
 i15 = i15 | 0;
 var d1 = 0.0, i2 = 0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0, i9 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0;
 i26 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i22 = i26 + 16 | 0;
 i21 = i26 + 8 | 0;
 i2 = i26;
 i19 = i26 + 56 | 0;
 i20 = i26 + 44 | 0;
 i23 = i26 + 32 | 0;
 i24 = i26 + 20 | 0;
 i9 = Math_imul(i16 << 1, i17) | 0 | 1;
 d10 = +(i16 >>> 0);
 d11 = .5 / d10;
 d12 = d13 / d10;
 d3 = d12 * 14.260000228881836;
 d4 = +(i9 >>> 0);
 if (d12 > .5 | d12 <= 0.0) {
  i27 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i2 >> 3] = d12;
  _fprintf(i27, gb + 21517 | 0, i2) | 0;
  _exit(1);
 } else {
  d5 = .009999999776482582;
  d6 = 200.0;
  i7 = 0;
 }
 while (1) {
  d1 = (d5 + d6) * .5;
  if (d1 <= 0.0) {
   i25 = 4;
   break;
  }
  i2 = (d1 + -7.949999809265137) / d3 < d4;
  i7 = i7 + 1 | 0;
  if (i7 >>> 0 >= 20) {
   d8 = d1;
   break;
  } else {
   d5 = i2 ? d1 : d5;
   d6 = i2 ? d6 : d1;
  }
 }
 if ((i25 | 0) == 4) {
  i27 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i21 >> 3] = d1;
  _fprintf(i27, gb + 21454 | 0, i21) | 0;
  _exit(1);
 }
 HEAPF32[i19 >> 2] = 0.0;
 d12 = d12 * .5;
 HEAPF32[i19 + 4 >> 2] = d11 - d12;
 HEAPF32[i19 + 8 >> 2] = d11;
 HEAPF32[i19 + 12 >> 2] = d11;
 HEAPF32[i19 + 16 >> 2] = d11 + d12;
 HEAPF32[i19 + 20 >> 2] = .5;
 HEAPF32[i20 >> 2] = d10;
 HEAPF32[i20 + 4 >> 2] = d10 * .5;
 HEAPF32[i20 + 8 >> 2] = 0.0;
 HEAP32[i23 >> 2] = HEAP32[gb + 524 >> 2];
 HEAP32[i23 + 4 >> 2] = HEAP32[gb + 524 + 4 >> 2];
 HEAP32[i23 + 8 >> 2] = HEAP32[gb + 524 + 8 >> 2];
 HEAP32[i24 >> 2] = 0;
 HEAP32[i24 + 4 >> 2] = 0;
 HEAP32[i24 + 8 >> 2] = 0;
 do switch (i18 | 0) {
 case 1:
  {
   _liquid_firdes_kaiser(i9, d11, d8, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 2:
  {
   _firdespm_run(i9, 3, i19, i20, i23, i24, 0, i15);
   STACKTOP = i26;
   return;
  }
 case 3:
  {
   _liquid_firdes_rcos(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 4:
  {
   _liquid_firdes_fexp(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 5:
  {
   _liquid_firdes_fsech(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 6:
  {
   _liquid_firdes_farcsech(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 7:
  {
   _liquid_firdes_arkaiser(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 8:
  {
   _liquid_firdes_rkaiser(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 9:
  {
   _liquid_firdes_rrcos(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 10:
  {
   _liquid_firdes_hM3(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 11:
  {
   _liquid_firdes_gmsktx(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 12:
  {
   _liquid_firdes_gmskrx(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 13:
  {
   _liquid_firdes_rfexp(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 14:
  {
   _liquid_firdes_rfsech(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 case 15:
  {
   _liquid_firdes_rfarcsech(i16, i17, d13, d14, i15);
   STACKTOP = i26;
   return;
  }
 default:
  {
   i27 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i22 >> 2] = i18;
   _fprintf(i27, gb + 21803 | 0, i22) | 0;
   _exit(1);
  }
 } while (0);
}

function _modem_demodulate_sqam128(i20, i3, i10) {
 i20 = i20 | 0;
 i3 = i3 | 0;
 i10 = i10 | 0;
 var d1 = 0.0, d2 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, d11 = 0.0, d12 = 0.0, d13 = 0.0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0, i21 = 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i14 = i21 + 72 | 0;
 i15 = i21 + 64 | 0;
 i16 = i21 + 40 | 0;
 i17 = i21 + 24 | 0;
 i18 = i21 + 16 | 0;
 i4 = i21 + 56 | 0;
 i5 = i21 + 48 | 0;
 i6 = i21 + 32 | 0;
 i7 = i21 + 8 | 0;
 i9 = i21;
 d19 = +HEAPF32[i3 >> 2];
 d13 = +HEAPF32[i3 + 4 >> 2];
 i8 = (d19 < 0.0 & 1) << 1 | d13 < 0.0;
 switch (i8 | 0) {
 case 0:
  {
   d11 = d19;
   d12 = d13;
   break;
  }
 case 1:
  {
   HEAPF32[i5 >> 2] = d19;
   HEAPF32[i5 + 4 >> 2] = d13;
   HEAP32[i14 >> 2] = HEAP32[i5 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   _conjf(i4, i14);
   d11 = +HEAPF32[i4 >> 2];
   d12 = +HEAPF32[i4 + 4 >> 2];
   break;
  }
 case 2:
  {
   HEAPF32[i7 >> 2] = d19;
   HEAPF32[i7 + 4 >> 2] = d13;
   HEAP32[i14 >> 2] = HEAP32[i7 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   _conjf(i6, i14);
   d11 = -+HEAPF32[i6 >> 2];
   d12 = -+HEAPF32[i6 + 4 >> 2];
   break;
  }
 case 3:
  {
   d11 = -d19;
   d12 = -d13;
   break;
  }
 default:
  {}
 }
 if (!(d11 >= 0.0)) ___assert_fail(gb + 31371 | 0, gb + 31472 | 0, 99, gb + 31502 | 0);
 if (!(d12 >= 0.0)) ___assert_fail(gb + 31448 | 0, gb + 31472 | 0, 100, gb + 31502 | 0);
 i5 = i20 + 100 | 0;
 i3 = i9 + 4 | 0;
 d2 = 0.0;
 i4 = 0;
 while (1) {
  i7 = HEAP32[i5 >> 2] | 0;
  d1 = d12 - +HEAPF32[i7 + (i4 << 3) + 4 >> 2];
  HEAPF32[i9 >> 2] = d11 - +HEAPF32[i7 + (i4 << 3) >> 2];
  HEAPF32[i3 >> 2] = d1;
  HEAP32[i14 >> 2] = HEAP32[i9 >> 2];
  HEAP32[i14 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
  d1 = +_cabsf(i14);
  if ((i4 | 0) == 0 | d1 < d2) HEAP32[i10 >> 2] = i4; else d1 = d2;
  i4 = i4 + 1 | 0;
  if ((i4 | 0) == 32) break; else d2 = d1;
 }
 i7 = HEAP32[i10 >> 2] | 0;
 i9 = i7 | i8 << 5;
 HEAP32[i10 >> 2] = i9;
 i3 = i20 + 92 | 0;
 i10 = i7 & 31;
 i8 = HEAP32[i5 >> 2] | 0;
 d1 = +HEAPF32[i8 + (i10 << 3) >> 2];
 d2 = +HEAPF32[i8 + (i10 << 3) + 4 >> 2];
 switch (i9 >>> 5 & 3 | 0) {
 case 0:
  {
   HEAPF32[i3 >> 2] = d1;
   HEAPF32[i20 + 96 >> 2] = d2;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 case 1:
  {
   HEAPF32[i16 >> 2] = d1;
   HEAPF32[i16 + 4 >> 2] = d2;
   HEAP32[i14 >> 2] = HEAP32[i16 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
   _conjf(i15, i14);
   i18 = HEAP32[i15 + 4 >> 2] | 0;
   HEAP32[i3 >> 2] = HEAP32[i15 >> 2];
   HEAP32[i20 + 96 >> 2] = i18;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 case 2:
  {
   HEAPF32[i18 >> 2] = d1;
   HEAPF32[i18 + 4 >> 2] = d2;
   HEAP32[i14 >> 2] = HEAP32[i18 >> 2];
   HEAP32[i14 + 4 >> 2] = HEAP32[i18 + 4 >> 2];
   _conjf(i17, i14);
   d12 = -+HEAPF32[i17 + 4 >> 2];
   HEAPF32[i3 >> 2] = -+HEAPF32[i17 >> 2];
   HEAPF32[i20 + 96 >> 2] = d12;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 case 3:
  {
   HEAPF32[i3 >> 2] = -d1;
   HEAPF32[i20 + 96 >> 2] = -d2;
   i18 = i20 + 88 | 0;
   i20 = i20 + 84 | 0;
   HEAPF32[i20 >> 2] = d19;
   HEAPF32[i18 >> 2] = d13;
   STACKTOP = i21;
   return;
  }
 default:
  {}
 }
}

function _parse_object(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i16 = i17 + 32 | 0;
 i15 = i17 + 24 | 0;
 i14 = i17 + 16 | 0;
 i13 = i17 + 8 | 0;
 i12 = i17;
 i6 = i17 + 64 | 0;
 i7 = i17 + 60 | 0;
 i4 = i17 + 56 | 0;
 i8 = i17 + 52 | 0;
 i10 = i17 + 48 | 0;
 i9 = i17 + 44 | 0;
 i5 = i17 + 40 | 0;
 i11 = i17 + 36 | 0;
 HEAP32[i7 >> 2] = i3;
 HEAP32[i4 >> 2] = i2;
 HEAP32[i8 >> 2] = i1;
 HEAP32[i10 >> 2] = _json_object() | 0;
 if (!(HEAP32[i10 >> 2] | 0)) {
  HEAP32[i6 >> 2] = 0;
  i16 = HEAP32[i6 >> 2] | 0;
  STACKTOP = i17;
  return i16 | 0;
 }
 _lex_scan(HEAP32[i7 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
 if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 56 >> 2] | 0) == 125) {
  HEAP32[i6 >> 2] = HEAP32[i10 >> 2];
  i16 = HEAP32[i6 >> 2] | 0;
  STACKTOP = i17;
  return i16 | 0;
 }
 while (1) {
  if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 56 >> 2] | 0) != 256) {
   i1 = 6;
   break;
  }
  HEAP32[i9 >> 2] = _lex_steal_string(HEAP32[i7 >> 2] | 0, i5) | 0;
  if (!(HEAP32[i9 >> 2] | 0)) {
   i1 = 8;
   break;
  }
  if (_memchr(HEAP32[i9 >> 2] | 0, 0, HEAP32[i5 >> 2] | 0) | 0) {
   i1 = 10;
   break;
  }
  if (HEAP32[i4 >> 2] & 1 | 0 ? _json_object_get(HEAP32[i10 >> 2] | 0, HEAP32[i9 >> 2] | 0) | 0 : 0) {
   i1 = 13;
   break;
  }
  _lex_scan(HEAP32[i7 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 56 >> 2] | 0) != 58) {
   i1 = 15;
   break;
  }
  _lex_scan(HEAP32[i7 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  HEAP32[i11 >> 2] = _parse_value(HEAP32[i7 >> 2] | 0, HEAP32[i4 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  if (!(HEAP32[i11 >> 2] | 0)) {
   i1 = 17;
   break;
  }
  if (_json_object_set_nocheck(HEAP32[i10 >> 2] | 0, HEAP32[i9 >> 2] | 0, HEAP32[i11 >> 2] | 0) | 0) {
   i1 = 19;
   break;
  }
  _json_decref(HEAP32[i11 >> 2] | 0);
  _jsonp_free(HEAP32[i9 >> 2] | 0);
  _lex_scan(HEAP32[i7 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
  i2 = HEAP32[i7 >> 2] | 0;
  if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 56 >> 2] | 0) != 44) {
   i1 = 22;
   break;
  }
  _lex_scan(i2, HEAP32[i8 >> 2] | 0) | 0;
 }
 do if ((i1 | 0) == 6) _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0, gb + 41186 | 0, i12); else if ((i1 | 0) == 8) {
  HEAP32[i6 >> 2] = 0;
  i16 = HEAP32[i6 >> 2] | 0;
  STACKTOP = i17;
  return i16 | 0;
 } else if ((i1 | 0) == 10) {
  _jsonp_free(HEAP32[i9 >> 2] | 0);
  _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0, gb + 41209 | 0, i13);
 } else if ((i1 | 0) == 13) {
  _jsonp_free(HEAP32[i9 >> 2] | 0);
  _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0, gb + 41246 | 0, i14);
 } else if ((i1 | 0) == 15) {
  _jsonp_free(HEAP32[i9 >> 2] | 0);
  _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0, gb + 41267 | 0, i15);
 } else if ((i1 | 0) == 17) _jsonp_free(HEAP32[i9 >> 2] | 0); else if ((i1 | 0) == 19) {
  _jsonp_free(HEAP32[i9 >> 2] | 0);
  _json_decref(HEAP32[i11 >> 2] | 0);
 } else if ((i1 | 0) == 22) {
  if ((HEAP32[i2 + 56 >> 2] | 0) != 125) {
   _error_set(HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0, gb + 41280 | 0, i16);
   break;
  }
  HEAP32[i6 >> 2] = HEAP32[i10 >> 2];
  i16 = HEAP32[i6 >> 2] | 0;
  STACKTOP = i17;
  return i16 | 0;
 } while (0);
 _json_decref(HEAP32[i10 >> 2] | 0);
 HEAP32[i6 >> 2] = 0;
 i16 = HEAP32[i6 >> 2] | 0;
 STACKTOP = i17;
 return i16 | 0;
}

function _iirfilt_crcf_execute(i8, i1, i9) {
 i8 = i8 | 0;
 i1 = i1 | 0;
 i9 = i9 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, d15 = 0.0, d16 = 0.0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i7 = HEAP32[i1 >> 2] | 0;
 i6 = HEAP32[i1 + 4 >> 2] | 0;
 if (HEAP32[i8 + 24 >> 2] | 0) {
  i5 = i8 + 32 | 0;
  if (!(HEAP32[i5 >> 2] | 0)) {
   i4 = 0;
   i1 = 0;
  } else {
   d3 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
   i1 = i8 + 28 | 0;
   i4 = 0;
   d2 = (HEAP32[tempDoublePtr >> 2] = i7, +HEAPF32[tempDoublePtr >> 2]);
   do {
    i8 = HEAP32[(HEAP32[i1 >> 2] | 0) + (i4 << 2) >> 2] | 0;
    i21 = i8 + 80 | 0;
    i18 = HEAP32[i21 >> 2] | 0;
    i20 = i8 + 84 | 0;
    i17 = HEAP32[i20 >> 2] | 0;
    HEAP32[i8 + 88 >> 2] = i18;
    HEAP32[i8 + 92 >> 2] = i17;
    i6 = i8 + 72 | 0;
    i19 = HEAP32[i6 >> 2] | 0;
    i7 = i8 + 76 | 0;
    d12 = +HEAPF32[i7 >> 2];
    HEAP32[i21 >> 2] = i19;
    HEAPF32[i20 >> 2] = d12;
    d13 = +HEAPF32[i8 + 16 >> 2];
    d16 = (HEAP32[tempDoublePtr >> 2] = i19, +HEAPF32[tempDoublePtr >> 2]);
    d14 = +HEAPF32[i8 + 20 >> 2];
    d15 = (HEAP32[tempDoublePtr >> 2] = i18, +HEAPF32[tempDoublePtr >> 2]);
    d10 = (HEAP32[tempDoublePtr >> 2] = i17, +HEAPF32[tempDoublePtr >> 2]);
    d2 = d2 - d16 * d13 - d15 * d14;
    d14 = d3 - d12 * d13 - d10 * d14;
    HEAPF32[i6 >> 2] = d2;
    HEAPF32[i7 >> 2] = d14;
    d13 = +HEAPF32[i8 >> 2];
    d11 = +HEAPF32[i8 + 4 >> 2];
    d3 = +HEAPF32[i8 + 8 >> 2];
    d2 = d2 * d13 + d16 * d11 + d15 * d3;
    d3 = d14 * d13 + d12 * d11 + d10 * d3;
    i4 = i4 + 1 | 0;
   } while (i4 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
   i4 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
   i1 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
  }
  HEAP32[i9 >> 2] = i4;
  HEAP32[i9 + 4 >> 2] = i1;
  return;
 }
 i1 = HEAP32[i8 + 12 >> 2] | 0;
 i4 = i1 + -1 | 0;
 if (i4 | 0) {
  i5 = i8 + 8 | 0;
  while (1) {
   i20 = i1 + -2 | 0;
   i1 = HEAP32[i5 >> 2] | 0;
   i21 = HEAP32[i1 + (i20 << 3) + 4 >> 2] | 0;
   HEAP32[i1 + (i4 << 3) >> 2] = HEAP32[i1 + (i20 << 3) >> 2];
   HEAP32[i1 + (i4 << 3) + 4 >> 2] = i21;
   i1 = i4 + -1 | 0;
   if (!i1) break; else {
    i21 = i4;
    i4 = i1;
    i1 = i21;
   }
  }
 }
 d3 = (HEAP32[tempDoublePtr >> 2] = i7, +HEAPF32[tempDoublePtr >> 2]);
 d2 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 i5 = HEAP32[i8 + 20 >> 2] | 0;
 if (i5 >>> 0 > 1) {
  i6 = HEAP32[i8 + 4 >> 2] | 0;
  i4 = i8 + 8 | 0;
  i1 = HEAP32[i4 >> 2] | 0;
  i7 = 1;
  do {
   d16 = +HEAPF32[i6 + (i7 << 2) >> 2];
   d3 = d3 - d16 * +HEAPF32[i1 + (i7 << 3) >> 2];
   d2 = d2 - d16 * +HEAPF32[i1 + (i7 << 3) + 4 >> 2];
   i7 = i7 + 1 | 0;
  } while ((i7 | 0) != (i5 | 0));
 } else {
  i1 = i8 + 8 | 0;
  i4 = i1;
  i1 = HEAP32[i1 >> 2] | 0;
 }
 HEAPF32[i1 >> 2] = d3;
 HEAPF32[i1 + 4 >> 2] = d2;
 i6 = HEAP32[i8 + 16 >> 2] | 0;
 if (!i6) {
  d3 = 0.0;
  d2 = 0.0;
 } else {
  i5 = HEAP32[i8 >> 2] | 0;
  i1 = HEAP32[i4 >> 2] | 0;
  i4 = 0;
  d3 = 0.0;
  d2 = 0.0;
  do {
   d16 = +HEAPF32[i5 + (i4 << 2) >> 2];
   d3 = d3 + d16 * +HEAPF32[i1 + (i4 << 3) >> 2];
   d2 = d2 + d16 * +HEAPF32[i1 + (i4 << 3) + 4 >> 2];
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i6 | 0));
 }
 HEAPF32[i9 >> 2] = d3;
 HEAPF32[i9 + 4 >> 2] = d2;
 return;
}

function _liquid_cplxpair_cleanup(i19, i18, i17) {
 i19 = i19 | 0;
 i18 = i18 | 0;
 i17 = i17 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i20 = 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i1 = i20 + 32 | 0;
 i2 = i20 + 24 | 0;
 i3 = i20 + 16 | 0;
 i8 = i20 + 8 | 0;
 i9 = i20;
 i10 = (i17 | 0) == 0;
 if (!i10) {
  i11 = i9 + 4 | 0;
  i12 = i8 + 4 | 0;
  i13 = i3 + 4 | 0;
  i14 = i2 + 4 | 0;
  i16 = 0;
  do {
   i15 = i16 << 1;
   i5 = i19 + (i15 << 3) | 0;
   i7 = i19 + (i15 << 3) + 4 | 0;
   d6 = +HEAPF32[i7 >> 2];
   d4 = +HEAPF32[i5 >> 2];
   if (!(d6 < 0.0)) {
    HEAPF32[i3 >> 2] = d4;
    HEAPF32[i13 >> 2] = d6;
    HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
    _conjf(i2, i1);
    d4 = +HEAPF32[i2 >> 2];
    d6 = +HEAPF32[i14 >> 2];
   }
   HEAPF32[i5 >> 2] = d4;
   HEAPF32[i7 >> 2] = d6;
   HEAPF32[i9 >> 2] = d4;
   HEAPF32[i11 >> 2] = d6;
   HEAP32[i1 >> 2] = HEAP32[i9 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
   _conjf(i8, i1);
   i7 = HEAP32[i12 >> 2] | 0;
   i15 = i15 | 1;
   HEAP32[i19 + (i15 << 3) >> 2] = HEAP32[i8 >> 2];
   HEAP32[i19 + (i15 << 3) + 4 >> 2] = i7;
   i16 = i16 + 1 | 0;
  } while ((i16 | 0) != (i17 | 0));
  if (!i10) {
   i10 = i17 + -1 | 0;
   i8 = 0;
   do {
    if (i10 >>> 0 > i8 >>> 0) {
     i1 = i17;
     i9 = i10;
     while (1) {
      i1 = i1 << 1;
      i2 = i1 + -4 | 0;
      i3 = i19 + (i2 << 3) | 0;
      d4 = +HEAPF32[i3 >> 2];
      i5 = i9 << 1;
      i7 = i19 + (i5 << 3) | 0;
      d6 = +HEAPF32[i7 >> 2];
      if (d4 > d6) {
       i15 = i19 + (i2 << 3) + 4 | 0;
       i13 = HEAP32[i15 >> 2] | 0;
       i12 = i19 + (i5 << 3) + 4 | 0;
       i16 = HEAP32[i12 >> 2] | 0;
       HEAPF32[i3 >> 2] = d6;
       HEAP32[i15 >> 2] = i16;
       HEAPF32[i7 >> 2] = d4;
       HEAP32[i12 >> 2] = i13;
       i12 = i1 + -3 | 0;
       i7 = i19 + (i12 << 3) | 0;
       i13 = HEAP32[i7 >> 2] | 0;
       i12 = i19 + (i12 << 3) + 4 | 0;
       i15 = HEAP32[i12 >> 2] | 0;
       i16 = i5 | 1;
       i14 = i19 + (i16 << 3) | 0;
       i16 = i19 + (i16 << 3) + 4 | 0;
       i11 = HEAP32[i16 >> 2] | 0;
       HEAP32[i7 >> 2] = HEAP32[i14 >> 2];
       HEAP32[i12 >> 2] = i11;
       HEAP32[i14 >> 2] = i13;
       HEAP32[i16 >> 2] = i15;
      }
      i1 = i9 + -1 | 0;
      if (i1 >>> 0 > i8 >>> 0) {
       i16 = i9;
       i9 = i1;
       i1 = i16;
      } else break;
     }
    }
    i8 = i8 + 1 | 0;
   } while ((i8 | 0) != (i17 | 0));
  }
 }
 i1 = i17 << 1;
 if (i1 >>> 0 >= i18 >>> 0) {
  STACKTOP = i20;
  return;
 }
 i8 = i18 + -1 | 0;
 do {
  if (i8 >>> 0 > i1 >>> 0) {
   i2 = i18;
   i7 = i8;
   while (1) {
    i2 = i2 + -2 | 0;
    i3 = i19 + (i2 << 3) | 0;
    d4 = +HEAPF32[i3 >> 2];
    i5 = i19 + (i7 << 3) | 0;
    d6 = +HEAPF32[i5 >> 2];
    if (d4 > d6) {
     i15 = i19 + (i2 << 3) + 4 | 0;
     i16 = HEAP32[i15 >> 2] | 0;
     i17 = i19 + (i7 << 3) + 4 | 0;
     i14 = HEAP32[i17 >> 2] | 0;
     HEAPF32[i3 >> 2] = d6;
     HEAP32[i15 >> 2] = i14;
     HEAPF32[i5 >> 2] = d4;
     HEAP32[i17 >> 2] = i16;
    }
    i2 = i7 + -1 | 0;
    if (i2 >>> 0 > i1 >>> 0) {
     i17 = i7;
     i7 = i2;
     i2 = i17;
    } else break;
   }
  }
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i18 | 0));
 STACKTOP = i20;
 return;
}

function runPostSets2() {
 HEAP32[gb + 1664 >> 2] = (HEAP32[gb + 1664 >> 2] | 0) + (gb + 1636 | 0);
 HEAP32[gb + 1668 >> 2] = (HEAP32[gb + 1668 >> 2] | 0) + (gb + 1644 | 0);
 HEAP32[gb + 1672 >> 2] = (HEAP32[gb + 1672 >> 2] | 0) + (gb + 44176 | 0);
 HEAP32[gb + 1676 >> 2] = (HEAP32[gb + 1676 >> 2] | 0) + (gb + 1652 | 0);
 HEAP32[gb + 1680 >> 2] = (HEAP32[gb + 1680 >> 2] | 0) + (gb + 34204 | 0);
 HEAP32[gb + 1724 >> 2] = (HEAP32[gb + 1724 >> 2] | 0) + (gb + 1684 | 0);
 HEAP32[gb + 1728 >> 2] = (HEAP32[gb + 1728 >> 2] | 0) + (gb + 1696 | 0);
 HEAP32[gb + 1732 >> 2] = (HEAP32[gb + 1732 >> 2] | 0) + (gb + 44184 | 0);
 HEAP32[gb + 1736 >> 2] = (HEAP32[gb + 1736 >> 2] | 0) + (gb + 1708 | 0);
 HEAP32[gb + 1740 >> 2] = (HEAP32[gb + 1740 >> 2] | 0) + (gb + 34220 | 0);
 HEAP32[gb + 1796 >> 2] = (HEAP32[gb + 1796 >> 2] | 0) + (gb + 1744 | 0);
 HEAP32[gb + 1800 >> 2] = (HEAP32[gb + 1800 >> 2] | 0) + (gb + 1760 | 0);
 HEAP32[gb + 1804 >> 2] = (HEAP32[gb + 1804 >> 2] | 0) + (gb + 44196 | 0);
 HEAP32[gb + 1808 >> 2] = (HEAP32[gb + 1808 >> 2] | 0) + (gb + 1776 | 0);
 HEAP32[gb + 1812 >> 2] = (HEAP32[gb + 1812 >> 2] | 0) + (gb + 34252 | 0);
 HEAP32[gb + 1880 >> 2] = (HEAP32[gb + 1880 >> 2] | 0) + (gb + 1816 | 0);
 HEAP32[gb + 1884 >> 2] = (HEAP32[gb + 1884 >> 2] | 0) + (gb + 1836 | 0);
 HEAP32[gb + 1888 >> 2] = (HEAP32[gb + 1888 >> 2] | 0) + (gb + 44212 | 0);
 HEAP32[gb + 1892 >> 2] = (HEAP32[gb + 1892 >> 2] | 0) + (gb + 1856 | 0);
 HEAP32[gb + 1896 >> 2] = (HEAP32[gb + 1896 >> 2] | 0) + (gb + 34316 | 0);
 HEAP32[gb + 1988 >> 2] = (HEAP32[gb + 1988 >> 2] | 0) + (gb + 1900 | 0);
 HEAP32[gb + 1992 >> 2] = (HEAP32[gb + 1992 >> 2] | 0) + (gb + 1928 | 0);
 HEAP32[gb + 1996 >> 2] = (HEAP32[gb + 1996 >> 2] | 0) + (gb + 44232 | 0);
 HEAP32[gb + 2e3 >> 2] = (HEAP32[gb + 2e3 >> 2] | 0) + (gb + 1956 | 0);
 HEAP32[gb + 2004 >> 2] = (HEAP32[gb + 2004 >> 2] | 0) + (gb + 34444 | 0);
 HEAP32[gb + 8776 >> 2] = fb + 1;
 HEAP32[gb + 8780 >> 2] = fb + 1;
 HEAP32[gb + 8808 >> 2] = (HEAP32[gb + 8808 >> 2] | 0) + (gb + 8812 | 0);
 HEAP32[gb + 8824 >> 2] = fb + 2;
 HEAP32[gb + 8848 >> 2] = fb + 1;
 HEAP32[gb + 8852 >> 2] = fb + 2;
 HEAP32[gb + 8856 >> 2] = (HEAP32[gb + 8856 >> 2] | 0) + (gb + 44849 | 0);
 HEAP32[gb + 8924 >> 2] = (HEAP32[gb + 8924 >> 2] | 0) + (gb + 8928 | 0);
 HEAP32[gb + 8940 >> 2] = fb + 2;
 HEAP32[gb + 8964 >> 2] = fb + 3;
 HEAP32[gb + 8968 >> 2] = fb + 2;
 HEAP32[gb + 8972 >> 2] = (HEAP32[gb + 8972 >> 2] | 0) + (gb + 44857 | 0);
 HEAP32[gb + 9040 >> 2] = (HEAP32[gb + 9040 >> 2] | 0) + (gb + 8928 | 0);
 HEAP32[gb + 9080 >> 2] = fb + 4;
 HEAP32[gb + 9188 >> 2] = (HEAP32[gb + 9188 >> 2] | 0) + (gb + 44141 | 0);
 HEAP32[gb + 9192 >> 2] = (HEAP32[gb + 9192 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9196 >> 2] = (HEAP32[gb + 9196 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9200 >> 2] = (HEAP32[gb + 9200 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9204 >> 2] = (HEAP32[gb + 9204 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9208 >> 2] = (HEAP32[gb + 9208 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9212 >> 2] = (HEAP32[gb + 9212 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9216 >> 2] = (HEAP32[gb + 9216 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9220 >> 2] = (HEAP32[gb + 9220 >> 2] | 0) + (gb + 45889 | 0);
 HEAP32[gb + 9224 >> 2] = (HEAP32[gb + 9224 >> 2] | 0) + (gb + 45889 | 0);
}

function _fft_execute_dft_3(i24) {
 i24 = i24 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0, d14 = 0.0, d15 = 0.0, d16 = 0.0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i25 = 0, i26 = 0;
 i25 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i17 = i25 + 64 | 0;
 i3 = i25 + 56 | 0;
 i11 = i25 + 48 | 0;
 i10 = i25 + 40 | 0;
 i13 = i25 + 32 | 0;
 i19 = i25 + 24 | 0;
 i18 = i25 + 16 | 0;
 i20 = i25 + 8 | 0;
 i22 = i25;
 i21 = i24 + 4 | 0;
 i26 = HEAP32[i21 >> 2] | 0;
 d14 = +HEAPF32[i26 + 4 >> 2] + +HEAPF32[i26 + 12 >> 2] + +HEAPF32[i26 + 20 >> 2];
 i23 = i24 + 8 | 0;
 i2 = HEAP32[i23 >> 2] | 0;
 HEAPF32[i2 >> 2] = +HEAPF32[i26 >> 2] + +HEAPF32[i26 + 8 >> 2] + +HEAPF32[i26 + 16 >> 2];
 HEAPF32[i2 + 4 >> 2] = d14;
 i2 = HEAP32[i21 >> 2] | 0;
 d14 = +HEAPF32[i2 >> 2];
 d15 = +HEAPF32[i2 + 4 >> 2];
 d1 = +HEAPF32[i2 + 8 >> 2];
 d4 = +HEAPF32[i2 + 12 >> 2];
 d5 = d4 * .8660253882408142 - d1 * .5;
 d6 = d4 * -.5 - d1 * .8660253882408142;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i3, d1, d4, -.5, -.8660253882408142);
  d5 = +HEAPF32[i3 >> 2];
  d12 = +HEAPF32[i3 + 4 >> 2];
  i2 = HEAP32[i21 >> 2] | 0;
 } else d12 = d6;
 d9 = +HEAPF32[i2 + 16 >> 2];
 d8 = +HEAPF32[i2 + 20 >> 2];
 HEAPF32[i10 >> 2] = -.5;
 HEAPF32[i10 + 4 >> 2] = -.8660253882408142;
 HEAP32[i17 >> 2] = HEAP32[i10 >> 2];
 HEAP32[i17 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
 _conjf(i11, i17);
 d7 = +HEAPF32[i11 >> 2];
 d6 = +HEAPF32[i11 + 4 >> 2];
 d4 = d9 * d7 - d8 * d6;
 d1 = d8 * d7 + d9 * d6;
 if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i13, d9, d8, d7, d6);
  d4 = +HEAPF32[i13 >> 2];
  d1 = +HEAPF32[i13 + 4 >> 2];
 }
 d16 = d14 + d5 + d4;
 d14 = d15 + d12 + d1;
 i26 = HEAP32[i21 >> 2] | 0;
 d9 = +HEAPF32[i26 >> 2];
 d12 = +HEAPF32[i26 + 4 >> 2];
 d7 = +HEAPF32[i26 + 8 >> 2];
 d8 = +HEAPF32[i26 + 12 >> 2];
 HEAPF32[i18 >> 2] = -.5;
 HEAPF32[i18 + 4 >> 2] = -.8660253882408142;
 HEAP32[i17 >> 2] = HEAP32[i18 >> 2];
 HEAP32[i17 + 4 >> 2] = HEAP32[i18 + 4 >> 2];
 _conjf(i19, i17);
 d5 = +HEAPF32[i19 >> 2];
 d1 = +HEAPF32[i19 + 4 >> 2];
 d6 = d7 * d5 - d8 * d1;
 d4 = d8 * d5 + d7 * d1;
 if ((d6 != d6 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i20, d7, d8, d5, d1);
  d8 = +HEAPF32[i20 + 4 >> 2];
  d7 = +HEAPF32[i20 >> 2];
 } else {
  d8 = d4;
  d7 = d6;
 }
 i26 = HEAP32[i21 >> 2] | 0;
 d5 = +HEAPF32[i26 + 16 >> 2];
 d6 = +HEAPF32[i26 + 20 >> 2];
 d4 = d6 * .8660253882408142 - d5 * .5;
 d1 = d6 * -.5 - d5 * .8660253882408142;
 if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i22, d5, d6, -.5, -.8660253882408142);
  d4 = +HEAPF32[i22 >> 2];
  d1 = +HEAPF32[i22 + 4 >> 2];
 }
 d4 = d9 + d7 + d4;
 d1 = d12 + d8 + d1;
 i3 = HEAP32[i23 >> 2] | 0;
 i2 = i3 + 8 | 0;
 i3 = i3 + 12 | 0;
 if ((HEAP32[i24 + 12 >> 2] | 0) == 1) {
  HEAPF32[i2 >> 2] = d16;
  HEAPF32[i3 >> 2] = d14;
  i26 = HEAP32[i23 >> 2] | 0;
  HEAPF32[i26 + 16 >> 2] = d4;
  HEAPF32[i26 + 20 >> 2] = d1;
  STACKTOP = i25;
  return;
 } else {
  HEAPF32[i2 >> 2] = d4;
  HEAPF32[i3 >> 2] = d1;
  i26 = HEAP32[i23 >> 2] | 0;
  HEAPF32[i26 + 16 >> 2] = d16;
  HEAPF32[i26 + 20 >> 2] = d14;
  STACKTOP = i25;
  return;
 }
}

function _fft_execute_radix2(i21) {
 i21 = i21 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i22 = 0, i23 = 0, i24 = 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i20 = i22;
 i2 = HEAP32[i21 >> 2] & -4;
 if (!i2) i1 = i21 + 8 | 0; else {
  i3 = i21 + 44 | 0;
  i4 = i21 + 4 | 0;
  i1 = i21 + 8 | 0;
  i5 = 0;
  do {
   i16 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0;
   i18 = HEAP32[i4 >> 2] | 0;
   i15 = HEAP32[i18 + (i16 << 3) + 4 >> 2] | 0;
   i19 = HEAP32[i1 >> 2] | 0;
   HEAP32[i19 + (i5 << 3) >> 2] = HEAP32[i18 + (i16 << 3) >> 2];
   HEAP32[i19 + (i5 << 3) + 4 >> 2] = i15;
   i19 = i5 | 1;
   i15 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i19 << 2) >> 2] | 0;
   i16 = HEAP32[i4 >> 2] | 0;
   i18 = HEAP32[i16 + (i15 << 3) + 4 >> 2] | 0;
   i17 = HEAP32[i1 >> 2] | 0;
   HEAP32[i17 + (i19 << 3) >> 2] = HEAP32[i16 + (i15 << 3) >> 2];
   HEAP32[i17 + (i19 << 3) + 4 >> 2] = i18;
   i19 = i5 | 2;
   i17 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i19 << 2) >> 2] | 0;
   i18 = HEAP32[i4 >> 2] | 0;
   i15 = HEAP32[i18 + (i17 << 3) + 4 >> 2] | 0;
   i16 = HEAP32[i1 >> 2] | 0;
   HEAP32[i16 + (i19 << 3) >> 2] = HEAP32[i18 + (i17 << 3) >> 2];
   HEAP32[i16 + (i19 << 3) + 4 >> 2] = i15;
   i19 = i5 | 3;
   i16 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i19 << 2) >> 2] | 0;
   i15 = HEAP32[i4 >> 2] | 0;
   i17 = HEAP32[i15 + (i16 << 3) + 4 >> 2] | 0;
   i18 = HEAP32[i1 >> 2] | 0;
   HEAP32[i18 + (i19 << 3) >> 2] = HEAP32[i15 + (i16 << 3) >> 2];
   HEAP32[i18 + (i19 << 3) + 4 >> 2] = i17;
   i5 = i5 + 4 | 0;
  } while (i5 >>> 0 < i2 >>> 0);
 }
 i16 = HEAP32[i1 >> 2] | 0;
 i17 = i21 + 40 | 0;
 i1 = HEAP32[i17 >> 2] | 0;
 if (!i1) {
  STACKTOP = i22;
  return;
 }
 i15 = HEAP32[i21 >> 2] | 0;
 i18 = i21 + 48 | 0;
 i19 = i20 + 4 | 0;
 i2 = i15;
 i13 = 0;
 i14 = 1;
 do {
  i12 = i14;
  i14 = i14 << 1;
  i15 = i15 >>> 1;
  if (i12) {
   i4 = 0;
   i5 = 0;
   do {
    i3 = HEAP32[i18 >> 2] | 0;
    d10 = +HEAPF32[i3 + (i5 << 3) >> 2];
    d11 = +HEAPF32[i3 + (i5 << 3) + 4 >> 2];
    i5 = ((i5 + i15 | 0) >>> 0) % (i2 >>> 0) | 0;
    if (i4 >>> 0 < i2 >>> 0) {
     i3 = i4;
     do {
      i2 = i3 + i12 | 0;
      i1 = i16 + (i2 << 3) | 0;
      d8 = +HEAPF32[i1 >> 2];
      i2 = i16 + (i2 << 3) + 4 | 0;
      d9 = +HEAPF32[i2 >> 2];
      d7 = d10 * d8 - d11 * d9;
      d6 = d11 * d8 + d10 * d9;
      if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
       ___mulsc3(i20, d8, d9, d10, d11);
       d7 = +HEAPF32[i20 >> 2];
       d6 = +HEAPF32[i19 >> 2];
      }
      i24 = i16 + (i3 << 3) | 0;
      i23 = i16 + (i3 << 3) + 4 | 0;
      d9 = +HEAPF32[i23 >> 2] - d6;
      HEAPF32[i1 >> 2] = +HEAPF32[i24 >> 2] - d7;
      HEAPF32[i2 >> 2] = d9;
      d9 = d6 + +HEAPF32[i23 >> 2];
      HEAPF32[i24 >> 2] = d7 + +HEAPF32[i24 >> 2];
      HEAPF32[i23 >> 2] = d9;
      i3 = i3 + i14 | 0;
      i2 = HEAP32[i21 >> 2] | 0;
     } while (i3 >>> 0 < i2 >>> 0);
    }
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != (i12 | 0));
   i1 = HEAP32[i17 >> 2] | 0;
  }
  i13 = i13 + 1 | 0;
 } while (i13 >>> 0 < i1 >>> 0);
 STACKTOP = i22;
 return;
}

function _gmskframesync_create(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 i14 = STACKTOP;
 i13 = _malloc(256) | 0;
 HEAP32[i13 + 16 >> 2] = i1;
 HEAP32[i13 + 20 >> 2] = i2;
 i10 = i13 + 4 | 0;
 HEAP32[i10 >> 2] = 2;
 i11 = i13 + 8 | 0;
 HEAP32[i11 >> 2] = 3;
 i12 = i13 + 12 | 0;
 HEAPF32[i12 >> 2] = .5;
 HEAP32[i13 >> 2] = _iirfilt_crcf_create_lowpass(3, .375) | 0;
 i9 = i13 + 132 | 0;
 HEAP32[i9 >> 2] = 63;
 i5 = i13 + 136 | 0;
 HEAP32[i5 >> 2] = _malloc(252) | 0;
 HEAP32[i13 + 140 >> 2] = _malloc(252) | 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[i10 >> 2] | 0) * 63 << 3) | 0) + 15 & -16) | 0;
 i1 = _msequence_create(6, 109, 1) | 0;
 i2 = _gmskmod_create(HEAP32[i10 >> 2] | 0, HEAP32[i11 >> 2] | 0, +HEAPF32[i12 >> 2]) | 0;
 if ((HEAP32[i11 >> 2] | 0) != (0 - (HEAP32[i9 >> 2] | 0) | 0)) {
  i6 = 0;
  do {
   i3 = _msequence_advance(i1) | 0;
   i3 = i3 & 255;
   if (i6 >>> 0 < (HEAP32[i9 >> 2] | 0) >>> 0) HEAPF32[(HEAP32[i5 >> 2] | 0) + (i6 << 2) >> 2] = i3 | 0 ? 1.0 : -1.0;
   i4 = HEAP32[i11 >> 2] | 0;
   if (i6 >>> 0 < i4 >>> 0) _gmskmod_modulate(i2, i3, i7); else _gmskmod_modulate(i2, i3, i7 + ((Math_imul(HEAP32[i10 >> 2] | 0, i6 - i4 | 0) | 0) << 3) | 0);
   i6 = i6 + 1 | 0;
  } while (i6 >>> 0 < ((HEAP32[i11 >> 2] | 0) + (HEAP32[i9 >> 2] | 0) | 0) >>> 0);
 }
 _gmskmod_destroy(i2);
 _msequence_destroy(i1);
 i8 = i13 + 108 | 0;
 HEAP32[i8 >> 2] = _detector_cccf_create(i7, Math_imul(HEAP32[i10 >> 2] | 0, HEAP32[i9 >> 2] | 0) | 0, .5, .05000000074505806) | 0;
 i6 = i13 + 124 | 0;
 HEAP32[i6 >> 2] = _windowcf_create(Math_imul((HEAP32[i11 >> 2] | 0) + (HEAP32[i9 >> 2] | 0) | 0, HEAP32[i10 >> 2] | 0) | 0) | 0;
 i1 = i13 + 84 | 0;
 HEAP32[i1 >> 2] = 32;
 i4 = i13 + 76 | 0;
 HEAP32[i4 >> 2] = _firpfb_rrrf_create_rnyquist(12, 32, HEAP32[i10 >> 2] | 0, HEAP32[i11 >> 2] | 0, +HEAPF32[i12 >> 2]) | 0;
 i5 = i13 + 80 | 0;
 HEAP32[i5 >> 2] = _firpfb_rrrf_create_drnyquist(12, HEAP32[i1 >> 2] | 0, HEAP32[i10 >> 2] | 0, HEAP32[i11 >> 2] | 0, +HEAPF32[i12 >> 2]) | 0;
 i1 = i13 + 128 | 0;
 HEAP32[i1 >> 2] = _nco_crcf_create(0) | 0;
 i3 = i13 + 156 | 0;
 HEAP32[i3 >> 2] = 0;
 HEAP32[i3 + 4 >> 2] = 0;
 HEAP32[i3 + 8 >> 2] = 0;
 HEAP32[i3 + 12 >> 2] = 0;
 _gmskframesync_set_header_len(i13, 8);
 i3 = i13 + 196 | 0;
 HEAP32[i3 >> 2] = 1;
 HEAP32[i13 + 180 >> 2] = 6;
 HEAP32[i13 + 184 >> 2] = 1;
 HEAP32[i13 + 188 >> 2] = 1;
 i2 = _packetizer_create(1, 6, 1, 1) | 0;
 HEAP32[i13 + 208 >> 2] = i2;
 i2 = _packetizer_get_enc_msg_len(i2) | 0;
 HEAP32[i13 + 192 >> 2] = i2;
 HEAP32[i13 + 204 >> 2] = _malloc(HEAP32[i3 >> 2] | 0) | 0;
 HEAP32[i13 + 200 >> 2] = _malloc(i2) | 0;
 i2 = i13 + 216 | 0;
 i3 = i2 + 40 | 0;
 do {
  HEAP32[i2 >> 2] = 0;
  i2 = i2 + 4 | 0;
 } while ((i2 | 0) < (i3 | 0));
 _windowcf_clear(HEAP32[i6 >> 2] | 0);
 _detector_cccf_reset(HEAP32[i8 >> 2] | 0);
 _nco_crcf_reset(HEAP32[i1 >> 2] | 0);
 HEAPF32[i13 + 64 >> 2] = 0.0;
 HEAPF32[i13 + 68 >> 2] = 0.0;
 HEAPF32[i13 + 72 >> 2] = 0.0;
 _firpfb_rrrf_reset(HEAP32[i4 >> 2] | 0);
 _firpfb_rrrf_reset(HEAP32[i5 >> 2] | 0);
 HEAPF32[i13 + 88 >> 2] = 0.0;
 STACKTOP = i14;
 return i13 | 0;
}

function _fft_execute_rader2(i18) {
 i18 = i18 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i11 = i19;
 i16 = HEAP32[i18 + 52 >> 2] | 0;
 i12 = HEAP32[i18 + 56 >> 2] | 0;
 i13 = HEAP32[i18 + 48 >> 2] | 0;
 i17 = HEAP32[i18 + 44 >> 2] | 0;
 i14 = HEAP32[i18 + 40 >> 2] | 0;
 i6 = HEAP32[i17 + ((HEAP32[i18 >> 2] | 0) + -2 << 2) >> 2] | 0;
 i15 = i18 + 4 | 0;
 i4 = HEAP32[i15 >> 2] | 0;
 i1 = HEAP32[i4 + (i6 << 3) + 4 >> 2] | 0;
 HEAP32[i16 >> 2] = HEAP32[i4 + (i6 << 3) >> 2];
 HEAP32[i16 + 4 >> 2] = i1;
 i1 = HEAP32[i18 >> 2] | 0;
 i6 = i14 + 1 | 0;
 if ((i6 | 0) != (i1 | 0)) {
  i3 = 0;
  do {
   i3 = i3 + 1 | 0;
   HEAPF32[i16 + (i3 << 3) >> 2] = 0.0;
   HEAPF32[i16 + (i3 << 3) + 4 >> 2] = 0.0;
   i1 = HEAP32[i18 >> 2] | 0;
  } while (i3 >>> 0 < (i6 - i1 | 0) >>> 0);
 }
 i3 = i1 + -1 | 0;
 if (i3 >>> 0 > 1) {
  i4 = 1;
  do {
   i22 = HEAP32[i17 + (i3 + ~i4 << 2) >> 2] | 0;
   i23 = HEAP32[i15 >> 2] | 0;
   i21 = HEAP32[i23 + (i22 << 3) + 4 >> 2] | 0;
   i20 = i6 + i4 - i1 | 0;
   HEAP32[i16 + (i20 << 3) >> 2] = HEAP32[i23 + (i22 << 3) >> 2];
   HEAP32[i16 + (i20 << 3) + 4 >> 2] = i21;
   i4 = i4 + 1 | 0;
   i1 = HEAP32[i18 >> 2] | 0;
   i3 = i1 + -1 | 0;
  } while (i3 >>> 0 > i4 >>> 0);
 }
 i23 = HEAP32[i18 + 60 >> 2] | 0;
 mftCall_vi(HEAP32[i23 + 28 >> 2] | 0, i23 | 0);
 if (i14 | 0) {
  i1 = i11 + 4 | 0;
  i6 = 0;
  do {
   d7 = +HEAPF32[i13 + (i6 << 3) >> 2];
   d8 = +HEAPF32[i13 + (i6 << 3) + 4 >> 2];
   i3 = i12 + (i6 << 3) | 0;
   d9 = +HEAPF32[i3 >> 2];
   i4 = i12 + (i6 << 3) + 4 | 0;
   d10 = +HEAPF32[i4 >> 2];
   d5 = d7 * d9 - d8 * d10;
   d2 = d8 * d9 + d7 * d10;
   if ((d5 != d5 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i11, d9, d10, d7, d8);
    d5 = +HEAPF32[i11 >> 2];
    d2 = +HEAPF32[i1 >> 2];
   }
   HEAPF32[i3 >> 2] = d5;
   HEAPF32[i4 >> 2] = d2;
   i6 = i6 + 1 | 0;
  } while ((i6 | 0) != (i14 | 0));
 }
 i4 = HEAP32[i18 + 64 >> 2] | 0;
 mftCall_vi(HEAP32[i4 + 28 >> 2] | 0, i4 | 0);
 i4 = i18 + 8 | 0;
 i23 = HEAP32[i4 >> 2] | 0;
 HEAPF32[i23 >> 2] = 0.0;
 HEAPF32[i23 + 4 >> 2] = 0.0;
 if (HEAP32[i18 >> 2] | 0) {
  i3 = 0;
  do {
   i22 = HEAP32[i15 >> 2] | 0;
   i23 = HEAP32[i4 >> 2] | 0;
   i1 = i23 + 4 | 0;
   d10 = +HEAPF32[i22 + (i3 << 3) + 4 >> 2] + +HEAPF32[i1 >> 2];
   HEAPF32[i23 >> 2] = +HEAPF32[i22 + (i3 << 3) >> 2] + +HEAPF32[i23 >> 2];
   HEAPF32[i1 >> 2] = d10;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i18 >> 2] | 0;
  } while (i3 >>> 0 < i1 >>> 0);
  if ((i1 | 0) == 1) {
   STACKTOP = i19;
   return;
  }
 }
 d2 = +(i14 >>> 0);
 i1 = 0;
 do {
  i23 = HEAP32[i17 + (i1 << 2) >> 2] | 0;
  i21 = HEAP32[i15 >> 2] | 0;
  d10 = +HEAPF32[i16 + (i1 << 3) + 4 >> 2] / d2 + +HEAPF32[i21 + 4 >> 2];
  i22 = HEAP32[i4 >> 2] | 0;
  HEAPF32[i22 + (i23 << 3) >> 2] = +HEAPF32[i16 + (i1 << 3) >> 2] / d2 + +HEAPF32[i21 >> 2];
  HEAPF32[i22 + (i23 << 3) + 4 >> 2] = d10;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < ((HEAP32[i18 >> 2] | 0) + -1 | 0) >>> 0);
 STACKTOP = i19;
 return;
}

function _rkaiser_approximate_rho(i2, d5) {
 i2 = i2 | 0;
 d5 = +d5;
 var d1 = 0.0, d3 = 0.0, d4 = 0.0;
 if (!i2) {
  _fwrite(gb + 24193 | 0, 59, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d5 < 0.0 | d5 > 1.0) {
  _fwrite(gb + 24253 | 0, 56, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 do switch (i2 | 0) {
 case 1:
  {
   d1 = .7574973106384277;
   d3 = .061343029141426086;
   d4 = -.08729662746191025;
   break;
  }
 case 2:
  {
   d1 = .8115186095237732;
   d3 = .07437658309936523;
   d4 = -.01427088025957346;
   break;
  }
 case 3:
  {
   d1 = .8424953818321228;
   d3 = .07684185355901718;
   d4 = -.005368790123611689;
   break;
  }
 case 4:
  {
   d1 = .8614078164100647;
   d3 = .07144126296043396;
   d4 = -.005586519837379456;
   break;
  }
 case 5:
  {
   d1 = .8745774030685425;
   d3 = .0657869428396225;
   d4 = -.006504470016807318;
   break;
  }
 case 6:
  {
   d1 = .8843879699707031;
   d3 = .06074265018105507;
   d4 = -.007364050019532442;
   break;
  }
 case 7:
  {
   d1 = .8921661972999573;
   d3 = .05669236183166504;
   d4 = -.007912220433354378;
   break;
  }
 case 8:
  {
   d1 = .898749828338623;
   d3 = .0536169596016407;
   d4 = -.008153010159730911;
   break;
  }
 case 9:
  {
   d1 = .9046003222465515;
   d3 = .051679521799087524;
   d4 = -.008078929968178272;
   break;
  }
 case 10:
  {
   d1 = .9103443026542664;
   d3 = .05130752921104431;
   d4 = -.007461919914931059;
   break;
  }
 case 11:
  {
   d1 = .9158767461776733;
   d3 = .05180436000227928;
   d4 = -.006707109976559877;
   break;
  }
 case 12:
  {
   d1 = .921218752861023;
   d3 = .0527380108833313;
   d4 = -.00588351022452116;
   break;
  }
 case 13:
  {
   d1 = .9263819456100464;
   d3 = .054007638245821;
   d4 = -.00508452020585537;
   break;
  }
 case 14:
  {
   d1 = .9312355518341064;
   d3 = .05516162887215614;
   d4 = -4.3730600737035275e-03;
   break;
  }
 case 15:
  {
   d1 = .9356499314308167;
   d3 = .0559656098484993;
   d4 = -3.8815198931843042e-03;
   break;
  }
 case 16:
  {
   d1 = .9397674202919006;
   d3 = .056622739881277084;
   d4 = -3.4827999770641327e-03;
   break;
  }
 case 17:
  {
   d1 = .9435170292854309;
   d3 = .0569412000477314;
   d4 = -3.1882100738584995e-03;
   break;
  }
 case 18:
  {
   d1 = .9455727338790894;
   d3 = .05227591097354889;
   d4 = -.004006760194897652;
   break;
  }
 case 19:
  {
   d1 = .9500161409378052;
   d3 = .05681641027331352;
   d4 = -3.0062799341976643e-03;
   break;
  }
 case 20:
  {
   d1 = .9528170824050903;
   d3 = .05637606978416443;
   d4 = -.003047900041565299;
   break;
  }
 case 21:
  {
   d1 = .9553625583648682;
   d3 = .055758800357580185;
   d4 = -.00312987994402647;
   break;
  }
 case 22:
  {
   d1 = .9575420618057251;
   d3 = .05426060035824776;
   d4 = -3.8594501093029976e-03;
   break;
  }
 default:
  {
   d1 = +Math_log(+(+(i2 >>> 0) + 1.0000000474974513e-03)) * .056873 + .781388;
   d3 = .054260000586509705;
   d4 = -.003860000055283308;
  }
 } while (0);
 d5 = +Math_log(+d5);
 d1 = d1 + d3 * d5 + d5 * (d4 * d5);
 if (d1 < 0.0) {
  d5 = 0.0;
  return +d5;
 }
 if (!(d1 > 1.0)) {
  d5 = d1;
  return +d5;
 }
 d5 = 1.0;
 return +d5;
}

function _interleaver_encode(i10, i1, i12) {
 i10 = i10 | 0;
 i1 = i1 | 0;
 i12 = i12 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 _memmove(i12 | 0, i1 | 0, HEAP32[i10 >> 2] | 0) | 0;
 i8 = i10 + 12 | 0;
 i1 = HEAP32[i8 >> 2] | 0;
 if (!i1) return;
 i3 = HEAP32[i10 >> 2] | 0;
 i9 = i10 + 4 | 0;
 i5 = HEAP32[i9 >> 2] | 0;
 i11 = i10 + 8 | 0;
 i6 = HEAP32[i11 >> 2] | 0;
 i7 = i3 >>> 1;
 if (i7) {
  i1 = 0;
  i2 = 0;
  i3 = (i3 >>> 0) / 3 | 0;
  do {
   do {
    i4 = (Math_imul(i2, i6) | 0) + i3 | 0;
    i2 = i2 + 1 | 0;
    if ((i2 | 0) == (i5 | 0)) {
     i2 = 0;
     i3 = ((i3 + 1 | 0) >>> 0) % (i6 >>> 0) | 0;
    }
   } while (i4 >>> 0 >= i7 >>> 0);
   i14 = i12 + (i4 << 1 | 1) | 0;
   i13 = HEAP8[i14 >> 0] | 0;
   i4 = i12 + (i1 << 1) | 0;
   HEAP8[i14 >> 0] = HEAP8[i4 >> 0] | 0;
   HEAP8[i4 >> 0] = i13;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i7 | 0));
  i1 = HEAP32[i8 >> 2] | 0;
 }
 if (i1 >>> 0 <= 1) return;
 i2 = HEAP32[i10 >> 2] | 0;
 i5 = HEAP32[i9 >> 2] | 0;
 i6 = (HEAP32[i11 >> 2] | 0) + 2 | 0;
 i7 = i2 >>> 1;
 if (i7) {
  i1 = 0;
  i4 = 0;
  i3 = (i2 >>> 0) / 3 | 0;
  while (1) {
   i2 = i4;
   do {
    i4 = (Math_imul(i2, i6) | 0) + i3 | 0;
    i2 = i2 + 1 | 0;
    if ((i2 | 0) == (i5 | 0)) {
     i2 = 0;
     i3 = ((i3 + 1 | 0) >>> 0) % (i6 >>> 0) | 0;
    }
   } while (i4 >>> 0 >= i7 >>> 0);
   i15 = i12 + (i1 << 1) | 0;
   i13 = HEAP8[i15 >> 0] | 0;
   i14 = i12 + (i4 << 1 | 1) | 0;
   i4 = HEAP8[i14 >> 0] | 0;
   HEAP8[i15 >> 0] = i4 & 15 | i13 & 240;
   HEAP8[i14 >> 0] = i4 & 240 | i13 & 15;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i7 | 0)) break; else i4 = i2;
  }
  i1 = HEAP32[i8 >> 2] | 0;
 }
 if (i1 >>> 0 <= 2) return;
 i2 = HEAP32[i10 >> 2] | 0;
 i5 = HEAP32[i9 >> 2] | 0;
 i6 = (HEAP32[i11 >> 2] | 0) + 4 | 0;
 i7 = i2 >>> 1;
 if (i7) {
  i1 = 0;
  i4 = 0;
  i3 = (i2 >>> 0) / 3 | 0;
  while (1) {
   i2 = i4;
   do {
    i4 = (Math_imul(i2, i6) | 0) + i3 | 0;
    i2 = i2 + 1 | 0;
    if ((i2 | 0) == (i5 | 0)) {
     i2 = 0;
     i3 = ((i3 + 1 | 0) >>> 0) % (i6 >>> 0) | 0;
    }
   } while (i4 >>> 0 >= i7 >>> 0);
   i16 = i12 + (i1 << 1) | 0;
   i14 = HEAP8[i16 >> 0] | 0;
   i15 = i12 + (i4 << 1 | 1) | 0;
   i13 = HEAP8[i15 >> 0] | 0;
   HEAP8[i16 >> 0] = i13 & 85 | i14 & 170;
   HEAP8[i15 >> 0] = i13 & 170 | i14 & 85;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i7 | 0)) break; else i4 = i2;
  }
  i1 = HEAP32[i8 >> 2] | 0;
 }
 if (i1 >>> 0 <= 3) return;
 i3 = HEAP32[i10 >> 2] | 0;
 i7 = HEAP32[i9 >> 2] | 0;
 i5 = (HEAP32[i11 >> 2] | 0) + 8 | 0;
 i6 = i3 >>> 1;
 if (!i6) return;
 i1 = 0;
 i2 = 0;
 i3 = (i3 >>> 0) / 3 | 0;
 do {
  do {
   i4 = (Math_imul(i2, i5) | 0) + i3 | 0;
   i2 = i2 + 1 | 0;
   if ((i2 | 0) == (i7 | 0)) {
    i2 = 0;
    i3 = ((i3 + 1 | 0) >>> 0) % (i5 >>> 0) | 0;
   }
  } while (i4 >>> 0 >= i6 >>> 0);
  i13 = i12 + (i1 << 1) | 0;
  i15 = HEAP8[i13 >> 0] | 0;
  i16 = i12 + (i4 << 1 | 1) | 0;
  i14 = HEAP8[i16 >> 0] | 0;
  HEAP8[i13 >> 0] = i14 & 51 | i15 & 204;
  HEAP8[i16 >> 0] = i14 & 204 | i15 & 51;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i6 | 0));
 return;
}

function _modem_create_apsk(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i18;
 switch (i2 | 0) {
 case 2:
  {
   i17 = gb + 1560 | 0;
   break;
  }
 case 3:
  {
   i17 = gb + 1608 | 0;
   break;
  }
 case 4:
  {
   i17 = gb + 1656 | 0;
   break;
  }
 case 5:
  {
   i17 = gb + 1716 | 0;
   break;
  }
 case 6:
  {
   i17 = gb + 1788 | 0;
   break;
  }
 case 7:
  {
   i17 = gb + 1872 | 0;
   break;
  }
 case 8:
  {
   i17 = gb + 1980 | 0;
   break;
  }
 default:
  {
   i16 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i1 >> 2] = i2;
   _fprintf(i16, gb + 31248 | 0, i1) | 0;
   _exit(1);
  }
 }
 i12 = _malloc(252) | 0;
 HEAP32[i12 >> 2] = HEAP32[i17 >> 2];
 i13 = i12 + 76 | 0;
 HEAP32[i13 >> 2] = 0;
 i14 = i12 + 80 | 0;
 HEAP32[i14 >> 2] = 0;
 i15 = i12 + 4 | 0;
 HEAP32[i15 >> 2] = i2;
 i16 = i12 + 8 | 0;
 HEAP32[i16 >> 2] = 1 << i2;
 i11 = i12 + 236 | 0;
 HEAP32[i11 >> 2] = 0;
 HEAP32[i11 + 4 >> 2] = 0;
 HEAP32[i11 + 8 >> 2] = 0;
 HEAP32[i11 + 12 >> 2] = 0;
 i8 = HEAP32[i17 + 4 >> 2] | 0;
 i10 = i12 + 100 | 0;
 HEAP32[i10 >> 2] = i8;
 if (i8) {
  i2 = HEAP32[i17 + 8 >> 2] | 0;
  i3 = i12 + 104 | 0;
  i4 = HEAP32[i17 + 12 >> 2] | 0;
  i5 = i12 + 136 | 0;
  i6 = HEAP32[i17 + 16 >> 2] | 0;
  i7 = i12 + 200 | 0;
  i8 = 0;
  do {
   HEAP32[i3 + (i8 << 2) >> 2] = HEAP32[i2 + (i8 << 2) >> 2];
   HEAP32[i5 + (i8 << 2) >> 2] = HEAP32[i4 + (i8 << 2) >> 2];
   HEAP32[i7 + (i8 << 2) >> 2] = HEAP32[i6 + (i8 << 2) >> 2];
   i8 = i8 + 1 | 0;
   i1 = HEAP32[i10 >> 2] | 0;
  } while (i8 >>> 0 < i1 >>> 0);
  if ((i1 | 0) != 1) i9 = 12;
 } else i9 = 12;
 if ((i9 | 0) == 12) {
  i1 = HEAP32[i17 + 20 >> 2] | 0;
  i2 = i12 + 168 | 0;
  i3 = 0;
  do {
   HEAP32[i2 + (i3 << 2) >> 2] = HEAP32[i1 + (i3 << 2) >> 2];
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < ((HEAP32[i10 >> 2] | 0) + -1 | 0) >>> 0);
 }
 i10 = HEAP32[i16 >> 2] | 0;
 i9 = _malloc(i10) | 0;
 HEAP32[i12 + 232 >> 2] = i9;
 _memmove(i9 | 0, HEAP32[i17 + 24 >> 2] | 0, i10 | 0) | 0;
 HEAP32[i11 >> 2] = fb + 21;
 HEAP32[i12 + 240 >> 2] = fb + 22;
 switch (HEAP32[i15 >> 2] | 0) {
 case 2:
  {
   _modem_demodsoft_gentab(i12, 3);
   break;
  }
 case 3:
  {
   _modem_demodsoft_gentab(i12, 3);
   break;
  }
 case 4:
  {
   _modem_demodsoft_gentab(i12, 4);
   break;
  }
 case 5:
  {
   _modem_demodsoft_gentab(i12, 4);
   break;
  }
 case 6:
  {
   _modem_demodsoft_gentab(i12, 4);
   break;
  }
 case 7:
  {
   _modem_demodsoft_gentab(i12, 5);
   break;
  }
 case 8:
  {
   _modem_demodsoft_gentab(i12, 5);
   break;
  }
 default:
  {}
 }
 HEAP32[i13 >> 2] = _malloc(HEAP32[i16 >> 2] << 3) | 0;
 _modem_init_map(i12);
 HEAP32[i14 >> 2] = 1;
 HEAPF32[i12 + 84 >> 2] = 1.0;
 HEAPF32[i12 + 88 >> 2] = 0.0;
 HEAP32[i12 + 92 >> 2] = 1065353216;
 HEAPF32[i12 + 96 >> 2] = 0.0;
 if (!(_liquid_modem_is_dpsk(HEAP32[i12 >> 2] | 0) | 0)) {
  STACKTOP = i18;
  return i12 | 0;
 }
 HEAPF32[i12 + 104 >> 2] = 0.0;
 STACKTOP = i18;
 return i12 | 0;
}

function _ofdmframesync_execute(i26, i27, i25) {
 i26 = i26 | 0;
 i27 = i27 | 0;
 i25 = i25 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, d33 = 0.0, d34 = 0.0;
 i31 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i3 = i31 + 40 | 0;
 i29 = i31 + 16 | 0;
 i30 = i31;
 i4 = i31 + 32 | 0;
 i5 = i31 + 24 | 0;
 i16 = i31 + 8 | 0;
 if (!i25) {
  STACKTOP = i31;
  return;
 }
 i19 = i30 + 4 | 0;
 i20 = i26 + 104 | 0;
 i21 = i26 + 60 | 0;
 i22 = i5 + 4 | 0;
 i23 = i26 + 168 | 0;
 i24 = i26 + 124 | 0;
 i6 = i26 + 4 | 0;
 i7 = i26 + 8 | 0;
 i8 = i26 + 84 | 0;
 i9 = i26 + 80 | 0;
 i10 = i29 + 4 | 0;
 i11 = i26 + 140 | 0;
 i12 = i26 + 136 | 0;
 i13 = i26 + 176 | 0;
 i14 = i16 + 4 | 0;
 i15 = i26 + 180 | 0;
 i17 = i26 + 108 | 0;
 i18 = i4 + 4 | 0;
 i28 = 0;
 do {
  i1 = HEAP32[i27 + (i28 << 3) >> 2] | 0;
  i2 = HEAP32[i27 + (i28 << 3) + 4 >> 2] | 0;
  HEAP32[i30 >> 2] = i1;
  HEAP32[i19 >> 2] = i2;
  if (HEAP32[i20 >> 2] | 0) {
   i32 = HEAP32[i17 >> 2] | 0;
   HEAP32[i4 >> 2] = i1;
   HEAP32[i18 >> 2] = i2;
   HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
   HEAP32[i3 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   _nco_crcf_mix_down(i32, i3, i30);
   _nco_crcf_step(HEAP32[i17 >> 2] | 0);
   i1 = HEAP32[i30 >> 2] | 0;
   i2 = HEAP32[i19 >> 2] | 0;
  }
  i32 = HEAP32[i21 >> 2] | 0;
  HEAP32[i5 >> 2] = i1;
  HEAP32[i22 >> 2] = i2;
  HEAP32[i3 >> 2] = HEAP32[i5 >> 2];
  HEAP32[i3 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
  _windowcf_push(i32, i3);
  if (HEAP32[i23 >> 2] | 0) {
   i32 = HEAP32[i13 >> 2] | 0;
   i2 = HEAP32[i19 >> 2] | 0;
   HEAP32[i16 >> 2] = HEAP32[i30 >> 2];
   HEAP32[i14 >> 2] = i2;
   HEAP32[i3 >> 2] = HEAP32[i16 >> 2];
   HEAP32[i3 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
   _windowcf_push(i32, i3);
   d34 = +HEAPF32[i30 >> 2];
   d33 = +HEAPF32[i19 >> 2];
   _windowf_push(HEAP32[i15 >> 2] | 0, d34 * d34 + d33 * d33);
  }
  switch (HEAP32[i20 >> 2] | 0) {
  case 0:
   {
    _ofdmframesync_execute_seekplcp(i26);
    break;
   }
  case 1:
   {
    i32 = (HEAP32[i24 >> 2] | 0) + 1 | 0;
    HEAP32[i24 >> 2] = i32;
    if (i32 >>> 0 >= (HEAP32[i6 >> 2] | 0) >>> 0) {
     HEAP32[i24 >> 2] = 0;
     _windowcf_read(HEAP32[i21 >> 2] | 0, i3);
     _ofdmframesync_estimate_gain_S0(i26, (HEAP32[i3 >> 2] | 0) + (HEAP32[i7 >> 2] << 3) | 0, HEAP32[i8 >> 2] | 0);
     _ofdmframesync_S0_metrics(i26, HEAP32[i8 >> 2] | 0, i29);
     d33 = +HEAPF32[i9 >> 2];
     d34 = d33 * +HEAPF32[i10 >> 2];
     HEAPF32[i12 >> 2] = d33 * +HEAPF32[i29 >> 2];
     HEAPF32[i11 >> 2] = d34;
     HEAP32[i20 >> 2] = 2;
    }
    break;
   }
  case 2:
   {
    _ofdmframesync_execute_S0b(i26);
    break;
   }
  case 3:
   {
    _ofdmframesync_execute_S1(i26);
    break;
   }
  case 4:
   {
    _ofdmframesync_execute_rxsymbols(i26);
    break;
   }
  default:
   {}
  }
  i28 = i28 + 1 | 0;
 } while ((i28 | 0) != (i25 | 0));
 STACKTOP = i31;
 return;
}

function _ofdmframegen_create(i5, i1, i2, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 var d3 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, d13 = 0.0;
 if (i5 >>> 0 < 2) {
  _fwrite(gb + 34973 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i5 & 1 | 0) {
  _fwrite(gb + 35045 | 0, 65, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i1 >>> 0 > i5 >>> 0) {
  _fwrite(gb + 35111 | 0, 72, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i2 >>> 0 > i1 >>> 0) {
  _fwrite(gb + 35184 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i9 = _malloc(80) | 0;
 HEAP32[i9 >> 2] = i5;
 HEAP32[i9 + 4 >> 2] = i1;
 i7 = i9 + 12 | 0;
 HEAP32[i7 >> 2] = i2;
 i1 = _malloc(i5) | 0;
 i6 = i9 + 8 | 0;
 HEAP32[i6 >> 2] = i1;
 if (!i4) {
  _ofdmframe_init_default_sctype(i5, i1);
  i1 = HEAP32[i6 >> 2] | 0;
  i2 = HEAP32[i9 >> 2] | 0;
 } else {
  _memcpy(i1 | 0, i4 | 0, i5 | 0) | 0;
  i2 = i5;
 }
 i5 = i9 + 28 | 0;
 i8 = i9 + 32 | 0;
 _ofdmframe_validate_sctype(i1, i2, i9 + 24 | 0, i5, i8);
 i1 = HEAP32[i5 >> 2] | 0;
 i2 = HEAP32[i8 >> 2] | 0;
 if ((i1 | 0) == (0 - i2 | 0)) {
  _fwrite(gb + 35256 | 0, 72, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i2) {
  _fwrite(gb + 35329 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i1 >>> 0 < 2) {
  _fwrite(gb + 35400 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i10 = HEAP32[i9 >> 2] | 0;
 i11 = i10 << 3;
 i12 = _malloc(i11) | 0;
 HEAP32[i9 + 52 >> 2] = i12;
 i11 = _malloc(i11) | 0;
 HEAP32[i9 + 56 >> 2] = i11;
 HEAP32[i9 + 48 >> 2] = _fft_create_plan(i10, i12, i11, -1, 0) | 0;
 i11 = HEAP32[i9 >> 2] | 0;
 i12 = i11 << 3;
 i10 = _malloc(i12) | 0;
 HEAP32[i9 + 60 >> 2] = i10;
 i4 = _malloc(i12) | 0;
 HEAP32[i9 + 64 >> 2] = i4;
 i2 = i9 + 68 | 0;
 HEAP32[i2 >> 2] = _malloc(i12) | 0;
 i1 = i9 + 72 | 0;
 HEAP32[i1 >> 2] = _malloc(i12) | 0;
 _ofdmframe_init_S0(HEAP32[i6 >> 2] | 0, i11, i10, i4, i9 + 36 | 0);
 _ofdmframe_init_S1(HEAP32[i6 >> 2] | 0, HEAP32[i9 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i1 >> 2] | 0, i9 + 40 | 0);
 i1 = HEAP32[i7 >> 2] | 0;
 i2 = _malloc(i1 << 2) | 0;
 HEAP32[i9 + 16 >> 2] = i2;
 HEAP32[i9 + 20 >> 2] = _malloc(i1 << 3) | 0;
 if (!i1) {
  i11 = HEAP32[i5 >> 2] | 0;
  i12 = HEAP32[i8 >> 2] | 0;
  i11 = i12 + i11 | 0;
  d3 = +(i11 >>> 0);
  d3 = +Math_sqrt(+d3);
  d3 = 1.0 / d3;
  i11 = i9 + 44 | 0;
  HEAPF32[i11 >> 2] = d3;
  i11 = _msequence_create_default(8) | 0;
  i12 = i9 + 76 | 0;
  HEAP32[i12 >> 2] = i11;
  return i9 | 0;
 }
 d3 = +(i1 >>> 0);
 i4 = 0;
 do {
  d13 = +Math_sin(+((+(i4 >>> 0) + .5) / d3 * 1.5707963267948966));
  HEAPF32[i2 + (i4 << 2) >> 2] = d13 * d13;
  i4 = i4 + 1 | 0;
 } while (i4 >>> 0 < i1 >>> 0);
 i11 = HEAP32[i5 >> 2] | 0;
 i12 = HEAP32[i8 >> 2] | 0;
 i11 = i12 + i11 | 0;
 d13 = +(i11 >>> 0);
 d13 = +Math_sqrt(+d13);
 d13 = 1.0 / d13;
 i11 = i9 + 44 | 0;
 HEAPF32[i11 >> 2] = d13;
 i11 = _msequence_create_default(8) | 0;
 i12 = i9 + 76 | 0;
 HEAP32[i12 >> 2] = i11;
 return i9 | 0;
}

function _gmskframesync_execute(i26, i27, i25) {
 i26 = i26 | 0;
 i27 = i27 | 0;
 i25 = i25 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0;
 i30 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i1 = i30 + 64 | 0;
 i2 = i30 + 24 | 0;
 i3 = i30 + 8 | 0;
 i29 = i30;
 i14 = i30 + 56 | 0;
 i19 = i30 + 48 | 0;
 i20 = i30 + 40 | 0;
 i21 = i30 + 32 | 0;
 i22 = i30 + 16 | 0;
 if (!i25) {
  STACKTOP = i30;
  return;
 }
 i23 = i14 + 4 | 0;
 i24 = i26 + 232 | 0;
 i4 = i26 + 216 | 0;
 i5 = i29 + 4 | 0;
 i6 = i26 + 124 | 0;
 i7 = i2 + 4 | 0;
 i8 = i26 + 108 | 0;
 i9 = i26 + 112 | 0;
 i10 = i26 + 116 | 0;
 i11 = i26 + 120 | 0;
 i12 = i3 + 4 | 0;
 i13 = i20 + 4 | 0;
 i15 = i21 + 4 | 0;
 i16 = i22 + 4 | 0;
 i17 = i26 + 240 | 0;
 i18 = i19 + 4 | 0;
 i28 = 0;
 do {
  i31 = HEAP32[i26 >> 2] | 0;
  i32 = HEAP32[i27 + (i28 << 3) + 4 >> 2] | 0;
  HEAP32[i14 >> 2] = HEAP32[i27 + (i28 << 3) >> 2];
  HEAP32[i23 >> 2] = i32;
  HEAP32[i1 >> 2] = HEAP32[i14 >> 2];
  HEAP32[i1 + 4 >> 2] = HEAP32[i14 + 4 >> 2];
  _iirfilt_crcf_execute(i31, i1, i29);
  if (HEAP32[i24 >> 2] | 0) {
   i32 = HEAP32[i17 >> 2] | 0;
   i31 = HEAP32[i5 >> 2] | 0;
   HEAP32[i19 >> 2] = HEAP32[i29 >> 2];
   HEAP32[i18 >> 2] = i31;
   HEAP32[i1 >> 2] = HEAP32[i19 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
   _windowcf_push(i32, i1);
  }
  switch (HEAP32[i4 >> 2] | 0) {
  case 0:
   {
    i33 = HEAP32[i29 >> 2] | 0;
    i31 = HEAP32[i5 >> 2] | 0;
    i32 = HEAP32[i6 >> 2] | 0;
    HEAP32[i2 >> 2] = i33;
    HEAP32[i7 >> 2] = i31;
    HEAP32[i1 >> 2] = HEAP32[i2 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
    _windowcf_push(i32, i1);
    i32 = HEAP32[i8 >> 2] | 0;
    HEAP32[i3 >> 2] = i33;
    HEAP32[i12 >> 2] = i31;
    HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
    if (_detector_cccf_correlate(i32, i1, i9, i10, i11) | 0) _gmskframesync_pushpn(i26);
    break;
   }
  case 1:
   {
    i33 = HEAP32[i5 >> 2] | 0;
    HEAP32[i20 >> 2] = HEAP32[i29 >> 2];
    HEAP32[i13 >> 2] = i33;
    HEAP32[i1 >> 2] = HEAP32[i20 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i20 + 4 >> 2];
    _gmskframesync_execute_rxpreamble(i26, i1);
    break;
   }
  case 2:
   {
    i33 = HEAP32[i5 >> 2] | 0;
    HEAP32[i21 >> 2] = HEAP32[i29 >> 2];
    HEAP32[i15 >> 2] = i33;
    HEAP32[i1 >> 2] = HEAP32[i21 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i21 + 4 >> 2];
    _gmskframesync_execute_rxheader(i26, i1);
    break;
   }
  case 3:
   {
    i33 = HEAP32[i5 >> 2] | 0;
    HEAP32[i22 >> 2] = HEAP32[i29 >> 2];
    HEAP32[i16 >> 2] = i33;
    HEAP32[i1 >> 2] = HEAP32[i22 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i22 + 4 >> 2];
    _gmskframesync_execute_rxpayload(i26, i1);
    break;
   }
  default:
   {}
  }
  i28 = i28 + 1 | 0;
 } while ((i28 | 0) != (i25 | 0));
 STACKTOP = i30;
 return;
}

function _decoder_profile(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i6;
 i5 = _json_object_get(i1, i2) | 0;
 if (!i5) {
  HEAP32[i3 >> 2] = i2;
  _printf(gb + 9993 | 0, i3) | 0;
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 i3 = _calloc(1, 60) | 0;
 if (!i3) {
  _puts(gb + 10468 | 0) | 0;
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 i1 = _json_object_get(i5, gb + 10109 | 0) | 0;
 if (!i1) i1 = 0; else {
  i1 = (_strcmp(_json_string_value(i1) | 0, gb + 10120 | 0) | 0) == 0;
  i1 = i1 ? 2 : 1;
  HEAP32[i3 + 52 >> 2] = i1;
 }
 i2 = _json_object_get(i5, gb + 10138 | 0) | 0;
 if (i2 | 0) {
  if ((i1 | 0) == 2) {
   _puts(gb + 10143 | 0) | 0;
   i5 = 0;
   STACKTOP = i6;
   return i5 | 0;
  }
  HEAP32[i3 + 52 >> 2] = 0;
  i1 = _json_object_get(i2, gb + 10190 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10206 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 4 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10227 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 8 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10240 | 0) | 0;
  if (i1 | 0) {
   i1 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 12 >> 2] = i1;
  }
  i1 = _json_object_get(i2, gb + 10250 | 0) | 0;
  if (i1 | 0) {
   i2 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 16 >> 2] = i2;
  }
 }
 i1 = _json_object_get(i5, gb + 10261 | 0) | 0;
 if (i1 | 0 ? (i4 = _json_object_get(i1, gb + 10272 | 0) | 0, i4 | 0) : 0) HEAPF32[i3 + 32 >> 2] = +_json_number_value(i4) / 44100.0 * 3.141592653589793 * 2.0;
 i2 = _json_object_get(i5, gb + 10294 | 0) | 0;
 if (i2) {
  i1 = _json_object_get(i2, gb + 10308 | 0) | 0;
  if (i1 | 0) {
   i4 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 20 >> 2] = i4;
  }
  i1 = _json_object_get(i2, gb + 10327 | 0) | 0;
  if (i1 | 0) {
   i4 = _json_integer_value(i1) | 0;
   getTempRet0() | 0;
   HEAP32[i3 + 24 >> 2] = i4;
  }
  i1 = _json_object_get(i2, gb + 10340 | 0) | 0;
  if (i1 | 0) HEAPF32[i3 + 28 >> 2] = +_json_number_value(i1);
 } else HEAP32[i3 + 20 >> 2] = 1;
 i2 = _json_object_get(i5, gb + 10389 | 0) | 0;
 if (!i2) {
  i5 = i3;
  STACKTOP = i6;
  return i5 | 0;
 }
 i1 = _json_object_get(i2, gb + 10399 | 0) | 0;
 if (i1 | 0) {
  i5 = _json_integer_value(i1) | 0;
  getTempRet0() | 0;
  HEAP32[i3 + 36 >> 2] = i5;
 }
 i1 = _json_object_get(i2, gb + 10405 | 0) | 0;
 if (i1 | 0) HEAPF32[i3 + 40 >> 2] = +_json_number_value(i1);
 i1 = _json_object_get(i2, gb + 10415 | 0) | 0;
 if (i1 | 0) HEAPF32[i3 + 44 >> 2] = +_json_number_value(i1);
 i1 = _json_object_get(i2, gb + 10427 | 0) | 0;
 if (!i1) {
  i5 = i3;
  STACKTOP = i6;
  return i5 | 0;
 }
 HEAP32[i3 + 48 >> 2] = ~~+_json_number_value(i1) >>> 0;
 i5 = i3;
 STACKTOP = i6;
 return i5 | 0;
}

function _quiet_decoder_recv(i15, i20, i19) {
 i15 = i15 | 0;
 i20 = i20 | 0;
 i19 = i19 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, i18 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i23 = i24 + 16 | 0;
 i22 = i24 + 8 | 0;
 i21 = i24;
 i17 = i24 + 24 | 0;
 i18 = i24 + 20 | 0;
 if (!i15) {
  i23 = 0;
  STACKTOP = i24;
  return i23 | 0;
 }
 i11 = i15 + 64 | 0;
 i12 = Math_imul(HEAP32[HEAP32[i11 >> 2] >> 2] | 0, HEAP32[i15 + 84 >> 2] | 0) | 0;
 L4 : do if (i19 | 0) {
  i13 = i15 + 96 | 0;
  i14 = i15 + 104 | 0;
  i4 = i15 + 100 | 0;
  i5 = i15 + 80 | 0;
  i6 = i15 + 52 | 0;
  i7 = i15 + 60 | 0;
  i8 = i15 + 56 | 0;
  i9 = i15 + 88 | 0;
  i10 = i15 + 60 | 0;
  i16 = 0;
  while (1) {
   i1 = HEAP32[i13 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i14 >> 2] | 0;
    i2 = i1 + (i19 - i16) | 0;
    i2 = i2 >>> 0 < i12 >>> 0 ? i2 : i12;
    _memmove((HEAP32[i4 >> 2] | 0) + (i1 << 2) | 0, i20 + (i16 << 2) | 0, i2 - i1 << 2 | 0) | 0;
    i1 = i2 - (HEAP32[i14 >> 2] | 0) | 0;
   } else {
    i2 = HEAP32[i14 >> 2] | 0;
    _resamp_rrrf_execute_output_block(i1, i20 + (i16 << 2) | 0, i19 - i16 | 0, i17, (HEAP32[i4 >> 2] | 0) + (i2 << 2) | 0, i12 - i2 | 0, i18) | 0;
    i1 = HEAP32[i17 >> 2] | 0;
    i2 = (HEAP32[i14 >> 2] | 0) + (HEAP32[i18 >> 2] | 0) | 0;
   }
   i16 = i1 + i16 | 0;
   i25 = HEAP32[i11 >> 2] | 0;
   i3 = (i2 >>> 0) % ((HEAP32[i25 >> 2] | 0) >>> 0) | 0;
   i1 = i2 - i3 | 0;
   i2 = _demodulator_recv(i25, HEAP32[i4 >> 2] | 0, i1, HEAP32[i5 >> 2] | 0) | 0;
   if (i3 | 0) {
    i25 = HEAP32[i4 >> 2] | 0;
    _memmove(i25 | 0, i25 + (i1 << 2) | 0, i3 << 2 | 0) | 0;
   }
   HEAP32[i14 >> 2] = i3;
   switch (HEAP32[i6 >> 2] | 0) {
   case 0:
    {
     _ofdmflexframesync_execute(HEAP32[i7 >> 2] | 0, HEAP32[i5 >> 2] | 0, i2);
     if (HEAP8[i8 >> 0] | 0) {
      HEAP32[i21 >> 2] = HEAP32[i9 >> 2];
      _sprintf(i17, gb + 9808 | 0, i21) | 0;
      _ofdmflexframesync_debug_print(HEAP32[i7 >> 2] | 0, i17);
      HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
     }
     break;
    }
   case 1:
    {
     _flexframesync_execute(HEAP32[i10 >> 2] | 0, HEAP32[i5 >> 2] | 0, i2);
     if (HEAP8[i8 >> 0] | 0) {
      HEAP32[i22 >> 2] = HEAP32[i9 >> 2];
      _sprintf(i17, gb + 9808 | 0, i22) | 0;
      _flexframesync_debug_print(HEAP32[i10 >> 2] | 0, i17);
      HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
     }
     break;
    }
   case 2:
    {
     _gmskframesync_execute(HEAP32[i10 >> 2] | 0, HEAP32[i5 >> 2] | 0, i2);
     if (HEAP8[i8 >> 0] | 0) {
      HEAP32[i23 >> 2] = HEAP32[i9 >> 2];
      _sprintf(i17, gb + 9808 | 0, i23) | 0;
      _gmskframesync_debug_print(HEAP32[i10 >> 2] | 0, i17);
      HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
     }
     break;
    }
   default:
    {}
   }
   if (i16 >>> 0 >= i19 >>> 0) break L4;
  }
 } while (0);
 i25 = HEAP32[i15 + 76 >> 2] | 0;
 STACKTOP = i24;
 return i25 | 0;
}

function _fft_execute_mixed_radix(i13) {
 i13 = i13 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i20;
 i19 = HEAP32[i13 + 40 >> 2] | 0;
 i16 = HEAP32[i13 + 44 >> 2] | 0;
 i17 = HEAP32[i13 + 52 >> 2] | 0;
 i18 = HEAP32[i13 + 56 >> 2] | 0;
 i15 = HEAP32[i13 + 48 >> 2] | 0;
 i3 = HEAP32[i13 + 60 >> 2] | 0;
 _memmove(i15 | 0, HEAP32[i13 + 4 >> 2] | 0, HEAP32[i13 >> 2] << 3 | 0) | 0;
 i14 = (i16 | 0) == 0;
 L1 : do if (!i14) {
  i12 = i13 + 64 | 0;
  i4 = i2 + 4 | 0;
  if (!i19) {
   i1 = 0;
   while (1) {
    i5 = HEAP32[i12 >> 2] | 0;
    mftCall_vi(HEAP32[i5 + 28 >> 2] | 0, i5 | 0);
    i1 = i1 + 1 | 0;
    if ((i1 | 0) == (i16 | 0)) break L1;
   }
  } else i5 = 0;
  do {
   i1 = 0;
   do {
    i22 = (Math_imul(i1, i16) | 0) + i5 | 0;
    i21 = HEAP32[i15 + (i22 << 3) + 4 >> 2] | 0;
    HEAP32[i17 + (i1 << 3) >> 2] = HEAP32[i15 + (i22 << 3) >> 2];
    HEAP32[i17 + (i1 << 3) + 4 >> 2] = i21;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i19 | 0));
   i1 = HEAP32[i12 >> 2] | 0;
   mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
   i1 = 0;
   do {
    d8 = +HEAPF32[i18 + (i1 << 3) >> 2];
    d9 = +HEAPF32[i18 + (i1 << 3) + 4 >> 2];
    i22 = Math_imul(i1, i5) | 0;
    d10 = +HEAPF32[i3 + (i22 << 3) >> 2];
    d11 = +HEAPF32[i3 + (i22 << 3) + 4 >> 2];
    d7 = d8 * d10 - d9 * d11;
    d6 = d9 * d10 + d8 * d11;
    if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
     ___mulsc3(i2, d8, d9, d10, d11);
     d7 = +HEAPF32[i2 >> 2];
     d6 = +HEAPF32[i4 >> 2];
    }
    i22 = (Math_imul(i1, i16) | 0) + i5 | 0;
    HEAPF32[i15 + (i22 << 3) >> 2] = d7;
    HEAPF32[i15 + (i22 << 3) + 4 >> 2] = d6;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i19 | 0));
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i16 | 0));
 } while (0);
 if (!i19) {
  STACKTOP = i20;
  return;
 }
 i5 = i13 + 68 | 0;
 i4 = i13 + 8 | 0;
 if (i14) {
  i1 = 0;
  do {
   i22 = HEAP32[i5 >> 2] | 0;
   mftCall_vi(HEAP32[i22 + 28 >> 2] | 0, i22 | 0);
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i19 | 0));
  STACKTOP = i20;
  return;
 } else i3 = 0;
 do {
  i1 = Math_imul(i3, i16) | 0;
  i2 = 0;
  do {
   i21 = i2 + i1 | 0;
   i22 = HEAP32[i15 + (i21 << 3) + 4 >> 2] | 0;
   HEAP32[i17 + (i2 << 3) >> 2] = HEAP32[i15 + (i21 << 3) >> 2];
   HEAP32[i17 + (i2 << 3) + 4 >> 2] = i22;
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i16 | 0));
  i1 = HEAP32[i5 >> 2] | 0;
  mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
  i1 = 0;
  do {
   i14 = HEAP32[i18 + (i1 << 3) + 4 >> 2] | 0;
   i22 = (Math_imul(i1, i19) | 0) + i3 | 0;
   i21 = HEAP32[i4 >> 2] | 0;
   HEAP32[i21 + (i22 << 3) >> 2] = HEAP32[i18 + (i1 << 3) >> 2];
   HEAP32[i21 + (i22 << 3) + 4 >> 2] = i14;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i16 | 0));
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i19 | 0));
 STACKTOP = i20;
 return;
}

function _modem_demodsoft_gentab(i7, i20) {
 i7 = i7 | 0;
 i20 = i20 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, d8 = 0.0, i9 = 0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i21 = 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i15 = i21 + 8 | 0;
 i16 = i21;
 i2 = i7 + 8 | 0;
 i18 = HEAP32[i2 >> 2] | 0;
 if ((i18 + -1 | 0) >>> 0 < i20 >>> 0) {
  _fwrite(gb + 30800 | 0, 63, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 HEAP32[i7 + 248 >> 2] = i20;
 i19 = i7 + 244 | 0;
 HEAP32[i19 >> 2] = _malloc(Math_imul(i18, i20) | 0) | 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i18 << 3) | 0) + 15 & -16) | 0;
 i10 = (i18 | 0) == 0;
 if (i10) {
  STACKTOP = i21;
  return;
 }
 i3 = i7 + 80 | 0;
 i4 = i7 + 236 | 0;
 i5 = i7 + 76 | 0;
 if (!i18) {
  i14 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 30864 | 0, 65, 1, i14) | 0;
  _exit(1);
 } else {
  i6 = i17;
  i1 = 0;
 }
 while (1) {
  if (!(HEAP32[i3 >> 2] | 0)) mftCall_viii(HEAP32[i4 >> 2] | 0, i7 | 0, i1 | 0, i6 | 0); else {
   i13 = HEAP32[i5 >> 2] | 0;
   i14 = HEAP32[i13 + (i1 << 3) + 4 >> 2] | 0;
   HEAP32[i6 >> 2] = HEAP32[i13 + (i1 << 3) >> 2];
   HEAP32[i17 + (i1 << 3) + 4 >> 2] = i14;
  }
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i18 >>> 0) break;
  if ((HEAP32[i2 >> 2] | 0) >>> 0 > i1 >>> 0) i6 = i17 + (i1 << 3) | 0; else {
   i9 = 10;
   break;
  }
 }
 if ((i9 | 0) == 10) {
  i14 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 30864 | 0, 65, 1, i14) | 0;
  _exit(1);
 }
 if (i10) {
  STACKTOP = i21;
  return;
 }
 i1 = i18 & 255;
 if (i20 | 0) {
  i3 = 0;
  do {
   i2 = Math_imul(i3, i20) | 0;
   i4 = 0;
   do {
    HEAP8[(HEAP32[i19 >> 2] | 0) + (i4 + i2) >> 0] = i1;
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != (i20 | 0));
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i18 | 0));
  if (i10) {
   STACKTOP = i21;
   return;
  }
 }
 i4 = (i20 | 0) == 0;
 i5 = i16 + 4 | 0;
 i12 = 0;
 do {
  if (!i4) {
   i6 = i17 + (i12 << 3) | 0;
   i7 = i17 + (i12 << 3) + 4 | 0;
   i9 = Math_imul(i12, i20) | 0;
   i14 = 0;
   do {
    i10 = i14 + i9 | 0;
    d11 = 1.0e9;
    i13 = 0;
    while (1) {
     i2 = HEAP32[i19 >> 2] | 0;
     i3 = 0;
     i1 = (i12 | 0) != (i13 | 0) & 1;
     do {
      i1 = (HEAPU8[i2 + (i3 + i9) >> 0] | 0 | 0) == (i13 | 0) ? 0 : i1;
      i3 = i3 + 1 | 0;
     } while ((i3 | 0) != (i20 | 0));
     d8 = +HEAPF32[i7 >> 2] - +HEAPF32[i17 + (i13 << 3) + 4 >> 2];
     HEAPF32[i16 >> 2] = +HEAPF32[i6 >> 2] - +HEAPF32[i17 + (i13 << 3) >> 2];
     HEAPF32[i5 >> 2] = d8;
     HEAP32[i15 >> 2] = HEAP32[i16 >> 2];
     HEAP32[i15 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
     d8 = +_cabsf(i15);
     if ((i1 | 0) != 0 & d8 < d11) HEAP8[(HEAP32[i19 >> 2] | 0) + i10 >> 0] = i13; else d8 = d11;
     i13 = i13 + 1 | 0;
     if ((i13 | 0) == (i18 | 0)) break; else d11 = d8;
    }
    i14 = i14 + 1 | 0;
   } while ((i14 | 0) != (i20 | 0));
  }
  i12 = i12 + 1 | 0;
 } while ((i12 | 0) != (i18 | 0));
 STACKTOP = i21;
 return;
}

function _ccoshf(i13, i6) {
 i13 = i13 | 0;
 i6 = i6 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, d11 = 0.0, i12 = 0, i14 = 0, d15 = 0.0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i2 = i14 + 16 | 0;
 i3 = i14 + 8 | 0;
 i4 = i14;
 d10 = +HEAPF32[i6 >> 2];
 i5 = i6 + 4 | 0;
 d11 = +HEAPF32[i5 >> 2];
 i12 = (HEAPF32[tempDoublePtr >> 2] = d10, HEAP32[tempDoublePtr >> 2] | 0);
 d1 = +Math_abs(+d10);
 i7 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 d1 = +Math_abs(+d11);
 i8 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 i9 = (i7 | 0) < 2139095040;
 do if (i9 & (i8 | 0) < 2139095040) {
  if (!i8) {
   HEAPF32[i13 >> 2] = +_coshf(d10);
   HEAPF32[i13 + 4 >> 2] = d10 * d11;
   break;
  }
  if ((i7 | 0) < 1091567616) {
   d1 = +_coshf(d10) * +Math_cos(+d11);
   d11 = +_sinhf(d10) * +Math_sin(+d11);
   HEAPF32[i13 >> 2] = d1;
   HEAPF32[i13 + 4 >> 2] = d11;
   break;
  }
  if ((i7 | 0) < 1118925336) {
   d15 = +Math_exp(+(+Math_abs(+d10))) * .5;
   d1 = d15 * +Math_cos(+d11);
   d11 = +_copysignf(d15, d10) * +Math_sin(+d11);
   HEAPF32[i13 >> 2] = d1;
   HEAPF32[i13 + 4 >> 2] = d11;
   break;
  }
  if ((i7 | 0) < 1128313319) {
   HEAPF32[i4 >> 2] = +Math_abs(+d10);
   HEAPF32[i4 + 4 >> 2] = d11;
   HEAP32[i2 >> 2] = HEAP32[i4 >> 2];
   HEAP32[i2 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   ___ldexp_cexpf(i3, i2, -1);
   i12 = HEAP32[i3 >> 2] | 0;
   d15 = +HEAPF32[i3 + 4 >> 2];
   HEAP32[i6 >> 2] = i12;
   HEAPF32[i5 >> 2] = d15;
   d15 = d15 * +_copysignf(1.0, d10);
   HEAP32[i13 >> 2] = i12;
   HEAPF32[i13 + 4 >> 2] = d15;
   break;
  } else {
   d10 = d10 * 1701411834604692317316873.0e14;
   d15 = d10 * +Math_sin(+d11);
   HEAPF32[i13 >> 2] = d10 * d10 * +Math_cos(+d11);
   HEAPF32[i13 + 4 >> 2] = d15;
   break;
  }
 } else {
  i3 = (i8 | 0) > 2139095039;
  if ((i7 | 0) == 0 & i3) {
   d11 = d11 - d11;
   d15 = +_copysignf(0.0, d10 * d11);
   HEAPF32[i13 >> 2] = d11;
   HEAPF32[i13 + 4 >> 2] = d15;
   break;
  }
  i2 = (i7 | 0) > 2139095039;
  if (i2 & (i8 | 0) == 0) {
   d1 = d10 * d10;
   if (!(i12 & 8388607)) {
    d15 = d11 * +_copysignf(0.0, d10);
    HEAPF32[i13 >> 2] = d1;
    HEAPF32[i13 + 4 >> 2] = d15;
    break;
   } else {
    d15 = +_copysignf(0.0, (d10 + d10) * d11);
    HEAPF32[i13 >> 2] = d1;
    HEAPF32[i13 + 4 >> 2] = d15;
    break;
   }
  }
  if (i9 & i3) {
   d15 = d11 - d11;
   HEAPF32[i13 >> 2] = d15;
   HEAPF32[i13 + 4 >> 2] = d10 * d15;
   break;
  }
  d1 = d10 * d10;
  if (!(i2 & (i12 & 8388607 | 0) == 0)) {
   d15 = d11 - d11;
   HEAPF32[i13 >> 2] = d1 * d15;
   HEAPF32[i13 + 4 >> 2] = (d10 + d10) * d15;
   break;
  }
  if (i3) {
   HEAPF32[i13 >> 2] = d1;
   HEAPF32[i13 + 4 >> 2] = d10 * (d11 - d11);
   break;
  } else {
   d15 = d10 * +Math_sin(+d11);
   HEAPF32[i13 >> 2] = d1 * +Math_cos(+d11);
   HEAPF32[i13 + 4 >> 2] = d15;
   break;
  }
 } while (0);
 STACKTOP = i14;
 return;
}

function _iirdes_dzpk2sosf(i1, i2, i24, i23, i25, i22) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i24 = i24 | 0;
 i23 = i23 | 0;
 i25 = i25 | 0;
 i22 = i22 | 0;
 var d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i26 = 0, d27 = 0.0;
 i26 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i18 = i26 + 8 | 0;
 i19 = i26;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 _liquid_cplxpair(i1, i24, 9.999999974752427e-07, i21);
 i20 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i24 << 3) | 0) + 15 & -16) | 0;
 _liquid_cplxpair(i2, i24, 9.999999974752427e-07, i20);
 i16 = i24 & 1;
 i17 = (i24 - i16 | 0) >>> 1;
 if (!i17) i1 = 0; else {
  i14 = i24 >>> 1;
  i15 = 0;
  do {
   i8 = i15 << 1;
   d4 = +HEAPF32[i20 + (i8 << 3) >> 2];
   d5 = +HEAPF32[i20 + (i8 << 3) + 4 >> 2];
   i2 = i8 | 1;
   d27 = +HEAPF32[i20 + (i2 << 3) >> 2];
   d6 = +HEAPF32[i20 + (i2 << 3) + 4 >> 2];
   d7 = -d27;
   d9 = +HEAPF32[i21 + (i8 << 3) >> 2];
   d10 = +HEAPF32[i21 + (i8 << 3) + 4 >> 2];
   d11 = +HEAPF32[i21 + (i2 << 3) >> 2];
   d12 = +HEAPF32[i21 + (i2 << 3) + 4 >> 2];
   d13 = -d11;
   i2 = i15 * 3 | 0;
   HEAPF32[i22 + (i2 << 2) >> 2] = 1.0;
   i8 = i2 + 1 | 0;
   HEAPF32[i22 + (i8 << 2) >> 2] = d7 - d4;
   d3 = d4 * d27 - d5 * d6;
   d27 = d5 * d27 + d4 * d6;
   if ((d3 != d3 | 0.0 != 0.0) & (d27 != d27 | 0.0 != 0.0)) {
    ___mulsc3(i18, -d4, -d5, d7, -d6);
    d3 = +HEAPF32[i18 >> 2];
   }
   i1 = i2 + 2 | 0;
   HEAPF32[i22 + (i1 << 2) >> 2] = d3;
   HEAPF32[i25 + (i2 << 2) >> 2] = 1.0;
   HEAPF32[i25 + (i8 << 2) >> 2] = d13 - d9;
   d3 = d9 * d11 - d10 * d12;
   d27 = d10 * d11 + d9 * d12;
   if ((d3 != d3 | 0.0 != 0.0) & (d27 != d27 | 0.0 != 0.0)) {
    ___mulsc3(i19, -d9, -d10, d13, -d12);
    d3 = +HEAPF32[i19 >> 2];
   }
   HEAPF32[i25 + (i1 << 2) >> 2] = d3;
   i15 = i15 + 1 | 0;
  } while ((i15 | 0) != (i14 | 0));
  i1 = i17 * 3 | 0;
 }
 if (i16 | 0) {
  i19 = i24 + -1 | 0;
  d13 = -+HEAPF32[i20 + (i19 << 3) >> 2];
  d27 = -+HEAPF32[i21 + (i19 << 3) >> 2];
  HEAPF32[i22 + (i1 << 2) >> 2] = 1.0;
  i20 = i1 + 1 | 0;
  HEAPF32[i22 + (i20 << 2) >> 2] = d13;
  i21 = i1 + 2 | 0;
  HEAPF32[i22 + (i21 << 2) >> 2] = 0.0;
  HEAPF32[i25 + (i1 << 2) >> 2] = 1.0;
  HEAPF32[i25 + (i20 << 2) >> 2] = d27;
  HEAPF32[i25 + (i21 << 2) >> 2] = 0.0;
 }
 i22 = i17 + i16 | 0;
 d3 = +Math_pow(+(+HEAPF32[i23 >> 2]), +(1.0 / +(i22 >>> 0)));
 if (!i22) {
  STACKTOP = i26;
  return;
 }
 i1 = i24 & 1;
 i1 = ((i24 - i1 | 0) >>> 1) + i1 | 0;
 i2 = 0;
 do {
  i24 = i2 * 3 | 0;
  i23 = i25 + (i24 << 2) | 0;
  HEAPF32[i23 >> 2] = d3 * +HEAPF32[i23 >> 2];
  i23 = i25 + (i24 + 1 << 2) | 0;
  HEAPF32[i23 >> 2] = d3 * +HEAPF32[i23 >> 2];
  i24 = i25 + (i24 + 2 << 2) | 0;
  HEAPF32[i24 >> 2] = d3 * +HEAPF32[i24 >> 2];
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i1 | 0));
 STACKTOP = i26;
 return;
}

function _ofdmflexframesync_decode_header(i9) {
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i11 + 8 | 0;
 i10 = i11;
 i2 = i9 + 48 | 0;
 i8 = i9 + 64 | 0;
 _liquid_repack_bytes(HEAP32[i9 + 52 >> 2] | 0, HEAP32[gb + 580 + 764 >> 2] | 0, HEAP32[i9 + 68 >> 2] | 0, HEAP32[i2 >> 2] | 0, 8, HEAP32[i8 >> 2] | 0, i1);
 i1 = HEAP32[i1 >> 2] | 0;
 if ((i1 | 0) != (HEAP32[i8 >> 2] | 0)) ___assert_fail(gb + 28536 | 0, gb + 28568 | 0, 492, gb + 28604 | 0);
 _unscramble_data(HEAP32[i2 >> 2] | 0, i1);
 i3 = i9 + 44 | 0;
 i1 = _packetizer_decode(HEAP32[i9 + 40 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
 i8 = i9 + 72 | 0;
 HEAP32[i8 >> 2] = i1;
 if (!i1) {
  STACKTOP = i11;
  return;
 }
 i4 = HEAP32[i9 + 56 >> 2] | 0;
 i2 = HEAP32[i3 >> 2] | 0;
 if ((HEAP8[i2 + i4 >> 0] | 0) != 104) {
  _fwrite(gb + 28636 | 0, 68, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i8 >> 2] = 0;
  i1 = 0;
  i2 = HEAP32[i3 >> 2] | 0;
 }
 i7 = HEAPU8[i2 + (i4 + 1) >> 0] << 8 | HEAPU8[i2 + (i4 + 2) >> 0];
 i5 = HEAP8[i2 + (i4 + 3) >> 0] | 0;
 i6 = i5 & 255;
 if ((i5 + -1 & 255) > 58) {
  _fwrite(gb + 28705 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i8 >> 2] = 0;
  STACKTOP = i11;
  return;
 }
 i5 = HEAPU8[i2 + (i4 + 4) >> 0] | 0;
 i3 = i5 >>> 5;
 i5 = i5 & 31;
 i4 = HEAPU8[i2 + (i4 + 5) >> 0] & 31;
 if ((i3 | 0) == 7) {
  _fwrite(gb + 28776 | 0, 74, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i8 >> 2] = 0;
  i1 = 0;
  i3 = 0;
 }
 if (i5 >>> 0 > 27) {
  _fwrite(gb + 28851 | 0, 82, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i8 >> 2] = 0;
  i1 = 0;
  i2 = 0;
 } else i2 = i5;
 if (i4 >>> 0 > 27) {
  _fwrite(gb + 28934 | 0, 82, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i8 >> 2] = 0;
  STACKTOP = i11;
  return;
 }
 if (!i1) {
  STACKTOP = i11;
  return;
 }
 i1 = i9 + 76 | 0;
 if ((i6 | 0) == (HEAP32[i1 >> 2] | 0)) i1 = i9 + 80 | 0; else {
  HEAP32[i1 >> 2] = i6;
  i1 = i9 + 80 | 0;
  HEAP32[i1 >> 2] = HEAP32[gb + 580 + (i6 << 4) + 12 >> 2];
  i8 = i9 + 104 | 0;
  HEAP32[i8 >> 2] = _modem_recreate(HEAP32[i8 >> 2] | 0, i6) | 0;
 }
 i6 = i9 + 84 | 0;
 HEAP32[i6 >> 2] = i7;
 HEAP32[i9 + 88 >> 2] = i3;
 HEAP32[i9 + 92 >> 2] = i2;
 HEAP32[i9 + 96 >> 2] = i4;
 i8 = i9 + 100 | 0;
 i5 = _packetizer_recreate(HEAP32[i8 >> 2] | 0, i7, i3, i2, i4) | 0;
 HEAP32[i8 >> 2] = i5;
 i5 = _packetizer_get_enc_msg_len(i5) | 0;
 i8 = i9 + 116 | 0;
 HEAP32[i8 >> 2] = i5;
 i7 = i9 + 108 | 0;
 HEAP32[i7 >> 2] = _realloc(HEAP32[i7 >> 2] | 0, i5) | 0;
 i7 = i9 + 112 | 0;
 HEAP32[i7 >> 2] = _realloc(HEAP32[i7 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
 _div(i10, HEAP32[i8 >> 2] << 3, HEAP32[i1 >> 2] | 0);
 i8 = ((HEAP32[i10 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i10 >> 2] | 0) | 0;
 HEAP32[i9 + 120 >> 2] = i8;
 i10 = i9 + 128 | 0;
 HEAP32[i10 >> 2] = _realloc(HEAP32[i10 >> 2] | 0, i8 << 3) | 0;
 STACKTOP = i11;
 return;
}

function _stream_get(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i10;
 i3 = i10 + 24 | 0;
 i4 = i10 + 20 | 0;
 i5 = i10 + 16 | 0;
 i6 = i10 + 12 | 0;
 i8 = i10 + 8 | 0;
 i7 = i10 + 4 | 0;
 HEAP32[i4 >> 2] = i2;
 HEAP32[i5 >> 2] = i1;
 i1 = HEAP32[i4 >> 2] | 0;
 if (HEAP32[(HEAP32[i4 >> 2] | 0) + 20 >> 2] | 0) {
  HEAP32[i3 >> 2] = HEAP32[i1 + 20 >> 2];
  i9 = HEAP32[i3 >> 2] | 0;
  STACKTOP = i10;
  return i9 | 0;
 }
 do if (!(HEAP8[(HEAP32[i4 >> 2] | 0) + 8 + (HEAP32[i1 + 16 >> 2] | 0) >> 0] | 0)) {
  HEAP32[i6 >> 2] = mftCall_ii(HEAP32[HEAP32[i4 >> 2] >> 2] | 0, HEAP32[(HEAP32[i4 >> 2] | 0) + 4 >> 2] | 0) | 0;
  if ((HEAP32[i6 >> 2] | 0) == -1) {
   HEAP32[(HEAP32[i4 >> 2] | 0) + 20 >> 2] = -1;
   HEAP32[i3 >> 2] = -1;
   i9 = HEAP32[i3 >> 2] | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
  HEAP8[(HEAP32[i4 >> 2] | 0) + 8 >> 0] = HEAP32[i6 >> 2];
  HEAP32[(HEAP32[i4 >> 2] | 0) + 16 >> 2] = 0;
  if (!(128 <= (HEAP32[i6 >> 2] | 0) & (HEAP32[i6 >> 2] | 0) <= 255)) {
   HEAP8[(HEAP32[i4 >> 2] | 0) + 8 + 1 >> 0] = 0;
   break;
  }
  HEAP32[i7 >> 2] = _utf8_check_first(HEAP32[i6 >> 2] & 255) | 0;
  if (HEAP32[i7 >> 2] | 0) {
   if ((HEAP32[i7 >> 2] | 0) >>> 0 < 2) ___assert_fail(gb + 40608 | 0, gb + 40619 | 0, 179, gb + 40626 | 0);
   HEAP32[i8 >> 2] = 1;
   while (1) {
    i1 = HEAP32[i4 >> 2] | 0;
    if ((HEAP32[i8 >> 2] | 0) >>> 0 >= (HEAP32[i7 >> 2] | 0) >>> 0) break;
    i2 = (mftCall_ii(HEAP32[i1 >> 2] | 0, HEAP32[(HEAP32[i4 >> 2] | 0) + 4 >> 2] | 0) | 0) & 255;
    HEAP8[(HEAP32[i4 >> 2] | 0) + 8 + (HEAP32[i8 >> 2] | 0) >> 0] = i2;
    HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + 1;
   }
   if (_utf8_check_full(i1 + 8 | 0, HEAP32[i7 >> 2] | 0, 0) | 0) {
    HEAP8[(HEAP32[i4 >> 2] | 0) + 8 + (HEAP32[i7 >> 2] | 0) >> 0] = 0;
    break;
   }
  }
  HEAP32[(HEAP32[i4 >> 2] | 0) + 20 >> 2] = -2;
  i7 = HEAP32[i5 >> 2] | 0;
  i8 = HEAP32[i4 >> 2] | 0;
  HEAP32[i9 >> 2] = HEAP32[i6 >> 2];
  _error_set(i7, i8, gb + 40637 | 0, i9);
  HEAP32[i3 >> 2] = -2;
  i9 = HEAP32[i3 >> 2] | 0;
  STACKTOP = i10;
  return i9 | 0;
 } while (0);
 i8 = (HEAP32[i4 >> 2] | 0) + 16 | 0;
 i9 = HEAP32[i8 >> 2] | 0;
 HEAP32[i8 >> 2] = i9 + 1;
 HEAP32[i6 >> 2] = HEAP8[(HEAP32[i4 >> 2] | 0) + 8 + i9 >> 0];
 i9 = (HEAP32[i4 >> 2] | 0) + 36 | 0;
 HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
 if ((HEAP32[i6 >> 2] | 0) != 10) {
  if (_utf8_check_first(HEAP32[i6 >> 2] & 255) | 0) {
   i9 = (HEAP32[i4 >> 2] | 0) + 28 | 0;
   HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
  }
 } else {
  i9 = (HEAP32[i4 >> 2] | 0) + 24 | 0;
  HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
  HEAP32[(HEAP32[i4 >> 2] | 0) + 32 >> 2] = HEAP32[(HEAP32[i4 >> 2] | 0) + 28 >> 2];
  HEAP32[(HEAP32[i4 >> 2] | 0) + 28 >> 2] = 0;
 }
 HEAP32[i3 >> 2] = HEAP32[i6 >> 2];
 i9 = HEAP32[i3 >> 2] | 0;
 STACKTOP = i10;
 return i9 | 0;
}

function _fec_conv_punctured_encode(i20, i19, i15, i18) {
 i20 = i20 | 0;
 i19 = i19 | 0;
 i15 = i15 | 0;
 i18 = i18 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0;
 i16 = g$_P_init() | 0;
 i17 = g$_Partab() | 0;
 if (!i19) {
  i2 = 0;
  i1 = 0;
  i5 = 0;
  i4 = 0;
 } else {
  i11 = i20 + 28 | 0;
  i12 = i20 + 36 | 0;
  i13 = i20 + 40 | 0;
  i14 = i20 + 24 | 0;
  i5 = HEAP32[i11 >> 2] | 0;
  i2 = 0;
  i3 = 0;
  i1 = 0;
  i6 = 0;
  i4 = 0;
  do {
   i10 = HEAPU8[i15 + i3 >> 0] | 0;
   i7 = i5;
   i9 = 0;
   while (1) {
    i8 = i10 >>> (7 - i9 | 0) & 1 | i4 << 1;
    if (!i5) {
     i5 = i7;
     i4 = 0;
    } else {
     i4 = i7;
     i5 = 0;
     do {
      i7 = (Math_imul(HEAP32[i12 >> 2] | 0, i5) | 0) + i6 | 0;
      if (HEAP32[(HEAP32[i13 >> 2] | 0) + (i7 << 2) >> 2] | 0) {
       i4 = HEAP32[(HEAP32[i14 >> 2] | 0) + (i5 << 2) >> 2] & i8;
       i4 = i4 >> 16 ^ i4;
       if (!(HEAP32[i16 >> 2] | 0)) _partab_init();
       i2 = (HEAPU8[i17 + ((i4 >>> 8 ^ i4) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
       HEAP8[i18 + (i1 >>> 3) >> 0] = i2;
       i4 = HEAP32[i11 >> 2] | 0;
       i1 = i1 + 1 | 0;
      }
      i5 = i5 + 1 | 0;
     } while (i5 >>> 0 < i4 >>> 0);
     i5 = i4;
    }
    i6 = ((i6 + 1 | 0) >>> 0) % ((HEAP32[i12 >> 2] | 0) >>> 0) | 0;
    i9 = i9 + 1 | 0;
    if ((i9 | 0) == 8) {
     i4 = i8;
     break;
    } else {
     i7 = i5;
     i5 = i4;
     i4 = i8;
    }
   }
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i19 | 0));
  i5 = i6;
 }
 i11 = i20 + 32 | 0;
 if ((HEAP32[i11 >> 2] | 0) != 1) {
  i12 = i20 + 28 | 0;
  i13 = i20 + 36 | 0;
  i9 = i20 + 40 | 0;
  i10 = i20 + 24 | 0;
  i7 = HEAP32[i12 >> 2] | 0;
  i3 = i7;
  i8 = 0;
  while (1) {
   i4 = i4 << 1;
   if (!i7) {
    i6 = i3;
    i7 = 0;
   } else {
    i6 = 0;
    do {
     i15 = (Math_imul(HEAP32[i13 >> 2] | 0, i6) | 0) + i5 | 0;
     if (HEAP32[(HEAP32[i9 >> 2] | 0) + (i15 << 2) >> 2] | 0) {
      i3 = HEAP32[(HEAP32[i10 >> 2] | 0) + (i6 << 2) >> 2] & i4;
      i3 = i3 >> 16 ^ i3;
      if (!(HEAP32[i16 >> 2] | 0)) _partab_init();
      i2 = (HEAPU8[i17 + ((i3 >>> 8 ^ i3) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
      HEAP8[i18 + (i1 >>> 3) >> 0] = i2;
      i3 = HEAP32[i12 >> 2] | 0;
      i1 = i1 + 1 | 0;
     }
     i6 = i6 + 1 | 0;
    } while (i6 >>> 0 < i3 >>> 0);
    i6 = i3;
    i7 = i3;
   }
   i8 = i8 + 1 | 0;
   if (i8 >>> 0 >= ((HEAP32[i11 >> 2] | 0) + -1 | 0) >>> 0) break; else {
    i3 = i6;
    i5 = ((i5 + 1 | 0) >>> 0) % ((HEAP32[i13 >> 2] | 0) >>> 0) | 0;
   }
  }
 }
 if (i1 & 7) do {
  i2 = (i2 & 255) << 1 & 255;
  HEAP8[i18 + (i1 >>> 3) >> 0] = i2;
  i1 = i1 + 1 | 0;
 } while ((i1 & 7 | 0) != 0);
 if ((i1 | 0) == ((_fec_get_enc_msg_length(HEAP32[i20 >> 2] | 0, i19) | 0) << 3 | 0)) return; else ___assert_fail(gb + 12477 | 0, gb + 12532 | 0, 157, gb + 12565 | 0);
}

function _liquid_vectorcf_mulscalar(i22, i21, i19, i23) {
 i22 = i22 | 0;
 i21 = i21 | 0;
 i19 = i19 | 0;
 i23 = i23 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i20 = 0, i24 = 0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i9 = i24 + 32 | 0;
 i10 = i24 + 24 | 0;
 i15 = i24 + 16 | 0;
 i16 = i24 + 8 | 0;
 i20 = i24;
 i17 = i21 & -4;
 if (!i17) i1 = 0; else {
  d6 = +HEAPF32[i19 >> 2];
  d8 = +HEAPF32[i19 + 4 >> 2];
  i11 = i9 + 4 | 0;
  i12 = i10 + 4 | 0;
  i13 = i15 + 4 | 0;
  i14 = i16 + 4 | 0;
  i1 = i21 & -4;
  i18 = 0;
  do {
   d4 = +HEAPF32[i22 + (i18 << 3) >> 2];
   d5 = +HEAPF32[i22 + (i18 << 3) + 4 >> 2];
   d3 = d4 * d6 - d5 * d8;
   d2 = d5 * d6 + d4 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i9, d4, d5, d6, d8);
    d3 = +HEAPF32[i9 >> 2];
    d2 = +HEAPF32[i11 >> 2];
   }
   HEAPF32[i23 + (i18 << 3) >> 2] = d3;
   HEAPF32[i23 + (i18 << 3) + 4 >> 2] = d2;
   i7 = i18 | 1;
   d4 = +HEAPF32[i22 + (i7 << 3) >> 2];
   d5 = +HEAPF32[i22 + (i7 << 3) + 4 >> 2];
   d3 = d4 * d6 - d5 * d8;
   d2 = d5 * d6 + d4 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i10, d4, d5, d6, d8);
    d3 = +HEAPF32[i10 >> 2];
    d2 = +HEAPF32[i12 >> 2];
   }
   HEAPF32[i23 + (i7 << 3) >> 2] = d3;
   HEAPF32[i23 + (i7 << 3) + 4 >> 2] = d2;
   i7 = i18 | 2;
   d4 = +HEAPF32[i22 + (i7 << 3) >> 2];
   d5 = +HEAPF32[i22 + (i7 << 3) + 4 >> 2];
   d3 = d4 * d6 - d5 * d8;
   d2 = d5 * d6 + d4 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i15, d4, d5, d6, d8);
    d3 = +HEAPF32[i15 >> 2];
    d2 = +HEAPF32[i13 >> 2];
   }
   HEAPF32[i23 + (i7 << 3) >> 2] = d3;
   HEAPF32[i23 + (i7 << 3) + 4 >> 2] = d2;
   i7 = i18 | 3;
   d4 = +HEAPF32[i22 + (i7 << 3) >> 2];
   d5 = +HEAPF32[i22 + (i7 << 3) + 4 >> 2];
   d3 = d4 * d6 - d5 * d8;
   d2 = d5 * d6 + d4 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i16, d4, d5, d6, d8);
    d3 = +HEAPF32[i16 >> 2];
    d2 = +HEAPF32[i14 >> 2];
   }
   HEAPF32[i23 + (i7 << 3) >> 2] = d3;
   HEAPF32[i23 + (i7 << 3) + 4 >> 2] = d2;
   i18 = i18 + 4 | 0;
  } while (i18 >>> 0 < i17 >>> 0);
 }
 if (i1 >>> 0 >= i21 >>> 0) {
  STACKTOP = i24;
  return;
 }
 d8 = +HEAPF32[i19 >> 2];
 d6 = +HEAPF32[i19 + 4 >> 2];
 i7 = i20 + 4 | 0;
 do {
  d5 = +HEAPF32[i22 + (i1 << 3) >> 2];
  d4 = +HEAPF32[i22 + (i1 << 3) + 4 >> 2];
  d3 = d5 * d8 - d4 * d6;
  d2 = d4 * d8 + d5 * d6;
  if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___mulsc3(i20, d5, d4, d8, d6);
   d3 = +HEAPF32[i20 >> 2];
   d2 = +HEAPF32[i7 >> 2];
  }
  HEAPF32[i23 + (i1 << 3) >> 2] = d3;
  HEAPF32[i23 + (i1 << 3) + 4 >> 2] = d2;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i21 | 0));
 STACKTOP = i24;
 return;
}

function _csinhf(i12, i5) {
 i12 = i12 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i6 = 0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, d14 = 0.0, d15 = 0.0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i13 + 16 | 0;
 i2 = i13 + 8 | 0;
 i3 = i13;
 d7 = +HEAPF32[i5 >> 2];
 i4 = i5 + 4 | 0;
 d8 = +HEAPF32[i4 >> 2];
 i9 = (HEAPF32[tempDoublePtr >> 2] = d7, HEAP32[tempDoublePtr >> 2] | 0);
 d14 = +Math_abs(+d7);
 i6 = (HEAPF32[tempDoublePtr >> 2] = d14, HEAP32[tempDoublePtr >> 2] | 0);
 d14 = +Math_abs(+d8);
 i10 = (HEAPF32[tempDoublePtr >> 2] = d14, HEAP32[tempDoublePtr >> 2] | 0);
 i11 = (i6 | 0) < 2139095040;
 do if (i11 & (i10 | 0) < 2139095040) {
  if (!i10) {
   HEAPF32[i12 >> 2] = +_sinhf(d7);
   HEAPF32[i12 + 4 >> 2] = d8;
   break;
  }
  if ((i6 | 0) < 1091567616) {
   d15 = +_sinhf(d7) * +Math_cos(+d8);
   d14 = +_coshf(d7) * +Math_sin(+d8);
   HEAPF32[i12 >> 2] = d15;
   HEAPF32[i12 + 4 >> 2] = d14;
   break;
  }
  if ((i6 | 0) < 1118925336) {
   d14 = +Math_exp(+(+Math_abs(+d7))) * .5;
   d15 = d14 * +Math_sin(+d8);
   HEAPF32[i12 >> 2] = +_copysignf(d14, d7) * +Math_cos(+d8);
   HEAPF32[i12 + 4 >> 2] = d15;
   break;
  }
  if ((i6 | 0) < 1128313319) {
   HEAPF32[i3 >> 2] = +Math_abs(+d7);
   HEAPF32[i3 + 4 >> 2] = d8;
   HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   ___ldexp_cexpf(i2, i1, -1);
   i10 = HEAP32[i2 >> 2] | 0;
   i11 = HEAP32[i2 + 4 >> 2] | 0;
   HEAP32[i5 >> 2] = i10;
   HEAP32[i4 >> 2] = i11;
   d15 = (HEAP32[tempDoublePtr >> 2] = i10, +HEAPF32[tempDoublePtr >> 2]);
   HEAPF32[i12 >> 2] = d15 * +_copysignf(1.0, d7);
   HEAP32[i12 + 4 >> 2] = i11;
   break;
  } else {
   d14 = d7 * 1701411834604692317316873.0e14;
   d15 = d14 * d14 * +Math_sin(+d8);
   HEAPF32[i12 >> 2] = d14 * +Math_cos(+d8);
   HEAPF32[i12 + 4 >> 2] = d15;
   break;
  }
 } else {
  i2 = (i10 | 0) > 2139095039;
  if ((i6 | 0) == 0 & i2) {
   d15 = d8 - d8;
   HEAPF32[i12 >> 2] = +_copysignf(0.0, d7 * d15);
   HEAPF32[i12 + 4 >> 2] = d15;
   break;
  }
  i1 = (i6 | 0) > 2139095039;
  if (i1 & (i10 | 0) == 0) if (!(i9 & 8388607)) {
   HEAPF32[i12 >> 2] = d7;
   HEAPF32[i12 + 4 >> 2] = d8;
   break;
  } else {
   d15 = +_copysignf(0.0, d8);
   HEAPF32[i12 >> 2] = d7;
   HEAPF32[i12 + 4 >> 2] = d15;
   break;
  }
  if (i11 & i2) {
   d15 = d8 - d8;
   HEAPF32[i12 >> 2] = d15;
   HEAPF32[i12 + 4 >> 2] = d7 * d15;
   break;
  }
  if (!(i1 & (i9 & 8388607 | 0) == 0)) {
   d15 = d8 - d8;
   HEAPF32[i12 >> 2] = d7 * d7 * d15;
   HEAPF32[i12 + 4 >> 2] = (d7 + d7) * d15;
   break;
  }
  if (i2) {
   HEAPF32[i12 >> 2] = d7 * d7;
   HEAPF32[i12 + 4 >> 2] = d7 * (d8 - d8);
   break;
  } else {
   d14 = d7 * +Math_cos(+d8);
   d15 = +Math_sin(+d8) * inf;
   HEAPF32[i12 >> 2] = d14;
   HEAPF32[i12 + 4 >> 2] = d15;
   break;
  }
 } while (0);
 STACKTOP = i13;
 return;
}

function _fft_execute_rader(i15) {
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, i18 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i13 = i16;
 i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
 i14 = i15 + 40 | 0;
 if (i1 | 0) {
  i3 = i15 + 4 | 0;
  i4 = i15 + 48 | 0;
  i2 = 0;
  do {
   i17 = HEAP32[(HEAP32[i14 >> 2] | 0) + (i1 + ~i2 << 2) >> 2] | 0;
   i18 = HEAP32[i3 >> 2] | 0;
   i7 = HEAP32[i18 + (i17 << 3) + 4 >> 2] | 0;
   i12 = HEAP32[i4 >> 2] | 0;
   HEAP32[i12 + (i2 << 3) >> 2] = HEAP32[i18 + (i17 << 3) >> 2];
   HEAP32[i12 + (i2 << 3) + 4 >> 2] = i7;
   i2 = i2 + 1 | 0;
   i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
  } while (i1 >>> 0 > i2 >>> 0);
 }
 i18 = HEAP32[i15 + 56 >> 2] | 0;
 mftCall_vi(HEAP32[i18 + 28 >> 2] | 0, i18 | 0);
 if ((HEAP32[i15 >> 2] | 0) != 1) {
  i1 = i15 + 44 | 0;
  i2 = i15 + 52 | 0;
  i3 = i13 + 4 | 0;
  i12 = 0;
  do {
   i7 = HEAP32[i1 >> 2] | 0;
   d8 = +HEAPF32[i7 + (i12 << 3) >> 2];
   d9 = +HEAPF32[i7 + (i12 << 3) + 4 >> 2];
   i7 = HEAP32[i2 >> 2] | 0;
   i4 = i7 + (i12 << 3) | 0;
   d10 = +HEAPF32[i4 >> 2];
   i7 = i7 + (i12 << 3) + 4 | 0;
   d11 = +HEAPF32[i7 >> 2];
   d6 = d8 * d10 - d9 * d11;
   d5 = d9 * d10 + d8 * d11;
   if ((d6 != d6 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
    ___mulsc3(i13, d10, d11, d8, d9);
    d6 = +HEAPF32[i13 >> 2];
    d5 = +HEAPF32[i3 >> 2];
   }
   HEAPF32[i4 >> 2] = d6;
   HEAPF32[i7 >> 2] = d5;
   i12 = i12 + 1 | 0;
  } while (i12 >>> 0 < ((HEAP32[i15 >> 2] | 0) + -1 | 0) >>> 0);
 }
 i7 = HEAP32[i15 + 60 >> 2] | 0;
 mftCall_vi(HEAP32[i7 + 28 >> 2] | 0, i7 | 0);
 i7 = i15 + 8 | 0;
 i18 = HEAP32[i7 >> 2] | 0;
 HEAPF32[i18 >> 2] = 0.0;
 HEAPF32[i18 + 4 >> 2] = 0.0;
 if (HEAP32[i15 >> 2] | 0) {
  i2 = i15 + 4 | 0;
  i3 = 0;
  do {
   i17 = HEAP32[i2 >> 2] | 0;
   i18 = HEAP32[i7 >> 2] | 0;
   i1 = i18 + 4 | 0;
   d11 = +HEAPF32[i17 + (i3 << 3) + 4 >> 2] + +HEAPF32[i1 >> 2];
   HEAPF32[i18 >> 2] = +HEAPF32[i17 + (i3 << 3) >> 2] + +HEAPF32[i18 >> 2];
   HEAPF32[i1 >> 2] = d11;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i15 >> 2] | 0;
  } while (i3 >>> 0 < i1 >>> 0);
  i1 = i1 + -1 | 0;
  if (!i1) {
   STACKTOP = i16;
   return;
  }
 } else i1 = -1;
 i3 = i15 + 48 | 0;
 i4 = i15 + 4 | 0;
 i2 = 0;
 do {
  i18 = HEAP32[(HEAP32[i14 >> 2] | 0) + (i2 << 2) >> 2] | 0;
  i12 = HEAP32[i3 >> 2] | 0;
  d10 = +(i1 >>> 0);
  i13 = HEAP32[i4 >> 2] | 0;
  d11 = +HEAPF32[i12 + (i2 << 3) + 4 >> 2] / d10 + +HEAPF32[i13 + 4 >> 2];
  i17 = HEAP32[i7 >> 2] | 0;
  HEAPF32[i17 + (i18 << 3) >> 2] = +HEAPF32[i12 + (i2 << 3) >> 2] / d10 + +HEAPF32[i13 >> 2];
  HEAPF32[i17 + (i18 << 3) + 4 >> 2] = d11;
  i2 = i2 + 1 | 0;
  i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 STACKTOP = i16;
 return;
}

function _quiet_decoder_flush(i8) {
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i11;
 if (!i8) {
  i10 = 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 i2 = HEAP32[i8 + 96 >> 2] | 0;
 if (!i2) {
  i1 = i8 + 104 | 0;
  i5 = 0;
 } else {
  i13 = HEAP32[i8 + 36 >> 2] | 0;
  i6 = _calloc(i13, 4) | 0;
  i4 = i8 + 64 | 0;
  i12 = Math_imul(HEAP32[HEAP32[i4 >> 2] >> 2] | 0, HEAP32[i8 + 84 >> 2] | 0) | 0;
  i5 = i8 + 100 | 0;
  i1 = i8 + 104 | 0;
  i3 = HEAP32[i1 >> 2] | 0;
  _resamp_rrrf_execute_output_block(i2, i6, i13, i11 + 4 | 0, (HEAP32[i5 >> 2] | 0) + (i3 << 2) | 0, i12 - i3 | 0, i7) | 0;
  i2 = (HEAP32[i7 >> 2] | 0) + (HEAP32[i1 >> 2] | 0) | 0;
  HEAP32[i7 >> 2] = i2;
  i4 = HEAP32[i4 >> 2] | 0;
  i3 = (i2 >>> 0) % ((HEAP32[i4 >> 2] | 0) >>> 0) | 0;
  if (!i3) i3 = 0; else {
   i2 = i2 - i3 | 0;
   HEAP32[i7 >> 2] = i2;
  }
  i2 = _demodulator_recv(i4, HEAP32[i5 >> 2] | 0, i2, HEAP32[i8 + 80 >> 2] | 0) | 0;
  if (i3 | 0) {
   i13 = HEAP32[i5 >> 2] | 0;
   _memmove(i13 | 0, i13 + (HEAP32[i7 >> 2] << 2) | 0, i3 << 2 | 0) | 0;
  }
  HEAP32[i1 >> 2] = i3;
  _free(i6);
  i5 = i2;
 }
 i1 = HEAP32[i1 >> 2] | 0;
 i6 = i8 + 64 | 0;
 if (!i1) i1 = i5; else {
  i2 = HEAP32[i6 >> 2] | 0;
  i3 = HEAP32[i2 >> 2] | 0;
  i4 = i8 + 100 | 0;
  if ((i3 | 0) != (i1 | 0)) {
   _memset(HEAP32[i4 >> 2] | 0, 0, i3 - i1 << 2 | 0) | 0;
   i1 = HEAP32[i6 >> 2] | 0;
   i2 = i1;
   i1 = HEAP32[i1 >> 2] | 0;
  }
  i1 = (_demodulator_recv(i2, HEAP32[i4 >> 2] | 0, i1, (HEAP32[i8 + 80 >> 2] | 0) + (i5 << 3) | 0) | 0) + i5 | 0;
 }
 i13 = _demodulator_flush_symbol_len(HEAP32[i6 >> 2] | 0) | 0;
 i3 = i8 + 84 | 0;
 if (i13 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) ___assert_fail(gb + 9825 | 0, gb + 9883 | 0, 318, gb + 9921 | 0);
 i4 = i8 + 80 | 0;
 i1 = (_demodulator_flush(HEAP32[i6 >> 2] | 0, (HEAP32[i4 >> 2] | 0) + (i1 << 3) | 0) | 0) + i1 | 0;
 switch (HEAP32[i8 + 52 >> 2] | 0) {
 case 0:
  {
   _ofdmflexframesync_execute(HEAP32[i8 + 60 >> 2] | 0, HEAP32[i4 >> 2] | 0, i1);
   break;
  }
 case 1:
  {
   i2 = i1 + 60 | 0;
   if (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0) {
    i9 = 0;
    i10 = i1;
   } else ___assert_fail(gb + 9941 | 0, gb + 9883 | 0, 332, gb + 9921 | 0);
   while (1) {
    i13 = i9 + i10 | 0;
    i12 = HEAP32[i4 >> 2] | 0;
    HEAPF32[i12 + (i13 << 3) >> 2] = 0.0;
    HEAPF32[i12 + (i13 << 3) + 4 >> 2] = 0.0;
    i9 = i9 + 1 | 0;
    if ((i9 | 0) == 60) break; else i10 = i10 + 1 | 0;
   }
   _flexframesync_execute(HEAP32[i8 + 60 >> 2] | 0, HEAP32[i4 >> 2] | 0, i2);
   break;
  }
 case 2:
  {
   _gmskframesync_execute(HEAP32[i8 + 60 >> 2] | 0, HEAP32[i4 >> 2] | 0, i1);
   break;
  }
 default:
  {}
 }
 i13 = HEAP32[i8 + 76 >> 2] | 0;
 STACKTOP = i11;
 return i13 | 0;
}

function _liquid_cacosf(i13, i5) {
 i13 = i13 | 0;
 i5 = i5 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, d15 = 0.0, d16 = 0.0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i8 = i14 + 48 | 0;
 i9 = i14 + 8 | 0;
 i10 = i14;
 i6 = i14 + 40 | 0;
 i11 = i14 + 32 | 0;
 i7 = i14 + 24 | 0;
 i12 = i14 + 16 | 0;
 d4 = +HEAPF32[i5 >> 2];
 d3 = +HEAPF32[i5 + 4 >> 2];
 d1 = d4 * d3;
 d2 = d4 * d4 - d3 * d3;
 d1 = d1 + d1;
 i5 = (d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0);
 if (d4 > 0.0 ^ d3 > 0.0) {
  if (i5) {
   ___mulsc3(i7, d4, d3, d4, d3);
   d2 = +HEAPF32[i7 >> 2];
   d1 = +HEAPF32[i7 + 4 >> 2];
  }
  d15 = d2 + -1.0;
  HEAPF32[i9 >> 2] = d15;
  HEAPF32[i9 + 4 >> 2] = d1;
  HEAP32[i8 >> 2] = HEAP32[i9 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
  d2 = +_cabsf(i8);
  d16 = +Math_sqrt(+((d15 + d2) * .5));
  d15 = +Math_sqrt(+((d2 - d15) * .5));
  i11 = d1 > 0.0;
  d2 = d15 * 0.0;
  d2 = d4 - (d16 + (i11 ? d2 : -d2));
  d3 = d3 - (i11 ? d15 : -d15);
  HEAPF32[i9 >> 2] = d2;
  HEAPF32[i9 + 4 >> 2] = d3;
  HEAP32[i8 >> 2] = HEAP32[i9 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
  d4 = +Math_log(+(+_cabsf(i8)));
  HEAPF32[i10 >> 2] = d2;
  HEAPF32[i10 + 4 >> 2] = d3;
  HEAP32[i8 >> 2] = HEAP32[i10 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
  d3 = +_cargf(i8);
  d4 = d4 + d3 * 0.0;
  d2 = d3 - d4 * 0.0;
  d1 = d3 * -0.0 - d4;
  if ((d1 != d1 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___mulsc3(i12, -0.0, -1.0, d4, d3);
   d2 = +HEAPF32[i12 >> 2];
   d1 = +HEAPF32[i12 + 4 >> 2];
  }
  HEAPF32[i13 >> 2] = d2;
  HEAPF32[i13 + 4 >> 2] = d1;
  STACKTOP = i14;
  return;
 } else {
  if (i5) {
   ___mulsc3(i6, d4, d3, d4, d3);
   d2 = +HEAPF32[i6 >> 2];
   d1 = +HEAPF32[i6 + 4 >> 2];
  }
  d16 = d2 + -1.0;
  HEAPF32[i9 >> 2] = d16;
  HEAPF32[i9 + 4 >> 2] = d1;
  HEAP32[i8 >> 2] = HEAP32[i9 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
  d2 = +_cabsf(i8);
  d15 = +Math_sqrt(+((d16 + d2) * .5));
  d16 = +Math_sqrt(+((d2 - d16) * .5));
  i12 = d1 > 0.0;
  d2 = d16 * 0.0;
  d2 = d4 + (d15 + (i12 ? d2 : -d2));
  d3 = d3 + (i12 ? d16 : -d16);
  HEAPF32[i9 >> 2] = d2;
  HEAPF32[i9 + 4 >> 2] = d3;
  HEAP32[i8 >> 2] = HEAP32[i9 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
  d4 = +Math_log(+(+_cabsf(i8)));
  HEAPF32[i10 >> 2] = d2;
  HEAPF32[i10 + 4 >> 2] = d3;
  HEAP32[i8 >> 2] = HEAP32[i10 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
  d3 = +_cargf(i8);
  d4 = d4 + d3 * 0.0;
  d2 = d3 - d4 * 0.0;
  d1 = d3 * -0.0 - d4;
  if ((d1 != d1 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___mulsc3(i11, -0.0, -1.0, d4, d3);
   d2 = +HEAPF32[i11 >> 2];
   d1 = +HEAPF32[i11 + 4 >> 2];
  }
  HEAPF32[i13 >> 2] = d2;
  HEAPF32[i13 + 4 >> 2] = d1;
  STACKTOP = i14;
  return;
 }
}

function _flexframesync_execute_rxheader(i12, i1) {
 i12 = i12 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i10 = i13 + 24 | 0;
 i3 = i13 + 16 | 0;
 i2 = i13 + 8 | 0;
 i4 = i13;
 i8 = HEAP32[i1 + 4 >> 2] | 0;
 i11 = i12 + 92 | 0;
 i9 = HEAP32[i11 >> 2] | 0;
 HEAP32[i2 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i2 + 4 >> 2] = i8;
 HEAP32[i10 >> 2] = HEAP32[i2 >> 2];
 HEAP32[i10 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
 _nco_crcf_mix_down(i9, i10, i3);
 _nco_crcf_step(HEAP32[i11 >> 2] | 0);
 i9 = i12 + 100 | 0;
 i2 = HEAP32[i9 >> 2] | 0;
 i1 = i3 + 4 | 0;
 i8 = HEAP32[i1 >> 2] | 0;
 HEAP32[i4 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i4 + 4 >> 2] = i8;
 HEAP32[i10 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i10 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 _firpfb_crcf_push(i2, i10);
 _firpfb_crcf_execute(HEAP32[i9 >> 2] | 0, HEAP32[i12 + 112 >> 2] | 0, i3);
 i2 = i12 + 108 | 0;
 i4 = HEAP32[i2 >> 2] | 0;
 HEAP32[i2 >> 2] = i4 + 1;
 if ((i4 | 0) > -1) {
  i7 = HEAP32[i3 >> 2] | 0;
  i8 = HEAP32[i1 >> 2] | 0;
  HEAP32[i2 >> 2] = i4 + -1;
  i1 = i7;
  i2 = i8;
 } else {
  i1 = 0;
  i2 = 0;
 }
 if ((i4 | 0) < 0) {
  STACKTOP = i13;
  return;
 }
 i8 = i12 + 196 | 0;
 i7 = HEAP32[i8 >> 2] | 0;
 i6 = HEAP32[i12 + 124 >> 2] | 0;
 HEAP32[i6 + (i7 << 3) >> 2] = i1;
 HEAP32[i6 + (i7 << 3) + 4 >> 2] = i2;
 i7 = (HEAP32[i8 >> 2] | 0) + 1 | 0;
 HEAP32[i8 >> 2] = i7;
 if ((i7 | 0) != (HEAP32[i12 + 128 >> 2] | 0)) {
  STACKTOP = i13;
  return;
 }
 _flexframesync_decode_header(i12);
 i1 = i12 + 160 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  HEAP32[i8 >> 2] = 0;
  HEAP32[i12 + 200 >> 2] = 3;
  STACKTOP = i13;
  return;
 }
 i7 = i12 + 48 | 0;
 HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + 1;
 if (HEAP32[i12 >> 2] | 0) {
  i4 = i12 + 8 | 0;
  HEAPF32[i4 >> 2] = 0.0;
  HEAPF32[i12 + 12 >> 2] = +_log10f(+HEAPF32[i12 + 88 >> 2]) * 20.0;
  HEAPF32[i12 + 16 >> 2] = +_nco_crcf_get_frequency(HEAP32[i11 >> 2] | 0);
  i6 = i12 + 20 | 0;
  HEAP32[i6 >> 2] = 0;
  HEAP32[i6 + 4 >> 2] = 0;
  HEAP32[i6 + 8 >> 2] = 0;
  HEAP32[i6 + 12 >> 2] = 0;
  HEAP32[i6 + 16 >> 2] = 0;
  HEAP32[i6 + 20 >> 2] = 0;
  HEAP32[i6 + 24 >> 2] = 0;
  i6 = HEAP32[i12 >> 2] | 0;
  i7 = HEAP32[i12 + 156 >> 2] | 0;
  i1 = HEAP32[i1 >> 2] | 0;
  i2 = HEAP32[i12 + 4 >> 2] | 0;
  i3 = i10;
  i5 = i3 + 40 | 0;
  do {
   HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
   i3 = i3 + 4 | 0;
   i4 = i4 + 4 | 0;
  } while ((i3 | 0) < (i5 | 0));
  mftCall_iiiiiiii(i6 | 0, i7 | 0, i1 | 0, 0, 0, 0, i10 | 0, i2 | 0) | 0;
 }
 _nco_crcf_reset(HEAP32[i11 >> 2] | 0);
 _nco_crcf_reset(HEAP32[i12 + 96 >> 2] | 0);
 _firpfb_crcf_reset(HEAP32[i9 >> 2] | 0);
 HEAP32[i12 + 200 >> 2] = 0;
 HEAP32[i12 + 192 >> 2] = 0;
 HEAP32[i8 >> 2] = 0;
 HEAPF32[i12 + 8 >> 2] = 0.0;
 STACKTOP = i13;
 return;
}

function _modem_demodulate_apsk(i11, i1, i9) {
 i11 = i11 | 0;
 i1 = i1 | 0;
 i9 = i9 | 0;
 var I42 = SIMD_Int32x4(0, 0, 0, 0), d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i12 + 16 | 0;
 i4 = i12 + 8 | 0;
 i7 = i12;
 i10 = HEAP32[i1 >> 2] | 0;
 i8 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i4 >> 2] = i10;
 HEAP32[i4 + 4 >> 2] = i8;
 HEAP32[i6 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i6 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 d3 = +_cabsf(i6);
 i1 = (HEAP32[i11 + 100 >> 2] | 0) + -1 | 0;
 L1 : do if (!i1) i4 = 0; else {
  i4 = 0;
  while (1) {
   if (d3 < +HEAPF32[i11 + 168 + (i4 << 2) >> 2]) break L1;
   i4 = i4 + 1 | 0;
   if (i4 >>> 0 >= i1 >>> 0) {
    i4 = i1;
    break;
   }
  }
 } while (0);
 HEAP32[i7 >> 2] = i10;
 HEAP32[i7 + 4 >> 2] = i8;
 HEAP32[i6 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i6 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 d3 = +_cargf(i6);
 if (d3 < 0.0) d3 = d3 + 6.283185307179586;
 i1 = HEAP32[i11 + 104 + (i4 << 2) >> 2] | 0;
 i1 = (~~+_roundf(+((d3 - +HEAPF32[i11 + 200 + (i4 << 2) >> 2]) / (6.283185307179586 / +(i1 >>> 0)))) >>> 0 >>> 0) % (i1 >>> 0) | 0;
 do if (i4) {
  if (i4 >>> 0 >= 4 ? (i5 = i4 & -4, (i5 | 0) != 0) : 0) {
   i6 = 0;
   I42 = SIMD_Int32x4_replaceLane(SIMD_Int32x4_splat(0), 0, i1);
   do {
    I42 = SIMD_Int32x4_add(SIMD_Int32x4_load(HEAPU8, i11 + 104 + (i6 << 2) | 0), I42);
    i6 = i6 + 4 | 0;
   } while ((i6 | 0) != (i5 | 0));
   I42 = SIMD_Int32x4_add(I42, SIMD_Int32x4_swizzle(I42, 2, 3, 0, 0));
   i1 = SIMD_Int32x4_extractLane(SIMD_Int32x4_add(I42, SIMD_Int32x4_swizzle(I42, 1, 0, 0, 0)), 0) | 0;
   if ((i4 | 0) == (i5 | 0)) break;
  } else i5 = 0;
  do {
   i1 = (HEAP32[i11 + 104 + (i5 << 2) >> 2] | 0) + i1 | 0;
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i4 | 0));
 } while (0);
 i7 = i11 + 8 | 0;
 i5 = HEAP32[i7 >> 2] | 0;
 L20 : do if (!i5) i4 = 0; else {
  i6 = HEAP32[i11 + 232 >> 2] | 0;
  i4 = 0;
  while (1) {
   if ((HEAPU8[i6 + i4 >> 0] | 0 | 0) == (i1 | 0)) break L20;
   i4 = i4 + 1 | 0;
   if (i4 >>> 0 >= i5 >>> 0) {
    i4 = 0;
    break;
   }
  }
 } while (0);
 HEAP32[i9 >> 2] = i4;
 i1 = i11 + 92 | 0;
 if ((HEAP32[i7 >> 2] | 0) >>> 0 <= i4 >>> 0) {
  _fwrite(gb + 30864 | 0, 65, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!(HEAP32[i11 + 80 >> 2] | 0)) {
  mftCall_viii(HEAP32[i11 + 236 >> 2] | 0, i11 | 0, i4 | 0, i1 | 0);
  i9 = i11 + 84 | 0;
  i11 = i11 + 88 | 0;
  HEAP32[i9 >> 2] = i10;
  HEAP32[i11 >> 2] = i8;
  STACKTOP = i12;
  return;
 } else {
  i7 = HEAP32[i11 + 76 >> 2] | 0;
  i9 = HEAP32[i7 + (i4 << 3) + 4 >> 2] | 0;
  HEAP32[i1 >> 2] = HEAP32[i7 + (i4 << 3) >> 2];
  HEAP32[i11 + 96 >> 2] = i9;
  i9 = i11 + 84 | 0;
  i11 = i11 + 88 | 0;
  HEAP32[i9 >> 2] = i10;
  HEAP32[i11 >> 2] = i8;
  STACKTOP = i12;
  return;
 }
}

function _liquid_firdes_hM3(i17, i18, d16, d3, i20) {
 i17 = i17 | 0;
 i18 = i18 | 0;
 d16 = +d16;
 d3 = +d3;
 i20 = i20 | 0;
 var i1 = 0, i2 = 0, F44 = SIMD_Float32x4(0, 0, 0, 0), i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i19 = 0, d21 = 0.0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i8 = i19 + 48 | 0;
 i9 = i19 + 32 | 0;
 i14 = i19 + 20 | 0;
 i15 = i19 + 8 | 0;
 i10 = i19 + 4 | 0;
 i11 = i19;
 if (i17 >>> 0 < 2) {
  _fwrite(gb + 22975 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i18) {
  _fwrite(gb + 23029 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d16 < 0.0 | d16 > 1.0) {
  _fwrite(gb + 23083 | 0, 50, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i2 = i17 << 1;
 i7 = Math_imul(i2, i18) | 0 | 1;
 d21 = 1.0 / +(i2 >>> 0);
 d3 = d21;
 d12 = d16;
 HEAPF32[i8 >> 2] = 0.0;
 i2 = i8 + 4 | 0;
 HEAPF32[i2 >> 2] = d3 * (1.0 - d12);
 HEAPF32[i8 + 8 >> 2] = d21;
 HEAPF32[i8 + 12 >> 2] = d21;
 HEAPF32[i8 + 16 >> 2] = d3 * (d12 + 1.0);
 HEAPF32[i8 + 20 >> 2] = .5;
 HEAPF32[i9 >> 2] = 1.0;
 HEAPF32[i9 + 4 >> 2] = .7071067690849304;
 HEAPF32[i9 + 8 >> 2] = 0.0;
 HEAP32[i14 >> 2] = HEAP32[gb + 524 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[gb + 524 + 4 >> 2];
 HEAP32[i14 + 8 >> 2] = HEAP32[gb + 524 + 8 >> 2];
 HEAP32[i15 >> 2] = HEAP32[gb + 536 >> 2];
 HEAP32[i15 + 4 >> 2] = HEAP32[gb + 536 + 4 >> 2];
 HEAP32[i15 + 8 >> 2] = HEAP32[gb + 536 + 8 >> 2];
 i5 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i7 << 2) | 0) + 15 & -16) | 0;
 _firdespm_run(i7, 3, i8, i9, i14, i15, 0, i5);
 i6 = i7 << 2;
 _memcpy(i20 | 0, i5 | 0, i6 | 0) | 0;
 _liquid_filter_isi(i5, i17, i18, i11, i10);
 d12 = +HEAPF32[i11 >> 2];
 i13 = 0;
 do {
  HEAPF32[i2 >> 2] = d3 * (1.0 - +(i13 >>> 0) * d16 / 100.0);
  _firdespm_run(i7, 3, i8, i9, i14, i15, 0, i5);
  _liquid_filter_isi(i5, i17, i18, i11, i10);
  d21 = d12;
  d12 = +HEAPF32[i11 >> 2];
  if (d12 > d21) break;
  _memcpy(i20 | 0, i5 | 0, i6 | 0) | 0;
  i13 = i13 + 1 | 0;
 } while (i13 >>> 0 < 100);
 i5 = (Math_imul(i18, i17) | 0) << 1 | 1;
 d3 = 0.0;
 i2 = 0;
 do {
  d21 = +HEAPF32[i20 + (i2 << 2) >> 2];
  d3 = d3 + d21 * d21;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i5 | 0));
 d3 = +Math_sqrt(+(+(i17 >>> 0) / d3));
 i2 = (Math_imul(i18, i17) | 0) << 1;
 if (i2 >>> 0 >= 4 ? (i1 = i2 & -4, (i1 | 0) != 0) : 0) {
  F44 = SIMD_Float32x4_splat(Math_fround(d3));
  i2 = 0;
  do {
   i18 = i20 + (i2 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i18, SIMD_Float32x4_mul(F44, SIMD_Float32x4_load(HEAPU8, i18)));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  i18 = i20 + (i1 << 2) | 0;
  HEAPF32[i18 >> 2] = d3 * +HEAPF32[i18 >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i5 | 0));
 STACKTOP = i19;
 return;
}

function _flexframesync_decode_header(i10) {
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, d12 = 0.0, d13 = 0.0, i14 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i11;
 i1 = i10 + 132 | 0;
 i8 = i10 + 136 | 0;
 _qpilotsync_execute(HEAP32[i1 >> 2] | 0, HEAP32[i10 + 124 >> 2] | 0, HEAP32[i8 >> 2] | 0);
 i2 = i10 + 156 | 0;
 i8 = _qpacketmodem_decode(HEAP32[i10 + 144 >> 2] | 0, HEAP32[i8 >> 2] | 0, HEAP32[i2 >> 2] | 0) | 0;
 i9 = i10 + 160 | 0;
 HEAP32[i9 >> 2] = i8;
 if (!i8) {
  STACKTOP = i11;
  return;
 }
 d12 = +_qpilotsync_get_dphi(HEAP32[i1 >> 2] | 0);
 d13 = +_qpilotsync_get_phi(HEAP32[i1 >> 2] | 0);
 i8 = i10 + 96 | 0;
 _nco_crcf_set_frequency(HEAP32[i8 >> 2] | 0, d12);
 _nco_crcf_set_phase(HEAP32[i8 >> 2] | 0, d13 + d12 * +((HEAP32[i10 + 128 >> 2] | 0) >>> 0));
 i8 = HEAP32[i10 + 148 >> 2] | 0;
 i7 = HEAP32[i2 >> 2] | 0;
 i1 = HEAP8[i7 + i8 >> 0] | 0;
 if (i1 << 24 >> 24 != 101) {
  i10 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i3 >> 2] = i1 & 255;
  HEAP32[i3 + 4 >> 2] = 101;
  _fprintf(i10, gb + 25295 | 0, i3) | 0;
  HEAP32[i9 >> 2] = 0;
  STACKTOP = i11;
  return;
 }
 i2 = (HEAPU8[i7 + (i8 + 1) >> 0] | 0) << 8 | (HEAPU8[i7 + (i8 + 2) >> 0] | 0);
 i3 = i10 + 184 | 0;
 HEAP32[i3 >> 2] = i2;
 i14 = HEAP8[i7 + (i8 + 3) >> 0] | 0;
 i4 = i14 & 255;
 i6 = HEAPU8[i7 + (i8 + 4) >> 0] | 0;
 i5 = i6 >>> 5;
 i6 = i6 & 31;
 i1 = (HEAPU8[i7 + (i8 + 5) >> 0] | 0) & 31;
 if ((i14 + -1 & 255) > 58) {
  _fwrite(gb + 25378 | 0, 66, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i9 >> 2] = 0;
  STACKTOP = i11;
  return;
 }
 switch (i5 | 0) {
 case 0:
 case 7:
  {
   _fwrite(gb + 25445 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   HEAP32[i9 >> 2] = 0;
   STACKTOP = i11;
   return;
  }
 default:
  {}
 }
 if ((i6 + -1 | 0) >>> 0 > 26) {
  _fwrite(gb + 25516 | 0, 78, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i9 >> 2] = 0;
  STACKTOP = i11;
  return;
 }
 if ((i1 + -1 | 0) >>> 0 > 26) {
  _fwrite(gb + 25595 | 0, 78, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i9 >> 2] = 0;
  STACKTOP = i11;
  return;
 }
 i8 = i10 + 164 | 0;
 HEAP32[i8 >> 2] = _modem_recreate(HEAP32[i8 >> 2] | 0, i4) | 0;
 i8 = i10 + 176 | 0;
 _qpacketmodem_configure(HEAP32[i8 >> 2] | 0, i2, i5, i6, i1, i4) | 0;
 i8 = _qpacketmodem_get_frame_len(HEAP32[i8 >> 2] | 0) | 0;
 HEAP32[i10 + 172 >> 2] = i8;
 i14 = i10 + 168 | 0;
 HEAP32[i14 >> 2] = _realloc(HEAP32[i14 >> 2] | 0, i8 << 3) | 0;
 i8 = i10 + 180 | 0;
 i10 = _realloc(HEAP32[i8 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
 HEAP32[i8 >> 2] = i10;
 if (!((i10 | 0) == 0 | (HEAP32[i14 >> 2] | 0) == 0)) {
  STACKTOP = i11;
  return;
 }
 _fwrite(gb + 25674 | 0, 75, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
 HEAP32[i9 >> 2] = 0;
 STACKTOP = i11;
 return;
}

function _gmskframesync_update_symsync(i12, d2, i13) {
 i12 = i12 | 0;
 d2 = +d2;
 i13 = i13 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, d9 = 0.0, i10 = 0, i11 = 0, i14 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i3 = i15 + 24 | 0;
 i14 = i15 + 20 | 0;
 i8 = i15 + 16 | 0;
 i4 = i15 + 8 | 0;
 i5 = i15;
 i6 = i12 + 76 | 0;
 _firpfb_rrrf_push(HEAP32[i6 >> 2] | 0, d2);
 i7 = i12 + 80 | 0;
 _firpfb_rrrf_push(HEAP32[i7 >> 2] | 0, d2);
 HEAPF32[i14 >> 2] = 0.0;
 HEAPF32[i8 >> 2] = 0.0;
 if (HEAP32[i12 + 232 >> 2] | 0) {
  _windowf_push(HEAP32[i12 + 244 >> 2] | 0, +HEAPF32[i12 + 72 >> 2]);
  _firpfb_rrrf_execute(HEAP32[i6 >> 2] | 0, HEAP32[i12 + 96 >> 2] | 0, i14);
  _windowf_push(HEAP32[i12 + 248 >> 2] | 0, +HEAPF32[i14 >> 2]);
 }
 i11 = i12 + 100 | 0;
 i1 = HEAP32[i11 >> 2] | 0;
 if ((i1 | 0) >= 1) {
  i8 = i1;
  i10 = 0;
  i8 = i8 + -1 | 0;
  HEAP32[i11 >> 2] = i8;
  d2 = +HEAPF32[i14 >> 2];
  i14 = i12 + 4 | 0;
  i14 = HEAP32[i14 >> 2] | 0;
  d9 = +(i14 >>> 0);
  d9 = d2 / d9;
  HEAPF32[i13 >> 2] = d9;
  STACKTOP = i15;
  return i10 | 0;
 }
 HEAP32[i11 >> 2] = 2;
 i10 = i12 + 96 | 0;
 _firpfb_rrrf_execute(HEAP32[i6 >> 2] | 0, HEAP32[i10 >> 2] | 0, i14);
 _firpfb_rrrf_execute(HEAP32[i7 >> 2] | 0, HEAP32[i10 >> 2] | 0, i8);
 i6 = i12 + 88 | 0;
 d2 = +HEAPF32[i6 >> 2] * .9900000095367432;
 HEAP32[i5 >> 2] = HEAP32[i14 >> 2];
 HEAPF32[i5 + 4 >> 2] = 0.0;
 HEAP32[i3 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i3 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 _conjf(i4, i3);
 d2 = d2 + +HEAPF32[i4 >> 2] * +HEAPF32[i8 >> 2] * .05000000074505806;
 HEAPF32[i6 >> 2] = d2;
 i6 = i12 + 92 | 0;
 d2 = +HEAPF32[i6 >> 2] + d2;
 HEAPF32[i6 >> 2] = d2;
 i3 = ~~+_roundf(+d2);
 HEAP32[i10 >> 2] = i3;
 i5 = HEAP32[i12 + 84 >> 2] | 0;
 if ((i3 | 0) < 0) {
  d9 = +(i5 >>> 0);
  i1 = HEAP32[i11 >> 2] | 0;
  do {
   i3 = i5 + i3 | 0;
   d2 = d9 + d2;
   i1 = i1 + -1 | 0;
  } while ((i3 | 0) < 0);
  HEAP32[i10 >> 2] = i3;
  HEAPF32[i6 >> 2] = d2;
  HEAP32[i11 >> 2] = i1;
 }
 i4 = i5 + -1 | 0;
 if (i3 >>> 0 <= i4 >>> 0) {
  i8 = HEAP32[i11 >> 2] | 0;
  i10 = 1;
  i8 = i8 + -1 | 0;
  HEAP32[i11 >> 2] = i8;
  d2 = +HEAPF32[i14 >> 2];
  i14 = i12 + 4 | 0;
  i14 = HEAP32[i14 >> 2] | 0;
  d9 = +(i14 >>> 0);
  d9 = d2 / d9;
  HEAPF32[i13 >> 2] = d9;
  STACKTOP = i15;
  return i10 | 0;
 }
 d9 = +(i5 >>> 0);
 i1 = HEAP32[i11 >> 2] | 0;
 do {
  i3 = i3 - i5 | 0;
  d2 = d2 - d9;
  i1 = i1 + 1 | 0;
 } while (i3 >>> 0 > i4 >>> 0);
 HEAP32[i10 >> 2] = i3;
 HEAPF32[i6 >> 2] = d2;
 HEAP32[i11 >> 2] = i1;
 i8 = i1;
 i10 = 1;
 i8 = i8 + -1 | 0;
 HEAP32[i11 >> 2] = i8;
 d2 = +HEAPF32[i14 >> 2];
 i14 = i12 + 4 | 0;
 i14 = HEAP32[i14 >> 2] | 0;
 d9 = +(i14 >>> 0);
 d9 = d2 / d9;
 HEAPF32[i13 >> 2] = d9;
 STACKTOP = i15;
 return i10 | 0;
}

function _firdespm_compute_taps(i17, i22) {
 i17 = i17 | 0;
 i22 = i22 | 0;
 var i1 = 0, F42 = SIMD_Float32x4(0, 0, 0, 0), i3 = 0, d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i23 = 0;
 i23 = STACKTOP;
 _firdespm_compute_interp(i17);
 i20 = i17 + 12 | 0;
 i5 = HEAP32[i20 >> 2] | 0;
 i19 = i17 + 4 | 0;
 i3 = HEAP32[i19 >> 2] | 0;
 i18 = i5 - i3 | 0;
 i16 = i18 + 1 | 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i16 << 3) | 0) + 15 & -16) | 0;
 L1 : do if (!i16) i3 = HEAP32[i17 + 28 >> 2] | 0; else {
  i15 = i17 + 64 | 0;
  i16 = i17 + 72 | 0;
  i13 = i17 + 68 | 0;
  i14 = i17 + 28 | 0;
  i11 = i5 + 1 - i3 | 0;
  i7 = 0;
  while (1) {
   d4 = +(i7 >>> 0);
   d6 = +Math_cos(+(d4 / +((HEAP32[i17 >> 2] | 0) >>> 0) * 6.283185307179586));
   d6 = +_poly_val_lagrange_barycentric(HEAP32[i15 >> 2] | 0, HEAP32[i16 >> 2] | 0, HEAP32[i13 >> 2] | 0, d6, i5 + 1 | 0);
   i3 = HEAP32[i14 >> 2] | 0;
   if ((i3 | 0) == 0 ? (HEAP32[i19 >> 2] | 0) == 0 : 0) d4 = +Math_cos(+(d4 * 3.141592653589793 / +((HEAP32[i17 >> 2] | 0) >>> 0))); else d4 = 1.0;
   HEAPF64[i21 + (i7 << 3) >> 3] = d6 * d4;
   i7 = i7 + 1 | 0;
   if ((i7 | 0) == (i11 | 0)) break L1;
   i5 = HEAP32[i20 >> 2] | 0;
  }
 } while (0);
 if (i3 | 0) switch (HEAP32[i19 >> 2] | 0) {
 case 1:
  {
   _fwrite(gb + 22279 | 0, 73, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   STACKTOP = i23;
   return;
  }
 case 0:
  {
   _fwrite(gb + 22279 | 0, 73, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   STACKTOP = i23;
   return;
  }
 default:
  {
   STACKTOP = i23;
   return;
  }
 }
 i7 = HEAP32[i17 >> 2] | 0;
 if (!i7) {
  STACKTOP = i23;
  return;
 }
 d12 = +HEAPF64[i21 >> 3];
 d10 = +(i18 >>> 0);
 d8 = +((1 - (HEAP32[i19 >> 2] | 0) | 0) >>> 0) * .5;
 i3 = HEAP32[i20 >> 2] | 0;
 d9 = +(i7 >>> 0);
 if (i3 >>> 0 > 1) {
  i1 = 0;
  while (1) {
   d6 = (+(i1 >>> 0) - d10 + d8) / d9 * 6.283185307179586;
   i5 = 1;
   d4 = d12;
   do {
    d4 = d4 + +HEAPF64[i21 + (i5 << 3) >> 3] * 2.0 * +Math_cos(+(d6 * +(i5 >>> 0)));
    i5 = i5 + 1 | 0;
   } while (i5 >>> 0 < i3 >>> 0);
   HEAPF32[i22 + (i1 << 2) >> 2] = d4 / d9;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= i7 >>> 0) break;
   i3 = HEAP32[i20 >> 2] | 0;
  }
  STACKTOP = i23;
  return;
 }
 d4 = d12 / d9;
 if (i7 >>> 0 >= 4 ? (i1 = i7 & -4, (i1 | 0) != 0) : 0) {
  F42 = SIMD_Float32x4_splat(Math_fround(d4));
  i3 = 0;
  do {
   SIMD_Float32x4_store(HEAPU8, i22 + (i3 << 2) | 0, F42);
   i3 = i3 + 4 | 0;
  } while ((i3 | 0) != (i1 | 0));
  if ((i7 | 0) == (i1 | 0)) {
   STACKTOP = i23;
   return;
  }
 } else i1 = 0;
 do {
  HEAPF32[i22 + (i1 << 2) >> 2] = d4;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i7 >>> 0);
 STACKTOP = i23;
 return;
}

function _fec_secded3932_encode(i1, i17, i11, i15) {
 i1 = i1 | 0;
 i17 = i17 | 0;
 i11 = i11 | 0;
 i15 = i15 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i18 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i12 = i16;
 i13 = i16 + 4 | 0;
 i14 = i17 & 3;
 i10 = i17 - i14 | 0;
 if ((i14 | 0) == (i17 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i9 = i11 + i2 | 0;
   i5 = HEAP8[i9 >> 0] | 0;
   i6 = HEAP8[i9 + 1 >> 0] | 0;
   i7 = HEAP8[i9 + 2 >> 0] | 0;
   i4 = HEAP8[i9 + 3 >> 0] | 0;
   i8 = 0;
   i3 = 0;
   do {
    i18 = i8 << 2;
    i3 = (HEAPU8[(HEAP8[(i18 | 1) + (gb + 18416) >> 0] & i6 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[gb + 18416 + i18 >> 0] & i5 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 2) + (gb + 18416) >> 0] & i7 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 3) + (gb + 18416) >> 0] & i4 & 255) + (gb + 38499) >> 0] | 0) & 1 | i3 << 1 & 510;
    i8 = i8 + 1 | 0;
   } while ((i8 | 0) != 7);
   HEAP8[i15 + i1 >> 0] = i3;
   HEAP8[i15 + (i1 + 1) >> 0] = HEAP8[i9 >> 0] | 0;
   HEAP8[i15 + (i1 + 2) >> 0] = HEAP8[i11 + (i2 | 1) >> 0] | 0;
   HEAP8[i15 + (i1 + 3) >> 0] = HEAP8[i11 + (i2 | 2) >> 0] | 0;
   HEAP8[i15 + (i1 + 4) >> 0] = HEAP8[i11 + (i2 | 3) >> 0] | 0;
   i1 = i1 + 5 | 0;
   i2 = i2 + 4 | 0;
  } while (i2 >>> 0 < i10 >>> 0);
 }
 if (i14) {
  HEAP32[i12 >> 2] = 0;
  _memcpy(i12 | 0, i11 + i2 | 0, i17 & 3 | 0) | 0;
  i10 = HEAP32[i12 >> 2] | 0;
  i5 = i10 & 255;
  i6 = (i10 & 65535) >>> 8 & 255;
  i8 = i10 >>> 16 & 255;
  i9 = i10 >>> 24 & 255;
  i10 = i10 & 255;
  i7 = (HEAPU16[i12 >> 1] | 0) >>> 8 & 255;
  i4 = 0;
  i3 = 0;
  do {
   i18 = i4 << 2;
   i3 = (HEAPU8[(HEAP8[(i18 | 1) + (gb + 18416) >> 0] & i6 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[gb + 18416 + i18 >> 0] & i5 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 2) + (gb + 18416) >> 0] & i8 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 3) + (gb + 18416) >> 0] & i9 & 255) + (gb + 38499) >> 0] | 0) & 1 | i3 << 1 & 510;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != 7);
  i12 = i3 & 255;
  HEAP8[i13 >> 0] = i12;
  i18 = i13 + 1 | 0;
  HEAP8[i18 >> 0] = i10;
  HEAP8[i13 + 2 >> 0] = i7;
  HEAP8[i13 + 3 >> 0] = i8;
  HEAP8[i13 + 4 >> 0] = i9;
  HEAP8[i15 + i1 >> 0] = i12;
  _memcpy(i15 + (i1 + 1) | 0, i18 | 0, i17 & 3 | 0) | 0;
  i2 = i2 | i14;
  i1 = i14 + 1 + i1 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(9, i17) | 0)) ___assert_fail(gb + 18483 | 0, gb + 18547 | 0, 296, gb + 18576 | 0);
 if ((i2 | 0) == (i17 | 0)) {
  STACKTOP = i16;
  return;
 } else ___assert_fail(gb + 18871 | 0, gb + 18547 | 0, 297, gb + 18576 | 0);
}

function _ofdmflexframesync_rxheader(i15, i9) {
 i15 = i15 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, d17 = 0.0, i18 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i13 = i16 + 16 | 0;
 i10 = i16;
 i3 = i16 + 8 | 0;
 i1 = HEAP32[i15 >> 2] | 0;
 if (!i1) {
  STACKTOP = i16;
  return;
 }
 i4 = i15 + 12 | 0;
 i5 = i15 + 36 | 0;
 i6 = i3 + 4 | 0;
 i7 = i15 + 196 | 0;
 i8 = i15 + 52 | 0;
 i14 = i15 + 180 | 0;
 i12 = i15 + 68 | 0;
 i2 = 0;
 while (1) {
  if ((HEAP8[(HEAP32[i4 >> 2] | 0) + i2 >> 0] | 0) == 2) {
   i1 = HEAP32[i5 >> 2] | 0;
   i18 = HEAP32[i9 + (i2 << 3) + 4 >> 2] | 0;
   HEAP32[i3 >> 2] = HEAP32[i9 + (i2 << 3) >> 2];
   HEAP32[i6 >> 2] = i18;
   HEAP32[i13 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i13 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   _modem_demodulate(i1, i13, i10);
   HEAP8[(HEAP32[i8 >> 2] | 0) + (HEAP32[i7 >> 2] | 0) >> 0] = HEAP32[i10 >> 2];
   HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + 1;
   d17 = +_modem_get_demodulator_evm(HEAP32[i5 >> 2] | 0);
   HEAPF32[i14 >> 2] = +HEAPF32[i14 >> 2] + d17 * d17;
   if ((HEAP32[i7 >> 2] | 0) == (HEAP32[i12 >> 2] | 0)) break;
   i1 = HEAP32[i15 >> 2] | 0;
  }
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= i1 >>> 0) {
   i11 = 10;
   break;
  }
 }
 if ((i11 | 0) == 10) {
  STACKTOP = i16;
  return;
 }
 _ofdmflexframesync_decode_header(i15);
 i9 = i15 + 140 | 0;
 HEAPF32[i9 >> 2] = +_log10f(+HEAPF32[i14 >> 2] / +((HEAP32[i12 >> 2] | 0) >>> 0)) * 10.0;
 i1 = i15 + 72 | 0;
 if (!(HEAP32[i1 >> 2] | 0)) {
  i6 = i15 + 184 | 0;
  HEAPF32[i15 + 144 >> 2] = +_ofdmframesync_get_rssi(HEAP32[i6 >> 2] | 0);
  HEAPF32[i15 + 148 >> 2] = +_ofdmframesync_get_cfo(HEAP32[i6 >> 2] | 0);
  i7 = i15 + 152 | 0;
  HEAP32[i7 >> 2] = 0;
  HEAP32[i7 + 4 >> 2] = 0;
  HEAP32[i7 + 8 >> 2] = 0;
  HEAP32[i7 + 12 >> 2] = 0;
  HEAP32[i7 + 16 >> 2] = 0;
  HEAP32[i7 + 20 >> 2] = 0;
  HEAP32[i7 + 24 >> 2] = 0;
  i7 = HEAP32[i15 + 132 >> 2] | 0;
  i8 = HEAP32[i15 + 44 >> 2] | 0;
  i1 = HEAP32[i1 >> 2] | 0;
  i2 = HEAP32[i15 + 136 >> 2] | 0;
  i3 = i13;
  i4 = i9;
  i5 = i3 + 40 | 0;
  do {
   HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
   i3 = i3 + 4 | 0;
   i4 = i4 + 4 | 0;
  } while ((i3 | 0) < (i5 | 0));
  mftCall_iiiiiiii(i7 | 0, i8 | 0, i1 | 0, 0, 0, 0, i13 | 0, i2 | 0) | 0;
  i18 = i15 + 188 | 0;
  HEAP32[i18 >> 2] = 0;
  HEAP32[i18 + 4 >> 2] = 0;
  HEAP32[i18 + 8 >> 2] = 0;
  HEAP32[i18 + 12 >> 2] = 0;
  HEAP32[i18 + 16 >> 2] = 0;
  HEAPF32[i14 >> 2] = 9.999999960041972e-13;
  _framesyncstats_init_default(i9);
  _ofdmframesync_reset(HEAP32[i6 >> 2] | 0);
  STACKTOP = i16;
  return;
 } else {
  HEAP32[i15 + 192 >> 2] = 1;
  STACKTOP = i16;
  return;
 }
}

function _gmskframesync_debug_print(i4, i7) {
 i4 = i4 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, d12 = 0.0, d13 = 0.0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 i9 = i11 + 80 | 0;
 i8 = i11 + 64 | 0;
 i5 = i11 + 48 | 0;
 i10 = i11 + 24 | 0;
 i3 = i11 + 16 | 0;
 i2 = i11 + 8 | 0;
 i1 = i11;
 if (!(HEAP32[i4 + 236 >> 2] | 0)) {
  _fwrite(gb + 27267 | 0, 86, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  STACKTOP = i11;
  return;
 }
 i6 = _fopen(i7, gb + 36126 | 0) | 0;
 if (!i6) {
  i10 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = i7;
  _fprintf(i10, gb + 27354 | 0, i1) | 0;
  STACKTOP = i11;
  return;
 }
 HEAP32[i2 >> 2] = i7;
 _fprintf(i6, gb + 27423 | 0, i2) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fwrite(gb + 36265 | 0, 11, 1, i6) | 0;
 _fwrite(gb + 27450 | 0, 12, 1, i6) | 0;
 HEAP32[i3 >> 2] = 2e3;
 _fprintf(i6, gb + 27463 | 0, i3) | 0;
 _fwrite(gb + 27482 | 0, 23, 1, i6) | 0;
 _fwrite(gb + 27506 | 0, 26, 1, i6) | 0;
 _windowcf_read(HEAP32[i4 + 240 >> 2] | 0, i3);
 i1 = 0;
 do {
  i2 = HEAP32[i3 >> 2] | 0;
  d13 = +HEAPF32[i2 + (i1 << 3) >> 2];
  d12 = +HEAPF32[i2 + (i1 << 3) + 4 >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i10 >> 2] = i1;
  HEAPF64[i10 + 8 >> 3] = d13;
  HEAPF64[i10 + 16 >> 3] = d12;
  _fprintf(i6, gb + 36520 | 0, i10) | 0;
 } while ((i1 | 0) != 2e3);
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fwrite(gb + 36549 | 0, 8, 1, i6) | 0;
 _fwrite(gb + 27533 | 0, 48, 1, i6) | 0;
 _fwrite(gb + 36623 | 0, 30, 1, i6) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fwrite(gb + 27582 | 0, 27, 1, i6) | 0;
 _windowf_read(HEAP32[i4 + 244 >> 2] | 0, i10);
 i1 = 0;
 do {
  d13 = +HEAPF32[(HEAP32[i10 >> 2] | 0) + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i5 >> 2] = i1;
  HEAPF64[i5 + 8 >> 3] = d13;
  _fprintf(i6, gb + 27610 | 0, i5) | 0;
 } while ((i1 | 0) != 2e3);
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fwrite(gb + 36549 | 0, 8, 1, i6) | 0;
 _fwrite(gb + 27629 | 0, 23, 1, i6) | 0;
 _fwrite(gb + 27653 | 0, 23, 1, i6) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fwrite(gb + 27677 | 0, 27, 1, i6) | 0;
 _windowf_read(HEAP32[i4 + 248 >> 2] | 0, i10);
 i1 = 0;
 do {
  d13 = +HEAPF32[(HEAP32[i10 >> 2] | 0) + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
  HEAP32[i8 >> 2] = i1;
  HEAPF64[i8 + 8 >> 3] = d13;
  _fprintf(i6, gb + 27705 | 0, i8) | 0;
 } while ((i1 | 0) != 2e3);
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fwrite(gb + 36549 | 0, 8, 1, i6) | 0;
 _fwrite(gb + 27724 | 0, 23, 1, i6) | 0;
 _fwrite(gb + 27748 | 0, 21, 1, i6) | 0;
 _fwrite(gb + 36694 | 0, 2, 1, i6) | 0;
 _fclose(i6) | 0;
 HEAP32[i9 >> 2] = i7;
 _printf(gb + 27770 | 0, i9) | 0;
 STACKTOP = i11;
 return;
}

function _modem_arb_init(i9, i4, i3) {
 i9 = i9 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, d2 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, d8 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, d16 = 0.0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i10 = i13 + 8 | 0;
 i11 = i13;
 if ((HEAP32[i9 >> 2] | 0) != 59) {
  _fwrite(gb + 31580 | 0, 56, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i12 = i9 + 8 | 0;
 if ((HEAP32[i12 >> 2] | 0) != (i3 | 0)) {
  _fwrite(gb + 31637 | 0, 50, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i3) {
  i1 = i9 + 76 | 0;
  i5 = 0;
  do {
   i15 = HEAP32[i4 + (i5 << 3) + 4 >> 2] | 0;
   i14 = HEAP32[i1 >> 2] | 0;
   HEAP32[i14 + (i5 << 3) >> 2] = HEAP32[i4 + (i5 << 3) >> 2];
   HEAP32[i14 + (i5 << 3) + 4 >> 2] = i15;
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i3 | 0));
  if ((HEAP32[i9 >> 2] | 0) != 59) i1 = HEAP32[i12 >> 2] | 0; else i7 = 10;
 } else i7 = 10;
 if ((i7 | 0) == 10) {
  i3 = HEAP32[i12 >> 2] | 0;
  if (!i3) {
   STACKTOP = i13;
   return;
  }
  i5 = i9 + 76 | 0;
  i4 = HEAP32[i5 >> 2] | 0;
  i1 = 0;
  d2 = 0.0;
  d6 = 0.0;
  do {
   d2 = d2 + +HEAPF32[i4 + (i1 << 3) >> 2];
   d6 = d6 + +HEAPF32[i4 + (i1 << 3) + 4 >> 2];
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i3 | 0));
  d16 = +(i3 >>> 0);
  d8 = d2 / d16;
  d2 = d6 / d16;
  i1 = i4 + 4 | 0;
  d6 = +HEAPF32[i1 >> 2] - d2;
  HEAPF32[i4 >> 2] = +HEAPF32[i4 >> 2] - d8;
  HEAPF32[i1 >> 2] = d6;
  i1 = HEAP32[i12 >> 2] | 0;
  if (i1 >>> 0 > 1) {
   i3 = 1;
   do {
    i1 = HEAP32[i5 >> 2] | 0;
    i15 = i1 + (i3 << 3) | 0;
    i1 = i1 + (i3 << 3) + 4 | 0;
    d16 = +HEAPF32[i1 >> 2] - d2;
    HEAPF32[i15 >> 2] = +HEAPF32[i15 >> 2] - d8;
    HEAPF32[i1 >> 2] = d16;
    i3 = i3 + 1 | 0;
    i1 = HEAP32[i12 >> 2] | 0;
   } while (i3 >>> 0 < i1 >>> 0);
  }
 }
 if (!i1) {
  STACKTOP = i13;
  return;
 }
 i5 = i9 + 76 | 0;
 i3 = i11 + 4 | 0;
 d2 = 0.0;
 i4 = 0;
 do {
  i15 = HEAP32[i5 >> 2] | 0;
  i1 = HEAP32[i15 + (i4 << 3) + 4 >> 2] | 0;
  HEAP32[i11 >> 2] = HEAP32[i15 + (i4 << 3) >> 2];
  HEAP32[i3 >> 2] = i1;
  HEAP32[i10 >> 2] = HEAP32[i11 >> 2];
  HEAP32[i10 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
  d16 = +_cabsf(i10);
  d2 = d2 + d16 * d16;
  i4 = i4 + 1 | 0;
  i1 = HEAP32[i12 >> 2] | 0;
 } while (i4 >>> 0 < i1 >>> 0);
 d2 = +Math_sqrt(+(d2 / +(i1 >>> 0)));
 if (!i1) {
  STACKTOP = i13;
  return;
 } else i1 = 0;
 do {
  i15 = HEAP32[i5 >> 2] | 0;
  i14 = i15 + (i1 << 3) | 0;
  i15 = i15 + (i1 << 3) + 4 | 0;
  d16 = +HEAPF32[i15 >> 2] / d2;
  HEAPF32[i14 >> 2] = +HEAPF32[i14 >> 2] / d2;
  HEAPF32[i15 >> 2] = d16;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < (HEAP32[i12 >> 2] | 0) >>> 0);
 STACKTOP = i13;
 return;
}

function _iirfilt_crcf_create(i8, i9, i13, i5) {
 i8 = i8 | 0;
 i9 = i9 | 0;
 i13 = i13 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, F44 = SIMD_Float32x4(0, 0, 0, 0), i6 = 0, i7 = 0, d10 = 0.0, i11 = 0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i16 + 8 | 0;
 i2 = i16;
 if (!i9) {
  i15 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 19656;
  _fprintf(i15, gb + 21249 | 0, i2) | 0;
  _exit(1);
 }
 if (!i5) {
  i15 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i3 >> 2] = gb + 19656;
  _fprintf(i15, gb + 21310 | 0, i3) | 0;
  _exit(1);
 }
 i15 = _malloc(36) | 0;
 HEAP32[i15 + 16 >> 2] = i9;
 i7 = i15 + 20 | 0;
 HEAP32[i7 >> 2] = i5;
 i12 = i5 >>> 0 > i9 >>> 0 ? i5 : i9;
 i11 = i15 + 12 | 0;
 HEAP32[i11 >> 2] = i12;
 HEAP32[i15 + 24 >> 2] = 0;
 i3 = _malloc(i5 << 2) | 0;
 HEAP32[i15 >> 2] = i3;
 i5 = i15 + 4 | 0;
 HEAP32[i5 >> 2] = _malloc(i9 << 2) | 0;
 d10 = +HEAPF32[i13 >> 2];
 if (i9 >>> 0 >= 4 ? (i6 = i9 & -4, (i6 | 0) != 0) : 0) {
  F44 = SIMD_Float32x4_splat(Math_fround(d10));
  i2 = 0;
  do {
   i17 = i3 + (i2 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i17, SIMD_Float32x4_div(SIMD_Float32x4_load(HEAPU8, i8 + (i2 << 2) | 0), F44));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i6 | 0));
  if ((i6 | 0) != (i9 | 0)) {
   i2 = i6;
   i14 = 16;
  }
 } else {
  i2 = 0;
  i14 = 16;
 }
 if ((i14 | 0) == 16) while (1) {
  i14 = 0;
  HEAPF32[i3 + (i2 << 2) >> 2] = +HEAPF32[i8 + (i2 << 2) >> 2] / d10;
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= i9 >>> 0) break; else i14 = 16;
 }
 i6 = HEAP32[i5 >> 2] | 0;
 i5 = HEAP32[i7 >> 2] | 0;
 i3 = i5 >>> 0 > 1 ? i5 : 1;
 if ((i3 >>> 0 >= 4 ? (i1 = i3 & -4, (i1 | 0) != 0) : 0) ? (i17 = (i5 >>> 0 > 1 ? i5 : 1) + -1 | 0, !(i6 >>> 0 <= (i13 + (i17 << 2) | 0) >>> 0 & (i6 + (i17 << 2) | 0) >>> 0 >= i13 >>> 0)) : 0) {
  F44 = SIMD_Float32x4_splat(Math_fround(d10));
  i2 = 0;
  do {
   i17 = i6 + (i2 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i17, SIMD_Float32x4_div(SIMD_Float32x4_load(HEAPU8, i13 + (i2 << 2) | 0), F44));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
  if ((i3 | 0) != (i1 | 0)) i14 = 17;
 } else {
  i1 = 0;
  i14 = 17;
 }
 if ((i14 | 0) == 17) while (1) {
  HEAPF32[i6 + (i1 << 2) >> 2] = +HEAPF32[i13 + (i1 << 2) >> 2] / d10;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i5 >>> 0) break; else i14 = 17;
 }
 i3 = _malloc(i12 << 3) | 0;
 HEAP32[i15 + 8 >> 2] = i3;
 if (!i12) {
  STACKTOP = i16;
  return i15 | 0;
 }
 i1 = HEAP32[i11 >> 2] | 0;
 i2 = 0;
 do {
  HEAPF32[i3 + (i2 << 3) >> 2] = 0.0;
  HEAPF32[i3 + (i2 << 3) + 4 >> 2] = 0.0;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 STACKTOP = i16;
 return i15 | 0;
}

function _fecsoft_hamming128_decode_n3(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0;
 i18 = i1 + 1 | 0;
 i20 = i1 + 2 | 0;
 i22 = i1 + 3 | 0;
 i24 = i1 + 4 | 0;
 i26 = i1 + 5 | 0;
 i2 = i1 + 6 | 0;
 i4 = i1 + 7 | 0;
 i6 = i1 + 8 | 0;
 i8 = i1 + 9 | 0;
 i10 = i1 + 10 | 0;
 i12 = i1 + 11 | 0;
 i15 = _fec_hamming128_decode_symbol(((HEAP8[i18 >> 0] | 0) < 0 ? 1024 : 0) | ((HEAP8[i1 >> 0] | 0) < 0 ? 2048 : 0) | ((HEAP8[i20 >> 0] | 0) < 0 ? 512 : 0) | ((HEAP8[i22 >> 0] | 0) < 0 ? 256 : 0) | ((HEAP8[i24 >> 0] | 0) < 0 ? 128 : 0) | ((HEAP8[i26 >> 0] | 0) < 0 ? 64 : 0) | ((HEAP8[i2 >> 0] | 0) < 0 ? 32 : 0) | ((HEAP8[i4 >> 0] | 0) < 0 ? 16 : 0) | ((HEAP8[i6 >> 0] | 0) < 0 ? 8 : 0) | ((HEAP8[i8 >> 0] | 0) < 0 ? 4 : 0) | ((HEAP8[i10 >> 0] | 0) < 0 ? 2 : 0) | (HEAPU8[i12 >> 0] | 0) >>> 7 & 255) | 0;
 i28 = HEAPU16[gb + 9244 + (i15 << 1) >> 1] | 0;
 i16 = HEAPU8[i1 >> 0] | 0;
 i17 = i16 ^ 255;
 i18 = HEAPU8[i18 >> 0] | 0;
 i19 = i18 ^ 255;
 i20 = HEAPU8[i20 >> 0] | 0;
 i21 = i20 ^ 255;
 i22 = HEAPU8[i22 >> 0] | 0;
 i23 = i22 ^ 255;
 i24 = HEAPU8[i24 >> 0] | 0;
 i25 = i24 ^ 255;
 i26 = HEAPU8[i26 >> 0] | 0;
 i27 = i26 ^ 255;
 i2 = HEAPU8[i2 >> 0] | 0;
 i3 = i2 ^ 255;
 i4 = HEAPU8[i4 >> 0] | 0;
 i5 = i4 ^ 255;
 i6 = HEAPU8[i6 >> 0] | 0;
 i7 = i6 ^ 255;
 i8 = HEAPU8[i8 >> 0] | 0;
 i9 = i8 ^ 255;
 i10 = HEAPU8[i10 >> 0] | 0;
 i11 = i10 ^ 255;
 i12 = HEAPU8[i12 >> 0] | 0;
 i13 = i12 ^ 255;
 i28 = (i28 & 1024 | 0 ? i19 : i18) + (i28 & 2048 | 0 ? i17 : i16) + (i28 & 512 | 0 ? i21 : i20) + (i28 & 256 | 0 ? i23 : i22) + (i28 & 128 | 0 ? i25 : i24) + (i28 & 64 | 0 ? i27 : i26) + (i28 & 32 | 0 ? i3 : i2) + (i28 & 16 | 0 ? i5 : i4) + (i28 & 8 | 0 ? i7 : i6) + (i28 & 4 | 0 ? i9 : i8) + (i28 & 2 | 0 ? i11 : i10) + (i28 & 1 | 0 ? i13 : i12) | 0;
 i29 = 0;
 i1 = i15;
 while (1) {
  i30 = HEAPU8[gb + 13660 + (i1 * 17 | 0) + i29 >> 0] | 0;
  i14 = HEAPU16[gb + 9244 + (i30 << 1) >> 1] | 0;
  i14 = (i14 & 1024 | 0 ? i19 : i18) + (i14 & 2048 | 0 ? i17 : i16) + (i14 & 512 | 0 ? i21 : i20) + (i14 & 256 | 0 ? i23 : i22) + (i14 & 128 | 0 ? i25 : i24) + (i14 & 64 | 0 ? i27 : i26) + (i14 & 32 | 0 ? i3 : i2) + (i14 & 16 | 0 ? i5 : i4) + (i14 & 8 | 0 ? i7 : i6) + (i14 & 4 | 0 ? i9 : i8) + (i14 & 2 | 0 ? i11 : i10) + (i14 & 1 | 0 ? i13 : i12) | 0;
  i15 = i14 >>> 0 < i28 >>> 0;
  i1 = i15 ? i30 : i1;
  i29 = i29 + 1 | 0;
  if ((i29 | 0) == 17) break; else i28 = i15 ? i14 : i28;
 }
 return i1 | 0;
}

function _lex_scan(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i7 + 12 | 0;
 i3 = i7 + 8 | 0;
 i4 = i7 + 4 | 0;
 i5 = i7;
 HEAP32[i6 >> 2] = i2;
 HEAP32[i3 >> 2] = i1;
 _strbuffer_clear((HEAP32[i6 >> 2] | 0) + 40 | 0);
 if ((HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] | 0) == 256) _lex_free_string(HEAP32[i6 >> 2] | 0);
 do HEAP32[i4 >> 2] = _lex_get(HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0; while ((HEAP32[i4 >> 2] | 0) == 32 | (HEAP32[i4 >> 2] | 0) == 9 | (HEAP32[i4 >> 2] | 0) == 10 | (HEAP32[i4 >> 2] | 0) == 13);
 do if ((HEAP32[i4 >> 2] | 0) != -1) {
  i1 = HEAP32[i6 >> 2] | 0;
  if ((HEAP32[i4 >> 2] | 0) == -2) {
   HEAP32[i1 + 56 >> 2] = -1;
   break;
  }
  _lex_save(i1, HEAP32[i4 >> 2] | 0);
  i1 = HEAP32[i4 >> 2] | 0;
  if ((HEAP32[i4 >> 2] | 0) == 123 | (HEAP32[i4 >> 2] | 0) == 125 | (HEAP32[i4 >> 2] | 0) == 91 | (HEAP32[i4 >> 2] | 0) == 93 | (HEAP32[i4 >> 2] | 0) == 58 | (HEAP32[i4 >> 2] | 0) == 44) {
   HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] = i1;
   break;
  }
  if ((i1 | 0) == 34) {
   _lex_scan_string(HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] | 0);
   break;
  }
  if (48 <= (HEAP32[i4 >> 2] | 0) & (HEAP32[i4 >> 2] | 0) <= 57 | (HEAP32[i4 >> 2] | 0) == 45) {
   _lex_scan_number(HEAP32[i6 >> 2] | 0, HEAP32[i4 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
   break;
  }
  if (!(65 <= (HEAP32[i4 >> 2] | 0) & (HEAP32[i4 >> 2] | 0) <= 90) ? !(97 <= (HEAP32[i4 >> 2] | 0) & (HEAP32[i4 >> 2] | 0) <= 122) : 0) {
   _lex_save_cached(HEAP32[i6 >> 2] | 0);
   HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] = -1;
   break;
  }
  while (1) {
   HEAP32[i4 >> 2] = _lex_get_save(HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
   if (65 <= (HEAP32[i4 >> 2] | 0) & (HEAP32[i4 >> 2] | 0) <= 90) continue;
   if (!(97 <= (HEAP32[i4 >> 2] | 0) ? (HEAP32[i4 >> 2] | 0) <= 122 : 0)) break;
  }
  _lex_unget_unsave(HEAP32[i6 >> 2] | 0, HEAP32[i4 >> 2] | 0);
  HEAP32[i5 >> 2] = _strbuffer_value((HEAP32[i6 >> 2] | 0) + 40 | 0) | 0;
  if (!(_strcmp(HEAP32[i5 >> 2] | 0, gb + 41105 | 0) | 0)) {
   HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] = 259;
   break;
  }
  if (!(_strcmp(HEAP32[i5 >> 2] | 0, gb + 41110 | 0) | 0)) {
   HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] = 260;
   break;
  }
  i5 = (_strcmp(HEAP32[i5 >> 2] | 0, gb + 41116 | 0) | 0) == 0;
  i1 = (HEAP32[i6 >> 2] | 0) + 56 | 0;
  if (i5) {
   HEAP32[i1 >> 2] = 261;
   break;
  } else {
   HEAP32[i1 >> 2] = -1;
   break;
  }
 } else HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] = 0; while (0);
 STACKTOP = i7;
 return HEAP32[(HEAP32[i6 >> 2] | 0) + 56 >> 2] | 0;
}

function _resamp_rrrf_create(d3, i13, d11, d10, i14) {
 d3 = +d3;
 i13 = i13 | 0;
 d11 = +d11;
 d10 = +d10;
 i14 = i14 | 0;
 var i1 = 0, i2 = 0, F44 = SIMD_Float32x4(0, 0, 0, 0), i5 = 0, i6 = 0, i7 = 0, i8 = 0, d9 = 0.0, i12 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i6 = i15 + 32 | 0;
 i8 = i15 + 24 | 0;
 i7 = i15 + 16 | 0;
 i5 = i15 + 8 | 0;
 i2 = i15;
 if (d3 <= 0.0) {
  i12 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 18911;
  _fprintf(i12, gb + 19241 | 0, i2) | 0;
  _exit(1);
 }
 if (!i13) {
  i12 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i5 >> 2] = gb + 18911;
  _fprintf(i12, gb + 19311 | 0, i5) | 0;
  _exit(1);
 }
 if (!i14) {
  i12 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i7 >> 2] = gb + 18911;
  _fprintf(i12, gb + 19384 | 0, i7) | 0;
  _exit(1);
 }
 if (d11 <= 0.0 | d11 >= .5) {
  i12 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = gb + 18911;
  _fprintf(i12, gb + 19461 | 0, i8) | 0;
  _exit(1);
 }
 if (d10 <= 0.0) {
  i12 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 18911;
  _fprintf(i12, gb + 19522 | 0, i6) | 0;
  _exit(1);
 }
 i12 = _malloc(56) | 0;
 HEAPF32[i12 + 12 >> 2] = d3;
 HEAPF32[i12 + 16 >> 2] = 1.0 / d3;
 HEAP32[i12 >> 2] = i13;
 HEAPF32[i12 + 8 >> 2] = d11;
 HEAPF32[i12 + 4 >> 2] = d10;
 HEAP32[i12 + 44 >> 2] = i14;
 i6 = Math_imul(i13 << 1, i14) | 0;
 i5 = i6 | 1;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 2) | 0) + 15 & -16) | 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 2) | 0) + 15 & -16) | 0;
 d9 = +(i14 >>> 0);
 _liquid_firdes_kaiser(i5, d11 / d9, d10, 0.0, i7);
 i5 = (Math_imul(i13, i14) | 0) << 1 | 1;
 d3 = 0.0;
 i2 = 0;
 do {
  d3 = d3 + +HEAPF32[i7 + (i2 << 2) >> 2];
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i5 | 0));
 d3 = d9 / d3;
 i2 = (Math_imul(i14, i13) | 0) << 1;
 if (i2 >>> 0 >= 4 ? (i1 = i2 & -4, (i1 | 0) != 0) : 0) {
  F44 = SIMD_Float32x4_splat(Math_fround(d3));
  i2 = 0;
  do {
   SIMD_Float32x4_store(HEAPU8, i8 + (i2 << 2) | 0, SIMD_Float32x4_mul(F44, SIMD_Float32x4_load(HEAPU8, i7 + (i2 << 2) | 0)));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  HEAPF32[i8 + (i1 << 2) >> 2] = d3 * +HEAPF32[i7 + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i5 | 0));
 i14 = _firpfb_rrrf_create(i14, i8, i6) | 0;
 HEAP32[i12 + 48 >> 2] = i14;
 _windowf_clear(HEAP32[i14 + 16 >> 2] | 0);
 HEAP32[i12 + 52 >> 2] = 1;
 i14 = i12 + 20 | 0;
 HEAP32[i14 >> 2] = 0;
 HEAP32[i14 + 4 >> 2] = 0;
 HEAP32[i14 + 8 >> 2] = 0;
 HEAP32[i14 + 12 >> 2] = 0;
 HEAP32[i14 + 16 >> 2] = 0;
 HEAP32[i14 + 20 >> 2] = 0;
 STACKTOP = i15;
 return i12 | 0;
}

function _parse_value(i9, i6, i5) {
 i9 = i9 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i13 = i14 + 16 | 0;
 i12 = i14 + 8 | 0;
 i11 = i14;
 i1 = i14 + 44 | 0;
 i2 = i14 + 40 | 0;
 i3 = i14 + 36 | 0;
 i4 = i14 + 32 | 0;
 i7 = i14 + 28 | 0;
 i10 = i14 + 24 | 0;
 i8 = i14 + 20 | 0;
 HEAP32[i2 >> 2] = i9;
 HEAP32[i3 >> 2] = i6;
 HEAP32[i4 >> 2] = i5;
 do switch (HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) {
 case 256:
  {
   HEAP32[i10 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 64 >> 2];
   HEAP32[i8 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 64 + 4 >> 2];
   if ((HEAP32[i3 >> 2] & 16 | 0) == 0 ? _memchr(HEAP32[i10 >> 2] | 0, 0, HEAP32[i8 >> 2] | 0) | 0 : 0) {
    _error_set(HEAP32[i4 >> 2] | 0, HEAP32[i2 >> 2] | 0, gb + 41141 | 0, i11);
    HEAP32[i1 >> 2] = 0;
    i13 = HEAP32[i1 >> 2] | 0;
    STACKTOP = i14;
    return i13 | 0;
   }
   HEAP32[i7 >> 2] = _jsonp_stringn_nocheck_own(HEAP32[i10 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   if (HEAP32[i7 >> 2] | 0) {
    HEAP32[(HEAP32[i2 >> 2] | 0) + 64 >> 2] = 0;
    HEAP32[(HEAP32[i2 >> 2] | 0) + 64 + 4 >> 2] = 0;
   }
   break;
  }
 case 257:
  {
   i13 = (HEAP32[i2 >> 2] | 0) + 64 | 0;
   HEAP32[i7 >> 2] = _json_integer(HEAP32[i13 >> 2] | 0, HEAP32[i13 + 4 >> 2] | 0) | 0;
   break;
  }
 case 258:
  {
   HEAP32[i7 >> 2] = _json_real(+HEAPF64[(HEAP32[i2 >> 2] | 0) + 64 >> 3]) | 0;
   break;
  }
 case 259:
  {
   HEAP32[i7 >> 2] = _json_true() | 0;
   break;
  }
 case 260:
  {
   HEAP32[i7 >> 2] = _json_false() | 0;
   break;
  }
 case 261:
  {
   HEAP32[i7 >> 2] = _json_null() | 0;
   break;
  }
 case 123:
  {
   HEAP32[i7 >> 2] = _parse_object(HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
   break;
  }
 case 91:
  {
   HEAP32[i7 >> 2] = _parse_array(HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
   break;
  }
 case -1:
  {
   _error_set(HEAP32[i4 >> 2] | 0, HEAP32[i2 >> 2] | 0, gb + 41306 | 0, i12);
   HEAP32[i1 >> 2] = 0;
   i13 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i14;
   return i13 | 0;
  }
 default:
  {
   _error_set(HEAP32[i4 >> 2] | 0, HEAP32[i2 >> 2] | 0, gb + 41320 | 0, i13);
   HEAP32[i1 >> 2] = 0;
   i13 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i14;
   return i13 | 0;
  }
 } while (0);
 if (HEAP32[i7 >> 2] | 0) {
  HEAP32[i1 >> 2] = HEAP32[i7 >> 2];
  i13 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i14;
  return i13 | 0;
 } else {
  HEAP32[i1 >> 2] = 0;
  i13 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i14;
  return i13 | 0;
 }
 return 0;
}

function _fec_secded2216_estimate_ehat(i1, i6) {
 i1 = i1 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i8;
 HEAP8[i6 >> 0] = 0;
 HEAP8[i6 + 1 >> 0] = 0;
 HEAP8[i6 + 2 >> 0] = 0;
 i4 = HEAPU8[i1 >> 0] | 0;
 i5 = HEAP8[i1 + 1 >> 0] | 0;
 i2 = HEAP8[i1 + 2 >> 0] | 0;
 i3 = 0;
 i1 = 0;
 do {
  i9 = i3 << 1;
  i1 = ((1 << 5 - i3 & i4 | 0) != 0 & 1) + (HEAPU8[(HEAP8[gb + 18245 + i9 >> 0] & i5 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i9 | 1) + (gb + 18245) >> 0] & i2 & 255) + (gb + 38499) >> 0] | 0) & 1 | i1 << 1 & 510;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 6);
 i2 = i1 & 255;
 if (!(HEAP8[(i1 & 255) + (gb + 38499) >> 0] | 0)) {
  i9 = 0;
  STACKTOP = i8;
  return i9 | 0;
 }
 do if (i2 << 24 >> 24 != (HEAP8[gb + 18257 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 1 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 2 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 3 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 4 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 5 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 6 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 7 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 8 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 9 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 10 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 11 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 12 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 13 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 14 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 15 >> 0] | 0)) if (i2 << 24 >> 24 != (HEAP8[gb + 18257 + 16 >> 0] | 0)) if (i2 << 24 >> 24 == (HEAP8[gb + 18257 + 17 >> 0] | 0)) i1 = 17; else {
  if (i2 << 24 >> 24 == (HEAP8[gb + 18257 + 18 >> 0] | 0)) {
   i1 = 18;
   break;
  }
  if (i2 << 24 >> 24 == (HEAP8[gb + 18257 + 19 >> 0] | 0)) {
   i1 = 19;
   break;
  }
  if (i2 << 24 >> 24 == (HEAP8[gb + 18257 + 20 >> 0] | 0)) {
   i1 = 20;
   break;
  }
  if (i2 << 24 >> 24 == (HEAP8[gb + 18257 + 21 >> 0] | 0)) {
   i1 = 21;
   break;
  } else i1 = 2;
  STACKTOP = i8;
  return i1 | 0;
 } else i1 = 16; else i1 = 15; else i1 = 14; else i1 = 13; else i1 = 12; else i1 = 11; else i1 = 10; else i1 = 9; else i1 = 8; else i1 = 7; else i1 = 6; else i1 = 5; else i1 = 4; else i1 = 3; else i1 = 2; else i1 = 1; else i1 = 0; while (0);
 _div(i7, i1, 8);
 HEAP8[i6 + (2 - (HEAP32[i7 >> 2] | 0)) >> 0] = 1 << HEAP32[i7 + 4 >> 2];
 i9 = 1;
 STACKTOP = i8;
 return i9 | 0;
}

function _quiet_encoder_create(i6, d7) {
 i6 = i6 | 0;
 d7 = +d7;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i8;
 if (!i6) {
  i6 = 0;
  STACKTOP = i8;
  return i6 | 0;
 }
 i5 = _malloc(156) | 0;
 i2 = i5;
 i3 = i6;
 i4 = i2 + 96 | 0;
 do {
  HEAP32[i2 >> 2] = HEAP32[i3 >> 2];
  i2 = i2 + 4 | 0;
  i3 = i3 + 4 | 0;
 } while ((i2 | 0) < (i4 | 0));
 switch (HEAP32[i5 + 60 >> 2] | 0) {
 case 0:
  {
   HEAP32[i1 >> 2] = HEAP32[i6 + 64 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i6 + 68 >> 2];
   HEAP32[i1 + 8 >> 2] = HEAP32[i6 + 72 >> 2];
   HEAP32[i1 + 12 >> 2] = HEAP32[i6 + 76 >> 2];
   i3 = _ofdm_subcarriers_create(i6) | 0;
   i2 = i6 + 4 | 0;
   i4 = _ofdmflexframegen_create(HEAP32[i6 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i6 + 8 >> 2] | 0, i3, i1) | 0;
   _ofdmflexframegen_set_header_len(i4, 0);
   i2 = (HEAP32[i2 >> 2] | 0) + (HEAP32[i6 >> 2] | 0) | 0;
   HEAP32[i5 + 108 >> 2] = _malloc(i2 << 3) | 0;
   i1 = i5 + 112 | 0;
   HEAP32[i1 >> 2] = i2;
   _free(i3);
   HEAP32[i5 + 96 >> 2] = i4;
   break;
  }
 case 1:
  {
   HEAP32[i1 >> 2] = HEAP32[i6 + 64 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i6 + 68 >> 2];
   HEAP32[i1 + 8 >> 2] = HEAP32[i6 + 72 >> 2];
   HEAP32[i1 + 12 >> 2] = HEAP32[i6 + 76 >> 2];
   i4 = _flexframegen_create(i1) | 0;
   _flexframegen_set_header_len(i4, 0);
   HEAP32[i5 + 108 >> 2] = 0;
   i1 = i5 + 112 | 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i5 + 96 >> 2] = i4;
   HEAP32[i5 + 100 >> 2] = 0;
   break;
  }
 case 2:
  {
   i4 = _gmskframegen_create() | 0;
   _gmskframegen_set_header_len(i4, 0);
   HEAP32[i5 + 108 >> 2] = 0;
   i1 = i5 + 112 | 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i5 + 96 >> 2] = i4;
   HEAP32[i5 + 100 >> 2] = 2;
   break;
  }
 default:
  i1 = i5 + 112 | 0;
 }
 i2 = _modulator_create(i6 + 20 | 0) | 0;
 HEAP32[i5 + 104 >> 2] = i2;
 i1 = _modulator_sample_len(i2, HEAP32[i1 >> 2] | 0) | 0;
 HEAP32[i5 + 120 >> 2] = i1;
 HEAP32[i5 + 116 >> 2] = _malloc(i1 << 2) | 0;
 i1 = i5 + 124 | 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 HEAP8[i5 + 140 >> 0] = 1;
 HEAP8[i5 + 92 >> 0] = 0;
 i1 = i5 + 148 | 0;
 HEAPF32[i1 >> 2] = 1.0;
 i2 = i5 + 152 | 0;
 HEAP32[i2 >> 2] = 0;
 if (!(d7 != 44100.0)) {
  i6 = i5;
  STACKTOP = i8;
  return i6 | 0;
 }
 d7 = d7 / 44100.0;
 HEAP32[i2 >> 2] = _resamp_rrrf_create(d7, HEAP32[i6 + 44 >> 2] | 0, +HEAPF32[i6 + 48 >> 2], +HEAPF32[i6 + 52 >> 2], HEAP32[i6 + 56 >> 2] | 0) | 0;
 HEAPF32[i1 >> 2] = d7;
 i6 = i5;
 STACKTOP = i8;
 return i6 | 0;
}

function _flexframesync_execute(i17, i18, i16) {
 i17 = i17 | 0;
 i18 = i18 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i1 = i20 + 40 | 0;
 i2 = i20 + 32 | 0;
 i3 = i20 + 24 | 0;
 i9 = i20 + 16 | 0;
 i10 = i20 + 8 | 0;
 i11 = i20;
 if (!i16) {
  STACKTOP = i20;
  return;
 }
 i12 = i17 + 204 | 0;
 i13 = i17 + 200 | 0;
 i14 = i3 + 4 | 0;
 i15 = i9 + 4 | 0;
 i4 = i10 + 4 | 0;
 i5 = i11 + 4 | 0;
 i6 = i17 + 212 | 0;
 i7 = i17 + 216 | 0;
 i8 = i2 + 4 | 0;
 i19 = 0;
 L4 : while (1) {
  if (HEAP32[i12 >> 2] | 0 ? (HEAP32[i6 >> 2] | 0) == 0 : 0) {
   i21 = HEAP32[i7 >> 2] | 0;
   i22 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
   HEAP32[i2 >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
   HEAP32[i8 >> 2] = i22;
   HEAP32[i1 >> 2] = HEAP32[i2 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
   _windowcf_push(i21, i1);
  }
  switch (HEAP32[i13 >> 2] | 0) {
  case 0:
   {
    i22 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
    HEAP32[i3 >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
    HEAP32[i14 >> 2] = i22;
    HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
    _flexframesync_execute_seekpn(i17, i1);
    break;
   }
  case 1:
   {
    i22 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
    HEAP32[i9 >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
    HEAP32[i15 >> 2] = i22;
    HEAP32[i1 >> 2] = HEAP32[i9 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
    _flexframesync_execute_rxpreamble(i17, i1);
    break;
   }
  case 2:
   {
    i22 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
    HEAP32[i10 >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
    HEAP32[i4 >> 2] = i22;
    HEAP32[i1 >> 2] = HEAP32[i10 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
    _flexframesync_execute_rxheader(i17, i1);
    break;
   }
  case 3:
   {
    i22 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
    HEAP32[i11 >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
    HEAP32[i5 >> 2] = i22;
    HEAP32[i1 >> 2] = HEAP32[i11 >> 2];
    HEAP32[i1 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
    _flexframesync_execute_rxpayload(i17, i1);
    break;
   }
  default:
   {
    i1 = 11;
    break L4;
   }
  }
  i19 = i19 + 1 | 0;
  if (i19 >>> 0 >= i16 >>> 0) {
   i1 = 13;
   break;
  }
 }
 if ((i1 | 0) == 11) {
  _fwrite(gb + 25750 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else if ((i1 | 0) == 13) {
  STACKTOP = i20;
  return;
 }
}

function _ofdmframegen_writesymbol(i8, i7, i9) {
 i8 = i8 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i10 = 0, i11 = 0, d12 = 0.0, d13 = 0.0, d14 = 0.0;
 i1 = HEAP32[i8 >> 2] | 0;
 L1 : do if (i1 | 0) {
  i3 = i8 + 8 | 0;
  i4 = i8 + 44 | 0;
  i5 = i8 + 52 | 0;
  i6 = i8 + 76 | 0;
  i2 = 0;
  while (1) {
   i1 = (((i1 >>> 1) + i2 | 0) >>> 0) % (i1 >>> 0) | 0;
   switch (HEAP8[(HEAP32[i3 >> 2] | 0) + i1 >> 0] | 0) {
   case 0:
    {
     i10 = HEAP32[i5 >> 2] | 0;
     HEAPF32[i10 + (i1 << 3) >> 2] = 0.0;
     HEAPF32[i10 + (i1 << 3) + 4 >> 2] = 0.0;
     break;
    }
   case 1:
    {
     i11 = (_msequence_advance(HEAP32[i6 >> 2] | 0) | 0) != 0;
     i10 = HEAP32[i5 >> 2] | 0;
     HEAPF32[i10 + (i1 << 3) >> 2] = +HEAPF32[i4 >> 2] * (i11 ? 1.0 : -1.0);
     HEAPF32[i10 + (i1 << 3) + 4 >> 2] = 0.0;
     break;
    }
   default:
    {
     d13 = +HEAPF32[i4 >> 2];
     d12 = +HEAPF32[i7 + (i1 << 3) + 4 >> 2] * d13;
     i11 = HEAP32[i5 >> 2] | 0;
     HEAPF32[i11 + (i1 << 3) >> 2] = +HEAPF32[i7 + (i1 << 3) >> 2] * d13;
     HEAPF32[i11 + (i1 << 3) + 4 >> 2] = d12;
    }
   }
   i2 = i2 + 1 | 0;
   i1 = HEAP32[i8 >> 2] | 0;
   if (i2 >>> 0 >= i1 >>> 0) break L1;
  }
 } while (0);
 _fft_execute(HEAP32[i8 + 48 >> 2] | 0);
 i3 = i8 + 4 | 0;
 i11 = HEAP32[i3 >> 2] | 0;
 i6 = i8 + 56 | 0;
 _memmove(i9 | 0, (HEAP32[i6 >> 2] | 0) + ((HEAP32[i8 >> 2] | 0) - i11 << 3) | 0, i11 << 3 | 0) | 0;
 _memmove(i9 + (HEAP32[i3 >> 2] << 3) | 0, HEAP32[i6 >> 2] | 0, HEAP32[i8 >> 2] << 3 | 0) | 0;
 i3 = i8 + 12 | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  i11 = 0;
  i9 = i8 + 20 | 0;
  i9 = HEAP32[i9 >> 2] | 0;
  i10 = HEAP32[i6 >> 2] | 0;
  _memmove(i9 | 0, i10 | 0, i11 | 0) | 0;
  return;
 }
 i4 = i8 + 16 | 0;
 i5 = i8 + 20 | 0;
 i2 = 0;
 do {
  d13 = +HEAPF32[(HEAP32[i4 >> 2] | 0) + (i2 << 2) >> 2];
  i11 = i9 + (i2 << 3) | 0;
  i1 = i9 + (i2 << 3) + 4 | 0;
  d14 = d13 * +HEAPF32[i11 >> 2];
  d13 = d13 * +HEAPF32[i1 >> 2];
  HEAPF32[i11 >> 2] = d14;
  HEAPF32[i1 >> 2] = d13;
  i10 = HEAP32[i5 >> 2] | 0;
  d12 = +HEAPF32[(HEAP32[i4 >> 2] | 0) + ((HEAP32[i3 >> 2] | 0) + ~i2 << 2) >> 2];
  d13 = d13 + +HEAPF32[i10 + (i2 << 3) + 4 >> 2] * d12;
  HEAPF32[i11 >> 2] = d14 + +HEAPF32[i10 + (i2 << 3) >> 2] * d12;
  HEAPF32[i1 >> 2] = d13;
  i2 = i2 + 1 | 0;
  i1 = HEAP32[i3 >> 2] | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 i11 = i1 << 3;
 i9 = i5;
 i9 = HEAP32[i9 >> 2] | 0;
 i10 = HEAP32[i6 >> 2] | 0;
 _memmove(i9 | 0, i10 | 0, i11 | 0) | 0;
 return;
}

function _liquid_firdes_rkaiser_quadratic(i12, i13, d9, d10, i14, i15) {
 i12 = i12 | 0;
 i13 = i13 | 0;
 d9 = +d9;
 d10 = +d10;
 i14 = i14 | 0;
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, F44 = SIMD_Float32x4(0, 0, 0, 0), d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i11 = 0, d16 = 0.0, d17 = 0.0, d18 = 0.0, d19 = 0.0, d20 = 0.0, d21 = 0.0, d22 = 0.0, d23 = 0.0;
 if (!i12) {
  _fwrite(gb + 23992 | 0, 67, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i13) {
  _fwrite(gb + 24060 | 0, 67, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d9 < 0.0 | d9 > 1.0) {
  _fwrite(gb + 24128 | 0, 64, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 d7 = +_rkaiser_approximate_rho(i13, d9);
 d6 = .20000000298023224;
 i2 = 0;
 d3 = d7;
 d8 = 0.0;
 while (1) {
  d17 = d7 - d6;
  d16 = d7 + d6;
  d17 = !(d17 <= 0.0) ? d17 : .009999999776482582;
  d16 = !(d16 >= 1.0) ? d16 : .9900000095367432;
  d20 = +_liquid_firdes_rkaiser_internal_isi(i12, i13, d9, d10, d17, i14);
  d19 = +_liquid_firdes_rkaiser_internal_isi(i12, i13, d9, d10, d7, i14);
  d18 = +_liquid_firdes_rkaiser_internal_isi(i12, i13, d9, d10, d16, i14);
  i11 = (i2 | 0) == 0 | d19 < d8;
  d8 = i11 ? d19 : d8;
  d3 = i11 ? d7 : d3;
  d21 = d7 * d7;
  d23 = d16 * d16;
  d22 = d17 * d17;
  d5 = d7;
  d7 = ((d21 - d23) * d20 + (d23 - d22) * d19 + (d22 - d21) * d18) * .5 / ((d7 - d16) * d20 + (d16 - d17) * d19 + (d17 - d7) * d18);
  if (d7 < d17 | d7 > d16) {
   d5 = d3;
   break;
  }
  if (i2 >>> 0 > 3 ? +Math_abs(+(d7 - d5)) < 9.999999974752427e-07 : 0) {
   d5 = d3;
   break;
  }
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= 14) {
   d5 = d3;
   break;
  } else d6 = d6 * .5;
 }
 +_liquid_firdes_rkaiser_internal_isi(i12, i13, d9, d10, d5, i14);
 i11 = (Math_imul(i13, i12) | 0) << 1 | 1;
 d3 = 0.0;
 i2 = 0;
 do {
  d23 = +HEAPF32[i14 + (i2 << 2) >> 2];
  d3 = d3 + d23 * d23;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i11 | 0));
 d3 = +Math_sqrt(+(+(i12 >>> 0) / d3));
 i2 = (Math_imul(i13, i12) | 0) << 1;
 if (i2 >>> 0 >= 4 ? (i1 = i2 & -4, (i1 | 0) != 0) : 0) {
  F44 = SIMD_Float32x4_splat(Math_fround(d3));
  i2 = 0;
  do {
   i13 = i14 + (i2 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i13, SIMD_Float32x4_mul(F44, SIMD_Float32x4_load(HEAPU8, i13)));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  i13 = i14 + (i1 << 2) | 0;
  HEAPF32[i13 >> 2] = d3 * +HEAPF32[i13 >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i11 | 0));
 HEAPF32[i15 >> 2] = d5;
 return;
}

function _liquid_cplxpair(i19, i20, d18, i21) {
 i19 = i19 | 0;
 i20 = i20 | 0;
 d18 = +d18;
 i21 = i21 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, i13 = 0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i22 = 0, i23 = 0;
 i22 = STACKTOP;
 if (d18 < 0.0) {
  _fwrite(gb + 23134 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i17 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * i20 | 0) + 15 & -16) | 0;
 _memset(i17 | 0, 0, i20 | 0) | 0;
 i16 = (i20 | 0) == 0;
 if (i16) {
  i19 = 0;
  _liquid_cplxpair_cleanup(i21, i20, i19);
  STACKTOP = i22;
  return;
 } else {
  i15 = 0;
  i2 = 0;
  i1 = 0;
 }
 do {
  i7 = i17 + i15 | 0;
  L8 : do if ((HEAP8[i7 >> 0] | 0) == 0 ? (i13 = i19 + (i15 << 3) | 0, d14 = +HEAPF32[i19 + (i15 << 3) + 4 >> 2], !(+Math_abs(+d14) < d18)) : 0) {
   i3 = 0;
   while (1) {
    if (((((i3 | 0) != (i15 | 0) ? (i8 = i17 + i3 | 0, (HEAP8[i8 >> 0] | 0) == 0) : 0) ? (i9 = i19 + (i3 << 3) | 0, i10 = i19 + (i3 << 3) + 4 | 0, d11 = +HEAPF32[i10 >> 2], !(+Math_abs(+d11) < d18)) : 0) ? +Math_abs(+(d11 + d14)) < d18 : 0) ? (d12 = +HEAPF32[i13 >> 2], +Math_abs(+(d12 - +HEAPF32[i9 >> 2])) < d18) : 0) {
     i3 = i8;
     i5 = i9;
     i6 = i10;
     d4 = d12;
     break;
    }
    i3 = i3 + 1 | 0;
    if (i3 >>> 0 >= i20 >>> 0) break L8;
   }
   i23 = i2 + 1 | 0;
   HEAPF32[i21 + (i2 << 3) >> 2] = d4;
   HEAPF32[i21 + (i2 << 3) + 4 >> 2] = d14;
   i6 = HEAP32[i6 >> 2] | 0;
   HEAP32[i21 + (i23 << 3) >> 2] = HEAP32[i5 >> 2];
   HEAP32[i21 + (i23 << 3) + 4 >> 2] = i6;
   HEAP8[i7 >> 0] = 1;
   HEAP8[i3 >> 0] = 1;
   i2 = i2 + 2 | 0;
   i1 = i1 + 1 | 0;
  } while (0);
  i15 = i15 + 1 | 0;
 } while ((i15 | 0) != (i20 | 0));
 if (i2 >>> 0 > i20 >>> 0) ___assert_fail(gb + 23188 | 0, gb + 23196 | 0, 102, gb + 23220 | 0);
 if (i16) {
  i23 = i1;
  _liquid_cplxpair_cleanup(i21, i20, i23);
  STACKTOP = i22;
  return;
 }
 i5 = HEAP32[gb + 8808 >> 2] | 0;
 i6 = 0;
 do {
  i3 = i17 + i6 | 0;
  do if (!(HEAP8[i3 >> 0] | 0)) {
   d4 = +HEAPF32[i19 + (i6 << 3) + 4 >> 2];
   if (d4 > d18) {
    _fwrite(gb + 23236 | 0, 61, 1, i5) | 0;
    break;
   } else {
    HEAP32[i21 + (i2 << 3) >> 2] = HEAP32[i19 + (i6 << 3) >> 2];
    HEAPF32[i21 + (i2 << 3) + 4 >> 2] = d4;
    HEAP8[i3 >> 0] = 1;
    i2 = i2 + 1 | 0;
    break;
   }
  } while (0);
  i6 = i6 + 1 | 0;
 } while ((i6 | 0) != (i20 | 0));
 _liquid_cplxpair_cleanup(i21, i20, i1);
 STACKTOP = i22;
 return;
}
function _fft_create_plan_radix2(i7, i3, i4, i1, i2) {
 i7 = i7 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var d5 = 0.0, d6 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i13 = i17 + 24 | 0;
 i12 = i17 + 16 | 0;
 i14 = i17 + 8 | 0;
 i15 = i17;
 i16 = _malloc(72) | 0;
 HEAP32[i16 >> 2] = i7;
 HEAP32[i16 + 4 >> 2] = i3;
 HEAP32[i16 + 8 >> 2] = i4;
 HEAP32[i16 + 16 >> 2] = i2;
 i1 = (i1 | 0) == 1 ? 1 : -1;
 HEAP32[i16 + 20 >> 2] = i1;
 i4 = i16 + 12 | 0;
 HEAP32[i4 >> 2] = i1;
 HEAP32[i16 + 24 >> 2] = 1;
 HEAP32[i16 + 28 >> 2] = fb + 8;
 i2 = (_liquid_msb_index(i7) | 0) + -1 | 0;
 HEAP32[i16 + 40 >> 2] = i2;
 i3 = _malloc(i7 << 2) | 0;
 HEAP32[i16 + 44 >> 2] = i3;
 if (!i7) {
  i2 = 0;
  i11 = 0;
 } else {
  i1 = 0;
  do {
   HEAP32[i3 + (i1 << 2) >> 2] = _fft_reverse_index(i1, i2) | 0;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i7 >>> 0);
  i2 = i7 << 3;
  i1 = HEAP32[i4 >> 2] | 0;
  i11 = HEAP32[i16 >> 2] | 0;
 }
 i7 = _malloc(i2) | 0;
 HEAP32[i16 + 48 >> 2] = i7;
 d6 = (i1 | 0) == 1 ? -1.0 : 1.0;
 if (!i11) {
  STACKTOP = i17;
  return i16 | 0;
 }
 d8 = d6 * 0.0;
 d5 = d8 * 2.0 - d8;
 d9 = d6 * 2.0 + d8 * 0.0;
 i2 = i12 + 4 | 0;
 d10 = +(i11 >>> 0);
 i3 = i15 + 4 | 0;
 i4 = i14 + 4 | 0;
 if ((d5 != d5 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
  i1 = 0;
  do {
   ___mulsc3(i12, d8, d6, 2.0, 0.0);
   d5 = +(i1 >>> 0);
   d9 = d5 * (+HEAPF32[i2 >> 2] * 3.141592653589793) / d10;
   HEAPF32[i15 >> 2] = d5 * (+HEAPF32[i12 >> 2] * 3.141592653589793) / d10;
   HEAPF32[i3 >> 2] = d9;
   HEAP32[i13 >> 2] = HEAP32[i15 >> 2];
   HEAP32[i13 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
   _cexpf(i14, i13);
   i18 = HEAP32[i4 >> 2] | 0;
   HEAP32[i7 + (i1 << 3) >> 2] = HEAP32[i14 >> 2];
   HEAP32[i7 + (i1 << 3) + 4 >> 2] = i18;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i11 >>> 0);
  STACKTOP = i17;
  return i16 | 0;
 }
 d6 = d5 * 3.141592653589793;
 d5 = d9 * 3.141592653589793;
 i1 = 0;
 do {
  d9 = +(i1 >>> 0);
  HEAPF32[i15 >> 2] = d9 * d6 / d10;
  HEAPF32[i3 >> 2] = d9 * d5 / d10;
  HEAP32[i13 >> 2] = HEAP32[i15 >> 2];
  HEAP32[i13 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
  _cexpf(i14, i13);
  i18 = HEAP32[i4 >> 2] | 0;
  HEAP32[i7 + (i1 << 3) >> 2] = HEAP32[i14 >> 2];
  HEAP32[i7 + (i1 << 3) + 4 >> 2] = i18;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i11 >>> 0);
 STACKTOP = i17;
 return i16 | 0;
}

function _hashtable_set(i8, i10, i13, i14) {
 i8 = i8 | 0;
 i10 = i10 | 0;
 i13 = i13 | 0;
 i14 = i14 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i11 = 0, i12 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i1 = i15 + 36 | 0;
 i2 = i15 + 32 | 0;
 i3 = i15 + 28 | 0;
 i4 = i15 + 24 | 0;
 i5 = i15 + 20 | 0;
 i12 = i15 + 16 | 0;
 i6 = i15 + 12 | 0;
 i7 = i15 + 8 | 0;
 i9 = i15 + 4 | 0;
 i11 = i15;
 HEAP32[i2 >> 2] = i8;
 HEAP32[i3 >> 2] = i10;
 HEAP32[i4 >> 2] = i13;
 HEAP32[i5 >> 2] = i14;
 if ((HEAP32[HEAP32[i2 >> 2] >> 2] | 0) >>> 0 >= 1 << HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2] >>> 0 ? _hashtable_do_rehash(HEAP32[i2 >> 2] | 0) | 0 : 0) {
  HEAP32[i1 >> 2] = -1;
  i14 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i15;
  return i14 | 0;
 }
 i13 = HEAP32[i3 >> 2] | 0;
 i14 = _strlen(HEAP32[i3 >> 2] | 0) | 0;
 HEAP32[i7 >> 2] = _hashlittle(i13, i14, HEAP32[gb + 44300 >> 2] | 0) | 0;
 HEAP32[i9 >> 2] = HEAP32[i7 >> 2] & (1 << HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2]) - 1;
 HEAP32[i6 >> 2] = (HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i9 >> 2] << 3);
 HEAP32[i12 >> 2] = _hashtable_find_pair(HEAP32[i2 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i7 >> 2] | 0) | 0;
 do if (HEAP32[i12 >> 2] | 0) {
  _json_decref_1945(HEAP32[(HEAP32[i12 >> 2] | 0) + 12 >> 2] | 0);
  HEAP32[(HEAP32[i12 >> 2] | 0) + 12 >> 2] = HEAP32[i5 >> 2];
 } else {
  HEAP32[i11 >> 2] = _strlen(HEAP32[i3 >> 2] | 0) | 0;
  if ((HEAP32[i11 >> 2] | 0) >>> 0 >= 4294967275) {
   HEAP32[i1 >> 2] = -1;
   i14 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i15;
   return i14 | 0;
  }
  HEAP32[i12 >> 2] = _jsonp_malloc(20 + (HEAP32[i11 >> 2] | 0) + 1 | 0) | 0;
  if (HEAP32[i12 >> 2] | 0) {
   HEAP32[(HEAP32[i12 >> 2] | 0) + 8 >> 2] = HEAP32[i7 >> 2];
   HEAP32[(HEAP32[i12 >> 2] | 0) + 16 >> 2] = HEAP32[i4 >> 2];
   _strncpy((HEAP32[i12 >> 2] | 0) + 20 | 0, HEAP32[i3 >> 2] | 0, (HEAP32[i11 >> 2] | 0) + 1 | 0) | 0;
   HEAP32[(HEAP32[i12 >> 2] | 0) + 12 >> 2] = HEAP32[i5 >> 2];
   _list_init(HEAP32[i12 >> 2] | 0);
   _insert_to_bucket(HEAP32[i2 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i12 >> 2] | 0);
   i14 = HEAP32[i2 >> 2] | 0;
   HEAP32[i14 >> 2] = (HEAP32[i14 >> 2] | 0) + 1;
   break;
  }
  HEAP32[i1 >> 2] = -1;
  i14 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i15;
  return i14 | 0;
 } while (0);
 HEAP32[i1 >> 2] = 0;
 i14 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i15;
 return i14 | 0;
}

function _fec_conv_punctured_decode_hard(i17, i1, i14, i16) {
 i17 = i17 | 0;
 i1 = i1 | 0;
 i14 = i14 | 0;
 i16 = i16 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0;
 i15 = i17 + 8 | 0;
 if ((HEAP32[i15 >> 2] | 0) == (i1 | 0)) {
  i3 = i17 + 28 | 0;
  i6 = i17 + 32 | 0;
 } else {
  HEAP32[i15 >> 2] = i1;
  HEAP32[i17 + 12 >> 2] = _fec_get_enc_msg_length(HEAP32[i17 >> 2] | 0, i1) | 0;
  i1 = HEAP32[i15 >> 2] | 0;
  i6 = i17 + 32 | 0;
  i3 = i17 + 28 | 0;
  i4 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, HEAP32[i3 >> 2] | 0) | 0;
  i5 = i17 + 20 | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  if (i2) {
   mftCall_vi(HEAP32[i17 + 60 >> 2] | 0, i2 | 0);
   i1 = HEAP32[i15 >> 2] | 0;
  }
  HEAP32[i5 >> 2] = mftCall_ii(HEAP32[i17 + 44 >> 2] | 0, i1 << 3 | 0) | 0;
  i1 = i17 + 16 | 0;
  HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i4) | 0;
  i1 = HEAP32[i15 >> 2] | 0;
 }
 i2 = HEAP32[i3 >> 2] | 0;
 i11 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, i2) | 0;
 if (!i11) i1 = i17 + 16 | 0; else {
  i12 = i17 + 36 | 0;
  i13 = i17 + 40 | 0;
  i1 = i17 + 16 | 0;
  i4 = HEAP8[i14 >> 0] | 0;
  i9 = 0;
  i7 = 0;
  i5 = 0;
  i10 = 0;
  while (1) {
   if (!i2) i2 = 0; else {
    i2 = i7;
    i8 = 0;
    while (1) {
     i7 = (Math_imul(HEAP32[i12 >> 2] | 0, i8) | 0) + i10 | 0;
     if (HEAP32[(HEAP32[i13 >> 2] | 0) + (i7 << 2) >> 2] | 0) {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i8 + i9) >> 0] = ((i4 & 255 & 1 << 7 - i2 | 0) != 0) << 31 >> 31;
      i2 = i2 + 1 | 0;
      if ((i2 | 0) == 8) {
       i5 = i5 + 1 | 0;
       i4 = HEAP8[i14 + i5 >> 0] | 0;
       i7 = 0;
      } else i7 = i2;
     } else {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i8 + i9) >> 0] = 127;
      i7 = i2;
     }
     i8 = i8 + 1 | 0;
     i2 = HEAP32[i3 >> 2] | 0;
     if (i8 >>> 0 >= i2 >>> 0) break; else i2 = i7;
    }
   }
   i9 = i2 + i9 | 0;
   if (i9 >>> 0 >= i11 >>> 0) break; else i10 = ((i10 + 1 | 0) >>> 0) % ((HEAP32[i12 >> 2] | 0) >>> 0) | 0;
  }
 }
 i14 = i17 + 20 | 0;
 mftCall_iii(HEAP32[i17 + 48 >> 2] | 0, HEAP32[i14 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i17 + 52 >> 2] | 0, HEAP32[i14 >> 2] | 0, HEAP32[i1 >> 2] | 0, (HEAP32[i6 >> 2] | 0) + -1 + (HEAP32[i15 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i17 + 56 >> 2] | 0, HEAP32[i14 >> 2] | 0, i16 | 0, HEAP32[i15 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _scanexp(i8, i3) {
 i8 = i8 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i6 = i8 + 4 | 0;
 i1 = HEAP32[i6 >> 2] | 0;
 i7 = i8 + 100 | 0;
 if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
  HEAP32[i6 >> 2] = i1 + 1;
  i1 = HEAPU8[i1 >> 0] | 0;
 } else i1 = ___shgetc(i8) | 0;
 switch (i1 | 0) {
 case 43:
 case 45:
  {
   i2 = (i1 | 0) == 45 & 1;
   i1 = HEAP32[i6 >> 2] | 0;
   if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
    HEAP32[i6 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i8) | 0;
   if ((i3 | 0) != 0 & (i1 + -48 | 0) >>> 0 > 9 ? (HEAP32[i7 >> 2] | 0) != 0 : 0) {
    HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + -1;
    i5 = i2;
   } else i5 = i2;
   break;
  }
 default:
  i5 = 0;
 }
 if ((i1 + -48 | 0) >>> 0 > 9) if (!(HEAP32[i7 >> 2] | 0)) {
  i2 = -2147483648;
  i1 = 0;
 } else {
  HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + -1;
  i2 = -2147483648;
  i1 = 0;
 } else {
  i2 = 0;
  do {
   i2 = i1 + -48 + (i2 * 10 | 0) | 0;
   i1 = HEAP32[i6 >> 2] | 0;
   if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
    HEAP32[i6 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i8) | 0;
  } while ((i1 + -48 | 0) >>> 0 < 10 & (i2 | 0) < 214748364);
  i3 = ((i2 | 0) < 0) << 31 >> 31;
  if ((i1 + -48 | 0) >>> 0 < 10) {
   do {
    i3 = ___muldi3(i2 | 0, i3 | 0, 10, 0) | 0;
    i2 = getTempRet0() | 0;
    i1 = _i64Add(i1 | 0, ((i1 | 0) < 0) << 31 >> 31 | 0, -48, -1) | 0;
    i2 = _i64Add(i1 | 0, getTempRet0() | 0, i3 | 0, i2 | 0) | 0;
    i3 = getTempRet0() | 0;
    i1 = HEAP32[i6 >> 2] | 0;
    if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
     HEAP32[i6 >> 2] = i1 + 1;
     i1 = HEAPU8[i1 >> 0] | 0;
    } else i1 = ___shgetc(i8) | 0;
   } while ((i1 + -48 | 0) >>> 0 < 10 & ((i3 | 0) < 21474836 | (i3 | 0) == 21474836 & i2 >>> 0 < 2061584302));
   i4 = i2;
  } else i4 = i2;
  if ((i1 + -48 | 0) >>> 0 < 10) do {
   i1 = HEAP32[i6 >> 2] | 0;
   if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
    HEAP32[i6 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i8) | 0;
  } while ((i1 + -48 | 0) >>> 0 < 10);
  if (HEAP32[i7 >> 2] | 0) HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + -1;
  i8 = (i5 | 0) != 0;
  i1 = _i64Subtract(0, 0, i4 | 0, i3 | 0) | 0;
  i2 = getTempRet0() | 0;
  i2 = i8 ? i2 : i3;
  i1 = i8 ? i1 : i4;
 }
 setTempRet0(i2 | 0);
 return i1 | 0;
}

function _flexframesync_create(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 i6 = _malloc(220) | 0;
 HEAP32[i6 >> 2] = i1;
 HEAP32[i6 + 4 >> 2] = i2;
 i1 = i6 + 64 | 0;
 HEAP32[i1 >> 2] = 7;
 i2 = i6 + 68 | 0;
 HEAPF32[i2 >> 2] = .30000001192092896;
 i3 = i6 + 116 | 0;
 HEAP32[i3 >> 2] = _malloc(512) | 0;
 HEAP32[i6 + 120 >> 2] = _malloc(512) | 0;
 i4 = _msequence_create(7, 137, 1) | 0;
 i5 = 0;
 do {
  i9 = (_msequence_advance(i4) | 0) != 0;
  i8 = (_msequence_advance(i4) | 0) != 0;
  i7 = HEAP32[i3 >> 2] | 0;
  HEAPF32[i7 + (i5 << 3) >> 2] = (i9 ? .7071067811865476 : -.7071067811865476) + (i8 ? 0.0 : -0.0);
  HEAPF32[i7 + (i5 << 3) + 4 >> 2] = i8 ? .7071067690849304 : -.7071067690849304;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != 64);
 _msequence_destroy(i4);
 i9 = _qdetector_cccf_create_linear(HEAP32[i3 >> 2] | 0, 64, 7, 2, HEAP32[i1 >> 2] | 0, +HEAPF32[i2 >> 2]) | 0;
 HEAP32[i6 + 72 >> 2] = i9;
 _qdetector_cccf_set_threshold(i9, .5);
 HEAP32[i6 + 104 >> 2] = 32;
 i9 = i6 + 100 | 0;
 HEAP32[i9 >> 2] = _firpfb_crcf_create_rnyquist(7, 32, 2, HEAP32[i1 >> 2] | 0, +HEAPF32[i2 >> 2]) | 0;
 i7 = i6 + 92 | 0;
 HEAP32[i7 >> 2] = _nco_crcf_create(0) | 0;
 i5 = _nco_crcf_create(0) | 0;
 i8 = i6 + 96 | 0;
 HEAP32[i8 >> 2] = i5;
 _nco_crcf_pll_set_bandwidth(i5, 9.999999747378752e-05);
 HEAP32[i6 + 124 >> 2] = 0;
 HEAP32[i6 + 136 >> 2] = 0;
 HEAP32[i6 + 156 >> 2] = 0;
 HEAP32[i6 + 132 >> 2] = 0;
 HEAP32[i6 + 144 >> 2] = 0;
 _flexframesync_set_header_len(i6, 14);
 HEAP32[i6 + 164 >> 2] = _modem_create(48) | 0;
 i5 = i6 + 184 | 0;
 HEAP32[i5 >> 2] = 64;
 i3 = _qpacketmodem_create() | 0;
 i4 = i6 + 176 | 0;
 HEAP32[i4 >> 2] = i3;
 _qpacketmodem_configure(i3, HEAP32[i5 >> 2] | 0, 5, 1, 7, 48) | 0;
 i4 = _qpacketmodem_get_frame_len(HEAP32[i4 >> 2] | 0) | 0;
 HEAP32[i6 + 172 >> 2] = i4;
 HEAP32[i6 + 168 >> 2] = _malloc(i4 << 3) | 0;
 HEAP32[i6 + 180 >> 2] = _malloc(HEAP32[i5 >> 2] | 0) | 0;
 _framedatastats_reset(i6 + 48 | 0);
 i5 = i6 + 204 | 0;
 HEAP32[i5 >> 2] = 0;
 HEAP32[i5 + 4 >> 2] = 0;
 HEAP32[i5 + 8 >> 2] = 0;
 HEAP32[i5 + 12 >> 2] = 0;
 _nco_crcf_reset(HEAP32[i7 >> 2] | 0);
 _nco_crcf_reset(HEAP32[i8 >> 2] | 0);
 _firpfb_crcf_reset(HEAP32[i9 >> 2] | 0);
 HEAP32[i6 + 200 >> 2] = 0;
 HEAP32[i6 + 192 >> 2] = 0;
 HEAP32[i6 + 196 >> 2] = 0;
 HEAPF32[i6 + 8 >> 2] = 0.0;
 return i6 | 0;
}

function _pop_arg(i2, i3, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0, d6 = 0.0;
 L1 : do if (i3 >>> 0 <= 20) do switch (i3 | 0) {
 case 9:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i3 = HEAP32[i4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 4;
   HEAP32[i2 >> 2] = i3;
   break L1;
  }
 case 10:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i3 = HEAP32[i4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 4;
   i4 = i2;
   HEAP32[i4 >> 2] = i3;
   HEAP32[i4 + 4 >> 2] = ((i3 | 0) < 0) << 31 >> 31;
   break L1;
  }
 case 11:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i3 = HEAP32[i4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 4;
   i4 = i2;
   HEAP32[i4 >> 2] = i3;
   HEAP32[i4 + 4 >> 2] = 0;
   break L1;
  }
 case 12:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (8 - 1) & ~(8 - 1);
   i3 = i4;
   i5 = HEAP32[i3 >> 2] | 0;
   i3 = HEAP32[i3 + 4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 8;
   i4 = i2;
   HEAP32[i4 >> 2] = i5;
   HEAP32[i4 + 4 >> 2] = i3;
   break L1;
  }
 case 13:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i4 = (i4 & 65535) << 16 >> 16;
   i5 = i2;
   HEAP32[i5 >> 2] = i4;
   HEAP32[i5 + 4 >> 2] = ((i4 | 0) < 0) << 31 >> 31;
   break L1;
  }
 case 14:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i5 = i2;
   HEAP32[i5 >> 2] = i4 & 65535;
   HEAP32[i5 + 4 >> 2] = 0;
   break L1;
  }
 case 15:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i4 = (i4 & 255) << 24 >> 24;
   i5 = i2;
   HEAP32[i5 >> 2] = i4;
   HEAP32[i5 + 4 >> 2] = ((i4 | 0) < 0) << 31 >> 31;
   break L1;
  }
 case 16:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i5 = i2;
   HEAP32[i5 >> 2] = i4 & 255;
   HEAP32[i5 + 4 >> 2] = 0;
   break L1;
  }
 case 17:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (8 - 1) & ~(8 - 1);
   d6 = +HEAPF64[i5 >> 3];
   HEAP32[i1 >> 2] = i5 + 8;
   HEAPF64[i2 >> 3] = d6;
   break L1;
  }
 case 18:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (8 - 1) & ~(8 - 1);
   d6 = +HEAPF64[i5 >> 3];
   HEAP32[i1 >> 2] = i5 + 8;
   HEAPF64[i2 >> 3] = d6;
   break L1;
  }
 default:
  break L1;
 } while (0); while (0);
 return;
}

function _ofdmframesync_execute_rxsymbols(i13) {
 i13 = i13 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, i15 = 0, i16 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i14 + 16 | 0;
 i1 = i14 + 8 | 0;
 i10 = i14;
 i11 = i13 + 124 | 0;
 i12 = (HEAP32[i11 >> 2] | 0) + -1 | 0;
 HEAP32[i11 >> 2] = i12;
 if (i12 | 0) {
  STACKTOP = i14;
  return;
 }
 _windowcf_read(HEAP32[i13 + 60 >> 2] | 0, i1);
 i12 = i13 + 8 | 0;
 _memmove(HEAP32[i13 + 56 >> 2] | 0, (HEAP32[i1 >> 2] | 0) + ((HEAP32[i12 >> 2] | 0) - (HEAP32[i13 + 132 >> 2] | 0) << 3) | 0, HEAP32[i13 >> 2] << 3 | 0) | 0;
 _fft_execute(HEAP32[i13 + 48 >> 2] | 0);
 _ofdmframesync_rxsymbol(i13);
 if (HEAP32[i13 + 168 >> 2] | 0 ? (i4 = HEAP32[i13 >> 2] | 0, i4 | 0) : 0) {
  i5 = i13 + 12 | 0;
  i6 = i13 + 184 | 0;
  i7 = i13 + 52 | 0;
  i8 = i10 + 4 | 0;
  i1 = 0;
  do {
   if ((HEAP8[(HEAP32[i5 >> 2] | 0) + i1 >> 0] | 0) == 2) {
    i4 = HEAP32[i6 >> 2] | 0;
    i16 = HEAP32[i7 >> 2] | 0;
    i15 = HEAP32[i16 + (i1 << 3) + 4 >> 2] | 0;
    HEAP32[i10 >> 2] = HEAP32[i16 + (i1 << 3) >> 2];
    HEAP32[i8 >> 2] = i15;
    HEAP32[i9 >> 2] = HEAP32[i10 >> 2];
    HEAP32[i9 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
    _windowcf_push(i4, i9);
    i4 = HEAP32[i13 >> 2] | 0;
   }
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i4 >>> 0);
 }
 i1 = HEAP32[i13 + 160 >> 2] | 0;
 if (i1 | 0 ? mftCall_iiiii(i1 | 0, HEAP32[i13 + 52 >> 2] | 0, HEAP32[i13 + 12 >> 2] | 0, HEAP32[i13 >> 2] | 0, HEAP32[i13 + 164 >> 2] | 0) | 0 : 0) {
  _nco_crcf_reset(HEAP32[i13 + 108 >> 2] | 0);
  _msequence_reset(HEAP32[i13 + 112 >> 2] | 0);
  i1 = i13 + 136 | 0;
  i16 = i13 + 116 | 0;
  HEAP32[i16 >> 2] = 0;
  HEAP32[i16 + 4 >> 2] = 0;
  HEAP32[i16 + 8 >> 2] = 0;
  HEAP32[i16 + 12 >> 2] = 0;
  HEAP32[i1 >> 2] = 0;
  HEAP32[i1 + 4 >> 2] = 0;
  HEAP32[i1 + 8 >> 2] = 0;
  HEAP32[i1 + 12 >> 2] = 0;
  i1 = HEAP32[i13 >> 2] | 0;
  if (i1 >>> 0 > 44) {
   d2 = .3499999940395355;
   d3 = .30000001192092896;
  } else {
   d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
   d2 = d3 + .3499999940395355;
   d3 = d3 + .30000001192092896;
  }
  HEAPF32[i13 + 152 >> 2] = d2;
  HEAPF32[i13 + 156 >> 2] = d3;
  HEAP32[i13 + 104 >> 2] = 0;
 }
 HEAP32[i11 >> 2] = (HEAP32[i12 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
 STACKTOP = i14;
 return;
}

function _modulator_emit(i20, i24, i23, i22) {
 i20 = i20 | 0;
 i24 = i24 | 0;
 i23 = i23 | 0;
 i22 = i22 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i21 = 0, i25 = 0, i26 = 0;
 i26 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i5 = i26 + 32 | 0;
 i6 = i26 + 24 | 0;
 i21 = i26 + 8 | 0;
 i7 = i26 + 16 | 0;
 i15 = i26;
 if (!i20) {
  i25 = 0;
  STACKTOP = i26;
  return i25 | 0;
 }
 i19 = HEAP32[i20 >> 2] | 0;
 i25 = _llvm_stacksave() | 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i19 << 3) | 0) + 15 & -16) | 0;
 if (!i23) i1 = 0; else {
  i17 = i20 + 28 | 0;
  i18 = i16 + 4 | 0;
  i8 = i6 + 4 | 0;
  i9 = i20 + 24 | 0;
  i10 = i7 + 4 | 0;
  i11 = i20 + 32 | 0;
  i12 = i20 + 16 | 0;
  i13 = i21 + 4 | 0;
  i14 = i15 + 4 | 0;
  i19 = 0;
  i1 = 0;
  do {
   i2 = HEAP32[i17 >> 2] | 0;
   i3 = HEAP32[i24 + (i19 << 3) >> 2] | 0;
   i4 = HEAP32[i24 + (i19 << 3) + 4 >> 2] | 0;
   if (!i2) {
    HEAP32[i16 >> 2] = i3;
    HEAP32[i18 >> 2] = i4;
   } else {
    HEAP32[i6 >> 2] = i3;
    HEAP32[i8 >> 2] = i4;
    HEAP32[i5 >> 2] = HEAP32[i6 >> 2];
    HEAP32[i5 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
    _firinterp_crcf_execute(i2, i5, i16);
   }
   if (HEAP32[i20 >> 2] | 0) {
    i3 = 0;
    do {
     i2 = HEAP32[i9 >> 2] | 0;
     i4 = HEAP32[i16 + (i3 << 3) + 4 >> 2] | 0;
     HEAP32[i7 >> 2] = HEAP32[i16 + (i3 << 3) >> 2];
     HEAP32[i10 >> 2] = i4;
     HEAP32[i5 >> 2] = HEAP32[i7 >> 2];
     HEAP32[i5 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
     _nco_crcf_mix_up(i2, i5, i21);
     i2 = HEAP32[i11 >> 2] | 0;
     if (i2 | 0) {
      i4 = HEAP32[i13 >> 2] | 0;
      HEAP32[i15 >> 2] = HEAP32[i21 >> 2];
      HEAP32[i14 >> 2] = i4;
      HEAP32[i5 >> 2] = HEAP32[i15 >> 2];
      HEAP32[i5 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
      _iirfilt_crcf_execute(i2, i5, i21);
     }
     HEAPF32[i22 + ((Math_imul(HEAP32[i20 >> 2] | 0, i19) | 0) + i3 << 2) >> 2] = +HEAPF32[i21 >> 2] * +HEAPF32[i12 >> 2];
     i1 = i1 + 1 | 0;
     _nco_crcf_step(HEAP32[i9 >> 2] | 0);
     i3 = i3 + 1 | 0;
    } while (i3 >>> 0 < (HEAP32[i20 >> 2] | 0) >>> 0);
   }
   i19 = i19 + 1 | 0;
  } while ((i19 | 0) != (i23 | 0));
 }
 _llvm_stackrestore(i25 | 0);
 i25 = i1;
 STACKTOP = i26;
 return i25 | 0;
}

function _fec_conv_encode(i18, i17, i13, i16) {
 i18 = i18 | 0;
 i17 = i17 | 0;
 i13 = i13 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, i15 = 0;
 i14 = g$_P_init() | 0;
 i15 = g$_Partab() | 0;
 if (!i17) {
  i2 = 0;
  i1 = 0;
  i5 = 0;
 } else {
  i11 = i18 + 28 | 0;
  i12 = i18 + 24 | 0;
  i4 = HEAP32[i11 >> 2] | 0;
  i2 = 0;
  i3 = 0;
  i1 = 0;
  i5 = 0;
  do {
   i10 = HEAPU8[i13 + i3 >> 0] | 0;
   i7 = i4;
   i6 = i4;
   i9 = 0;
   i4 = i5;
   while (1) {
    i8 = i10 >>> (7 - i9 | 0) & 1 | i4 << 1;
    if (!i6) {
     i4 = i7;
     i5 = 0;
    } else {
     i6 = 0;
     do {
      i4 = HEAP32[(HEAP32[i12 >> 2] | 0) + (i6 << 2) >> 2] & i8;
      i4 = i4 >> 16 ^ i4;
      if (!(HEAP32[i14 >> 2] | 0)) _partab_init();
      i2 = (HEAPU8[i15 + ((i4 >>> 8 ^ i4) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
      HEAP8[i16 + (i1 >>> 3) >> 0] = i2;
      i1 = i1 + 1 | 0;
      i6 = i6 + 1 | 0;
      i5 = HEAP32[i11 >> 2] | 0;
     } while (i6 >>> 0 < i5 >>> 0);
     i4 = i5;
    }
    i9 = i9 + 1 | 0;
    if ((i9 | 0) == 8) {
     i5 = i8;
     break;
    } else {
     i7 = i4;
     i6 = i5;
     i4 = i8;
    }
   }
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i17 | 0));
 }
 i8 = i18 + 32 | 0;
 i3 = HEAP32[i8 >> 2] | 0;
 if ((i3 | 0) != 1) {
  i9 = i18 + 28 | 0;
  i10 = i18 + 24 | 0;
  i4 = HEAP32[i9 >> 2] | 0;
  i7 = 0;
  i6 = i5;
  do {
   i6 = i6 << 1;
   if (!i4) i4 = 0; else {
    i5 = 0;
    do {
     i3 = HEAP32[(HEAP32[i10 >> 2] | 0) + (i5 << 2) >> 2] & i6;
     i3 = i3 >> 16 ^ i3;
     if (!(HEAP32[i14 >> 2] | 0)) _partab_init();
     i2 = (HEAPU8[i15 + ((i3 >>> 8 ^ i3) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
     HEAP8[i16 + (i1 >>> 3) >> 0] = i2;
     i1 = i1 + 1 | 0;
     i5 = i5 + 1 | 0;
     i4 = HEAP32[i9 >> 2] | 0;
    } while (i5 >>> 0 < i4 >>> 0);
    i3 = HEAP32[i8 >> 2] | 0;
   }
   i7 = i7 + 1 | 0;
  } while (i7 >>> 0 < (i3 + -1 | 0) >>> 0);
 }
 if (i1 & 7) do {
  i2 = (i2 & 255) << 1 & 255;
  HEAP8[i16 + (i1 >>> 3) >> 0] = i2;
  i1 = i1 + 1 | 0;
 } while ((i1 & 7 | 0) != 0);
 if ((i1 | 0) == ((_fec_get_enc_msg_length(HEAP32[i18 >> 2] | 0, i17) | 0) << 3 | 0)) return; else ___assert_fail(gb + 12477 | 0, gb + 12398 | 0, 131, gb + 12421 | 0);
}

function _crc_generate_key(i1, i4, i5) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i6;
 switch (i1 | 0) {
 case 0:
  {
   _fwrite(gb + 10733 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(-1);
   break;
  }
 case 2:
  {
   if (!i5) {
    i5 = 0;
    STACKTOP = i6;
    return i5 | 0;
   } else {
    i2 = 0;
    i1 = 0;
   }
   do {
    i1 = (HEAPU8[i4 + i2 >> 0] | 0) + i1 | 0;
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i5 | 0));
   i5 = (i1 ^ 255) + 1 & 255;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 3:
  {
   i2 = HEAPU8[gb + 39011 + 7 >> 0] | 0;
   if (!i5) {
    i5 = 0;
    STACKTOP = i6;
    return i5 | 0;
   } else {
    i3 = 0;
    i1 = -1;
   }
   do {
    i1 = (HEAPU8[i4 + i3 >> 0] | 0) ^ i1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i5 | 0));
   i5 = i1 & 255 ^ 255;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 4:
  {
   i5 = _crc16_generate_key(i4, i5) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 5:
  {
   i5 = _crc24_generate_key(i4, i5) | 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 6:
  {
   i2 = _liquid_reverse_uint32(79764919) | 0;
   if (!i5) {
    i5 = 0;
    STACKTOP = i6;
    return i5 | 0;
   } else {
    i3 = 0;
    i1 = -1;
   }
   do {
    i1 = (HEAPU8[i4 + i3 >> 0] | 0) ^ i1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i5 | 0));
   i5 = ~i1;
   STACKTOP = i6;
   return i5 | 0;
  }
 case 1:
  {
   i5 = 0;
   STACKTOP = i6;
   return i5 | 0;
  }
 default:
  {
   i6 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i2 >> 2] = i1;
   _fprintf(i6, gb + 10805 | 0, i2) | 0;
   _exit(1);
  }
 }
 return 0;
}

function _fec_golay2412_encode(i1, i16, i14, i15) {
 i1 = i1 | 0;
 i16 = i16 | 0;
 i14 = i14 | 0;
 i15 = i15 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 i13 = (i16 >>> 0) % 3 | 0;
 i2 = i16 - i13 | 0;
 if ((i13 | 0) == (i16 | 0)) i1 = 0; else {
  i11 = HEAPU8[gb + 38499 >> 0] | 0;
  i12 = 0;
  i1 = 0;
  do {
   i8 = HEAPU8[i14 + (i12 + 1) >> 0] | 0;
   i7 = HEAP8[i14 + (i12 + 2) >> 0] | 0;
   i3 = i8 >>> 4 | (HEAPU8[i14 + i12 >> 0] | 0) << 4;
   i8 = i8 << 8 & 3840;
   i5 = 0;
   i6 = 0;
   while (1) {
    i4 = HEAP32[gb + 380 + (i5 << 2) >> 2] & i3;
    i4 = (HEAPU8[(i4 >>> 8) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 38499) >> 0] | 0) + i11 & 1 | i6 << 1;
    i5 = i5 + 1 | 0;
    if ((i5 | 0) == 24) {
     i10 = i4;
     i9 = i6;
     break;
    } else i6 = i4;
   }
   i5 = i8 | i7 & 255;
   i6 = 0;
   i3 = 0;
   while (1) {
    i4 = HEAP32[gb + 380 + (i6 << 2) >> 2] & i5;
    i4 = (HEAPU8[(i4 >>> 8) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 38499) >> 0] | 0) + i11 & 1 | i3 << 1;
    i6 = i6 + 1 | 0;
    if ((i6 | 0) == 24) break; else i3 = i4;
   }
   HEAP8[i15 + i1 >> 0] = i9 >>> 15;
   HEAP8[i15 + (i1 | 1) >> 0] = i9 >>> 7;
   HEAP8[i15 + (i1 + 2) >> 0] = i10;
   HEAP8[i15 + (i1 + 3) >> 0] = i3 >>> 15;
   HEAP8[i15 + (i1 + 4) >> 0] = i3 >>> 7;
   HEAP8[i15 + (i1 + 5) >> 0] = i4;
   i1 = i1 + 6 | 0;
   i12 = i12 + 3 | 0;
  } while (i12 >>> 0 < i2 >>> 0);
 }
 if (i2 >>> 0 < i16 >>> 0) {
  i8 = i13 * 3 | 0;
  i7 = i1;
  while (1) {
   i5 = HEAPU8[i14 + i2 >> 0] | 0;
   i6 = 0;
   i3 = 0;
   while (1) {
    i4 = (HEAPU8[(HEAP32[gb + 380 + (i6 << 2) >> 2] & i5) + (gb + 38499) >> 0] | 0) & 1 | i3 << 1;
    i6 = i6 + 1 | 0;
    if ((i6 | 0) == 24) break; else i3 = i4;
   }
   HEAP8[i15 + i7 >> 0] = i3 >>> 15;
   HEAP8[i15 + (i7 + 1) >> 0] = i3 >>> 7;
   HEAP8[i15 + (i7 + 2) >> 0] = i4;
   i2 = i2 + 1 | 0;
   if ((i2 | 0) == (i16 | 0)) break; else i7 = i7 + 3 | 0;
  }
  i2 = i16;
  i1 = i1 + i8 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(7, i16) | 0)) ___assert_fail(gb + 12703 | 0, gb + 12766 | 0, 326, gb + 12794 | 0);
 if ((i2 | 0) == (i16 | 0)) return; else ___assert_fail(gb + 18871 | 0, gb + 12766 | 0, 327, gb + 12794 | 0);
}

function _quiet_decoder_create(i6, d7) {
 i6 = i6 | 0;
 d7 = +d7;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0;
 if (!i6) {
  i8 = 0;
  return i8 | 0;
 }
 i8 = _malloc(112) | 0;
 i1 = i8;
 i2 = i6;
 i3 = i1 + 60 | 0;
 do {
  HEAP32[i1 >> 2] = HEAP32[i2 >> 2];
  i1 = i1 + 4 | 0;
  i2 = i2 + 4 | 0;
 } while ((i1 | 0) < (i3 | 0));
 HEAP32[i8 + 68 >> 2] = _malloc(8192) | 0;
 HEAP32[i8 + 72 >> 2] = 8192;
 HEAP32[i8 + 76 >> 2] = 0;
 switch (HEAP32[i8 + 52 >> 2] | 0) {
 case 0:
  {
   i3 = _ofdm_subcarriers_create(i6) | 0;
   i1 = i6 + 4 | 0;
   i2 = _ofdmflexframesync_create(HEAP32[i6 >> 2] | 0, HEAP32[i1 >> 2] | 0, HEAP32[i6 + 8 >> 2] | 0, i3, fb + 1 | 0, i8) | 0;
   _ofdmflexframesync_set_header_len(i2, 0);
   if (HEAP8[i6 + 56 >> 0] | 0) _ofdmflexframesync_debug_enable(i2);
   i5 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i6 >> 2] | 0) | 0;
   HEAP32[i8 + 80 >> 2] = _malloc(i5 << 3) | 0;
   HEAP32[i8 + 84 >> 2] = i5;
   _free(i3);
   HEAP32[i8 + 60 >> 2] = i2;
   break;
  }
 case 1:
  {
   i1 = _flexframesync_create(fb + 1 | 0, i8) | 0;
   _flexframesync_set_header_len(i1, 0);
   if (HEAP8[i6 + 56 >> 0] | 0) _flexframesync_debug_enable(i1);
   HEAP32[i8 + 80 >> 2] = _malloc(2048) | 0;
   HEAP32[i8 + 84 >> 2] = 256;
   HEAP32[i8 + 60 >> 2] = i1;
   break;
  }
 case 2:
  {
   i1 = _gmskframesync_create(fb + 1 | 0, i8) | 0;
   _gmskframesync_set_header_len(i1, 0);
   if (HEAP8[i6 + 56 >> 0] | 0) _gmskframesync_debug_enable(i1);
   HEAP32[i8 + 80 >> 2] = _malloc(2048) | 0;
   HEAP32[i8 + 84 >> 2] = 256;
   HEAP32[i8 + 60 >> 2] = i1;
   break;
  }
 default:
  {}
 }
 i1 = _demodulator_create(i6 + 20 | 0) | 0;
 i2 = i8 + 64 | 0;
 HEAP32[i2 >> 2] = i1;
 HEAP32[i8 + 88 >> 2] = 0;
 i3 = i8 + 92 | 0;
 HEAPF32[i3 >> 2] = 1.0;
 i5 = i8 + 100 | 0;
 HEAP32[i5 >> 2] = 0;
 i4 = i8 + 96 | 0;
 HEAP32[i4 >> 2] = 0;
 if (d7 != 44100.0) {
  d7 = 44100.0 / d7;
  HEAP32[i4 >> 2] = _resamp_rrrf_create(d7, HEAP32[i6 + 36 >> 2] | 0, +HEAPF32[i6 + 40 >> 2], +HEAPF32[i6 + 44 >> 2], HEAP32[i6 + 48 >> 2] | 0) | 0;
  HEAPF32[i3 >> 2] = d7;
  i1 = HEAP32[i2 >> 2] | 0;
 }
 HEAP32[i5 >> 2] = _malloc(Math_imul(HEAP32[i8 + 84 >> 2] << 2, HEAP32[i1 >> 2] | 0) | 0) | 0;
 HEAP32[i8 + 104 >> 2] = 0;
 HEAP32[i8 + 108 >> 2] = 0;
 return i8 | 0;
}

function _firpfb_rrrf_create_drnyquist(i6, i14, i7, i8, d2) {
 i6 = i6 | 0;
 i14 = i14 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 d2 = +d2;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0, d16 = 0.0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i15 + 24 | 0;
 i4 = i15 + 16 | 0;
 i3 = i15 + 8 | 0;
 i1 = i15;
 if (!i14) {
  i13 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 18911;
  _fprintf(i13, gb + 18916 | 0, i1) | 0;
  _exit(1);
 }
 if (i7 >>> 0 < 2) {
  i13 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i3 >> 2] = gb + 18911;
  _fprintf(i13, gb + 18998 | 0, i3) | 0;
  _exit(1);
 }
 if (!i8) {
  i13 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i4 >> 2] = gb + 18911;
  _fprintf(i13, gb + 19081 | 0, i4) | 0;
  _exit(1);
 }
 if (d2 < 0.0 | d2 > 1.0) {
  i13 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i5 >> 2] = gb + 18911;
  _fprintf(i13, gb + 19155 | 0, i5) | 0;
  _exit(1);
 }
 i10 = Math_imul(Math_imul(i14 << 1, i7) | 0, i8) | 0;
 i13 = i10 | 1;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i13 << 2) | 0) + 15 & -16) | 0;
 _liquid_firdes_prototype(i6, Math_imul(i7, i14) | 0, i8, d2, 0.0, i11);
 i12 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i13 << 2) | 0) + 15 & -16) | 0;
 i6 = i11 + (i10 << 2) | 0;
 d9 = +HEAPF32[i11 >> 2];
 i7 = (Math_imul(Math_imul(i8, i7) | 0, i14) | 0) << 1 | 1;
 i1 = i11 + 4 | 0;
 i3 = i11 + (i10 + -1 << 2) | 0;
 i4 = i12 + (i10 << 2) | 0;
 d2 = 0.0;
 i5 = 0;
 do {
  do if (i5) if ((i5 | 0) == (i10 | 0)) {
   HEAPF32[i4 >> 2] = d9 - +HEAPF32[i3 >> 2];
   break;
  } else {
   HEAPF32[i12 + (i5 << 2) >> 2] = +HEAPF32[i11 + (i5 + 1 << 2) >> 2] - +HEAPF32[i11 + (i5 + -1 << 2) >> 2];
   break;
  } else HEAPF32[i12 >> 2] = +HEAPF32[i1 >> 2] - +HEAPF32[i6 >> 2]; while (0);
  d16 = +Math_abs(+(+HEAPF32[i11 + (i5 << 2) >> 2] * +HEAPF32[i12 + (i5 << 2) >> 2]));
  d2 = d16 > d2 ? d16 : d2;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i7 | 0));
 i1 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i13 << 2) | 0) + 15 & -16) | 0;
 i3 = 0;
 do {
  HEAPF32[i1 + (i3 << 2) >> 2] = +HEAPF32[i12 + (i3 << 2) >> 2] * .05999999865889549 / d2;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i7 | 0));
 i14 = _firpfb_rrrf_create(i14, i1, i13) | 0;
 STACKTOP = i15;
 return i14 | 0;
}

function _expm1f(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0;
 i3 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 d6 = +Math_abs(+d1);
 i2 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
 i3 = i3 >>> 31;
 do if (i2 >>> 0 > 1100331075) {
  if (i2 >>> 0 <= 2139095040) if (!i3) if (d1 > 88.7216796875) d1 = d1 * 1701411834604692317316873.0e14; else i7 = 11; else d1 = -1.0;
 } else {
  if (i2 >>> 0 <= 1051816472) if (i2 >>> 0 < 855638016) break; else {
   d6 = 0.0;
   i3 = 0;
   i7 = 14;
   break;
  }
  if (i2 >>> 0 < 1065686418) if (!i3) {
   d4 = d1 + -.6931381225585938;
   i2 = 1;
   d5 = 9.05800061445916e-06;
   i7 = 12;
   break;
  } else {
   d4 = d1 + .6931381225585938;
   i2 = -1;
   d5 = -9.05800061445916e-06;
   i7 = 12;
   break;
  } else i7 = 11;
 } while (0);
 if ((i7 | 0) == 11) {
  i2 = ~~(d1 * 1.4426950216293335 + (i3 | 0 ? -.5 : .5));
  d5 = +(i2 | 0);
  d4 = d1 - d5 * .6931381225585938;
  d5 = d5 * 9.05800061445916e-06;
  i7 = 12;
 }
 if ((i7 | 0) == 12) {
  d6 = d4 - d5;
  d1 = d6;
  d6 = d4 - d6 - d5;
  i3 = i2;
  i7 = 14;
 }
 L18 : do if ((i7 | 0) == 14) {
  d5 = d1 * .5;
  d4 = d1 * d5;
  d8 = d4 * (d4 * 1.5807170420885086e-03 + -.03333321213722229) + 1.0;
  d5 = 3.0 - d5 * d8;
  d5 = d4 * ((d8 - d5) / (6.0 - d1 * d5));
  if (!i3) {
   d1 = d1 - (d1 * d5 - d4);
   break;
  }
  d4 = d1 * (d5 - d6) - d6 - d4;
  switch (i3 | 0) {
  case -1:
   {
    d1 = (d1 - d4) * .5 + -.5;
    break L18;
   }
  case 1:
   if (d1 < -.25) {
    d1 = (d4 - (d1 + .5)) * -2.0;
    break L18;
   } else {
    d1 = (d1 - d4) * 2.0 + 1.0;
    break L18;
   }
  default:
   {
    d5 = (HEAP32[tempDoublePtr >> 2] = (i3 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
    if (i3 >>> 0 > 56) {
     d1 = d1 - d4 + 1.0;
     d1 = ((i3 | 0) == 128 ? d1 * 2.0 * 1701411834604692317316873.0e14 : d5 * d1) + -1.0;
     break L18;
    }
    i2 = 127 - i3 << 23;
    if ((i3 | 0) < 23) d1 = 1.0 - (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]) + (d1 - d4); else d1 = d1 - ((HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]) + d4) + 1.0;
    d1 = d5 * d1;
    break L18;
   }
  }
 } while (0);
 return +d1;
}

function _utf8_check_full(i5, i8, i6) {
 i5 = i5 | 0;
 i8 = i8 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i12 + 20 | 0;
 i2 = i12 + 16 | 0;
 i3 = i12 + 12 | 0;
 i4 = i12 + 8 | 0;
 i7 = i12 + 4 | 0;
 i10 = i12;
 i9 = i12 + 24 | 0;
 HEAP32[i2 >> 2] = i5;
 HEAP32[i3 >> 2] = i8;
 HEAP32[i4 >> 2] = i6;
 HEAP32[i10 >> 2] = 0;
 HEAP8[i9 >> 0] = HEAP8[HEAP32[i2 >> 2] >> 0] | 0;
 do if ((HEAP32[i3 >> 2] | 0) == 2) HEAP32[i10 >> 2] = (HEAPU8[i9 >> 0] | 0) & 31; else {
  if ((HEAP32[i3 >> 2] | 0) == 3) {
   HEAP32[i10 >> 2] = (HEAPU8[i9 >> 0] | 0) & 15;
   break;
  }
  if ((HEAP32[i3 >> 2] | 0) == 4) {
   HEAP32[i10 >> 2] = (HEAPU8[i9 >> 0] | 0) & 7;
   break;
  }
  HEAP32[i1 >> 2] = 0;
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 } while (0);
 HEAP32[i7 >> 2] = 1;
 while (1) {
  if ((HEAP32[i7 >> 2] | 0) >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) break;
  HEAP8[i9 >> 0] = HEAP8[(HEAP32[i2 >> 2] | 0) + (HEAP32[i7 >> 2] | 0) >> 0] | 0;
  if ((HEAPU8[i9 >> 0] | 0 | 0) < 128) {
   i11 = 12;
   break;
  }
  if ((HEAPU8[i9 >> 0] | 0 | 0) > 191) {
   i11 = 12;
   break;
  }
  HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] << 6) + ((HEAPU8[i9 >> 0] | 0) & 63);
  HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + 1;
 }
 if ((i11 | 0) == 12) {
  HEAP32[i1 >> 2] = 0;
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 if ((HEAP32[i10 >> 2] | 0) > 1114111) {
  HEAP32[i1 >> 2] = 0;
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 if (55296 <= (HEAP32[i10 >> 2] | 0) & (HEAP32[i10 >> 2] | 0) <= 57343) {
  HEAP32[i1 >> 2] = 0;
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 if ((!((HEAP32[i3 >> 2] | 0) == 2 & (HEAP32[i10 >> 2] | 0) < 128) ? !((HEAP32[i3 >> 2] | 0) == 3 & (HEAP32[i10 >> 2] | 0) < 2048) : 0) ? !((HEAP32[i3 >> 2] | 0) == 4 & (HEAP32[i10 >> 2] | 0) < 65536) : 0) {
  if (HEAP32[i4 >> 2] | 0) HEAP32[HEAP32[i4 >> 2] >> 2] = HEAP32[i10 >> 2];
  HEAP32[i1 >> 2] = 1;
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 HEAP32[i1 >> 2] = 0;
 i11 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i12;
 return i11 | 0;
}

function _fec_conv_punctured_decode_soft(i15, i1, i12, i14) {
 i15 = i15 | 0;
 i1 = i1 | 0;
 i12 = i12 | 0;
 i14 = i14 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0;
 i13 = i15 + 8 | 0;
 if ((HEAP32[i13 >> 2] | 0) == (i1 | 0)) {
  i3 = i15 + 28 | 0;
  i6 = i15 + 32 | 0;
 } else {
  HEAP32[i13 >> 2] = i1;
  HEAP32[i15 + 12 >> 2] = _fec_get_enc_msg_length(HEAP32[i15 >> 2] | 0, i1) | 0;
  i1 = HEAP32[i13 >> 2] | 0;
  i6 = i15 + 32 | 0;
  i3 = i15 + 28 | 0;
  i4 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, HEAP32[i3 >> 2] | 0) | 0;
  i5 = i15 + 20 | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  if (i2) {
   mftCall_vi(HEAP32[i15 + 60 >> 2] | 0, i2 | 0);
   i1 = HEAP32[i13 >> 2] | 0;
  }
  HEAP32[i5 >> 2] = mftCall_ii(HEAP32[i15 + 44 >> 2] | 0, i1 << 3 | 0) | 0;
  i1 = i15 + 16 | 0;
  HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i4) | 0;
  i1 = HEAP32[i13 >> 2] | 0;
 }
 i2 = HEAP32[i3 >> 2] | 0;
 i9 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, i2) | 0;
 if (!i9) i1 = i15 + 16 | 0; else {
  i10 = i15 + 36 | 0;
  i11 = i15 + 40 | 0;
  i1 = i15 + 16 | 0;
  i7 = 0;
  i4 = 0;
  i8 = 0;
  while (1) {
   if (!i2) i2 = 0; else {
    i2 = i4;
    i5 = 0;
    while (1) {
     i4 = (Math_imul(HEAP32[i10 >> 2] | 0, i5) | 0) + i8 | 0;
     if (!(HEAP32[(HEAP32[i11 >> 2] | 0) + (i4 << 2) >> 2] | 0)) {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i5 + i7) >> 0] = 127;
      i4 = i2;
     } else {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i5 + i7) >> 0] = HEAP8[i12 + i2 >> 0] | 0;
      i4 = i2 + 1 | 0;
     }
     i5 = i5 + 1 | 0;
     i2 = HEAP32[i3 >> 2] | 0;
     if (i5 >>> 0 >= i2 >>> 0) break; else i2 = i4;
    }
   }
   i7 = i2 + i7 | 0;
   if (i7 >>> 0 >= i9 >>> 0) break; else i8 = ((i8 + 1 | 0) >>> 0) % ((HEAP32[i10 >> 2] | 0) >>> 0) | 0;
  }
 }
 i12 = i15 + 20 | 0;
 mftCall_iii(HEAP32[i15 + 48 >> 2] | 0, HEAP32[i12 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i15 + 52 >> 2] | 0, HEAP32[i12 >> 2] | 0, HEAP32[i1 >> 2] | 0, (HEAP32[i6 >> 2] | 0) + -1 + (HEAP32[i13 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i15 + 56 >> 2] | 0, HEAP32[i12 >> 2] | 0, i14 | 0, HEAP32[i13 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _fft_destroy_plan(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0;
 switch (HEAP32[i3 + 20 >> 2] | 0) {
 case -1:
 case 1:
  {
   switch (HEAP32[i3 + 24 >> 2] | 0) {
   case 5:
    {
     i1 = HEAP32[i3 + 40 >> 2] | 0;
     if (i1 | 0) _free(i1);
     i2 = i3 + 44 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (i1 | 0) {
      if (HEAP32[i3 >> 2] | 0) {
       _dotprod_cccf_destroy(HEAP32[i1 >> 2] | 0);
       if ((HEAP32[i3 >> 2] | 0) >>> 0 > 1) {
        i1 = 1;
        do {
         _dotprod_cccf_destroy(HEAP32[(HEAP32[i2 >> 2] | 0) + (i1 << 2) >> 2] | 0);
         i1 = i1 + 1 | 0;
        } while (i1 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
       }
       i1 = HEAP32[i2 >> 2] | 0;
      }
      _free(i1);
     }
     _free(i3);
     return;
    }
   case 1:
    {
     _free(HEAP32[i3 + 44 >> 2] | 0);
     _free(HEAP32[i3 + 48 >> 2] | 0);
     _free(i3);
     return;
    }
   case 2:
    {
     _fft_destroy_plan(HEAP32[i3 + 64 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i3 + 68 >> 2] | 0);
     _free(HEAP32[i3 + 52 >> 2] | 0);
     _free(HEAP32[i3 + 56 >> 2] | 0);
     _free(HEAP32[i3 + 48 >> 2] | 0);
     _free(HEAP32[i3 + 60 >> 2] | 0);
     _free(i3);
     return;
    }
   case 3:
    {
     _free(HEAP32[i3 + 40 >> 2] | 0);
     _free(HEAP32[i3 + 44 >> 2] | 0);
     _free(HEAP32[i3 + 48 >> 2] | 0);
     _free(HEAP32[i3 + 52 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i3 + 56 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i3 + 60 >> 2] | 0);
     _free(i3);
     return;
    }
   case 4:
    {
     _free(HEAP32[i3 + 44 >> 2] | 0);
     _free(HEAP32[i3 + 48 >> 2] | 0);
     _free(HEAP32[i3 + 52 >> 2] | 0);
     _free(HEAP32[i3 + 56 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i3 + 60 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i3 + 64 >> 2] | 0);
     _free(i3);
     return;
    }
   default:
    {
     _fwrite(gb + 39876 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
     _exit(1);
    }
   }
   break;
  }
 case 23:
 case 22:
 case 21:
 case 20:
 case 13:
 case 12:
 case 11:
 case 10:
  {
   _free(i3);
   return;
  }
 case 31:
 case 30:
  return;
 default:
  {
   _fwrite(gb + 39931 | 0, 52, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
}

function _ofdmflexframesync_create(i4, i5, i7, i6, i1, i2) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0;
 i3 = _malloc(208) | 0;
 if (i4 >>> 0 >= 8) {
  if (i4 & 1 | 0) {
   _fwrite(gb + 28372 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
  if (i5 >>> 0 > i4 >>> 0) {
   _fwrite(gb + 28443 | 0, 92, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 } else _fwrite(gb + 28310 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
 HEAP32[i3 >> 2] = i4;
 HEAP32[i3 + 4 >> 2] = i5;
 HEAP32[i3 + 8 >> 2] = i7;
 HEAP32[i3 + 132 >> 2] = i1;
 HEAP32[i3 + 136 >> 2] = i2;
 i1 = _malloc(i4) | 0;
 i2 = i3 + 12 | 0;
 HEAP32[i2 >> 2] = i1;
 if (!i6) {
  _ofdmframe_init_default_sctype(i4, i1);
  i1 = HEAP32[i2 >> 2] | 0;
  i2 = HEAP32[i3 >> 2] | 0;
 } else {
  _memcpy(i1 | 0, i6 | 0, i4 | 0) | 0;
  i2 = i4;
 }
 _ofdmframe_validate_sctype(i1, i2, i3 + 16 | 0, i3 + 20 | 0, i3 + 24 | 0);
 i2 = i3 + 184 | 0;
 HEAP32[i2 >> 2] = _ofdmframesync_create(i4, i5, i7, i6, fb + 5 | 0, i3) | 0;
 i7 = i3 + 36 | 0;
 HEAP32[i7 >> 2] = 0;
 HEAP32[i7 + 4 >> 2] = 0;
 HEAP32[i7 + 8 >> 2] = 0;
 HEAP32[i7 + 12 >> 2] = 0;
 HEAP32[i7 + 16 >> 2] = 0;
 _ofdmflexframesync_set_header_len(i3, 8);
 i7 = i3 + 84 | 0;
 SIMD_Int32x4_store(HEAPU8, i3 + 76 | 0, SIMD_Int32x4(48, 2, 1, 1));
 i5 = i3 + 92 | 0;
 HEAP32[i5 >> 2] = 1;
 i6 = i3 + 96 | 0;
 HEAP32[i6 >> 2] = 1;
 HEAP32[i3 + 104 >> 2] = _modem_create(48) | 0;
 i6 = _packetizer_create(HEAP32[i7 >> 2] | 0, HEAP32[i3 + 88 >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
 HEAP32[i3 + 100 >> 2] = i6;
 i6 = _packetizer_get_enc_msg_len(i6) | 0;
 HEAP32[i3 + 116 >> 2] = i6;
 HEAP32[i3 + 108 >> 2] = _malloc(i6) | 0;
 i7 = HEAP32[i7 >> 2] | 0;
 HEAP32[i3 + 112 >> 2] = _malloc(i7) | 0;
 HEAP32[i3 + 128 >> 2] = _malloc(i7 << 3) | 0;
 HEAP32[i3 + 120 >> 2] = 0;
 i7 = i3 + 188 | 0;
 HEAP32[i7 >> 2] = 0;
 HEAP32[i7 + 4 >> 2] = 0;
 HEAP32[i7 + 8 >> 2] = 0;
 HEAP32[i7 + 12 >> 2] = 0;
 HEAP32[i7 + 16 >> 2] = 0;
 HEAPF32[i3 + 180 >> 2] = 9.999999960041972e-13;
 _framesyncstats_init_default(i3 + 140 | 0);
 _ofdmframesync_reset(HEAP32[i2 >> 2] | 0);
 return i3 | 0;
}

function _gmskframesync_execute_rxpreamble(i17, i3) {
 i17 = i17 | 0;
 i3 = i3 | 0;
 var i1 = 0, d2 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0, i9 = 0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i14 = i18 + 48 | 0;
 i9 = i18 + 40 | 0;
 i7 = i18 + 32 | 0;
 i12 = i18 + 24 | 0;
 i13 = i18 + 8 | 0;
 i4 = i18;
 i1 = i18 + 16 | 0;
 i15 = i17 + 220 | 0;
 i16 = i17 + 132 | 0;
 if ((HEAP32[i15 >> 2] | 0) == (HEAP32[i16 >> 2] | 0)) {
  _fwrite(gb + 26880 | 0, 64, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  STACKTOP = i18;
  return;
 }
 i19 = i17 + 128 | 0;
 i20 = HEAP32[i19 >> 2] | 0;
 i21 = HEAP32[i3 + 4 >> 2] | 0;
 HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i1 + 4 >> 2] = i21;
 HEAP32[i14 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i1 + 4 >> 2];
 _nco_crcf_mix_down(i20, i14, i4);
 _nco_crcf_step(HEAP32[i19 >> 2] | 0);
 d11 = +HEAPF32[i4 >> 2];
 d10 = +HEAPF32[i4 + 4 >> 2];
 i3 = i17 + 64 | 0;
 i4 = i17 + 68 | 0;
 i1 = HEAP32[i4 >> 2] | 0;
 HEAP32[i7 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i7 + 4 >> 2] = i1;
 HEAP32[i14 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 _conjf(i9, i14);
 d8 = +HEAPF32[i9 >> 2];
 d6 = +HEAPF32[i9 + 4 >> 2];
 d5 = d11 * d8 - d10 * d6;
 d2 = d10 * d8 + d11 * d6;
 if ((d5 != d5 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
  ___mulsc3(i12, d8, d6, d11, d10);
  d5 = +HEAPF32[i12 >> 2];
  d2 = +HEAPF32[i12 + 4 >> 2];
 }
 HEAPF32[i13 >> 2] = d5;
 HEAPF32[i13 + 4 >> 2] = d2;
 HEAP32[i14 >> 2] = HEAP32[i13 >> 2];
 HEAP32[i14 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
 d8 = +_cargf(i14);
 i1 = i17 + 4 | 0;
 d8 = d8 * +((HEAP32[i1 >> 2] | 0) >>> 0);
 HEAPF32[i17 + 72 >> 2] = d8;
 HEAPF32[i3 >> 2] = d11;
 HEAPF32[i4 >> 2] = d10;
 HEAPF32[i14 >> 2] = 0.0;
 if (_gmskframesync_update_symsync(i17, d8, i14) | 0 ? (i21 = HEAP32[i15 >> 2] | 0, HEAPF32[(HEAP32[i17 + 140 >> 2] | 0) + (i21 << 2) >> 2] = +HEAPF32[i14 >> 2] / +((HEAP32[i1 >> 2] | 0) >>> 0), i21 = i21 + 1 | 0, HEAP32[i15 >> 2] = i21, (i21 | 0) == (HEAP32[i16 >> 2] | 0)) : 0) HEAP32[i17 + 216 >> 2] = 2;
 STACKTOP = i18;
 return;
}

function _fec_secded3932_decode(i1, i15, i13, i12) {
 i1 = i1 | 0;
 i15 = i15 | 0;
 i13 = i13 | 0;
 i12 = i12 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i14 = 0, i16 = 0, i17 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i14 + 9 | 0;
 i10 = i14 + 4 | 0;
 i9 = i14;
 i11 = i15 & 3;
 i3 = i15 - i11 | 0;
 if ((i11 | 0) == (i15 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i4 = i8 + 1 | 0;
  i5 = i8 + 2 | 0;
  i6 = i8 + 3 | 0;
  i7 = i8 + 4 | 0;
  i2 = 0;
  i1 = 0;
  do {
   i17 = i13 + i1 | 0;
   i16 = i12 + i2 | 0;
   HEAP8[i8 >> 0] = 0;
   HEAP8[i8 + 1 >> 0] = 0;
   HEAP8[i8 + 2 >> 0] = 0;
   HEAP8[i8 + 3 >> 0] = 0;
   HEAP8[i8 + 4 >> 0] = 0;
   _fec_secded3932_estimate_ehat(i17, i8) | 0;
   HEAP8[i16 >> 0] = HEAP8[i4 >> 0] ^ HEAP8[i17 + 1 >> 0];
   HEAP8[i16 + 1 >> 0] = HEAP8[i5 >> 0] ^ HEAP8[i17 + 2 >> 0];
   HEAP8[i16 + 2 >> 0] = HEAP8[i6 >> 0] ^ HEAP8[i17 + 3 >> 0];
   HEAP8[i16 + 3 >> 0] = HEAP8[i7 >> 0] ^ HEAP8[i17 + 4 >> 0];
   i1 = i1 + 5 | 0;
   i2 = i2 + 4 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i11) {
  HEAP8[i10 >> 0] = HEAP8[i13 + i1 >> 0] | 0;
  i7 = i10 + 1 | 0;
  HEAP8[i7 >> 0] = 0;
  HEAP8[i7 + 1 >> 0] = 0;
  HEAP8[i7 + 2 >> 0] = 0;
  HEAP8[i7 + 3 >> 0] = 0;
  _memcpy(i7 | 0, i13 + (i1 + 1) | 0, i15 & 3 | 0) | 0;
  i7 = HEAP8[i7 >> 0] | 0;
  i13 = HEAP8[i10 + 2 >> 0] | 0;
  i16 = HEAP8[i10 + 3 >> 0] | 0;
  i17 = HEAP8[i10 + 4 >> 0] | 0;
  HEAP8[i8 >> 0] = 0;
  HEAP8[i8 + 1 >> 0] = 0;
  HEAP8[i8 + 2 >> 0] = 0;
  HEAP8[i8 + 3 >> 0] = 0;
  HEAP8[i8 + 4 >> 0] = 0;
  _fec_secded3932_estimate_ehat(i10, i8) | 0;
  HEAP8[i9 >> 0] = HEAP8[i8 + 1 >> 0] ^ i7;
  HEAP8[i9 + 1 >> 0] = HEAP8[i8 + 2 >> 0] ^ i13;
  HEAP8[i9 + 2 >> 0] = HEAP8[i8 + 3 >> 0] ^ i16;
  HEAP8[i9 + 3 >> 0] = HEAP8[i8 + 4 >> 0] ^ i17;
  _memcpy(i12 + i2 | 0, i9 | 0, i15 & 3 | 0) | 0;
  i2 = i2 | i11;
  i1 = i11 + 1 + i1 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(9, i15) | 0)) ___assert_fail(gb + 18483 | 0, gb + 18547 | 0, 349, gb + 18598 | 0);
 if ((i2 | 0) == (i15 | 0)) {
  STACKTOP = i14;
  return;
 } else ___assert_fail(gb + 18871 | 0, gb + 18547 | 0, 350, gb + 18598 | 0);
}

function _fec_conv_create(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = i2;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(i2);
 HEAP32[i1 + 136 >> 2] = fb + 1;
 HEAP32[i1 + 140 >> 2] = fb + 2;
 HEAP32[i1 + 144 >> 2] = fb + 3;
 switch (HEAP32[i1 >> 2] | 0) {
 case 11:
  {
   HEAP32[i1 + 28 >> 2] = 2;
   HEAP32[i1 + 32 >> 2] = 7;
   HEAP32[i1 + 24 >> 2] = gb + 280;
   HEAP32[i1 + 44 >> 2] = fb + 3;
   HEAP32[i1 + 48 >> 2] = fb + 1;
   HEAP32[i1 + 52 >> 2] = fb + 5;
   HEAP32[i1 + 56 >> 2] = fb + 1;
   HEAP32[i1 + 60 >> 2] = fb + 2;
   i2 = i1 + 8 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 16 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 20 | 0;
   HEAP32[i2 >> 2] = 0;
   return i1 | 0;
  }
 case 12:
  {
   HEAP32[i1 + 28 >> 2] = 2;
   HEAP32[i1 + 32 >> 2] = 9;
   HEAP32[i1 + 24 >> 2] = gb + 288;
   HEAP32[i1 + 44 >> 2] = fb + 4;
   HEAP32[i1 + 48 >> 2] = fb + 2;
   HEAP32[i1 + 52 >> 2] = fb + 6;
   HEAP32[i1 + 56 >> 2] = fb + 2;
   HEAP32[i1 + 60 >> 2] = fb + 3;
   i2 = i1 + 8 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 16 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 20 | 0;
   HEAP32[i2 >> 2] = 0;
   return i1 | 0;
  }
 case 13:
  {
   HEAP32[i1 + 28 >> 2] = 3;
   HEAP32[i1 + 32 >> 2] = 9;
   HEAP32[i1 + 24 >> 2] = gb + 296;
   HEAP32[i1 + 44 >> 2] = fb + 5;
   HEAP32[i1 + 48 >> 2] = fb + 3;
   HEAP32[i1 + 52 >> 2] = fb + 7;
   HEAP32[i1 + 56 >> 2] = fb + 3;
   HEAP32[i1 + 60 >> 2] = fb + 4;
   i2 = i1 + 8 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 16 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 20 | 0;
   HEAP32[i2 >> 2] = 0;
   return i1 | 0;
  }
 case 14:
  {
   HEAP32[i1 + 28 >> 2] = 6;
   HEAP32[i1 + 32 >> 2] = 15;
   HEAP32[i1 + 24 >> 2] = gb + 308;
   HEAP32[i1 + 44 >> 2] = fb + 6;
   HEAP32[i1 + 48 >> 2] = fb + 4;
   HEAP32[i1 + 52 >> 2] = fb + 8;
   HEAP32[i1 + 56 >> 2] = fb + 4;
   HEAP32[i1 + 60 >> 2] = fb + 5;
   i2 = i1 + 8 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 16 | 0;
   HEAP32[i2 >> 2] = 0;
   i2 = i1 + 20 | 0;
   HEAP32[i2 >> 2] = 0;
   return i1 | 0;
  }
 default:
  {
   _fwrite(gb + 12437 | 0, 39, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 return 0;
}

function _ellip_acdf(i21, i5, d16, i17) {
 i21 = i21 | 0;
 i5 = i5 | 0;
 d16 = +d16;
 i17 = i17 | 0;
 var d1 = 0.0, d2 = 0.0, i3 = 0, i4 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i18 = 0, i19 = 0, i20 = 0, i22 = 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i18 = i22 + 48 | 0;
 i11 = i22 + 40 | 0;
 i12 = i22 + 32 | 0;
 i13 = i22 + 24 | 0;
 i14 = i22 + 16 | 0;
 i19 = i22 + 8 | 0;
 i20 = i22;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i17 << 2) | 0) + 15 & -16) | 0;
 i4 = (i17 | 0) == 0;
 if (!i4) {
  i3 = 0;
  d1 = d16;
  do {
   d8 = +Math_sqrt(+(1.0 - d1 * d1));
   d1 = (1.0 - d8) / (d8 + 1.0);
   HEAPF32[i15 + (i3 << 2) >> 2] = d1;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i17 | 0));
  d2 = +HEAPF32[i5 >> 2];
  d1 = +HEAPF32[i5 + 4 >> 2];
  if (!i4) {
   i3 = i11 + 4 | 0;
   i4 = i13 + 4 | 0;
   i5 = i12 + 4 | 0;
   i9 = i14 + 4 | 0;
   i10 = 0;
   do {
    if (!i10) d8 = d16; else d8 = +HEAPF32[i15 + (i10 + -1 << 2) >> 2];
    d7 = d2 * d1;
    d6 = d2 * d2 - d1 * d1;
    d7 = d7 + d7;
    if ((d6 != d6 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
     ___mulsc3(i11, d2, d1, d2, d1);
     d6 = +HEAPF32[i11 >> 2];
     d7 = +HEAPF32[i3 >> 2];
    }
    HEAPF32[i13 >> 2] = 1.0 - d8 * (d8 * d6);
    HEAPF32[i4 >> 2] = 0.0 - d8 * (d8 * d7);
    HEAP32[i18 >> 2] = HEAP32[i13 >> 2];
    HEAP32[i18 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
    _liquid_csqrtf(i12, i18);
    ___divsc3(i14, d2, d1, +HEAPF32[i12 >> 2] + 1.0, +HEAPF32[i5 >> 2] + 0.0);
    d1 = +HEAPF32[i15 + (i10 << 2) >> 2] + 1.0;
    d2 = +HEAPF32[i14 >> 2] * 2.0 / d1;
    d1 = +HEAPF32[i9 >> 2] * 2.0 / d1;
    i10 = i10 + 1 | 0;
   } while ((i10 | 0) != (i17 | 0));
  }
 } else {
  d2 = +HEAPF32[i5 >> 2];
  d1 = +HEAPF32[i5 + 4 >> 2];
 }
 HEAPF32[i20 >> 2] = d2;
 HEAPF32[i20 + 4 >> 2] = d1;
 HEAP32[i18 >> 2] = HEAP32[i20 >> 2];
 HEAP32[i18 + 4 >> 2] = HEAP32[i20 + 4 >> 2];
 _liquid_cacosf(i19, i18);
 d16 = +HEAPF32[i19 + 4 >> 2] * 2.0 / 3.141592653589793;
 HEAPF32[i21 >> 2] = +HEAPF32[i19 >> 2] * 2.0 / 3.141592653589793;
 HEAPF32[i21 + 4 >> 2] = d16;
 STACKTOP = i22;
 return;
}

function _firdespm_execute(i20, i19) {
 i20 = i20 | 0;
 i19 = i19 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d21 = 0.0, i22 = 0;
 i18 = i20 + 12 | 0;
 i1 = HEAP32[i18 >> 2] | 0;
 i16 = i20 + 20 | 0;
 i17 = i20 + 88 | 0;
 if ((i1 | 0) != -1) {
  i3 = HEAP32[i17 >> 2] | 0;
  i2 = 0;
  do {
   HEAP32[i3 + (i2 << 2) >> 2] = ((Math_imul((HEAP32[i16 >> 2] | 0) + -1 | 0, i2) | 0) >>> 0) / (i1 >>> 0) | 0;
   i2 = i2 + 1 | 0;
   i1 = HEAP32[i18 >> 2] | 0;
  } while (i2 >>> 0 < (i1 + 1 | 0) >>> 0);
 }
 i9 = i20 + 92 | 0;
 i10 = i20 + 60 | 0;
 i11 = i20 + 48 | 0;
 i12 = i20 + 64 | 0;
 i13 = i20 + 72 | 0;
 i14 = i20 + 68 | 0;
 i7 = i20 + 56 | 0;
 i8 = i20 + 52 | 0;
 i15 = 0;
 while (1) {
  _firdespm_compute_interp(i20);
  if (HEAP32[i16 >> 2] | 0) {
   i1 = 0;
   do {
    d5 = +Math_cos(+(+HEAPF64[(HEAP32[i11 >> 2] | 0) + (i1 << 3) >> 3] * 6.283185307179586));
    d5 = +_poly_val_lagrange_barycentric(HEAP32[i12 >> 2] | 0, HEAP32[i13 >> 2] | 0, HEAP32[i14 >> 2] | 0, d5, (HEAP32[i18 >> 2] | 0) + 1 | 0);
    HEAPF64[(HEAP32[i10 >> 2] | 0) + (i1 << 3) >> 3] = +HEAPF64[(HEAP32[i7 >> 2] | 0) + (i1 << 3) >> 3] * (+HEAPF64[(HEAP32[i8 >> 2] | 0) + (i1 << 3) >> 3] - d5);
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < (HEAP32[i16 >> 2] | 0) >>> 0);
  }
  _firdespm_iext_search(i20);
  if (!(HEAP32[i9 >> 2] | 0)) {
   i1 = 12;
   break;
  }
  i1 = HEAP32[i18 >> 2] | 0;
  if ((i1 | 0) == -1) {
   d5 = 0.0;
   d4 = 0.0;
  } else {
   i2 = HEAP32[i17 >> 2] | 0;
   i3 = HEAP32[i10 >> 2] | 0;
   d5 = 0.0;
   d4 = 0.0;
   i6 = 0;
   while (1) {
    d21 = +Math_abs(+(+HEAPF64[i3 + (HEAP32[i2 + (i6 << 2) >> 2] << 3) >> 3]));
    i22 = (i6 | 0) == 0;
    d4 = i22 | d21 < d4 ? d21 : d4;
    d5 = i22 | d21 > d5 ? d21 : d5;
    if ((i6 | 0) == (i1 | 0)) break; else i6 = i6 + 1 | 0;
   }
  }
  i15 = i15 + 1 | 0;
  if (!(i15 >>> 0 < 40 ? !((d5 - d4) / d5 < 1.0000000474974513e-03) : 0)) {
   i1 = 12;
   break;
  }
 }
 if ((i1 | 0) == 12) {
  _firdespm_compute_taps(i20, i19);
  return;
 }
}

function _gmskframesync_decode_header(i8) {
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i9;
 i2 = i8 + 160 | 0;
 i7 = i8 + 148 | 0;
 _liquid_pack_bytes(HEAP32[i8 + 156 >> 2] | 0, HEAP32[i8 + 152 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i7 >> 2] | 0, i1);
 i1 = HEAP32[i1 >> 2] | 0;
 if ((i1 | 0) != (HEAP32[i7 >> 2] | 0)) ___assert_fail(gb + 28536 | 0, gb + 26827 | 0, 757, gb + 26945 | 0);
 _unscramble_data(HEAP32[i2 >> 2] | 0, i1);
 i1 = i8 + 164 | 0;
 i2 = _packetizer_decode(HEAP32[i8 + 168 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i1 >> 2] | 0) | 0;
 i7 = i8 + 172 | 0;
 HEAP32[i7 >> 2] = i2;
 if (!i2) {
  STACKTOP = i9;
  return;
 }
 i4 = HEAP32[i8 + 144 >> 2] | 0;
 i3 = HEAP32[i1 >> 2] | 0;
 if ((HEAP8[i3 + i4 >> 0] | 0) != 3) {
  _fwrite(gb + 26973 | 0, 64, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i7 >> 2] = 0;
  STACKTOP = i9;
  return;
 }
 i6 = HEAPU8[i3 + (i4 + 1) >> 0] << 8 | HEAPU8[i3 + (i4 + 2) >> 0];
 i1 = HEAPU8[i3 + (i4 + 3) >> 0] | 0;
 i5 = i1 >>> 5;
 i1 = i1 & 31;
 i4 = HEAPU8[i3 + (i4 + 4) >> 0] & 31;
 if ((i5 | 0) == 7) {
  _fwrite(gb + 27038 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i7 >> 2] = 0;
  i2 = 0;
  i3 = 0;
 } else i3 = i5;
 if (i1 >>> 0 > 27) {
  _fwrite(gb + 27109 | 0, 78, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i7 >> 2] = 0;
  i2 = 0;
  i1 = 0;
 }
 if (i4 >>> 0 > 27) {
  _fwrite(gb + 27188 | 0, 78, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  HEAP32[i7 >> 2] = 0;
  STACKTOP = i9;
  return;
 }
 if (!i2) {
  STACKTOP = i9;
  return;
 }
 i7 = i8 + 196 | 0;
 HEAP32[i7 >> 2] = i6;
 HEAP32[i8 + 180 >> 2] = i3;
 HEAP32[i8 + 184 >> 2] = i1;
 HEAP32[i8 + 188 >> 2] = i4;
 i2 = i8 + 208 | 0;
 i5 = _packetizer_recreate(HEAP32[i2 >> 2] | 0, i6, i3, i1, i4) | 0;
 HEAP32[i2 >> 2] = i5;
 i5 = _packetizer_get_enc_msg_len(i5) | 0;
 HEAP32[i8 + 192 >> 2] = i5;
 i6 = i8 + 200 | 0;
 HEAP32[i6 >> 2] = _realloc(HEAP32[i6 >> 2] | 0, i5) | 0;
 i8 = i8 + 204 | 0;
 HEAP32[i8 >> 2] = _realloc(HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0) | 0;
 STACKTOP = i9;
 return;
}

function _fec_golay2412_decode_symbol(i5) {
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i6 = 0;
 if (i5 >>> 0 > 16777215) {
  _fwrite(gb + 12641 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  i3 = 0;
  i1 = 0;
 }
 while (1) {
  i2 = HEAP32[gb + 476 + (i3 << 2) >> 2] & i5;
  i2 = (HEAPU8[(i2 >>> 8 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 >>> 16 & 255) + (gb + 38499) >> 0] | 0) & 1 | i1 << 1;
  i3 = i3 + 1 | 0;
  if ((i3 | 0) == 12) {
   i4 = i2;
   break;
  } else i1 = i2;
 }
 if (((HEAPU8[(i1 >>> 7 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 38499) >> 0] | 0) | 0) >>> 0 < 4) {
  i6 = 0;
  i6 = i6 ^ i5;
  i6 = i6 & 4095;
  return i6 | 0;
 } else i1 = 0;
 while (1) {
  i2 = HEAP32[gb + 332 + (i1 << 2) >> 2] ^ i4;
  if (((HEAPU8[(i2 >>> 8 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 38499) >> 0] | 0) | 0) >>> 0 < 3) {
   i6 = 7;
   break;
  }
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= 12) {
   i3 = 0;
   i1 = 0;
   break;
  }
 }
 if ((i6 | 0) == 7) {
  i6 = i2 << 12 | 1 << 11 - i1;
  i6 = i6 ^ i5;
  i6 = i6 & 4095;
  return i6 | 0;
 }
 while (1) {
  i2 = HEAP32[gb + 332 + (i3 << 2) >> 2] & i4;
  i2 = (HEAPU8[(i2 >>> 8 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 >>> 16 & 255) + (gb + 38499) >> 0] | 0) & 1 | i1 << 1;
  i3 = i3 + 1 | 0;
  if ((i3 | 0) == 12) {
   i3 = i2;
   break;
  } else i1 = i2;
 }
 if (((HEAPU8[(i1 >>> 7 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i3 & 255) + (gb + 38499) >> 0] | 0) | 1 | 0) == 3) {
  i6 = i3;
  i6 = i6 ^ i5;
  i6 = i6 & 4095;
  return i6 | 0;
 } else i1 = 0;
 while (1) {
  i2 = HEAP32[gb + 332 + (i1 << 2) >> 2] ^ i3;
  if (((HEAPU8[(i2 >>> 8 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 38499) >> 0] | 0) | 0) >>> 0 < 3) break;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= 12) {
   i1 = 0;
   i6 = 13;
   break;
  }
 }
 if ((i6 | 0) == 13) {
  i6 = i1 ^ i5;
  i6 = i6 & 4095;
  return i6 | 0;
 }
 i6 = i2 | 1 << 23 - i1;
 i6 = i6 ^ i5;
 i6 = i6 & 4095;
 return i6 | 0;
}

function _demodulator_recv(i14, i16, i15, i17) {
 i14 = i14 | 0;
 i16 = i16 | 0;
 i15 = i15 | 0;
 i17 = i17 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i18 = 0, i19 = 0, i20 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i10 = i19 + 24 | 0;
 i11 = i19 + 16 | 0;
 i12 = i19 + 8 | 0;
 if (!i14) {
  i18 = 0;
  STACKTOP = i19;
  return i18 | 0;
 }
 i1 = HEAP32[i14 >> 2] | 0;
 if ((i15 >>> 0) % (i1 >>> 0) | 0 | 0) {
  _printf(gb + 9756 | 0, i19) | 0;
  i18 = 0;
  STACKTOP = i19;
  return i18 | 0;
 }
 i18 = _llvm_stacksave() | 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 3) | 0) + 15 & -16) | 0;
 if (!i15) i1 = 0; else {
  i8 = i14 + 20 | 0;
  i4 = i13 + 4 | 0;
  i5 = i12 + 4 | 0;
  i6 = i14 + 16 | 0;
  i7 = i11 + 4 | 0;
  i2 = HEAP32[i14 >> 2] | 0;
  i9 = 0;
  i1 = 0;
  do {
   if (!i2) i2 = 0; else {
    i3 = 0;
    do {
     i2 = HEAP32[i6 >> 2] | 0;
     HEAP32[i11 >> 2] = HEAP32[i16 + (i3 + i9 << 2) >> 2];
     HEAPF32[i7 >> 2] = 0.0;
     HEAP32[i10 >> 2] = HEAP32[i11 >> 2];
     HEAP32[i10 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
     _nco_crcf_mix_down(i2, i10, i13 + (i3 << 3) | 0);
     _nco_crcf_step(HEAP32[i6 >> 2] | 0);
     i3 = i3 + 1 | 0;
     i2 = HEAP32[i14 >> 2] | 0;
    } while (i3 >>> 0 < i2 >>> 0);
   }
   i3 = HEAP32[i8 >> 2] | 0;
   if (!i3) {
    i3 = HEAP32[i4 >> 2] | 0;
    HEAP32[i17 + (i9 << 3) >> 2] = HEAP32[i13 >> 2];
    HEAP32[i17 + (i9 << 3) + 4 >> 2] = i3;
   } else {
    _firdecim_crcf_execute(i3, i13, i17 + (((i9 >>> 0) / (i2 >>> 0) | 0) << 3) | 0);
    i2 = HEAP32[i14 >> 2] | 0;
    i3 = (i9 >>> 0) / (i2 >>> 0) | 0;
    i20 = i17 + (i3 << 3) | 0;
    i3 = i17 + (i3 << 3) + 4 | 0;
    ___divsc3(i12, +HEAPF32[i20 >> 2], +HEAPF32[i3 >> 2], +(i2 >>> 0), 0.0);
    i2 = HEAP32[i5 >> 2] | 0;
    HEAP32[i20 >> 2] = HEAP32[i12 >> 2];
    HEAP32[i3 >> 2] = i2;
   }
   i1 = i1 + 1 | 0;
   i2 = HEAP32[i14 >> 2] | 0;
   i9 = i2 + i9 | 0;
  } while (i9 >>> 0 < i15 >>> 0);
 }
 _llvm_stackrestore(i18 | 0);
 i20 = i1;
 STACKTOP = i19;
 return i20 | 0;
}

function _polycf_expandroots(i19, i21, i20) {
 i19 = i19 | 0;
 i21 = i21 | 0;
 i20 = i20 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i22 = 0, d23 = 0.0, d24 = 0.0, i25 = 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i17 = i22 + 8 | 0;
 i18 = i22;
 if (!i21) {
  HEAPF32[i20 >> 2] = 0.0;
  HEAPF32[i20 + 4 >> 2] = 0.0;
  STACKTOP = i22;
  return;
 } else i1 = 0;
 while (1) {
  HEAPF32[i20 + (i1 << 3) >> 2] = +((i1 | 0) == 0 & 1);
  HEAPF32[i20 + (i1 << 3) + 4 >> 2] = 0.0;
  if ((i1 | 0) == (i21 | 0)) break; else i1 = i1 + 1 | 0;
 }
 i14 = i18 + 4 | 0;
 i15 = i17 + 4 | 0;
 i16 = 0;
 do {
  i11 = i19 + (i16 << 3) | 0;
  i12 = i19 + (i16 << 3) + 4 | 0;
  i16 = i16 + 1 | 0;
  d3 = -+HEAPF32[i11 >> 2];
  d2 = -+HEAPF32[i12 >> 2];
  i1 = i20 + (i16 << 3) | 0;
  d24 = +HEAPF32[i1 >> 2];
  i8 = i20 + (i16 << 3) + 4 | 0;
  d23 = +HEAPF32[i8 >> 2];
  d6 = d3;
  d4 = d23;
  d7 = d2;
  d5 = d24;
  d3 = d24 * d3;
  d2 = d23 * d2;
  i13 = i16;
  while (1) {
   d3 = d3 - d2;
   d2 = d7 * d5 + d6 * d4;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i17, d6, d7, d5, d4);
    d3 = +HEAPF32[i17 >> 2];
    d2 = +HEAPF32[i15 >> 2];
   }
   i25 = i13;
   i13 = i13 + -1 | 0;
   i9 = i20 + (i13 << 3) | 0;
   i10 = i20 + (i13 << 3) + 4 | 0;
   d6 = d2 + +HEAPF32[i10 >> 2];
   HEAPF32[i1 >> 2] = d3 + +HEAPF32[i9 >> 2];
   HEAPF32[i8 >> 2] = d6;
   d6 = -+HEAPF32[i11 >> 2];
   d7 = -+HEAPF32[i12 >> 2];
   d5 = +HEAPF32[i9 >> 2];
   d4 = +HEAPF32[i10 >> 2];
   d3 = d5 * d6;
   d2 = d4 * d7;
   if ((i25 | 0) <= 1) {
    i8 = i9;
    i1 = i10;
    break;
   } else {
    i1 = i9;
    i8 = i10;
   }
  }
  d3 = d3 - d2;
  d2 = d5 * d7 + d4 * d6;
  if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___mulsc3(i18, d5, d4, d6, d7);
   d3 = +HEAPF32[i18 >> 2];
   d2 = +HEAPF32[i14 >> 2];
  }
  HEAPF32[i8 >> 2] = d3;
  HEAPF32[i1 >> 2] = d2;
 } while ((i16 | 0) != (i21 | 0));
 STACKTOP = i22;
 return;
}

function _cheby1_azpkf(i15, d2, i1, i16, i14) {
 i15 = i15 | 0;
 d2 = +d2;
 i1 = i1 | 0;
 i16 = i16 | 0;
 i14 = i14 | 0;
 var i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i17 = 0, d18 = 0.0, d19 = 0.0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i12 = i13;
 d7 = d2 * d2;
 d5 = +Math_sqrt(+(1.0 / d7 + 1.0));
 d2 = 1.0 / d2;
 d6 = 1.0 / +(i15 >>> 0);
 d8 = +Math_pow(+(d2 + d5), +d6);
 d6 = +Math_pow(+(d5 - d2), +d6);
 d2 = (d8 + d6) * .5;
 d6 = (d8 - d6) * .5;
 i11 = i15 & 1;
 if ((i15 - i11 | 0) >>> 0 < 2) i1 = 0; else {
  i1 = i15 + -1 | 0;
  d4 = +(i15 << 1 >>> 0);
  d5 = d2 * 0.0;
  i3 = i15 >>> 1;
  i9 = 0;
  i10 = 0;
  while (1) {
   i9 = i9 + 1 | 0;
   d8 = +((i1 + (i9 << 1) | 0) >>> 0) * 3.141592653589793 / d4;
   d19 = d6 * +Math_cos(+d8);
   d8 = +Math_sin(+d8);
   d18 = d5 * d8;
   d8 = d2 * d8;
   i17 = i10 | 1;
   HEAPF32[i16 + (i10 << 3) >> 2] = d19 - d18;
   HEAPF32[i16 + (i10 << 3) + 4 >> 2] = -d8;
   HEAPF32[i16 + (i17 << 3) >> 2] = d19 + d18;
   HEAPF32[i16 + (i17 << 3) + 4 >> 2] = d8;
   if ((i9 | 0) == (i3 | 0)) break; else i10 = i10 + 2 | 0;
  }
  i1 = i3 << 1;
 }
 i3 = (i11 | 0) != 0;
 if (i3) {
  HEAPF32[i16 + (i1 << 3) >> 2] = -d6;
  HEAPF32[i16 + (i1 << 3) + 4 >> 2] = 0.0;
  i1 = i1 | 1;
 }
 if ((i1 | 0) != (i15 | 0)) ___assert_fail(gb + 40171 | 0, gb + 40134 | 0, 85, gb + 40158 | 0);
 if (i3) d2 = 1.0; else d2 = 1.0 / +Math_sqrt(+(d7 + 1.0));
 i3 = i14 + 4 | 0;
 HEAPF32[i14 >> 2] = d2;
 HEAPF32[i3 >> 2] = 0.0;
 if (!i15) {
  STACKTOP = i13;
  return;
 }
 i9 = i12 + 4 | 0;
 d4 = 0.0;
 i1 = 0;
 do {
  d5 = +HEAPF32[i16 + (i1 << 3) >> 2];
  d6 = +HEAPF32[i16 + (i1 << 3) + 4 >> 2];
  d7 = d5 * d2 - d6 * d4;
  d8 = d6 * d2 + d5 * d4;
  if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
   ___mulsc3(i12, d2, d4, d5, d6);
   d2 = +HEAPF32[i12 >> 2];
   d4 = +HEAPF32[i9 >> 2];
  } else {
   d2 = d7;
   d4 = d8;
  }
  HEAPF32[i14 >> 2] = d2;
  HEAPF32[i3 >> 2] = d4;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i15 | 0));
 STACKTOP = i13;
 return;
}

function _strbuffer_append_bytes(i3, i1, i2) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i4 = i10 + 20 | 0;
 i5 = i10 + 16 | 0;
 i6 = i10 + 12 | 0;
 i7 = i10 + 8 | 0;
 i8 = i10 + 4 | 0;
 i9 = i10;
 HEAP32[i5 >> 2] = i3;
 HEAP32[i6 >> 2] = i1;
 HEAP32[i7 >> 2] = i2;
 do if ((HEAP32[i7 >> 2] | 0) >>> 0 >= ((HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] | 0) - (HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] | 0) | 0) >>> 0) {
  if (!((HEAP32[i7 >> 2] | 0) >>> 0 > 4294967294 ? 1 : (HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] | 0) >>> 0 > 2147483647) ? (HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] | 0) >>> 0 <= (-2 - (HEAP32[i7 >> 2] | 0) | 0) >>> 0 : 0) {
   i1 = HEAP32[i5 >> 2] | 0;
   if (HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] << 1 >>> 0 > ((HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i7 >> 2] | 0) + 1 | 0) >>> 0) i1 = HEAP32[i1 + 8 >> 2] << 1; else i1 = (HEAP32[i1 + 4 >> 2] | 0) + (HEAP32[i7 >> 2] | 0) + 1 | 0;
   HEAP32[i8 >> 2] = i1;
   HEAP32[i9 >> 2] = _jsonp_malloc(HEAP32[i8 >> 2] | 0) | 0;
   if (HEAP32[i9 >> 2] | 0) {
    _memcpy(HEAP32[i9 >> 2] | 0, HEAP32[HEAP32[i5 >> 2] >> 2] | 0, HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] | 0) | 0;
    _jsonp_free(HEAP32[HEAP32[i5 >> 2] >> 2] | 0);
    HEAP32[HEAP32[i5 >> 2] >> 2] = HEAP32[i9 >> 2];
    HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] = HEAP32[i8 >> 2];
    break;
   }
   HEAP32[i4 >> 2] = -1;
   i9 = HEAP32[i4 >> 2] | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
  HEAP32[i4 >> 2] = -1;
  i9 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i10;
  return i9 | 0;
 } while (0);
 _memcpy((HEAP32[HEAP32[i5 >> 2] >> 2] | 0) + (HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] | 0) | 0, HEAP32[i6 >> 2] | 0, HEAP32[i7 >> 2] | 0) | 0;
 i9 = (HEAP32[i5 >> 2] | 0) + 4 | 0;
 HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + (HEAP32[i7 >> 2] | 0);
 HEAP8[(HEAP32[HEAP32[i5 >> 2] >> 2] | 0) + (HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] | 0) >> 0] = 0;
 HEAP32[i4 >> 2] = 0;
 i9 = HEAP32[i4 >> 2] | 0;
 STACKTOP = i10;
 return i9 | 0;
}

function ___stdio_write(i14, i2, i1) {
 i14 = i14 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i11 = i15 + 16 | 0;
 i10 = i15;
 i3 = i15 + 32 | 0;
 i12 = i14 + 28 | 0;
 i4 = HEAP32[i12 >> 2] | 0;
 HEAP32[i3 >> 2] = i4;
 i13 = i14 + 20 | 0;
 i4 = (HEAP32[i13 >> 2] | 0) - i4 | 0;
 HEAP32[i3 + 4 >> 2] = i4;
 HEAP32[i3 + 8 >> 2] = i2;
 HEAP32[i3 + 12 >> 2] = i1;
 i8 = i14 + 60 | 0;
 i9 = i14 + 44 | 0;
 i2 = 2;
 i4 = i4 + i1 | 0;
 while (1) {
  if (!(HEAP32[gb + 44304 >> 2] | 0)) {
   HEAP32[i11 >> 2] = HEAP32[i8 >> 2];
   HEAP32[i11 + 4 >> 2] = i3;
   HEAP32[i11 + 8 >> 2] = i2;
   i6 = ___syscall_ret(___syscall146(146, i11 | 0) | 0) | 0;
  } else {
   _pthread_cleanup_push(fb + 21 | 0, i14 | 0);
   HEAP32[i10 >> 2] = HEAP32[i8 >> 2];
   HEAP32[i10 + 4 >> 2] = i3;
   HEAP32[i10 + 8 >> 2] = i2;
   i6 = ___syscall_ret(___syscall146(146, i10 | 0) | 0) | 0;
   _pthread_cleanup_pop(0);
  }
  if ((i4 | 0) == (i6 | 0)) {
   i4 = 6;
   break;
  }
  if ((i6 | 0) < 0) {
   i4 = 8;
   break;
  }
  i4 = i4 - i6 | 0;
  i5 = HEAP32[i3 + 4 >> 2] | 0;
  if (i6 >>> 0 <= i5 >>> 0) if ((i2 | 0) == 2) {
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + i6;
   i7 = i5;
   i2 = 2;
  } else i7 = i5; else {
   i7 = HEAP32[i9 >> 2] | 0;
   HEAP32[i12 >> 2] = i7;
   HEAP32[i13 >> 2] = i7;
   i7 = HEAP32[i3 + 12 >> 2] | 0;
   i6 = i6 - i5 | 0;
   i3 = i3 + 8 | 0;
   i2 = i2 + -1 | 0;
  }
  HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i6;
  HEAP32[i3 + 4 >> 2] = i7 - i6;
 }
 if ((i4 | 0) == 6) {
  i11 = HEAP32[i9 >> 2] | 0;
  HEAP32[i14 + 16 >> 2] = i11 + (HEAP32[i14 + 48 >> 2] | 0);
  i14 = i11;
  HEAP32[i12 >> 2] = i14;
  HEAP32[i13 >> 2] = i14;
 } else if ((i4 | 0) == 8) {
  HEAP32[i14 + 16 >> 2] = 0;
  HEAP32[i12 >> 2] = 0;
  HEAP32[i13 >> 2] = 0;
  HEAP32[i14 >> 2] = HEAP32[i14 >> 2] | 32;
  if ((i2 | 0) == 2) i1 = 0; else i1 = i1 - (HEAP32[i3 + 4 >> 2] | 0) | 0;
 }
 STACKTOP = i15;
 return i1 | 0;
}

function _error_set(i6, i7, i9, i18) {
 i6 = i6 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 i18 = i18 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 400 | 0;
 i17 = i19 + 16 | 0;
 i16 = i19 + 8 | 0;
 i15 = i19;
 i1 = i19 + 64 | 0;
 i2 = i19 + 60 | 0;
 i3 = i19 + 56 | 0;
 i4 = i19 + 40 | 0;
 i10 = i19 + 232 | 0;
 i11 = i19 + 72 | 0;
 i8 = i19 + 36 | 0;
 i5 = i19 + 32 | 0;
 i12 = i19 + 28 | 0;
 i13 = i19 + 24 | 0;
 i14 = i19 + 20 | 0;
 HEAP32[i1 >> 2] = i6;
 HEAP32[i2 >> 2] = i7;
 HEAP32[i3 >> 2] = i9;
 HEAP32[i8 >> 2] = -1;
 HEAP32[i5 >> 2] = -1;
 HEAP32[i12 >> 2] = 0;
 HEAP32[i13 >> 2] = i10;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i19;
  return;
 }
 HEAP32[i4 >> 2] = i18;
 _vsnprintf(i10, 160, HEAP32[i3 >> 2] | 0, i4) | 0;
 HEAP8[i10 + 159 >> 0] = 0;
 do if (HEAP32[i2 >> 2] | 0) {
  HEAP32[i14 >> 2] = _strbuffer_value((HEAP32[i2 >> 2] | 0) + 40 | 0) | 0;
  HEAP32[i8 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 24 >> 2];
  HEAP32[i5 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 28 >> 2];
  HEAP32[i12 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 36 >> 2];
  if (HEAP32[i14 >> 2] | 0 ? HEAP8[HEAP32[i14 >> 2] >> 0] | 0 : 0) {
   if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 40 + 4 >> 2] | 0) >>> 0 > 20) break;
   i18 = HEAP32[i14 >> 2] | 0;
   HEAP32[i15 >> 2] = i10;
   HEAP32[i15 + 4 >> 2] = i18;
   _snprintf(i11, 160, gb + 40572 | 0, i15) | 0;
   HEAP8[i11 + 159 >> 0] = 0;
   HEAP32[i13 >> 2] = i11;
   break;
  }
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 20 >> 2] | 0) == -2) {
   HEAP32[i13 >> 2] = i10;
   break;
  } else {
   HEAP32[i16 >> 2] = i10;
   _snprintf(i11, 160, gb + 40585 | 0, i16) | 0;
   HEAP8[i11 + 159 >> 0] = 0;
   HEAP32[i13 >> 2] = i11;
   break;
  }
 } while (0);
 i14 = HEAP32[i1 >> 2] | 0;
 i15 = HEAP32[i8 >> 2] | 0;
 i16 = HEAP32[i5 >> 2] | 0;
 i18 = HEAP32[i12 >> 2] | 0;
 HEAP32[i17 >> 2] = HEAP32[i13 >> 2];
 _jsonp_error_set(i14, i15, i16, i18, gb + 40605 | 0, i17);
 STACKTOP = i19;
 return;
}

function ___fdopen(i9, i3) {
 i9 = i9 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i11 = i12 + 40 | 0;
 i8 = i12 + 24 | 0;
 i7 = i12 + 16 | 0;
 i4 = i12;
 i10 = i12 + 52 | 0;
 i2 = HEAP8[i3 >> 0] | 0;
 if (_memchr(gb + 44143 | 0, i2 << 24 >> 24, 4) | 0) {
  i1 = _malloc(1144) | 0;
  if (!i1) i1 = 0; else {
   i5 = i1;
   i6 = i5 + 112 | 0;
   do {
    HEAP32[i5 >> 2] = 0;
    i5 = i5 + 4 | 0;
   } while ((i5 | 0) < (i6 | 0));
   if (!(_strchr(i3, 43) | 0)) HEAP32[i1 >> 2] = i2 << 24 >> 24 == 114 ? 8 : 4;
   if (_strchr(i3, 101) | 0) {
    HEAP32[i4 >> 2] = i9;
    HEAP32[i4 + 4 >> 2] = 2;
    HEAP32[i4 + 8 >> 2] = 1;
    ___syscall221(221, i4 | 0) | 0;
    i2 = HEAP8[i3 >> 0] | 0;
   }
   if (i2 << 24 >> 24 == 97) {
    HEAP32[i7 >> 2] = i9;
    HEAP32[i7 + 4 >> 2] = 3;
    i2 = ___syscall221(221, i7 | 0) | 0;
    if (!(i2 & 1024)) {
     HEAP32[i8 >> 2] = i9;
     HEAP32[i8 + 4 >> 2] = 4;
     HEAP32[i8 + 8 >> 2] = i2 | 1024;
     ___syscall221(221, i8 | 0) | 0;
    }
    i3 = HEAP32[i1 >> 2] | 128;
    HEAP32[i1 >> 2] = i3;
   } else i3 = HEAP32[i1 >> 2] | 0;
   HEAP32[i1 + 60 >> 2] = i9;
   HEAP32[i1 + 44 >> 2] = i1 + 120;
   HEAP32[i1 + 48 >> 2] = 1024;
   i2 = i1 + 75 | 0;
   HEAP8[i2 >> 0] = -1;
   if ((i3 & 8 | 0) == 0 ? (HEAP32[i11 >> 2] = i9, HEAP32[i11 + 4 >> 2] = 21505, HEAP32[i11 + 8 >> 2] = i10, (___syscall54(54, i11 | 0) | 0) == 0) : 0) HEAP8[i2 >> 0] = 10;
   HEAP32[i1 + 32 >> 2] = fb + 9;
   HEAP32[i1 + 36 >> 2] = fb + 1;
   HEAP32[i1 + 40 >> 2] = fb + 2;
   HEAP32[i1 + 12 >> 2] = fb + 2;
   if (!(HEAP32[gb + 44304 + 4 >> 2] | 0)) HEAP32[i1 + 76 >> 2] = -1;
   ___lock(gb + 44304 + 28 | 0);
   i2 = HEAP32[gb + 44304 + 24 >> 2] | 0;
   HEAP32[i1 + 56 >> 2] = i2;
   if (i2 | 0) HEAP32[i2 + 52 >> 2] = i1;
   HEAP32[gb + 44304 + 24 >> 2] = i1;
   ___unlock(gb + 44304 + 28 | 0);
  }
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  i1 = 0;
 }
 STACKTOP = i12;
 return i1 | 0;
}

function _ofdmframesync_estimate_gain_S0(i22, i1, i21) {
 i22 = i22 | 0;
 i1 = i1 | 0;
 i21 = i21 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i23 = 0;
 i23 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i17 = i23 + 24 | 0;
 i18 = i23 + 16 | 0;
 i19 = i23 + 8 | 0;
 i20 = i23;
 _memmove(HEAP32[i22 + 56 >> 2] | 0, i1 | 0, HEAP32[i22 >> 2] << 3 | 0) | 0;
 _fft_execute(HEAP32[i22 + 48 >> 2] | 0);
 d9 = +Math_sqrt(+(+((HEAP32[i22 + 28 >> 2] | 0) >>> 0)));
 i16 = HEAP32[i22 >> 2] | 0;
 d9 = d9 / +(i16 >>> 0);
 if (!i16) {
  STACKTOP = i23;
  return;
 }
 i10 = i22 + 12 | 0;
 i11 = i22 + 52 | 0;
 i12 = i22 + 64 | 0;
 i13 = i19 + 4 | 0;
 i14 = i18 + 4 | 0;
 i15 = i20 + 4 | 0;
 i16 = 0;
 do {
  if ((i16 & 1 | 0) == 0 ? (HEAP8[(HEAP32[i10 >> 2] | 0) + i16 >> 0] | 0) != 0 : 0) {
   i1 = HEAP32[i11 >> 2] | 0;
   d5 = +HEAPF32[i1 + (i16 << 3) >> 2];
   d6 = +HEAPF32[i1 + (i16 << 3) + 4 >> 2];
   i1 = HEAP32[i12 >> 2] | 0;
   i4 = HEAP32[i1 + (i16 << 3) + 4 >> 2] | 0;
   HEAP32[i19 >> 2] = HEAP32[i1 + (i16 << 3) >> 2];
   HEAP32[i13 >> 2] = i4;
   HEAP32[i17 >> 2] = HEAP32[i19 >> 2];
   HEAP32[i17 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
   _conjf(i18, i17);
   d7 = +HEAPF32[i18 >> 2];
   d8 = +HEAPF32[i14 >> 2];
   d3 = d5 * d7 - d6 * d8;
   d2 = d6 * d7 + d5 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i20, d5, d6, d7, d8);
    d3 = +HEAPF32[i20 >> 2];
    d2 = +HEAPF32[i15 >> 2];
   }
   i4 = i21 + (i16 << 3) | 0;
   i1 = i21 + (i16 << 3) + 4 | 0;
   HEAPF32[i4 >> 2] = d3;
   HEAPF32[i1 >> 2] = d2;
  } else {
   i4 = i21 + (i16 << 3) | 0;
   i1 = i21 + (i16 << 3) + 4 | 0;
   HEAPF32[i4 >> 2] = 0.0;
   HEAPF32[i1 >> 2] = 0.0;
   d3 = 0.0;
   d2 = 0.0;
  }
  HEAPF32[i4 >> 2] = d9 * d3;
  HEAPF32[i1 >> 2] = d9 * d2;
  i16 = i16 + 1 | 0;
 } while (i16 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0);
 STACKTOP = i23;
 return;
}

function _qpilotsync_create(i3, i1) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, d14 = 0.0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i8 = i12 + 24 | 0;
 i2 = i12 + 16 | 0;
 i9 = i12 + 8 | 0;
 i10 = i12;
 if (!i3) {
  _fwrite(gb + 29739 | 0, 67, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i1 >>> 0 < 2) {
  _fwrite(gb + 29807 | 0, 69, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i11 = _malloc(48) | 0;
 HEAP32[i11 >> 2] = i3;
 HEAP32[i11 + 4 >> 2] = i1;
 _div(i2, i3, i1 + -1 | 0);
 i5 = ((HEAP32[i2 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i2 >> 2] | 0) | 0;
 i6 = i11 + 8 | 0;
 HEAP32[i6 >> 2] = i5;
 HEAP32[i11 + 12 >> 2] = i5 + i3;
 i1 = _malloc(i5 << 3) | 0;
 HEAP32[i11 + 16 >> 2] = i1;
 i7 = _msequence_create_default(_liquid_nextpow2(i5) | 0) | 0;
 if (!i5) i1 = 0; else {
  i2 = i10 + 4 | 0;
  i3 = i9 + 4 | 0;
  i4 = 0;
  do {
   d14 = +((_msequence_generate_symbol(i7, 2) | 0) >>> 0) * 6.283185307179586 * .25 + .7853981633974483;
   HEAPF32[i10 >> 2] = d14 * 0.0;
   HEAPF32[i2 >> 2] = d14;
   HEAP32[i8 >> 2] = HEAP32[i10 >> 2];
   HEAP32[i8 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
   _cexpf(i9, i8);
   i13 = HEAP32[i3 >> 2] | 0;
   HEAP32[i1 + (i4 << 3) >> 2] = HEAP32[i9 >> 2];
   HEAP32[i1 + (i4 << 3) + 4 >> 2] = i13;
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < i5 >>> 0);
  i1 = HEAP32[i6 >> 2] | 0;
 }
 _msequence_destroy(i7);
 i1 = 1 << (_liquid_nextpow2((i1 >>> 1) + i1 | 0) | 0);
 HEAP32[i11 + 20 >> 2] = i1;
 i3 = i1 << 3;
 i2 = _malloc(i3) | 0;
 HEAP32[i11 + 24 >> 2] = i2;
 i3 = _malloc(i3) | 0;
 HEAP32[i11 + 28 >> 2] = i3;
 HEAP32[i11 + 32 >> 2] = _fft_create_plan(i1, i2, i3, 1, 0) | 0;
 i3 = 0;
 do {
  HEAPF32[i2 + (i3 << 3) >> 2] = 0.0;
  HEAPF32[i2 + (i3 << 3) + 4 >> 2] = 0.0;
  i3 = i3 + 1 | 0;
 } while (i3 >>> 0 < i1 >>> 0);
 HEAPF32[i11 + 36 >> 2] = 0.0;
 HEAPF32[i11 + 40 >> 2] = 0.0;
 HEAPF32[i11 + 44 >> 2] = 1.0;
 STACKTOP = i12;
 return i11 | 0;
}

function _ofdmframesync_estimate_gain_S1(i22, i1, i21) {
 i22 = i22 | 0;
 i1 = i1 | 0;
 i21 = i21 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i23 = 0;
 i23 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i17 = i23 + 24 | 0;
 i18 = i23 + 16 | 0;
 i19 = i23 + 8 | 0;
 i20 = i23;
 _memmove(HEAP32[i22 + 56 >> 2] | 0, i1 | 0, HEAP32[i22 >> 2] << 3 | 0) | 0;
 _fft_execute(HEAP32[i22 + 48 >> 2] | 0);
 d9 = +Math_sqrt(+(+((HEAP32[i22 + 32 >> 2] | 0) >>> 0)));
 i16 = HEAP32[i22 >> 2] | 0;
 d9 = d9 / +(i16 >>> 0);
 if (!i16) {
  STACKTOP = i23;
  return;
 }
 i10 = i22 + 12 | 0;
 i11 = i22 + 52 | 0;
 i12 = i22 + 72 | 0;
 i13 = i19 + 4 | 0;
 i14 = i18 + 4 | 0;
 i15 = i20 + 4 | 0;
 i16 = 0;
 do {
  if (!(HEAP8[(HEAP32[i10 >> 2] | 0) + i16 >> 0] | 0)) {
   i4 = i21 + (i16 << 3) | 0;
   i1 = i21 + (i16 << 3) + 4 | 0;
   HEAPF32[i4 >> 2] = 0.0;
   HEAPF32[i1 >> 2] = 0.0;
   d3 = 0.0;
   d2 = 0.0;
  } else {
   i1 = HEAP32[i11 >> 2] | 0;
   d5 = +HEAPF32[i1 + (i16 << 3) >> 2];
   d6 = +HEAPF32[i1 + (i16 << 3) + 4 >> 2];
   i1 = HEAP32[i12 >> 2] | 0;
   i4 = HEAP32[i1 + (i16 << 3) + 4 >> 2] | 0;
   HEAP32[i19 >> 2] = HEAP32[i1 + (i16 << 3) >> 2];
   HEAP32[i13 >> 2] = i4;
   HEAP32[i17 >> 2] = HEAP32[i19 >> 2];
   HEAP32[i17 + 4 >> 2] = HEAP32[i19 + 4 >> 2];
   _conjf(i18, i17);
   d7 = +HEAPF32[i18 >> 2];
   d8 = +HEAPF32[i14 >> 2];
   d3 = d5 * d7 - d6 * d8;
   d2 = d6 * d7 + d5 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i20, d5, d6, d7, d8);
    d3 = +HEAPF32[i20 >> 2];
    d2 = +HEAPF32[i15 >> 2];
   }
   i4 = i21 + (i16 << 3) | 0;
   i1 = i21 + (i16 << 3) + 4 | 0;
   HEAPF32[i4 >> 2] = d3;
   HEAPF32[i1 >> 2] = d2;
  }
  HEAPF32[i4 >> 2] = d9 * d3;
  HEAPF32[i1 >> 2] = d9 * d2;
  i16 = i16 + 1 | 0;
 } while (i16 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0);
 STACKTOP = i23;
 return;
}

function _qdetector_cccf_create(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 if (!i2) {
  _fwrite(gb + 29099 | 0, 63, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  i3 = _malloc(96) | 0;
  HEAP32[i3 >> 2] = i2;
  i6 = i2 << 3;
  i11 = _malloc(i6) | 0;
  i7 = i3 + 4 | 0;
  HEAP32[i7 >> 2] = i11;
  _memcpy(i11 | 0, i1 | 0, i6 | 0) | 0;
  HEAPF32[i3 + 12 >> 2] = +_liquid_sumsqcf(i11, i2);
  i11 = 1 << (_liquid_nextpow2(HEAP32[i3 >> 2] << 1) | 0);
  i2 = i3 + 32 | 0;
  HEAP32[i2 >> 2] = i11;
  i6 = i11 << 3;
  i10 = _malloc(i6) | 0;
  i4 = i3 + 16 | 0;
  HEAP32[i4 >> 2] = i10;
  i9 = _malloc(i6) | 0;
  i1 = i3 + 20 | 0;
  HEAP32[i1 >> 2] = i9;
  i5 = i3 + 24 | 0;
  HEAP32[i5 >> 2] = _malloc(i6) | 0;
  i8 = i3 + 28 | 0;
  HEAP32[i8 >> 2] = _malloc(i6) | 0;
  i6 = i3 + 36 | 0;
  HEAP32[i6 >> 2] = _fft_create_plan(i11, i10, i9, 1, 0) | 0;
  HEAP32[i3 + 40 >> 2] = _fft_create_plan(HEAP32[i2 >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i8 >> 2] | 0, -1, 0) | 0;
  i8 = HEAP32[i2 >> 2] << 3;
  i5 = i3 + 8 | 0;
  HEAP32[i5 >> 2] = _malloc(i8) | 0;
  _memset(HEAP32[i4 >> 2] | 0, 0, i8 | 0) | 0;
  _memmove(HEAP32[i4 >> 2] | 0, HEAP32[i7 >> 2] | 0, HEAP32[i3 >> 2] << 3 | 0) | 0;
  _fft_execute(HEAP32[i6 >> 2] | 0);
  _memmove(HEAP32[i5 >> 2] | 0, HEAP32[i1 >> 2] | 0, HEAP32[i2 >> 2] << 3 | 0) | 0;
  i1 = HEAP32[i2 >> 2] | 0;
  HEAP32[i3 + 44 >> 2] = i1 >>> 1;
  HEAP32[i3 + 56 >> 2] = 0;
  HEAPF32[i3 + 60 >> 2] = 0.0;
  HEAPF32[i3 + 64 >> 2] = 0.0;
  HEAP32[i3 + 88 >> 2] = 0;
  HEAP32[i3 + 92 >> 2] = 0;
  _memset(HEAP32[i4 >> 2] | 0, 0, i1 << 3 | 0) | 0;
  i1 = i3 + 72 | 0;
  HEAP32[i1 >> 2] = 0;
  HEAP32[i1 + 4 >> 2] = 0;
  HEAP32[i1 + 8 >> 2] = 0;
  HEAP32[i1 + 12 >> 2] = 0;
  HEAPF32[i3 + 48 >> 2] = .5;
  i2 = ~~(+((HEAP32[i2 >> 2] | 0) >>> 0) * .30000001192092896 / 6.283185307179586);
  HEAP32[i3 + 52 >> 2] = (i2 | 0) < 0 ? 0 : i2;
  return i3 | 0;
 }
 return 0;
}

function _fec_conv_punctured_create(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = i2;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(i2);
 HEAP32[i1 + 136 >> 2] = fb + 4;
 HEAP32[i1 + 140 >> 2] = fb + 5;
 HEAP32[i1 + 144 >> 2] = fb + 6;
 do switch (HEAP32[i1 >> 2] | 0) {
 case 15:
  {
   _fec_conv_init_v27(i1);
   HEAP32[i1 + 36 >> 2] = 2;
   HEAP32[i1 + 40 >> 2] = gb + 8344;
   break;
  }
 case 16:
  {
   _fec_conv_init_v27(i1);
   HEAP32[i1 + 36 >> 2] = 3;
   HEAP32[i1 + 40 >> 2] = gb + 8360;
   break;
  }
 case 17:
  {
   _fec_conv_init_v27(i1);
   HEAP32[i1 + 36 >> 2] = 4;
   HEAP32[i1 + 40 >> 2] = gb + 8384;
   break;
  }
 case 18:
  {
   _fec_conv_init_v27(i1);
   HEAP32[i1 + 36 >> 2] = 5;
   HEAP32[i1 + 40 >> 2] = gb + 8416;
   break;
  }
 case 19:
  {
   _fec_conv_init_v27(i1);
   HEAP32[i1 + 36 >> 2] = 6;
   HEAP32[i1 + 40 >> 2] = gb + 8456;
   break;
  }
 case 20:
  {
   _fec_conv_init_v27(i1);
   HEAP32[i1 + 36 >> 2] = 7;
   HEAP32[i1 + 40 >> 2] = gb + 8504;
   break;
  }
 case 21:
  {
   _fec_conv_init_v29(i1);
   HEAP32[i1 + 36 >> 2] = 2;
   HEAP32[i1 + 40 >> 2] = gb + 8560;
   break;
  }
 case 22:
  {
   _fec_conv_init_v29(i1);
   HEAP32[i1 + 36 >> 2] = 3;
   HEAP32[i1 + 40 >> 2] = gb + 8576;
   break;
  }
 case 23:
  {
   _fec_conv_init_v29(i1);
   HEAP32[i1 + 36 >> 2] = 4;
   HEAP32[i1 + 40 >> 2] = gb + 8600;
   break;
  }
 case 24:
  {
   _fec_conv_init_v29(i1);
   HEAP32[i1 + 36 >> 2] = 5;
   HEAP32[i1 + 40 >> 2] = gb + 8632;
   break;
  }
 case 25:
  {
   _fec_conv_init_v29(i1);
   HEAP32[i1 + 36 >> 2] = 6;
   HEAP32[i1 + 40 >> 2] = gb + 8672;
   break;
  }
 case 26:
  {
   _fec_conv_init_v29(i1);
   HEAP32[i1 + 36 >> 2] = 7;
   HEAP32[i1 + 40 >> 2] = gb + 8720;
   break;
  }
 default:
  {
   _fwrite(gb + 12591 | 0, 49, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 } while (0);
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 16 >> 2] = 0;
 HEAP32[i1 + 20 >> 2] = 0;
 return i1 | 0;
}

function _bilinear_zpkf(i21, i18, i19, i17, i3, d16, i22, i20, i23) {
 i21 = i21 | 0;
 i18 = i18 | 0;
 i19 = i19 | 0;
 i17 = i17 | 0;
 i3 = i3 | 0;
 d16 = +d16;
 i22 = i22 | 0;
 i20 = i20 | 0;
 i23 = i23 | 0;
 var d1 = 0.0, d2 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i24 = 0, i25 = 0, i26 = 0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i12 = i24 + 48 | 0;
 i13 = i24 + 32 | 0;
 i14 = i24 + 16 | 0;
 i15 = i24;
 d2 = +HEAPF32[i3 >> 2];
 d1 = +HEAPF32[i3 + 4 >> 2];
 if (!i17) {
  d7 = d2;
  d16 = d1;
  i22 = i23 + 4 | 0;
  HEAPF32[i23 >> 2] = d7;
  HEAPF32[i22 >> 2] = d16;
  STACKTOP = i24;
  return;
 }
 i10 = i12 + 8 | 0;
 i11 = i13 + 8 | 0;
 i8 = i14 + 8 | 0;
 i9 = i15 + 8 | 0;
 i3 = 0;
 do {
  if (i3 >>> 0 < i18 >>> 0) {
   d5 = +HEAPF32[i21 + (i3 << 3) >> 2] * d16;
   d4 = +HEAPF32[i21 + (i3 << 3) + 4 >> 2] * d16;
   ___divdc3(i12, d5 + 1.0, d4, 1.0 - d5, -d4);
   d4 = +HEAPF64[i10 >> 3];
   d5 = +HEAPF64[i12 >> 3];
  } else {
   d4 = 0.0;
   d5 = -1.0;
  }
  i26 = i22 + (i3 << 3) | 0;
  HEAPF32[i26 >> 2] = d5;
  i25 = i22 + (i3 << 3) + 4 | 0;
  HEAPF32[i25 >> 2] = d4;
  d6 = +HEAPF32[i19 + (i3 << 3) >> 2] * d16;
  d7 = +HEAPF32[i19 + (i3 << 3) + 4 >> 2] * d16;
  ___divdc3(i13, d6 + 1.0, d7, 1.0 - d6, -d7);
  d7 = +HEAPF64[i13 >> 3];
  d6 = +HEAPF64[i11 >> 3];
  HEAPF32[i20 + (i3 << 3) >> 2] = d7;
  HEAPF32[i20 + (i3 << 3) + 4 >> 2] = d6;
  ___divdc3(i14, 1.0 - d7, -d6, 1.0 - +HEAPF32[i26 >> 2], -+HEAPF32[i25 >> 2]);
  d6 = +HEAPF64[i14 >> 3];
  d7 = +HEAPF64[i8 >> 3];
  d5 = d2;
  d4 = d1;
  d2 = d5 * d6 - d4 * d7;
  d1 = d4 * d6 + d5 * d7;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i15, d5, d4, d6, d7);
   d2 = +HEAPF64[i15 >> 3];
   d1 = +HEAPF64[i9 >> 3];
  }
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i17 | 0));
 i26 = i23 + 4 | 0;
 HEAPF32[i23 >> 2] = d2;
 HEAPF32[i26 >> 2] = d1;
 STACKTOP = i24;
 return;
}

function _fft_execute_dft_4(i1) {
 i1 = i1 | 0;
 var i2 = 0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, i13 = 0, d14 = 0.0, d15 = 0.0, i16 = 0, i17 = 0, d18 = 0.0, d19 = 0.0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0;
 i9 = HEAP32[i1 + 4 >> 2] | 0;
 i13 = HEAP32[i1 + 8 >> 2] | 0;
 i23 = HEAP32[i9 >> 2] | 0;
 i22 = HEAP32[i9 + 4 >> 2] | 0;
 i10 = i13 + 4 | 0;
 HEAP32[i13 >> 2] = i23;
 HEAP32[i10 >> 2] = i22;
 i25 = HEAP32[i9 + 16 >> 2] | 0;
 i24 = HEAP32[i9 + 20 >> 2] | 0;
 i5 = i13 + 8 | 0;
 i2 = i13 + 12 | 0;
 HEAP32[i5 >> 2] = i25;
 HEAP32[i2 >> 2] = i24;
 i21 = HEAP32[i9 + 8 >> 2] | 0;
 i20 = HEAP32[i9 + 12 >> 2] | 0;
 i17 = i13 + 16 | 0;
 i16 = i13 + 20 | 0;
 HEAP32[i17 >> 2] = i21;
 HEAP32[i16 >> 2] = i20;
 d19 = +HEAPF32[i9 + 24 >> 2];
 d18 = +HEAPF32[i9 + 28 >> 2];
 i9 = i13 + 24 | 0;
 i8 = i13 + 28 | 0;
 d12 = (HEAP32[tempDoublePtr >> 2] = i25, +HEAPF32[tempDoublePtr >> 2]);
 d15 = (HEAP32[tempDoublePtr >> 2] = i24, +HEAPF32[tempDoublePtr >> 2]);
 d14 = (HEAP32[tempDoublePtr >> 2] = i23, +HEAPF32[tempDoublePtr >> 2]);
 d11 = (HEAP32[tempDoublePtr >> 2] = i22, +HEAPF32[tempDoublePtr >> 2]);
 d7 = d14 - d12;
 d4 = d11 - d15;
 HEAPF32[i5 >> 2] = d7;
 HEAPF32[i2 >> 2] = d4;
 d14 = d12 + d14;
 d11 = d15 + d11;
 d15 = (HEAP32[tempDoublePtr >> 2] = i21, +HEAPF32[tempDoublePtr >> 2]);
 d12 = (HEAP32[tempDoublePtr >> 2] = i20, +HEAPF32[tempDoublePtr >> 2]);
 d3 = d15 - d19;
 d6 = d12 - d18;
 HEAPF32[i9 >> 2] = d3;
 HEAPF32[i8 >> 2] = d6;
 d15 = d19 + d15;
 d12 = d18 + d12;
 HEAPF32[i17 >> 2] = d14 - d15;
 HEAPF32[i16 >> 2] = d11 - d12;
 HEAPF32[i13 >> 2] = d15 + d14;
 HEAPF32[i10 >> 2] = d12 + d11;
 d6 = d6 - d3 * 0.0;
 i1 = (HEAP32[i1 + 12 >> 2] | 0) == -1;
 d6 = i1 ? -d6 : d6;
 d3 = i1 ? d3 : -d3;
 HEAPF32[i9 >> 2] = d7 - d6;
 HEAPF32[i8 >> 2] = d4 - d3;
 HEAPF32[i5 >> 2] = d7 + d6;
 HEAPF32[i2 >> 2] = d4 + d3;
 return;
}

function _ofdmframesync_execute_seekplcp(i12) {
 i12 = i12 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, d14 = 0.0, d15 = 0.0, d16 = 0.0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i9 = i13 + 32 | 0;
 i2 = i13 + 24 | 0;
 i8 = i13 + 8 | 0;
 i5 = i13 + 16 | 0;
 i10 = i13;
 i11 = i12 + 124 | 0;
 i7 = (HEAP32[i11 >> 2] | 0) + 1 | 0;
 HEAP32[i11 >> 2] = i7;
 if (i7 >>> 0 < (HEAP32[i12 >> 2] | 0) >>> 0) {
  STACKTOP = i13;
  return;
 }
 HEAP32[i11 >> 2] = 0;
 _windowcf_read(HEAP32[i12 + 60 >> 2] | 0, i2);
 i6 = HEAP32[i12 + 8 >> 2] | 0;
 i7 = HEAP32[i12 >> 2] | 0;
 i3 = i6 + i7 | 0;
 i4 = HEAP32[i2 >> 2] | 0;
 if (i6 >>> 0 < i3 >>> 0) {
  d1 = 0.0;
  i2 = i6;
  do {
   d15 = +HEAPF32[i4 + (i2 << 3) >> 2];
   d14 = +HEAPF32[i4 + (i2 << 3) + 4 >> 2];
   d1 = d1 + (d15 * d15 + d14 * d14);
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 } else d1 = 0.0;
 d16 = +(i7 >>> 0) / d1;
 i2 = i12 + 84 | 0;
 _ofdmframesync_estimate_gain_S0(i12, i4 + (i6 << 3) | 0, HEAP32[i2 >> 2] | 0);
 _ofdmframesync_S0_metrics(i12, HEAP32[i2 >> 2] | 0, i8);
 i2 = i8 + 4 | 0;
 d14 = d16 * +HEAPF32[i8 >> 2];
 d15 = d16 * +HEAPF32[i2 >> 2];
 HEAPF32[i8 >> 2] = d14;
 HEAPF32[i2 >> 2] = d15;
 HEAPF32[i5 >> 2] = d14;
 HEAPF32[i5 + 4 >> 2] = d15;
 HEAP32[i9 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i9 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 d1 = +_cargf(i9);
 i2 = i12 + 4 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 HEAPF32[i12 + 80 >> 2] = d16;
 HEAPF32[i10 >> 2] = d14;
 HEAPF32[i10 + 4 >> 2] = d15;
 HEAP32[i9 >> 2] = HEAP32[i10 >> 2];
 HEAP32[i9 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
 d15 = +_cabsf(i9);
 if (d15 > +HEAPF32[i12 + 152 >> 2]) {
  i9 = ~~+_roundf(+(d1 * +(i3 >>> 0) / 6.283185307179586));
  i10 = HEAP32[i12 >> 2] | 0;
  HEAP32[i11 >> 2] = (((i10 + i9 | 0) >>> 0) % ((HEAP32[i2 >> 2] | 0) >>> 0) | 0) + i10;
  HEAP32[i12 + 104 >> 2] = 1;
 }
 STACKTOP = i13;
 return;
}

function _liquid_firdes_fnyquist(i4, i5, i9, i3, d2, d1, i13) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 i9 = i9 | 0;
 i3 = i3 | 0;
 d2 = +d2;
 d1 = +d1;
 i13 = i13 | 0;
 var i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 if (!i9) {
  _fwrite(gb + 22353 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i3) {
  _fwrite(gb + 22412 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d2 < 0.0 | d2 > 1.0) {
  _fwrite(gb + 22471 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i11 = Math_imul(i9 << 1, i3) | 0 | 1;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i11 << 3) | 0) + 15 & -16) | 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i11 << 3) | 0) + 15 & -16) | 0;
 switch (i4 | 0) {
 case 4:
  {
   _liquid_firdes_fexp_freqresponse(i9, i3, d2, i6);
   break;
  }
 case 5:
  {
   _liquid_firdes_fsech_freqresponse(i9, i3, d2, i6);
   break;
  }
 case 6:
  {
   _liquid_firdes_farcsech_freqresponse(i9, i3, d2, i6);
   break;
  }
 default:
  {
   _fwrite(gb + 22573 | 0, 65, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 i4 = Math_imul(i3, i9) | 0;
 i8 = i4 << 1 | 1;
 if (!i5) {
  i3 = 0;
  do {
   HEAP32[i7 + (i3 << 3) >> 2] = HEAP32[i6 + (i3 << 2) >> 2];
   HEAPF32[i7 + (i3 << 3) + 4 >> 2] = 0.0;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i8 | 0));
 } else {
  i3 = 0;
  do {
   HEAPF32[i7 + (i3 << 3) >> 2] = +Math_sqrt(+(+HEAPF32[i6 + (i3 << 2) >> 2]));
   HEAPF32[i7 + (i3 << 3) + 4 >> 2] = 0.0;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i8 | 0));
 }
 _fft_run(i11, i7, i10, -1, 0);
 i4 = i4 + 1 | 0;
 d1 = +(i9 >>> 0);
 d2 = +(i11 >>> 0);
 i3 = 0;
 do {
  HEAPF32[i13 + (i3 << 2) >> 2] = d1 * +HEAPF32[i10 + ((((i4 + i3 | 0) >>> 0) % (i11 >>> 0) | 0) << 3) >> 2] / d2;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i8 | 0));
 STACKTOP = i12;
 return;
}

function _modem_create_psk(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0;
 i7 = _malloc(252) | 0;
 switch (i1 | 0) {
 case 1:
  {
   HEAP32[i7 >> 2] = 1;
   break;
  }
 case 2:
  {
   HEAP32[i7 >> 2] = 2;
   break;
  }
 case 3:
  {
   HEAP32[i7 >> 2] = 3;
   break;
  }
 case 4:
  {
   HEAP32[i7 >> 2] = 4;
   break;
  }
 case 5:
  {
   HEAP32[i7 >> 2] = 5;
   break;
  }
 case 6:
  {
   HEAP32[i7 >> 2] = 6;
   break;
  }
 case 7:
  {
   HEAP32[i7 >> 2] = 7;
   break;
  }
 case 8:
  {
   HEAP32[i7 >> 2] = 8;
   break;
  }
 default:
  {
   _fwrite(gb + 30544 | 0, 57, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 i8 = i7 + 76 | 0;
 HEAP32[i8 >> 2] = 0;
 i9 = i7 + 80 | 0;
 HEAP32[i9 >> 2] = 0;
 i10 = i7 + 4 | 0;
 HEAP32[i10 >> 2] = i1;
 i1 = 1 << i1;
 i5 = i7 + 8 | 0;
 HEAP32[i5 >> 2] = i1;
 i6 = i7 + 236 | 0;
 HEAP32[i6 >> 2] = 0;
 HEAP32[i6 + 4 >> 2] = 0;
 HEAP32[i6 + 8 >> 2] = 0;
 HEAP32[i6 + 12 >> 2] = 0;
 d11 = 3.141592653589793 / +(i1 >>> 0);
 i1 = i7 + 100 | 0;
 i2 = i7 + 104 | 0;
 HEAPF32[i2 >> 2] = d11;
 i3 = i7 + 12 | 0;
 HEAPF32[i3 >> 2] = d11;
 if ((HEAP32[i10 >> 2] | 0) >>> 0 > 1) {
  i4 = 1;
  do {
   HEAPF32[i3 + (i4 << 2) >> 2] = +(1 << i4 | 0) * +HEAPF32[i2 >> 2];
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i10 >> 2] | 0) >>> 0);
 }
 i5 = HEAP32[i5 >> 2] | 0;
 HEAPF32[i1 >> 2] = (1.0 - 1.0 / +(i5 >>> 0)) * 3.141592653589793;
 HEAP32[i6 >> 2] = fb + 17;
 HEAP32[i7 + 240 >> 2] = fb + 18;
 HEAP32[i8 >> 2] = _malloc(i5 << 3) | 0;
 _modem_init_map(i7);
 HEAP32[i9 >> 2] = 1;
 if ((HEAP32[i10 >> 2] | 0) >>> 0 > 2) _modem_demodsoft_gentab(i7, 2);
 HEAPF32[i7 + 84 >> 2] = 1.0;
 HEAPF32[i7 + 88 >> 2] = 0.0;
 HEAP32[i7 + 92 >> 2] = 1065353216;
 HEAPF32[i7 + 96 >> 2] = 0.0;
 if (!(_liquid_modem_is_dpsk(HEAP32[i7 >> 2] | 0) | 0)) return i7 | 0;
 HEAPF32[i2 >> 2] = 0.0;
 return i7 | 0;
}

function _flexframegen_generate_symbol(i6, i4) {
 i6 = i6 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i7 = 0, i8 = 0;
 i2 = i4 + 112 | 0;
 if (!(HEAP32[i2 >> 2] | 0)) {
  HEAPF32[i6 >> 2] = 0.0;
  HEAPF32[i6 + 4 >> 2] = 0.0;
  return;
 }
 i5 = i4 + 120 | 0;
 switch (HEAP32[i5 >> 2] | 0) {
 case 0:
  {
   i3 = i4 + 104 | 0;
   i2 = HEAP32[i3 >> 2] | 0;
   i7 = i2 + 1 | 0;
   HEAP32[i3 >> 2] = i7;
   i4 = HEAP32[i4 + 48 >> 2] | 0;
   i1 = HEAP32[i4 + (i2 << 3) >> 2] | 0;
   i2 = HEAP32[i4 + (i2 << 3) + 4 >> 2] | 0;
   if ((i7 | 0) == 64) {
    HEAP32[i3 >> 2] = 0;
    HEAP32[i5 >> 2] = 1;
   }
   HEAP32[i6 >> 2] = i1;
   HEAP32[i6 + 4 >> 2] = i2;
   return;
  }
 case 1:
  {
   i1 = i4 + 104 | 0;
   i3 = HEAP32[i1 >> 2] | 0;
   i7 = i3 + 1 | 0;
   HEAP32[i1 >> 2] = i7;
   i8 = HEAP32[i4 + 84 >> 2] | 0;
   i2 = HEAP32[i8 + (i3 << 3) >> 2] | 0;
   i3 = HEAP32[i8 + (i3 << 3) + 4 >> 2] | 0;
   if ((i7 | 0) == (HEAP32[i4 + 80 >> 2] | 0)) {
    HEAP32[i1 >> 2] = 0;
    HEAP32[i5 >> 2] = 2;
   }
   HEAP32[i6 >> 2] = i2;
   HEAP32[i6 + 4 >> 2] = i3;
   return;
  }
 case 2:
  {
   i1 = i4 + 104 | 0;
   i3 = HEAP32[i1 >> 2] | 0;
   i8 = i3 + 1 | 0;
   HEAP32[i1 >> 2] = i8;
   i7 = HEAP32[i4 + 100 >> 2] | 0;
   i2 = HEAP32[i7 + (i3 << 3) >> 2] | 0;
   i3 = HEAP32[i7 + (i3 << 3) + 4 >> 2] | 0;
   if ((i8 | 0) == (HEAP32[i4 + 96 >> 2] | 0)) {
    HEAP32[i1 >> 2] = 0;
    HEAP32[i5 >> 2] = 3;
   }
   HEAP32[i6 >> 2] = i2;
   HEAP32[i6 + 4 >> 2] = i3;
   return;
  }
 case 3:
  {
   i1 = i4 + 104 | 0;
   i8 = (HEAP32[i1 >> 2] | 0) + 1 | 0;
   HEAP32[i1 >> 2] = i8;
   if ((i8 | 0) == (HEAP32[i4 + 4 >> 2] << 1 | 0)) {
    HEAP32[i1 >> 2] = 0;
    HEAP32[i4 + 116 >> 2] = 1;
    HEAP32[i2 >> 2] = 0;
   }
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   return;
  }
 default:
  {
   _fwrite(gb + 25220 | 0, 74, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
}

function _ellipkf(d7, i9, i10, i11) {
 d7 = +d7;
 i9 = i9 | 0;
 i10 = i10 | 0;
 i11 = i11 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d8 = 0.0, i12 = 0;
 i12 = STACKTOP;
 d8 = +Math_sqrt(+(1.0 - d7 * d7));
 if (d7 > .9999998807907104) {
  d6 = +Math_log(+(d8 * .25));
  d6 = d8 * (d8 * ((-1.0 - d6) * .25)) - d6;
 } else {
  i5 = _llvm_stacksave() | 0;
  i4 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
  i2 = (i9 | 0) == 0;
  if (!i2) {
   i3 = 0;
   d1 = d7;
   do {
    d6 = +Math_sqrt(+(1.0 - d1 * d1));
    d1 = (1.0 - d6) / (d6 + 1.0);
    HEAPF32[i4 + (i3 << 2) >> 2] = d1;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i9 | 0));
   if (!i2) {
    d1 = 1.5707963705062866;
    i2 = 0;
    do {
     d1 = d1 * (+HEAPF32[i4 + (i2 << 2) >> 2] + 1.0);
     i2 = i2 + 1 | 0;
    } while ((i2 | 0) != (i9 | 0));
   } else d1 = 1.5707963705062866;
  } else d1 = 1.5707963705062866;
  _llvm_stackrestore(i5 | 0);
  d6 = d1;
 }
 if (d7 < 3.9999998989515007e-04) {
  d8 = +Math_log(+(d7 * .25));
  d8 = (-1.0 - d8) * .25 * d7 * d7 - d8;
  HEAPF32[i10 >> 2] = d6;
  HEAPF32[i11 >> 2] = d8;
  STACKTOP = i12;
  return;
 }
 i5 = _llvm_stacksave() | 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 i2 = (i9 | 0) == 0;
 if (!i2) {
  i3 = 0;
  d1 = d8;
  do {
   d8 = +Math_sqrt(+(1.0 - d1 * d1));
   d1 = (1.0 - d8) / (d8 + 1.0);
   HEAPF32[i4 + (i3 << 2) >> 2] = d1;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i9 | 0));
  if (!i2) {
   d1 = 1.5707963705062866;
   i2 = 0;
   do {
    d1 = d1 * (+HEAPF32[i4 + (i2 << 2) >> 2] + 1.0);
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i9 | 0));
  } else d1 = 1.5707963705062866;
 } else d1 = 1.5707963705062866;
 _llvm_stackrestore(i5 | 0);
 d8 = d1;
 HEAPF32[i10 >> 2] = d6;
 HEAPF32[i11 >> 2] = d8;
 STACKTOP = i12;
 return;
}

function _iirfilt_crcf_create_sos(i3, i2, i13) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i13 = i13 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, d17 = 0.0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i16;
 i14 = i16 + 16 | 0;
 i15 = i16 + 4 | 0;
 if (!i13) {
  i12 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 19656;
  _fprintf(i12, gb + 21373 | 0, i1) | 0;
  _exit(1);
 }
 i11 = _malloc(36) | 0;
 HEAP32[i11 + 24 >> 2] = 1;
 HEAP32[i11 + 32 >> 2] = i13;
 i12 = _malloc(i13 << 2) | 0;
 HEAP32[i11 + 28 >> 2] = i12;
 HEAP32[i11 + 12 >> 2] = i13 << 1;
 i1 = i13 * 12 | 0;
 i9 = _malloc(i1) | 0;
 HEAP32[i11 >> 2] = i9;
 i10 = _malloc(i1) | 0;
 HEAP32[i11 + 4 >> 2] = i10;
 _memcpy(i9 | 0, i3 | 0, i1 | 0) | 0;
 _memcpy(i10 | 0, i2 | 0, i1 | 0) | 0;
 i1 = i15 + 4 | 0;
 i2 = i15 + 8 | 0;
 i3 = i14 + 4 | 0;
 i4 = i14 + 8 | 0;
 i6 = 0;
 do {
  i7 = i6 * 3 | 0;
  i5 = i9 + (i7 << 2) | 0;
  i7 = i10 + (i7 << 2) | 0;
  HEAP32[i14 >> 2] = HEAP32[i7 >> 2];
  HEAP32[i14 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
  HEAP32[i14 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
  HEAP32[i15 >> 2] = HEAP32[i5 >> 2];
  HEAP32[i15 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
  HEAP32[i15 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
  i5 = _malloc(96) | 0;
  d17 = +HEAPF32[i14 >> 2];
  HEAPF32[i5 >> 2] = +HEAPF32[i15 >> 2] / d17;
  HEAPF32[i5 + 4 >> 2] = +HEAPF32[i1 >> 2] / d17;
  HEAPF32[i5 + 8 >> 2] = +HEAPF32[i2 >> 2] / d17;
  HEAPF32[i5 + 12 >> 2] = d17 / d17;
  HEAPF32[i5 + 16 >> 2] = +HEAPF32[i3 >> 2] / d17;
  HEAPF32[i5 + 20 >> 2] = +HEAPF32[i4 >> 2] / d17;
  i7 = i5 + 24 | 0;
  i8 = i7 + 72 | 0;
  do {
   HEAP32[i7 >> 2] = 0;
   i7 = i7 + 4 | 0;
  } while ((i7 | 0) < (i8 | 0));
  HEAP32[i12 + (i6 << 2) >> 2] = i5;
  i6 = i6 + 1 | 0;
 } while (i6 >>> 0 < i13 >>> 0);
 STACKTOP = i16;
 return i11 | 0;
}

function _gmskframegen_assemble(i11, i9, i10, i6, i2, i3, i5) {
 i11 = i11 | 0;
 i9 = i9 | 0;
 i10 = i10 | 0;
 i6 = i6 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 var i1 = 0, i4 = 0, i7 = 0, i8 = 0, i12 = 0;
 i7 = i11 + 72 | 0;
 i8 = i11 + 60 | 0;
 if ((((HEAP32[i7 >> 2] | 0) == (i6 | 0) ? (HEAP32[i8 >> 2] | 0) == (i2 | 0) : 0) ? (i4 = i11 + 64 | 0, (HEAP32[i4 >> 2] | 0) == (i3 | 0)) : 0) ? (i1 = i11 + 68 | 0, (HEAP32[i1 >> 2] | 0) == (i5 | 0)) : 0) {
  i2 = i11 + 56 | 0;
  i3 = i11 + 80 | 0;
 } else {
  HEAP32[i7 >> 2] = i6;
  HEAP32[i8 >> 2] = i2;
  i4 = i11 + 64 | 0;
  HEAP32[i4 >> 2] = i3;
  i1 = i11 + 68 | 0;
  HEAP32[i1 >> 2] = i5;
  i12 = i11 + 56 | 0;
  i2 = _packetizer_recreate(HEAP32[i12 >> 2] | 0, i6, i2, i3, i5) | 0;
  HEAP32[i12 >> 2] = i2;
  i2 = _packetizer_get_enc_msg_len(i2) | 0;
  HEAP32[i11 + 76 >> 2] = i2;
  HEAP32[i11 + 24 >> 2] = i2 << 3;
  i3 = i11 + 80 | 0;
  HEAP32[i3 >> 2] = _realloc(HEAP32[i3 >> 2] | 0, i2) | 0;
  i2 = i12;
 }
 HEAP32[i11 + 88 >> 2] = 1;
 i6 = i11 + 44 | 0;
 i12 = i11 + 36 | 0;
 _memmove(HEAP32[i6 >> 2] | 0, i9 | 0, HEAP32[i12 >> 2] | 0) | 0;
 i12 = HEAP32[i12 >> 2] | 0;
 HEAP8[(HEAP32[i6 >> 2] | 0) + i12 >> 0] = 3;
 HEAP8[(HEAP32[i6 >> 2] | 0) + (i12 + 1) >> 0] = (HEAP32[i7 >> 2] | 0) >>> 8;
 HEAP8[(HEAP32[i6 >> 2] | 0) + (i12 + 2) >> 0] = HEAP32[i7 >> 2];
 i9 = i12 + 3 | 0;
 HEAP8[(HEAP32[i6 >> 2] | 0) + i9 >> 0] = HEAP32[i8 >> 2] << 5;
 i9 = (HEAP32[i6 >> 2] | 0) + i9 | 0;
 HEAP8[i9 >> 0] = HEAPU8[i9 >> 0] | 0 | HEAP32[i4 >> 2] & 31;
 HEAP8[(HEAP32[i6 >> 2] | 0) + (i12 + 4) >> 0] = HEAP32[i1 >> 2] & 31;
 i12 = i11 + 48 | 0;
 _packetizer_encode(HEAP32[i11 + 52 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i12 >> 2] | 0);
 _scramble_data(HEAP32[i12 >> 2] | 0, HEAP32[i11 + 40 >> 2] | 0);
 _packetizer_encode(HEAP32[i2 >> 2] | 0, i10, HEAP32[i3 >> 2] | 0);
 return;
}

function _hashtable_do_rehash(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i2 = i10 + 28 | 0;
 i3 = i10 + 24 | 0;
 i6 = i10 + 20 | 0;
 i8 = i10 + 16 | 0;
 i9 = i10 + 12 | 0;
 i4 = i10 + 8 | 0;
 i5 = i10 + 4 | 0;
 i7 = i10;
 HEAP32[i3 >> 2] = i1;
 _jsonp_free(HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
 i1 = (HEAP32[i3 >> 2] | 0) + 8 | 0;
 HEAP32[i1 >> 2] = (HEAP32[i1 >> 2] | 0) + 1;
 HEAP32[i7 >> 2] = 1 << HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2];
 i1 = _jsonp_malloc(HEAP32[i7 >> 2] << 3) | 0;
 HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] = i1;
 if (!(HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0)) {
  HEAP32[i2 >> 2] = -1;
  i9 = HEAP32[i2 >> 2] | 0;
  STACKTOP = i10;
  return i9 | 0;
 }
 HEAP32[i4 >> 2] = 0;
 while (1) {
  i1 = (HEAP32[i3 >> 2] | 0) + 12 | 0;
  if ((HEAP32[i4 >> 2] | 0) >>> 0 >= 1 << HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] >>> 0) break;
  HEAP32[(HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i4 >> 2] << 3) + 4 >> 2] = i1;
  HEAP32[(HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i4 >> 2] << 3) >> 2] = i1;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + 1;
 }
 HEAP32[i6 >> 2] = HEAP32[i1 + 4 >> 2];
 _list_init((HEAP32[i3 >> 2] | 0) + 12 | 0);
 while (1) {
  if ((HEAP32[i6 >> 2] | 0) == ((HEAP32[i3 >> 2] | 0) + 12 | 0)) break;
  HEAP32[i8 >> 2] = HEAP32[(HEAP32[i6 >> 2] | 0) + 4 >> 2];
  HEAP32[i9 >> 2] = HEAP32[i6 >> 2];
  HEAP32[i5 >> 2] = ((HEAP32[(HEAP32[i9 >> 2] | 0) + 8 >> 2] | 0) >>> 0) % ((HEAP32[i7 >> 2] | 0) >>> 0) | 0;
  _insert_to_bucket(HEAP32[i3 >> 2] | 0, (HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i5 >> 2] << 3) | 0, HEAP32[i9 >> 2] | 0);
  HEAP32[i6 >> 2] = HEAP32[i8 >> 2];
 }
 HEAP32[i2 >> 2] = 0;
 i9 = HEAP32[i2 >> 2] | 0;
 STACKTOP = i10;
 return i9 | 0;
}

function _log10(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i3 = HEAP32[tempDoublePtr >> 2] | 0;
 i2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i4 = (i2 | 0) < 0;
 do if (i4 | i2 >>> 0 < 1048576) {
  d6 = +Math_abs(+d1);
  HEAPF64[tempDoublePtr >> 3] = d6;
  if ((HEAP32[tempDoublePtr >> 2] | 0) == 0 & (HEAP32[tempDoublePtr + 4 >> 2] | 0) == 0) {
   d1 = -1.0 / (d1 * d1);
   break;
  }
  if (i4) {
   d1 = (d1 - d1) / 0.0;
   break;
  } else {
   HEAPF64[tempDoublePtr >> 3] = d1 * 18014398509481984.0;
   i2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   i4 = HEAP32[tempDoublePtr >> 2] | 0;
   i3 = -1077;
   i5 = 9;
   break;
  }
 } else if (i2 >>> 0 <= 2146435071) if ((i3 | 0) == 0 & 0 == 0 & (i2 | 0) == 1072693248) d1 = 0.0; else {
  i4 = i3;
  i3 = -1023;
  i5 = 9;
 } while (0);
 if ((i5 | 0) == 9) {
  i5 = i2 + 614242 | 0;
  HEAP32[tempDoublePtr >> 2] = i4;
  HEAP32[tempDoublePtr + 4 >> 2] = (i5 & 1048575) + 1072079006;
  d8 = +HEAPF64[tempDoublePtr >> 3] + -1.0;
  d7 = d8 * (d8 * .5);
  d9 = d8 / (d8 + 2.0);
  d10 = d9 * d9;
  d1 = d10 * d10;
  HEAPF64[tempDoublePtr >> 3] = d8 - d7;
  i4 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = i4;
  d6 = +HEAPF64[tempDoublePtr >> 3];
  d1 = d8 - d6 - d7 + d9 * (d7 + (d1 * (d1 * (d1 * .15313837699209373 + .22222198432149784) + .3999999999940942) + d10 * (d1 * (d1 * (d1 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735)));
  d10 = d6 * .4342944818781689;
  d7 = +(i3 + (i5 >>> 20) | 0);
  d9 = d7 * .30102999566361177;
  d8 = d9 + d10;
  d1 = d8 + (d10 + (d9 - d8) + (d1 * .4342944818781689 + (d7 * 3.694239077158931e-13 + (d6 + d1) * 2.5082946711645275e-11)));
 }
 return +d1;
}

function _ellip_snf(i14, i3, d4, i6) {
 i14 = i14 | 0;
 i3 = i3 | 0;
 d4 = +d4;
 i6 = i6 | 0;
 var d1 = 0.0, d2 = 0.0, d5 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0, i16 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i10 = i15 + 32 | 0;
 i11 = i15 + 24 | 0;
 i16 = i15 + 16 | 0;
 i12 = i15 + 8 | 0;
 i13 = i15;
 d2 = +HEAPF32[i3 + 4 >> 2] * 3.141592653589793 * .5;
 HEAPF32[i16 >> 2] = +HEAPF32[i3 >> 2] * 3.141592653589793 * .5;
 HEAPF32[i16 + 4 >> 2] = d2;
 HEAP32[i10 >> 2] = HEAP32[i16 >> 2];
 HEAP32[i10 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
 _csinf(i11, i10);
 d2 = +HEAPF32[i11 >> 2];
 d1 = +HEAPF32[i11 + 4 >> 2];
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i6 << 2) | 0) + 15 & -16) | 0;
 if (!i6) {
  d8 = d2;
  d9 = d1;
  i16 = i14 + 4 | 0;
  HEAPF32[i14 >> 2] = d8;
  HEAPF32[i16 >> 2] = d9;
  STACKTOP = i15;
  return;
 } else i3 = 0;
 do {
  d9 = +Math_sqrt(+(1.0 - d4 * d4));
  d4 = (1.0 - d9) / (d9 + 1.0);
  HEAPF32[i11 + (i3 << 2) >> 2] = d4;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i6 | 0));
 if (!i6) {
  d8 = d2;
  d9 = d1;
  i16 = i14 + 4 | 0;
  HEAPF32[i14 >> 2] = d8;
  HEAPF32[i16 >> 2] = d9;
  STACKTOP = i15;
  return;
 }
 i3 = i12 + 4 | 0;
 i10 = i13 + 4 | 0;
 do {
  i6 = i6 + -1 | 0;
  d8 = +HEAPF32[i11 + (i6 << 2) >> 2];
  d9 = d8 + 1.0;
  d7 = d2 * d8;
  d8 = d1 * d8;
  d5 = d2 * d7 - d1 * d8;
  d4 = d1 * d7 + d2 * d8;
  if ((d5 != d5 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
   ___mulsc3(i12, d7, d8, d2, d1);
   d5 = +HEAPF32[i12 >> 2];
   d4 = +HEAPF32[i3 >> 2];
  }
  ___divsc3(i13, d2 * d9, d1 * d9, d5 + 1.0, d4 + 0.0);
  d2 = +HEAPF32[i13 >> 2];
  d1 = +HEAPF32[i10 >> 2];
 } while ((i6 | 0) != 0);
 i16 = i14 + 4 | 0;
 HEAPF32[i14 >> 2] = d2;
 HEAPF32[i16 >> 2] = d1;
 STACKTOP = i15;
 return;
}

function _ellip_cdf(i14, i3, d4, i6) {
 i14 = i14 | 0;
 i3 = i3 | 0;
 d4 = +d4;
 i6 = i6 | 0;
 var d1 = 0.0, d2 = 0.0, d5 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0, i16 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i10 = i15 + 32 | 0;
 i11 = i15 + 24 | 0;
 i16 = i15 + 16 | 0;
 i12 = i15 + 8 | 0;
 i13 = i15;
 d2 = +HEAPF32[i3 + 4 >> 2] * 3.141592653589793 * .5;
 HEAPF32[i16 >> 2] = +HEAPF32[i3 >> 2] * 3.141592653589793 * .5;
 HEAPF32[i16 + 4 >> 2] = d2;
 HEAP32[i10 >> 2] = HEAP32[i16 >> 2];
 HEAP32[i10 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
 _ccosf(i11, i10);
 d2 = +HEAPF32[i11 >> 2];
 d1 = +HEAPF32[i11 + 4 >> 2];
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i6 << 2) | 0) + 15 & -16) | 0;
 if (!i6) {
  d8 = d2;
  d9 = d1;
  i16 = i14 + 4 | 0;
  HEAPF32[i14 >> 2] = d8;
  HEAPF32[i16 >> 2] = d9;
  STACKTOP = i15;
  return;
 } else i3 = 0;
 do {
  d9 = +Math_sqrt(+(1.0 - d4 * d4));
  d4 = (1.0 - d9) / (d9 + 1.0);
  HEAPF32[i11 + (i3 << 2) >> 2] = d4;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i6 | 0));
 if (!i6) {
  d8 = d2;
  d9 = d1;
  i16 = i14 + 4 | 0;
  HEAPF32[i14 >> 2] = d8;
  HEAPF32[i16 >> 2] = d9;
  STACKTOP = i15;
  return;
 }
 i3 = i12 + 4 | 0;
 i10 = i13 + 4 | 0;
 do {
  i6 = i6 + -1 | 0;
  d8 = +HEAPF32[i11 + (i6 << 2) >> 2];
  d9 = d8 + 1.0;
  d7 = d2 * d8;
  d8 = d1 * d8;
  d5 = d2 * d7 - d1 * d8;
  d4 = d1 * d7 + d2 * d8;
  if ((d5 != d5 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
   ___mulsc3(i12, d7, d8, d2, d1);
   d5 = +HEAPF32[i12 >> 2];
   d4 = +HEAPF32[i3 >> 2];
  }
  ___divsc3(i13, d2 * d9, d1 * d9, d5 + 1.0, d4 + 0.0);
  d2 = +HEAPF32[i13 >> 2];
  d1 = +HEAPF32[i10 >> 2];
 } while ((i6 | 0) != 0);
 i16 = i14 + 4 | 0;
 HEAPF32[i14 >> 2] = d2;
 HEAPF32[i16 >> 2] = d1;
 STACKTOP = i15;
 return;
}

function _hypot(d1, d2) {
 d1 = +d1;
 d2 = +d2;
 var d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0;
 d1 = +Math_abs(+d1);
 HEAPF64[tempDoublePtr >> 3] = d1;
 i10 = HEAP32[tempDoublePtr >> 2] | 0;
 i6 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 d1 = +Math_abs(+d2);
 HEAPF64[tempDoublePtr >> 3] = d1;
 i4 = HEAP32[tempDoublePtr >> 2] | 0;
 i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i7 = i6 >>> 0 < i5 >>> 0 | (i6 | 0) == (i5 | 0) & i10 >>> 0 < i4 >>> 0;
 i9 = i7 ? i4 : i10;
 i8 = i7 ? i5 : i6;
 i4 = i7 ? i10 : i4;
 i5 = i7 ? i6 : i5;
 i6 = _bitshift64Lshr(i9 | 0, i8 | 0, 52) | 0;
 getTempRet0() | 0;
 i7 = _bitshift64Lshr(i4 | 0, i5 | 0, 52) | 0;
 getTempRet0() | 0;
 HEAP32[tempDoublePtr >> 2] = i9;
 HEAP32[tempDoublePtr + 4 >> 2] = i8;
 d1 = +HEAPF64[tempDoublePtr >> 3];
 HEAP32[tempDoublePtr >> 2] = i4;
 HEAP32[tempDoublePtr + 4 >> 2] = i5;
 d2 = +HEAPF64[tempDoublePtr >> 3];
 do if ((i7 | 0) != 2047) {
  if (!((i4 | 0) == 0 & (i5 | 0) == 0 | (i6 | 0) == 2047)) {
   if ((i6 - i7 | 0) > 64) {
    d1 = d1 + d2;
    break;
   }
   if (i6 >>> 0 <= 1533) if (i7 >>> 0 < 573) {
    d1 = d1 * 5260135901548373507240989.0e186;
    d2 = d2 * 5260135901548373507240989.0e186;
    d3 = 1.90109156629516e-211;
   } else d3 = 1.0; else {
    d1 = d1 * 1.90109156629516e-211;
    d2 = d2 * 1.90109156629516e-211;
    d3 = 5260135901548373507240989.0e186;
   }
   d12 = d1 * 134217729.0;
   d12 = d12 + (d1 - d12);
   d11 = d1 - d12;
   d1 = d1 * d1;
   d14 = d2 * 134217729.0;
   d14 = d14 + (d2 - d14);
   d13 = d2 - d14;
   d2 = d2 * d2;
   d1 = d3 * +Math_sqrt(+(d1 + (d2 + (d13 * d13 + (d14 * d14 - d2 + d14 * 2.0 * d13) + (d11 * d11 + (d12 * d12 - d1 + d12 * 2.0 * d11))))));
  }
 } else d1 = d2; while (0);
 return +d1;
}

function _parse_array(i9, i8, i7) {
 i9 = i9 | 0;
 i8 = i8 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i10 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i10 = i12;
 i1 = i12 + 24 | 0;
 i2 = i12 + 20 | 0;
 i3 = i12 + 16 | 0;
 i4 = i12 + 12 | 0;
 i5 = i12 + 8 | 0;
 i6 = i12 + 4 | 0;
 HEAP32[i2 >> 2] = i9;
 HEAP32[i3 >> 2] = i8;
 HEAP32[i4 >> 2] = i7;
 HEAP32[i5 >> 2] = _json_array() | 0;
 if (!(HEAP32[i5 >> 2] | 0)) {
  HEAP32[i1 >> 2] = 0;
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 _lex_scan(HEAP32[i2 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
 if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) == 93) {
  HEAP32[i1 >> 2] = HEAP32[i5 >> 2];
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 while (1) {
  if (!(HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0)) {
   i11 = 10;
   break;
  }
  HEAP32[i6 >> 2] = _parse_value(HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
  if (!(HEAP32[i6 >> 2] | 0)) break;
  i9 = (_json_array_append(HEAP32[i5 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0) != 0;
  _json_decref(HEAP32[i6 >> 2] | 0);
  if (i9) break;
  _lex_scan(HEAP32[i2 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) != 44) {
   i11 = 10;
   break;
  }
  _lex_scan(HEAP32[i2 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
 }
 do if ((i11 | 0) == 10) {
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) != 93) {
   _error_set(HEAP32[i4 >> 2] | 0, HEAP32[i2 >> 2] | 0, gb + 41293 | 0, i10);
   break;
  }
  HEAP32[i1 >> 2] = HEAP32[i5 >> 2];
  i11 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i12;
  return i11 | 0;
 } while (0);
 _json_decref(HEAP32[i5 >> 2] | 0);
 HEAP32[i1 >> 2] = 0;
 i11 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i12;
 return i11 | 0;
}

function _firpfb_crcf_create(i11, i10, i3) {
 i11 = i11 | 0;
 i10 = i10 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i12 + 8 | 0;
 i1 = i12;
 if (!i11) {
  i9 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 19656;
  _fprintf(i9, gb + 20159 | 0, i1) | 0;
  _exit(1);
 }
 if (!i3) {
  i9 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 19656;
  _fprintf(i9, gb + 20231 | 0, i2) | 0;
  _exit(1);
 }
 i8 = _malloc(28) | 0;
 i7 = i8 + 12 | 0;
 HEAP32[i7 >> 2] = i11;
 HEAP32[i8 + 4 >> 2] = i3;
 i9 = _malloc(i11 << 2) | 0;
 HEAP32[i8 + 20 >> 2] = i9;
 i5 = (i3 >>> 0) / (i11 >>> 0) | 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 2) | 0) + 15 & -16) | 0;
 i3 = i5 + -1 | 0;
 if (!i5) {
  i1 = 0;
  do {
   HEAP32[i9 + (i1 << 2) >> 2] = _dotprod_crcf_create(i6, 0) | 0;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i11 >>> 0);
  i11 = i8 + 8 | 0;
  HEAP32[i11 >> 2] = i5;
  i11 = _windowcf_create(i5) | 0;
  i10 = i8 + 16 | 0;
  HEAP32[i10 >> 2] = i11;
  i10 = i8 + 24 | 0;
  HEAPF32[i10 >> 2] = 1.0;
  _windowcf_clear(i11);
  STACKTOP = i12;
  return i8 | 0;
 } else {
  i4 = i11;
  i1 = 0;
 }
 while (1) {
  i2 = 0;
  do {
   HEAP32[i6 + (i3 - i2 << 2) >> 2] = HEAP32[i10 + ((Math_imul(i4, i2) | 0) + i1 << 2) >> 2];
   i2 = i2 + 1 | 0;
  } while (i5 >>> 0 > i2 >>> 0);
  HEAP32[i9 + (i1 << 2) >> 2] = _dotprod_crcf_create(i6, i5) | 0;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i11 >>> 0) break;
  i4 = HEAP32[i7 >> 2] | 0;
 }
 i11 = i8 + 8 | 0;
 HEAP32[i11 >> 2] = i5;
 i11 = _windowcf_create(i5) | 0;
 i10 = i8 + 16 | 0;
 HEAP32[i10 >> 2] = i11;
 i10 = i8 + 24 | 0;
 HEAPF32[i10 >> 2] = 1.0;
 _windowcf_clear(i11);
 STACKTOP = i12;
 return i8 | 0;
}

function _ofdmflexframegen_create(i1, i2, i3, i4, i8) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i8 = i8 | 0;
 var i5 = 0, i6 = 0, i7 = 0;
 if (i1 >>> 0 < 2) {
  _fwrite(gb + 27816 | 0, 75, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i1 & 1 | 0) {
  _fwrite(gb + 27892 | 0, 69, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i6 = _malloc(156) | 0;
 HEAP32[i6 >> 2] = i1;
 i7 = i6 + 4 | 0;
 HEAP32[i7 >> 2] = i2;
 i5 = i6 + 8 | 0;
 HEAP32[i5 >> 2] = i3;
 HEAP32[i6 + 36 >> 2] = _malloc(i1 << 3) | 0;
 i2 = _malloc(i1) | 0;
 i3 = i6 + 12 | 0;
 HEAP32[i3 >> 2] = i2;
 if (!i4) {
  _ofdmframe_init_default_sctype(i1, i2);
  i2 = HEAP32[i3 >> 2] | 0;
  i1 = HEAP32[i6 >> 2] | 0;
 } else _memcpy(i2 | 0, i4 | 0, i1 | 0) | 0;
 _ofdmframe_validate_sctype(i2, i1, i6 + 16 | 0, i6 + 20 | 0, i6 + 24 | 0);
 i4 = i6 + 40 | 0;
 HEAP32[i4 >> 2] = _ofdmframegen_create(HEAP32[i6 >> 2] | 0, HEAP32[i7 >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
 i7 = i6 + 52 | 0;
 HEAP32[i7 >> 2] = 0;
 HEAP32[i7 + 4 >> 2] = 0;
 HEAP32[i7 + 8 >> 2] = 0;
 HEAP32[i7 + 12 >> 2] = 0;
 HEAP32[i7 + 16 >> 2] = 0;
 _ofdmflexframegen_set_header_len(i6, 8);
 HEAP32[i6 + 92 >> 2] = 1;
 i7 = _packetizer_create(1, 1, 1, 1) | 0;
 HEAP32[i6 + 88 >> 2] = i7;
 i7 = _packetizer_get_enc_msg_len(i7) | 0;
 HEAP32[i6 + 108 >> 2] = i7;
 HEAP32[i6 + 100 >> 2] = _malloc(i7) | 0;
 HEAP32[i6 + 112 >> 2] = 1;
 HEAP32[i6 + 104 >> 2] = _malloc(4) | 0;
 HEAP32[i6 + 96 >> 2] = _modem_create(48) | 0;
 _ofdmflexframegen_setprops(i6, i8);
 i8 = i6 + 116 | 0;
 HEAP32[i8 >> 2] = 0;
 HEAP32[i8 + 4 >> 2] = 0;
 HEAP32[i8 + 8 >> 2] = 0;
 HEAP32[i8 + 12 >> 2] = 0;
 HEAP32[i8 + 16 >> 2] = 0;
 HEAP32[i8 + 20 >> 2] = 0;
 _ofdmframegen_reset(HEAP32[i4 >> 2] | 0);
 return i6 | 0;
}

function _firpfb_rrrf_create(i11, i10, i3) {
 i11 = i11 | 0;
 i10 = i10 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i12 + 8 | 0;
 i1 = i12;
 if (!i11) {
  i9 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 18911;
  _fprintf(i9, gb + 20159 | 0, i1) | 0;
  _exit(1);
 }
 if (!i3) {
  i9 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 18911;
  _fprintf(i9, gb + 20231 | 0, i2) | 0;
  _exit(1);
 }
 i8 = _malloc(28) | 0;
 i7 = i8 + 12 | 0;
 HEAP32[i7 >> 2] = i11;
 HEAP32[i8 + 4 >> 2] = i3;
 i9 = _malloc(i11 << 2) | 0;
 HEAP32[i8 + 20 >> 2] = i9;
 i5 = (i3 >>> 0) / (i11 >>> 0) | 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 2) | 0) + 15 & -16) | 0;
 i3 = i5 + -1 | 0;
 if (!i5) {
  i1 = 0;
  do {
   HEAP32[i9 + (i1 << 2) >> 2] = _dotprod_rrrf_create(i6, 0) | 0;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < i11 >>> 0);
  i11 = i8 + 8 | 0;
  HEAP32[i11 >> 2] = i5;
  i11 = _windowf_create(i5) | 0;
  i10 = i8 + 16 | 0;
  HEAP32[i10 >> 2] = i11;
  i10 = i8 + 24 | 0;
  HEAPF32[i10 >> 2] = 1.0;
  _windowf_clear(i11);
  STACKTOP = i12;
  return i8 | 0;
 } else {
  i4 = i11;
  i1 = 0;
 }
 while (1) {
  i2 = 0;
  do {
   HEAP32[i6 + (i3 - i2 << 2) >> 2] = HEAP32[i10 + ((Math_imul(i4, i2) | 0) + i1 << 2) >> 2];
   i2 = i2 + 1 | 0;
  } while (i5 >>> 0 > i2 >>> 0);
  HEAP32[i9 + (i1 << 2) >> 2] = _dotprod_rrrf_create(i6, i5) | 0;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i11 >>> 0) break;
  i4 = HEAP32[i7 >> 2] | 0;
 }
 i11 = i8 + 8 | 0;
 HEAP32[i11 >> 2] = i5;
 i11 = _windowf_create(i5) | 0;
 i10 = i8 + 16 | 0;
 HEAP32[i10 >> 2] = i11;
 i10 = i8 + 24 | 0;
 HEAPF32[i10 >> 2] = 1.0;
 _windowf_clear(i11);
 STACKTOP = i12;
 return i8 | 0;
}

function _liquid_firdes_arkaiser(i9, i10, d5, d6, i11) {
 i9 = i9 | 0;
 i10 = i10 | 0;
 d5 = +d5;
 d6 = +d6;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, F43 = SIMD_Float32x4(0, 0, 0, 0), d4 = 0.0, d7 = 0.0, i8 = 0;
 if (i9 >>> 0 < 2) {
  _fwrite(gb + 24422 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i10) {
  _fwrite(gb + 24477 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d5 <= 0.0 | d5 >= 1.0) {
  _fwrite(gb + 24532 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d6 < -1.0 | d6 > 1.0) {
  _fwrite(gb + 24588 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 d7 = +(i10 >>> 0);
 d4 = +Math_log(+d5);
 d4 = +Math_log(+d7) * .067663 + .762886 + d4 * .06551499664783478 + d4 * (+Math_log(+(1.0 - +Math_pow(+d7, -1.600000023841858) * .088)) * d4);
 if (d4 <= 0.0 | d4 >= 1.0) d4 = +_rkaiser_approximate_rho(i10, d5);
 i8 = Math_imul(i9 << 1, i10) | 0 | 1;
 d7 = +(i9 >>> 0);
 _liquid_firdes_kaiser(i8, ((1.0 - d4) * d5 + 1.0) * .5 / d7, +_estimate_req_filter_As(d4 * d5 / d7, i8), d6, i11);
 i8 = (Math_imul(i10, i9) | 0) << 1 | 1;
 d4 = 0.0;
 i2 = 0;
 do {
  d6 = +HEAPF32[i11 + (i2 << 2) >> 2];
  d4 = d4 + d6 * d6;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i8 | 0));
 d4 = +Math_sqrt(+(d7 / d4));
 i2 = (Math_imul(i10, i9) | 0) << 1;
 if (i2 >>> 0 >= 4 ? (i1 = i2 & -4, (i1 | 0) != 0) : 0) {
  F43 = SIMD_Float32x4_splat(Math_fround(d4));
  i2 = 0;
  do {
   i10 = i11 + (i2 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i10, SIMD_Float32x4_mul(F43, SIMD_Float32x4_load(HEAPU8, i10)));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  i10 = i11 + (i1 << 2) | 0;
  HEAPF32[i10 >> 2] = d4 * +HEAPF32[i10 >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i8 | 0));
 return;
}

function _ofdmflexframegen_assemble(i5, i2, i3, i4) {
 i5 = i5 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i6 = 0, i7 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 92 | 0;
 if ((HEAP32[i1 >> 2] | 0) != (i4 | 0)) {
  HEAP32[i1 >> 2] = i4;
  _ofdmflexframegen_reconfigure(i5);
 }
 HEAP32[i5 + 124 >> 2] = 1;
 i7 = i5 + 60 | 0;
 i4 = i5 + 72 | 0;
 _memmove(HEAP32[i7 >> 2] | 0, i2 | 0, HEAP32[i4 >> 2] | 0) | 0;
 i4 = HEAP32[i4 >> 2] | 0;
 HEAP8[(HEAP32[i7 >> 2] | 0) + i4 >> 0] = 104;
 HEAP8[(HEAP32[i7 >> 2] | 0) + (i4 + 1) >> 0] = (HEAP32[i1 >> 2] | 0) >>> 8;
 HEAP8[(HEAP32[i7 >> 2] | 0) + (i4 + 2) >> 0] = HEAP32[i1 >> 2];
 i2 = i5 + 152 | 0;
 HEAP8[(HEAP32[i7 >> 2] | 0) + (i4 + 3) >> 0] = HEAP32[i2 >> 2];
 i1 = i4 + 4 | 0;
 HEAP8[(HEAP32[i7 >> 2] | 0) + i1 >> 0] = HEAP32[i5 + 140 >> 2] << 5;
 i1 = (HEAP32[i7 >> 2] | 0) + i1 | 0;
 HEAP8[i1 >> 0] = HEAPU8[i1 >> 0] | 0 | HEAP32[i5 + 144 >> 2] & 31;
 HEAP8[(HEAP32[i7 >> 2] | 0) + (i4 + 5) >> 0] = HEAP32[i5 + 148 >> 2] & 31;
 i4 = i5 + 64 | 0;
 _packetizer_encode(HEAP32[i5 + 56 >> 2] | 0, HEAP32[i7 >> 2] | 0, HEAP32[i4 >> 2] | 0);
 i1 = i5 + 80 | 0;
 _scramble_data(HEAP32[i4 >> 2] | 0, HEAP32[i1 >> 2] | 0);
 _liquid_repack_bytes(HEAP32[i4 >> 2] | 0, 8, HEAP32[i1 >> 2] | 0, HEAP32[i5 + 68 >> 2] | 0, HEAP32[gb + 580 + 764 >> 2] | 0, HEAP32[i5 + 84 >> 2] | 0, i6);
 i1 = i5 + 100 | 0;
 _packetizer_encode(HEAP32[i5 + 88 >> 2] | 0, i3, HEAP32[i1 >> 2] | 0);
 i4 = i5 + 104 | 0;
 i3 = i5 + 112 | 0;
 _memset(HEAP32[i4 >> 2] | 0, 0, HEAP32[i3 >> 2] << 2 | 0) | 0;
 _liquid_unpack_array_block(HEAP32[i1 >> 2] | 0, HEAP32[i5 + 108 >> 2] | 0, HEAP32[gb + 580 + (HEAP32[i2 >> 2] << 4) + 12 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0);
 STACKTOP = i6;
 return;
}

function _firdespm_compute_interp(i12) {
 i12 = i12 | 0;
 var d1 = 0.0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, d13 = 0.0;
 i8 = i12 + 12 | 0;
 i4 = (HEAP32[i8 >> 2] | 0) + 1 | 0;
 if (!i4) {
  i4 = 0;
  i2 = HEAP32[i12 + 64 >> 2] | 0;
 } else {
  i5 = HEAP32[i12 + 88 >> 2] | 0;
  i6 = HEAP32[i12 + 48 >> 2] | 0;
  i2 = HEAP32[i12 + 64 >> 2] | 0;
  i7 = 0;
  do {
   HEAPF64[i2 + (i7 << 3) >> 3] = +Math_cos(+(+HEAPF64[i6 + (HEAP32[i5 + (i7 << 2) >> 2] << 3) >> 3] * 6.283185307179586));
   i7 = i7 + 1 | 0;
  } while (i7 >>> 0 < i4 >>> 0);
 }
 i5 = i12 + 68 | 0;
 _poly_fit_lagrange_barycentric(i2, i4, HEAP32[i5 >> 2] | 0);
 i11 = HEAP32[i8 >> 2] | 0;
 i10 = (i11 | 0) == -1;
 if (i10) {
  HEAPF64[i12 + 80 >> 3] = nan;
  return;
 }
 i2 = HEAP32[i5 >> 2] | 0;
 i4 = HEAP32[i12 + 88 >> 2] | 0;
 i5 = HEAP32[i12 + 52 >> 2] | 0;
 i6 = HEAP32[i12 + 56 >> 2] | 0;
 i7 = i11 + 1 | 0;
 i8 = 0;
 d3 = 0.0;
 d1 = 0.0;
 do {
  d13 = +HEAPF64[i2 + (i8 << 3) >> 3];
  i9 = HEAP32[i4 + (i8 << 2) >> 2] | 0;
  d3 = d3 + d13 * +HEAPF64[i5 + (i9 << 3) >> 3];
  d1 = d1 + (i8 & 1 | 0 ? -1.0 : 1.0) * (d13 / +HEAPF64[i6 + (i9 << 3) >> 3]);
  i8 = i8 + 1 | 0;
 } while (i8 >>> 0 < i7 >>> 0);
 d1 = d3 / d1;
 i9 = i12 + 80 | 0;
 HEAPF64[i9 >> 3] = d1;
 if (i10) return;
 i6 = HEAP32[i12 + 88 >> 2] | 0;
 i7 = HEAP32[i12 + 52 >> 2] | 0;
 i8 = HEAP32[i12 + 56 >> 2] | 0;
 i5 = HEAP32[i12 + 72 >> 2] | 0;
 i4 = i11 + 1 | 0;
 i2 = 0;
 while (1) {
  i12 = HEAP32[i6 + (i2 << 2) >> 2] | 0;
  HEAPF64[i5 + (i2 << 3) >> 3] = +HEAPF64[i7 + (i12 << 3) >> 3] - +((i2 << 1 & 2 ^ 2) + -1 | 0) * d1 / +HEAPF64[i8 + (i12 << 3) >> 3];
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= i4 >>> 0) break;
  d1 = +HEAPF64[i9 >> 3];
 }
 return;
}

function _erfc2_142(i3, d1) {
 i3 = i3 | 0;
 d1 = +d1;
 var d2 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0;
 d4 = +Math_abs(+d1);
 if (i3 >>> 0 < 1067450368) {
  d1 = d4 + -1.0;
  d1 = .15493708848953247 - (d1 * (d1 * (d1 * (d1 * (d1 * (.03547830507159233 - d1 * .002166375517845154) + -.11089469492435455) + .31834661960601807) + -.3722078800201416) + .41485610604286194) + -2.3621185682713985e-03) / (d1 * (d1 * (d1 * (d1 * (d1 * (d1 * .011984500102698803 + .01363708358258009) + .12617121636867523) + .07182865589857101) + .5403979420661926) + .10642088204622269) + 1.0);
 } else {
  d5 = 1.0 / (d4 * d4);
  if (i3 >>> 0 < 1077336941) {
   d1 = d5 * (d5 * (d5 * (d5 * (d5 * (d5 * (6.570249557495117 - d5 * .06042441353201866) + 108.63500213623047) + 429.0081481933594) + 645.3872680664062) + 434.5658874511719) + 137.6577606201172) + 19.65127182006836;
   d2 = d5 * (d5 * (d5 * (d5 * (d5 * (d5 * (-81.28743743896484 - d5 * 9.814329147338867) + -184.60508728027344) + -162.39666748046875) + -62.37533187866211) + -10.558626174926758) + -.6938585638999939) + -.009864944033324718;
  } else {
   d1 = d5 * (d5 * (d5 * (d5 * (d5 * (474.5285339355469 - d5 * 22.44095230102539) + 2553.05029296875) + 3199.858154296875) + 1536.7296142578125) + 325.7925109863281) + 30.33806037902832;
   d2 = d5 * (d5 * (d5 * (d5 * (d5 * (-1025.0950927734375 - d5 * 483.5191955566406) + -637.5664672851562) + -160.63638305664062) + -17.75795555114746) + -.7992832660675049) + -.009864943102002144;
  }
  d6 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0) & -8192, +HEAPF32[tempDoublePtr >> 2]);
  d1 = +Math_exp(+(-.5625 - d6 * d6)) * +Math_exp(+((d6 - d4) * (d4 + d6) + d2 / (d5 * d1 + 1.0))) / d4;
 }
 return +d1;
}

function _butter_azpkf(i19, i1, i16, i18) {
 i19 = i19 | 0;
 i1 = i1 | 0;
 i16 = i16 | 0;
 i18 = i18 | 0;
 var i2 = 0, i3 = 0, d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i17 = 0, i20 = 0, i21 = 0, d22 = 0.0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i1 = i17 + 32 | 0;
 i2 = i17 + 24 | 0;
 i3 = i17 + 16 | 0;
 i10 = i17 + 8 | 0;
 i11 = i17;
 i15 = i19 & 1;
 if ((i19 - i15 | 0) >>> 0 < 2) i1 = 0; else {
  i12 = i19 + -1 | 0;
  d4 = +(i19 << 1 >>> 0);
  i5 = i3 + 4 | 0;
  i6 = i2 + 4 | 0;
  i7 = i11 + 4 | 0;
  i8 = i10 + 4 | 0;
  i9 = i19 >>> 1;
  i13 = 0;
  i14 = 0;
  while (1) {
   i13 = i13 + 1 | 0;
   d22 = +((i12 + (i13 << 1) | 0) >>> 0) * 3.141592653589793 / d4;
   HEAPF32[i3 >> 2] = d22 * 0.0;
   HEAPF32[i5 >> 2] = d22;
   HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   _cexpf(i2, i1);
   i21 = HEAP32[i6 >> 2] | 0;
   i20 = i14 | 1;
   HEAP32[i16 + (i14 << 3) >> 2] = HEAP32[i2 >> 2];
   HEAP32[i16 + (i14 << 3) + 4 >> 2] = i21;
   HEAPF32[i11 >> 2] = d22 * -0.0;
   HEAPF32[i7 >> 2] = -d22;
   HEAP32[i1 >> 2] = HEAP32[i11 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
   _cexpf(i10, i1);
   i21 = HEAP32[i8 >> 2] | 0;
   HEAP32[i16 + (i20 << 3) >> 2] = HEAP32[i10 >> 2];
   HEAP32[i16 + (i20 << 3) + 4 >> 2] = i21;
   if ((i13 | 0) == (i9 | 0)) break; else i14 = i14 + 2 | 0;
  }
  i1 = i9 << 1;
 }
 if (i15) {
  HEAPF32[i16 + (i1 << 3) >> 2] = -1.0;
  HEAPF32[i16 + (i1 << 3) + 4 >> 2] = 0.0;
  i1 = i1 | 1;
 }
 if ((i1 | 0) == (i19 | 0)) {
  HEAPF32[i18 >> 2] = 1.0;
  HEAPF32[i18 + 4 >> 2] = 0.0;
  STACKTOP = i17;
  return;
 } else ___assert_fail(gb + 40171 | 0, gb + 40097 | 0, 62, gb + 40121 | 0);
}

function _utf8_encode(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i8 + 12 | 0;
 i5 = i8 + 8 | 0;
 i6 = i8 + 4 | 0;
 i7 = i8;
 HEAP32[i5 >> 2] = i2;
 HEAP32[i6 >> 2] = i1;
 HEAP32[i7 >> 2] = i3;
 if ((HEAP32[i5 >> 2] | 0) < 0) {
  HEAP32[i4 >> 2] = -1;
  i7 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i8;
  return i7 | 0;
 }
 i1 = HEAP32[i5 >> 2] | 0;
 do if ((HEAP32[i5 >> 2] | 0) < 128) {
  HEAP8[HEAP32[i6 >> 2] >> 0] = i1;
  HEAP32[HEAP32[i7 >> 2] >> 2] = 1;
 } else {
  i2 = HEAP32[i5 >> 2] | 0;
  if ((i1 | 0) < 2048) {
   HEAP8[HEAP32[i6 >> 2] >> 0] = 192 + ((i2 & 1984) >> 6);
   HEAP8[(HEAP32[i6 >> 2] | 0) + 1 >> 0] = 128 + (HEAP32[i5 >> 2] & 63);
   HEAP32[HEAP32[i7 >> 2] >> 2] = 2;
   break;
  }
  i1 = HEAP32[i5 >> 2] | 0;
  if ((i2 | 0) < 65536) {
   HEAP8[HEAP32[i6 >> 2] >> 0] = 224 + ((i1 & 61440) >> 12);
   HEAP8[(HEAP32[i6 >> 2] | 0) + 1 >> 0] = 128 + ((HEAP32[i5 >> 2] & 4032) >> 6);
   HEAP8[(HEAP32[i6 >> 2] | 0) + 2 >> 0] = 128 + (HEAP32[i5 >> 2] & 63);
   HEAP32[HEAP32[i7 >> 2] >> 2] = 3;
   break;
  }
  if ((i1 | 0) <= 1114111) {
   HEAP8[HEAP32[i6 >> 2] >> 0] = 240 + ((HEAP32[i5 >> 2] & 1835008) >> 18);
   HEAP8[(HEAP32[i6 >> 2] | 0) + 1 >> 0] = 128 + ((HEAP32[i5 >> 2] & 258048) >> 12);
   HEAP8[(HEAP32[i6 >> 2] | 0) + 2 >> 0] = 128 + ((HEAP32[i5 >> 2] & 4032) >> 6);
   HEAP8[(HEAP32[i6 >> 2] | 0) + 3 >> 0] = 128 + (HEAP32[i5 >> 2] & 63);
   HEAP32[HEAP32[i7 >> 2] >> 2] = 4;
   break;
  }
  HEAP32[i4 >> 2] = -1;
  i7 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i8;
  return i7 | 0;
 } while (0);
 HEAP32[i4 >> 2] = 0;
 i7 = HEAP32[i4 >> 2] | 0;
 STACKTOP = i8;
 return i7 | 0;
}

function _json_array_grow(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i4 = i11 + 24 | 0;
 i5 = i11 + 20 | 0;
 i6 = i11 + 16 | 0;
 i7 = i11 + 12 | 0;
 i8 = i11 + 8 | 0;
 i10 = i11 + 4 | 0;
 i9 = i11;
 HEAP32[i5 >> 2] = i2;
 HEAP32[i6 >> 2] = i1;
 HEAP32[i7 >> 2] = i3;
 i1 = HEAP32[(HEAP32[i5 >> 2] | 0) + 16 >> 2] | 0;
 if (((HEAP32[(HEAP32[i5 >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[i6 >> 2] | 0) | 0) >>> 0 <= (HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] | 0) >>> 0) {
  HEAP32[i4 >> 2] = i1;
  i10 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 HEAP32[i10 >> 2] = i1;
 i3 = HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] | 0;
 HEAP32[i8 >> 2] = ((HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[i6 >> 2] | 0) | 0) >>> 0 > HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] << 1 >>> 0 ? i3 + (HEAP32[i6 >> 2] | 0) | 0 : i3 << 1;
 HEAP32[i9 >> 2] = _jsonp_malloc(HEAP32[i8 >> 2] << 2) | 0;
 if (!(HEAP32[i9 >> 2] | 0)) {
  HEAP32[i4 >> 2] = 0;
  i10 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 HEAP32[(HEAP32[i5 >> 2] | 0) + 8 >> 2] = HEAP32[i8 >> 2];
 HEAP32[(HEAP32[i5 >> 2] | 0) + 16 >> 2] = HEAP32[i9 >> 2];
 if (HEAP32[i7 >> 2] | 0) {
  _array_copy(HEAP32[(HEAP32[i5 >> 2] | 0) + 16 >> 2] | 0, 0, HEAP32[i10 >> 2] | 0, 0, HEAP32[(HEAP32[i5 >> 2] | 0) + 12 >> 2] | 0);
  _jsonp_free(HEAP32[i10 >> 2] | 0);
  HEAP32[i4 >> 2] = HEAP32[(HEAP32[i5 >> 2] | 0) + 16 >> 2];
  i10 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 } else {
  HEAP32[i4 >> 2] = HEAP32[i10 >> 2];
  i10 = HEAP32[i4 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 return 0;
}

function _liquid_firdes_gmsktx(i7, i8, d4, d6, i11) {
 i7 = i7 | 0;
 i8 = i8 | 0;
 d4 = +d4;
 d6 = +d6;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, F43 = SIMD_Float32x4(0, 0, 0, 0), d5 = 0.0, i9 = 0, d10 = 0.0, d12 = 0.0, d13 = 0.0, i14 = 0;
 if (!i7) {
  _fwrite(gb + 22639 | 0, 56, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i8) {
  _fwrite(gb + 22696 | 0, 56, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d4 < 0.0 | d4 > 1.0) {
  _fwrite(gb + 22753 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 d10 = +(i7 >>> 0);
 d5 = +(i8 >>> 0);
 d4 = d4 * 6.283185307179586;
 i9 = (Math_imul(i8, i7) | 0) << 1 | 1;
 i2 = 0;
 do {
  d12 = +(i2 >>> 0) / d10 - d5 + d6;
  d13 = +_liquid_Qf(d4 * (d12 + -.5) * 1.2011224031448364);
  HEAPF32[i11 + (i2 << 2) >> 2] = d13 - +_liquid_Qf(d4 * (d12 + .5) * 1.2011224031448364);
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i9 | 0));
 d4 = 0.0;
 i2 = 0;
 do {
  d4 = d4 + +HEAPF32[i11 + (i2 << 2) >> 2];
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i9 | 0));
 d4 = 3.141592653589793 / (d4 * 2.0);
 i2 = 0;
 do {
  i14 = i11 + (i2 << 2) | 0;
  HEAPF32[i14 >> 2] = d4 * +HEAPF32[i14 >> 2];
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i9 | 0));
 i2 = (Math_imul(i8, i7) | 0) << 1;
 if (i2 >>> 0 >= 4 ? (i1 = i2 & -4, (i1 | 0) != 0) : 0) {
  F43 = SIMD_Float32x4_splat(Math_fround(d10));
  i2 = 0;
  do {
   i14 = i11 + (i2 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i14, SIMD_Float32x4_mul(F43, SIMD_Float32x4_load(HEAPU8, i14)));
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  i14 = i11 + (i1 << 2) | 0;
  HEAPF32[i14 >> 2] = d10 * +HEAPF32[i14 >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i9 | 0));
 return;
}

function _liquid_repack_bytes(i12, i13, i1, i17, i15, i2, i16) {
 i12 = i12 | 0;
 i13 = i13 | 0;
 i1 = i1 | 0;
 i17 = i17 | 0;
 i15 = i15 | 0;
 i2 = i2 | 0;
 i16 = i16 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i14 = 0, i18 = 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i3 = i18;
 i14 = i18 + 16 | 0;
 i11 = Math_imul(i1, i13) | 0;
 _div(i14, i11, i15);
 i14 = ((HEAP32[i14 + 4 >> 2] | 0) > 0 & 1) + (HEAP32[i14 >> 2] | 0) | 0;
 if (i14 >>> 0 > i2 >>> 0) {
  i10 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 39469 | 0, 40, 1, i10) | 0;
  HEAP32[i3 >> 2] = i1;
  HEAP32[i3 + 4 >> 2] = i13;
  HEAP32[i3 + 8 >> 2] = i2;
  HEAP32[i3 + 12 >> 2] = i15;
  _fprintf(i10, gb + 39510 | 0, i3) | 0;
  _exit(-1);
 }
 if (!i11) {
  i3 = 0;
  i2 = 0;
  i1 = 0;
 } else {
  i7 = i13 + -1 | 0;
  i6 = i15 + -1 | 0;
  i8 = 0;
  i5 = 0;
  i3 = 0;
  i10 = 0;
  i2 = 0;
  i4 = 0;
  i1 = 0;
  while (1) {
   if (!i10) {
    i9 = i5 + 1 | 0;
    i4 = HEAP8[i12 + i5 >> 0] | 0;
   } else i9 = i5;
   i1 = ((i4 & 255) >>> (i7 - i10 | 0) & 1 | (i1 & 255) << 1) & 255;
   if ((i2 | 0) == (i6 | 0)) {
    HEAP8[i17 + i3 >> 0] = i1;
    i3 = i3 + 1 | 0;
    i1 = 0;
   }
   i2 = ((i2 + 1 | 0) >>> 0) % (i15 >>> 0) | 0;
   i8 = i8 + 1 | 0;
   if ((i8 | 0) == (i11 | 0)) break; else {
    i5 = i9;
    i10 = ((i10 + 1 | 0) >>> 0) % (i13 >>> 0) | 0;
   }
  }
 }
 if ((i3 | 0) == (i14 | 0)) {
  i17 = i14;
  HEAP32[i16 >> 2] = i17;
  STACKTOP = i18;
  return;
 }
 if (i2 >>> 0 < i15 >>> 0) do {
  i1 = (i1 & 255) << 1 & 255;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i15 | 0));
 HEAP8[i17 + i3 >> 0] = i1;
 i17 = i3 + 1 | 0;
 HEAP32[i16 >> 2] = i17;
 STACKTOP = i18;
 return;
}

function _liquid_fft_estimate_method(i1) {
 i1 = i1 | 0;
 if (!i1) {
  _fwrite(gb + 39984 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  i1 = 0;
  return i1 | 0;
 }
 if ((i1 | 1 | 0) == 17 | ((i1 | 0) == 13 | (i1 >>> 0 < 9 | (i1 | 0) == 11))) {
  i1 = 5;
  return i1 | 0;
 }
 if (((i1 >>> 31) + ((i1 >>> 30 & 1) + ((i1 >>> 29 & 1) + ((i1 >>> 28 & 1) + ((i1 >>> 27 & 1) + ((i1 >>> 26 & 1) + ((i1 >>> 25 & 1) + ((i1 >>> 24 & 1) + ((i1 >>> 23 & 1) + ((i1 >>> 22 & 1) + ((i1 >>> 21 & 1) + ((i1 >>> 20 & 1) + ((i1 >>> 19 & 1) + ((i1 >>> 18 & 1) + ((i1 >>> 17 & 1) + ((i1 >>> 16 & 1) + ((i1 >>> 15 & 1) + ((i1 >>> 14 & 1) + ((i1 >>> 13 & 1) + ((i1 >>> 12 & 1) + ((i1 >>> 11 & 1) + ((i1 >>> 10 & 1) + ((i1 >>> 9 & 1) + ((i1 >>> 8 & 1) + ((i1 >>> 7 & 1) + ((i1 >>> 6 & 1) + ((i1 >>> 5 & 1) + ((i1 >>> 4 & 1) + ((i1 >>> 3 & 1) + ((i1 >>> 2 & 1) + ((i1 >>> 1 & 1) + (i1 & 1))))))))))))))))))))))))))))))) | 0) == 1) {
  i1 = 2;
  return i1 | 0;
 }
 if (!(_liquid_is_prime(i1) | 0)) {
  i1 = 2;
  return i1 | 0;
 }
 i1 = i1 + -1 | 0;
 i1 = ((i1 >>> 31) + ((i1 >>> 30 & 1) + ((i1 >>> 29 & 1) + ((i1 >>> 28 & 1) + ((i1 >>> 27 & 1) + ((i1 >>> 26 & 1) + ((i1 >>> 25 & 1) + ((i1 >>> 24 & 1) + ((i1 >>> 23 & 1) + ((i1 >>> 22 & 1) + ((i1 >>> 21 & 1) + ((i1 >>> 20 & 1) + ((i1 >>> 19 & 1) + ((i1 >>> 18 & 1) + ((i1 >>> 17 & 1) + ((i1 >>> 16 & 1) + ((i1 >>> 15 & 1) + ((i1 >>> 14 & 1) + ((i1 >>> 13 & 1) + ((i1 >>> 12 & 1) + ((i1 >>> 11 & 1) + ((i1 >>> 10 & 1) + ((i1 >>> 9 & 1) + ((i1 >>> 8 & 1) + ((i1 >>> 7 & 1) + ((i1 >>> 6 & 1) + ((i1 >>> 5 & 1) + ((i1 >>> 4 & 1) + ((i1 >>> 3 & 1) + ((i1 >>> 2 & 1) + ((i1 >>> 1 & 1) + (i1 & 1))))))))))))))))))))))))))))))) | 0) == 1 ? 3 : 4;
 return i1 | 0;
}

function _fec_get_rate(i2) {
 i2 = i2 | 0;
 var d1 = 0.0, i3 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i4;
 do switch (i2 | 0) {
 case 0:
  {
   d1 = 0.0;
   break;
  }
 case 1:
  {
   d1 = 1.0;
   break;
  }
 case 2:
  {
   d1 = .3333333432674408;
   break;
  }
 case 3:
  {
   d1 = .20000000298023224;
   break;
  }
 case 4:
  {
   d1 = .5714285969734192;
   break;
  }
 case 5:
  {
   d1 = .5;
   break;
  }
 case 6:
  {
   d1 = .6666666865348816;
   break;
  }
 case 7:
  {
   d1 = .5;
   break;
  }
 case 8:
  {
   d1 = .6666666865348816;
   break;
  }
 case 9:
  {
   d1 = .800000011920929;
   break;
  }
 case 10:
  {
   d1 = .8888888955116272;
   break;
  }
 case 11:
  {
   d1 = .5;
   break;
  }
 case 12:
  {
   d1 = .5;
   break;
  }
 case 13:
  {
   d1 = .3333333432674408;
   break;
  }
 case 14:
  {
   d1 = .1666666716337204;
   break;
  }
 case 15:
  {
   d1 = .6666666865348816;
   break;
  }
 case 16:
  {
   d1 = .75;
   break;
  }
 case 17:
  {
   d1 = .800000011920929;
   break;
  }
 case 18:
  {
   d1 = .8333333134651184;
   break;
  }
 case 19:
  {
   d1 = .8571428656578064;
   break;
  }
 case 20:
  {
   d1 = .875;
   break;
  }
 case 21:
  {
   d1 = .6666666865348816;
   break;
  }
 case 22:
  {
   d1 = .75;
   break;
  }
 case 23:
  {
   d1 = .800000011920929;
   break;
  }
 case 24:
  {
   d1 = .8333333134651184;
   break;
  }
 case 25:
  {
   d1 = .8571428656578064;
   break;
  }
 case 26:
  {
   d1 = .875;
   break;
  }
 case 27:
  {
   d1 = .8745098114013672;
   break;
  }
 default:
  {
   HEAP32[i3 >> 2] = i2;
   _printf(gb + 12106 | 0, i3) | 0;
   _exit(-1);
  }
 } while (0);
 STACKTOP = i4;
 return +d1;
}

function _fec_secded7264_decode_symbol(i12, i11) {
 i12 = i12 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i13 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i3 = i13;
 i10 = i13 + 8 | 0;
 i1 = i10;
 i2 = i1 + 9 | 0;
 do {
  HEAP8[i1 >> 0] = 0;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) < (i2 | 0));
 i2 = _fec_secded7264_compute_syndrome(i12) | 0;
 L1 : do if (!(HEAP8[(i2 & 255) + (gb + 38499) >> 0] | 0)) {
  i3 = 0;
  i4 = 0;
  i5 = 0;
  i6 = 0;
  i7 = 0;
  i8 = 0;
  i9 = 0;
  i1 = 0;
  i2 = 0;
 } else {
  i1 = 0;
  while (1) {
   if (i2 << 24 >> 24 == (HEAP8[gb + 18684 + i1 >> 0] | 0)) break;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= 72) {
    i3 = 0;
    i4 = 0;
    i5 = 0;
    i6 = 0;
    i7 = 0;
    i8 = 0;
    i9 = 0;
    i1 = 0;
    i2 = 2;
    break L1;
   }
  }
  _div(i3, i1, 8);
  HEAP8[i10 + (8 - (HEAP32[i3 >> 2] | 0)) >> 0] = 1 << HEAP32[i3 + 4 >> 2];
  i3 = HEAP8[i10 + 1 >> 0] | 0;
  i4 = HEAP8[i10 + 2 >> 0] | 0;
  i5 = HEAP8[i10 + 3 >> 0] | 0;
  i6 = HEAP8[i10 + 4 >> 0] | 0;
  i7 = HEAP8[i10 + 5 >> 0] | 0;
  i8 = HEAP8[i10 + 6 >> 0] | 0;
  i9 = HEAP8[i10 + 7 >> 0] | 0;
  i1 = HEAP8[i10 + 8 >> 0] | 0;
  i2 = 1;
 } while (0);
 HEAP8[i11 >> 0] = i3 ^ HEAP8[i12 + 1 >> 0];
 HEAP8[i11 + 1 >> 0] = i4 ^ HEAP8[i12 + 2 >> 0];
 HEAP8[i11 + 2 >> 0] = i5 ^ HEAP8[i12 + 3 >> 0];
 HEAP8[i11 + 3 >> 0] = i6 ^ HEAP8[i12 + 4 >> 0];
 HEAP8[i11 + 4 >> 0] = i7 ^ HEAP8[i12 + 5 >> 0];
 HEAP8[i11 + 5 >> 0] = i8 ^ HEAP8[i12 + 6 >> 0];
 HEAP8[i11 + 6 >> 0] = i9 ^ HEAP8[i12 + 7 >> 0];
 HEAP8[i11 + 7 >> 0] = i1 ^ HEAP8[i12 + 8 >> 0];
 STACKTOP = i13;
 return i2 | 0;
}

function ___mulsc3(i14, d1, d2, d3, d4) {
 i14 = i14 | 0;
 d1 = +d1;
 d2 = +d2;
 d3 = +d3;
 d4 = +d4;
 var i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0;
 d8 = d1 * d3;
 d9 = d2 * d4;
 d10 = d1 * d4;
 d11 = d2 * d3;
 d12 = d8 - d9;
 d13 = d11 + d10;
 if (!((d12 != d12 | 0.0 != 0.0) & (d13 != d13 | 0.0 != 0.0))) {
  i7 = i14 + 4 | 0;
  HEAPF32[i14 >> 2] = d12;
  HEAPF32[i7 >> 2] = d13;
  return;
 }
 i5 = +Math_abs(+d1) == inf;
 i6 = +Math_abs(+d2) == inf;
 if (i5 | i6) {
  d1 = +_copysignf(+(i5 & 1), d1);
  d2 = +_copysignf(+(i6 & 1), d2);
  if (d3 != d3 | 0.0 != 0.0) d3 = +_copysignf(0.0, d3);
  if (d4 != d4 | 0.0 != 0.0) {
   d4 = +_copysignf(0.0, d4);
   i6 = 1;
  } else i6 = 1;
 } else i6 = 0;
 i5 = +Math_abs(+d3) == inf;
 i7 = +Math_abs(+d4) == inf;
 if (i7 | i5) {
  d3 = +_copysignf(+(i5 & 1), d3);
  d4 = +_copysignf(+(i7 & 1), d4);
  if (d1 != d1 | 0.0 != 0.0) d1 = +_copysignf(0.0, d1);
  if (d2 != d2 | 0.0 != 0.0) d2 = +_copysignf(0.0, d2);
 } else if (!i6) {
  i7 = +Math_abs(+d8) == inf;
  i7 = i7 | +Math_abs(+d9) == inf;
  i7 = +Math_abs(+d10) == inf | i7;
  if (!(+Math_abs(+d11) == inf | i7)) {
   i7 = i14 + 4 | 0;
   HEAPF32[i14 >> 2] = d12;
   HEAPF32[i7 >> 2] = d13;
   return;
  }
  if (d1 != d1 | 0.0 != 0.0) d1 = +_copysignf(0.0, d1);
  if (d2 != d2 | 0.0 != 0.0) d2 = +_copysignf(0.0, d2);
  if (d3 != d3 | 0.0 != 0.0) d3 = +_copysignf(0.0, d3);
  if (d4 != d4 | 0.0 != 0.0) d4 = +_copysignf(0.0, d4);
 }
 d12 = (d3 * d1 - d4 * d2) * inf;
 d13 = (d3 * d2 + d4 * d1) * inf;
 i7 = i14 + 4 | 0;
 HEAPF32[i14 >> 2] = d12;
 HEAPF32[i7 >> 2] = d13;
 return;
}

function _qdetector_cccf_create_linear(i12, i13, i2, i11, i3, d1) {
 i12 = i12 | 0;
 i13 = i13 | 0;
 i2 = i2 | 0;
 i11 = i11 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 var d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i14 = 0, i15 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i14 + 8 | 0;
 i7 = i14;
 if (!i13) {
  _fwrite(gb + 29215 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if ((i11 + -2 | 0) >>> 0 > 78) {
  _fwrite(gb + 29286 | 0, 76, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if ((i3 + -1 | 0) >>> 0 > 99) {
  _fwrite(gb + 29363 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  _fwrite(gb + 29435 | 0, 80, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i8 = (i3 << 1) + i13 | 0;
 i9 = Math_imul(i8, i11) | 0;
 i10 = _malloc(i9 << 3) | 0;
 i2 = _firinterp_crcf_create_prototype(i2, i11, i3, d1, 0.0) | 0;
 if (!i8) {
  _firinterp_crcf_destroy(i2);
  i13 = _qdetector_cccf_create(i10, i9) | 0;
  _free(i10);
  STACKTOP = i14;
  return i13 | 0;
 }
 i3 = i7 + 4 | 0;
 i5 = 0;
 do {
  if (i5 >>> 0 < i13 >>> 0) {
   d1 = +HEAPF32[i12 + (i5 << 3) >> 2];
   d4 = +HEAPF32[i12 + (i5 << 3) + 4 >> 2];
  } else {
   d1 = 0.0;
   d4 = 0.0;
  }
  i15 = i10 + ((Math_imul(i5, i11) | 0) << 3) | 0;
  HEAPF32[i7 >> 2] = d1;
  HEAPF32[i3 >> 2] = d4;
  HEAP32[i6 >> 2] = HEAP32[i7 >> 2];
  HEAP32[i6 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
  _firinterp_crcf_execute(i2, i6, i15);
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i8 | 0));
 _firinterp_crcf_destroy(i2);
 i15 = _qdetector_cccf_create(i10, i9) | 0;
 _free(i10);
 STACKTOP = i14;
 return i15 | 0;
}

function _cexpf(i9, i1) {
 i9 = i9 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, i10 = 0, d11 = 0.0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i10 + 16 | 0;
 i6 = i10 + 8 | 0;
 i7 = i10;
 d8 = +HEAPF32[i1 >> 2];
 d2 = +HEAPF32[i1 + 4 >> 2];
 d11 = +Math_abs(+d2);
 i3 = (HEAPF32[tempDoublePtr >> 2] = d11, HEAP32[tempDoublePtr >> 2] | 0);
 do if (i3) {
  i4 = (HEAPF32[tempDoublePtr >> 2] = d8, HEAP32[tempDoublePtr >> 2] | 0);
  d11 = +Math_abs(+d8);
  i1 = (HEAPF32[tempDoublePtr >> 2] = d11, HEAP32[tempDoublePtr >> 2] | 0);
  if (!i1) {
   d11 = +Math_sin(+d2);
   HEAPF32[i9 >> 2] = +Math_cos(+d2);
   HEAPF32[i9 + 4 >> 2] = d11;
   break;
  }
  if (i3 >>> 0 <= 2139095039) if ((i4 + -1118925336 | 0) >>> 0 < 9342557) {
   HEAPF32[i7 >> 2] = d8;
   HEAPF32[i7 + 4 >> 2] = d2;
   HEAP32[i5 >> 2] = HEAP32[i7 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   ___ldexp_cexpf(i6, i5, 0);
   i7 = HEAP32[i6 + 4 >> 2] | 0;
   HEAP32[i9 >> 2] = HEAP32[i6 >> 2];
   HEAP32[i9 + 4 >> 2] = i7;
   break;
  } else {
   d8 = +Math_exp(+d8);
   d11 = d8 * +Math_sin(+d2);
   HEAPF32[i9 >> 2] = d8 * +Math_cos(+d2);
   HEAPF32[i9 + 4 >> 2] = d11;
   break;
  }
  if ((i1 | 0) != 2139095040) {
   d11 = d2 - d2;
   HEAPF32[i9 >> 2] = d11;
   HEAPF32[i9 + 4 >> 2] = d11;
   break;
  }
  if ((i4 | 0) < 0) {
   HEAPF32[i9 >> 2] = 0.0;
   HEAPF32[i9 + 4 >> 2] = 0.0;
   break;
  } else {
   HEAPF32[i9 >> 2] = d8;
   HEAPF32[i9 + 4 >> 2] = d2 - d2;
   break;
  }
 } else {
  HEAPF32[i9 >> 2] = +Math_exp(+d8);
  HEAPF32[i9 + 4 >> 2] = d2;
 } while (0);
 STACKTOP = i10;
 return;
}

function ___muldc3(i14, d1, d2, d3, d4) {
 i14 = i14 | 0;
 d1 = +d1;
 d2 = +d2;
 d3 = +d3;
 d4 = +d4;
 var i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0;
 d8 = d1 * d3;
 d9 = d2 * d4;
 d10 = d1 * d4;
 d11 = d2 * d3;
 d12 = d8 - d9;
 d13 = d11 + d10;
 if (!((d12 != d12 | 0.0 != 0.0) & (d13 != d13 | 0.0 != 0.0))) {
  i7 = i14 + 8 | 0;
  HEAPF64[i14 >> 3] = d12;
  HEAPF64[i7 >> 3] = d13;
  return;
 }
 i5 = +Math_abs(+d1) == inf;
 i6 = +Math_abs(+d2) == inf;
 if (i5 | i6) {
  d1 = +_copysign(+(i5 & 1), d1);
  d2 = +_copysign(+(i6 & 1), d2);
  if (d3 != d3 | 0.0 != 0.0) d3 = +_copysign(0.0, d3);
  if (d4 != d4 | 0.0 != 0.0) {
   d4 = +_copysign(0.0, d4);
   i6 = 1;
  } else i6 = 1;
 } else i6 = 0;
 i5 = +Math_abs(+d3) == inf;
 i7 = +Math_abs(+d4) == inf;
 if (i7 | i5) {
  d3 = +_copysign(+(i5 & 1), d3);
  d4 = +_copysign(+(i7 & 1), d4);
  if (d1 != d1 | 0.0 != 0.0) d1 = +_copysign(0.0, d1);
  if (d2 != d2 | 0.0 != 0.0) d2 = +_copysign(0.0, d2);
 } else if (!i6) {
  i7 = +Math_abs(+d8) == inf;
  i7 = i7 | +Math_abs(+d9) == inf;
  i7 = +Math_abs(+d10) == inf | i7;
  if (!(+Math_abs(+d11) == inf | i7)) {
   i7 = i14 + 8 | 0;
   HEAPF64[i14 >> 3] = d12;
   HEAPF64[i7 >> 3] = d13;
   return;
  }
  if (d1 != d1 | 0.0 != 0.0) d1 = +_copysign(0.0, d1);
  if (d2 != d2 | 0.0 != 0.0) d2 = +_copysign(0.0, d2);
  if (d3 != d3 | 0.0 != 0.0) d3 = +_copysign(0.0, d3);
  if (d4 != d4 | 0.0 != 0.0) d4 = +_copysign(0.0, d4);
 }
 d12 = (d3 * d1 - d4 * d2) * inf;
 d13 = (d3 * d2 + d4 * d1) * inf;
 i7 = i14 + 8 | 0;
 HEAPF64[i14 >> 3] = d12;
 HEAPF64[i7 >> 3] = d13;
 return;
}

function _gmskframegen_write_samples(i5, i2) {
 i5 = i5 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i6;
 i4 = i5 + 84 | 0;
 switch (HEAP32[i4 >> 2] | 0) {
 case 0:
  {
   _gmskframegen_write_preamble(i5, i2);
   break;
  }
 case 1:
  {
   i1 = i5 + 96 | 0;
   _div(i3, HEAP32[i1 >> 2] | 0, 8);
   _gmskmod_modulate(HEAP32[i5 >> 2] | 0, (HEAPU8[(HEAP32[i5 + 48 >> 2] | 0) + (HEAP32[i3 >> 2] | 0) >> 0] | 0) >>> (7 - (HEAP32[i3 + 4 >> 2] | 0) | 0) & 1, i2);
   i3 = (HEAP32[i1 >> 2] | 0) + 1 | 0;
   HEAP32[i1 >> 2] = i3;
   if ((i3 | 0) == (HEAP32[i5 + 20 >> 2] | 0)) {
    HEAP32[i1 >> 2] = 0;
    HEAP32[i4 >> 2] = 2;
   }
   break;
  }
 case 2:
  {
   i1 = i5 + 96 | 0;
   _div(i3, HEAP32[i1 >> 2] | 0, 8);
   _gmskmod_modulate(HEAP32[i5 >> 2] | 0, (HEAPU8[(HEAP32[i5 + 80 >> 2] | 0) + (HEAP32[i3 >> 2] | 0) >> 0] | 0) >>> (7 - (HEAP32[i3 + 4 >> 2] | 0) | 0) & 1, i2);
   i3 = (HEAP32[i1 >> 2] | 0) + 1 | 0;
   HEAP32[i1 >> 2] = i3;
   if ((i3 | 0) == (HEAP32[i5 + 24 >> 2] | 0)) {
    HEAP32[i1 >> 2] = 0;
    HEAP32[i4 >> 2] = 3;
   }
   break;
  }
 case 3:
  {
   _gmskframegen_write_tail(i5, i2);
   break;
  }
 default:
  {
   _fwrite(gb + 26714 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 i1 = i5 + 92 | 0;
 if (!(HEAP32[i1 >> 2] | 0)) {
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 _gmskmod_reset(HEAP32[i5 >> 2] | 0);
 HEAP32[i4 >> 2] = 0;
 _msequence_reset(HEAP32[i5 + 32 >> 2] | 0);
 HEAP32[i5 + 88 >> 2] = 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i5 + 96 >> 2] = 0;
 i5 = 1;
 STACKTOP = i6;
 return i5 | 0;
}

function ___divdc3(i13, d11, d12, d2, d1) {
 i13 = i13 | 0;
 d11 = +d11;
 d12 = +d12;
 d2 = +d2;
 d1 = +d1;
 var d3 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 d9 = +_logb(+_fmax(+Math_abs(+d2), +Math_abs(+d1)));
 d10 = +Math_abs(+d9);
 if (d9 == d9 & 0.0 == 0.0 & d10 != inf) {
  i4 = ~~d9;
  i7 = 0 - i4 | 0;
  d2 = +_scalbn(d2, i7);
  d8 = +_scalbn(d1, i7);
 } else {
  d8 = d1;
  i4 = 0;
 }
 d5 = d2 * d2 + d8 * d8;
 i7 = 0 - i4 | 0;
 d3 = +_scalbn((d2 * d11 + d8 * d12) / d5, i7);
 d1 = +_scalbn((d2 * d12 - d8 * d11) / d5, i7);
 do if ((d3 != d3 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  if (d5 == 0.0 ? !((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) : 0) {
   d1 = +_copysign(inf, d2);
   d3 = d1 * d11;
   d1 = d1 * d12;
   break;
  }
  d5 = +Math_abs(+d11);
  i4 = d5 == inf;
  d6 = +Math_abs(+d12);
  i7 = d6 == inf;
  if ((i4 | i7 ? d2 == d2 & 0.0 == 0.0 & +Math_abs(+d2) != inf : 0) ? d8 == d8 & 0.0 == 0.0 & +Math_abs(+d8) != inf : 0) {
   d1 = +_copysign(i4 ? 1.0 : 0.0, d11);
   d12 = +_copysign(i7 ? 1.0 : 0.0, d12);
   d3 = (d2 * d1 + d8 * d12) * inf;
   d1 = (d2 * d12 - d8 * d1) * inf;
   break;
  }
  if ((d9 > 0.0 & d10 == inf ? d11 == d11 & 0.0 == 0.0 & d5 != inf : 0) ? d12 == d12 & 0.0 == 0.0 & d6 != inf : 0) {
   i7 = +Math_abs(+d2) == inf;
   d10 = +_copysign(i7 ? 1.0 : 0.0, d2);
   i7 = +Math_abs(+d8) == inf;
   d1 = +_copysign(i7 ? 1.0 : 0.0, d8);
   d3 = (d10 * d11 + d1 * d12) * 0.0;
   d1 = (d10 * d12 - d1 * d11) * 0.0;
  }
 } while (0);
 HEAPF64[i13 >> 3] = d3;
 HEAPF64[i13 + 8 >> 3] = d1;
 return;
}

function _flexframesync_execute_rxpreamble(i7, i1) {
 i7 = i7 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i4 = i8 + 24 | 0;
 i3 = i8 + 16 | 0;
 i9 = i8 + 8 | 0;
 i5 = i8;
 i10 = HEAP32[i1 + 4 >> 2] | 0;
 i2 = i7 + 92 | 0;
 i6 = HEAP32[i2 >> 2] | 0;
 HEAP32[i9 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i9 + 4 >> 2] = i10;
 HEAP32[i4 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i4 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 _nco_crcf_mix_down(i6, i4, i3);
 _nco_crcf_step(HEAP32[i2 >> 2] | 0);
 i2 = i7 + 100 | 0;
 i6 = HEAP32[i2 >> 2] | 0;
 i1 = i3 + 4 | 0;
 i9 = HEAP32[i1 >> 2] | 0;
 HEAP32[i5 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i5 + 4 >> 2] = i9;
 HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i4 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 _firpfb_crcf_push(i6, i4);
 _firpfb_crcf_execute(HEAP32[i2 >> 2] | 0, HEAP32[i7 + 112 >> 2] | 0, i3);
 i2 = i7 + 108 | 0;
 i4 = HEAP32[i2 >> 2] | 0;
 HEAP32[i2 >> 2] = i4 + 1;
 if ((i4 | 0) > -1) {
  i5 = HEAP32[i3 >> 2] | 0;
  i6 = HEAP32[i1 >> 2] | 0;
  HEAP32[i2 >> 2] = i4 + -1;
 } else {
  i5 = 0;
  i6 = 0;
 }
 if ((i4 | 0) < 0) {
  STACKTOP = i8;
  return;
 }
 i2 = HEAP32[i7 + 64 >> 2] << 1;
 i3 = i7 + 192 | 0;
 i1 = HEAP32[i3 >> 2] | 0;
 if (i1 >>> 0 >= i2 >>> 0) {
  i1 = i1 - i2 | 0;
  i10 = HEAP32[i7 + 120 >> 2] | 0;
  HEAP32[i10 + (i1 << 3) >> 2] = i5;
  HEAP32[i10 + (i1 << 3) + 4 >> 2] = i6;
  i1 = HEAP32[i3 >> 2] | 0;
 }
 HEAP32[i3 >> 2] = i1 + 1;
 if ((i1 | 0) != (i2 + 63 | 0)) {
  STACKTOP = i8;
  return;
 }
 HEAP32[i7 + 200 >> 2] = 2;
 STACKTOP = i8;
 return;
}

function _fec_secded7264_encode(i1, i10, i7, i8) {
 i1 = i1 | 0;
 i10 = i10 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i9 = 0, i11 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i9;
 i6 = i10 & 7;
 i3 = i10 - i6 | 0;
 if ((i6 | 0) == (i10 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i11 = i7 + i2 | 0;
   i5 = i8 + i1 | 0;
   HEAP8[i5 >> 0] = _fec_secded7264_compute_parity(i11) | 0;
   HEAP8[i5 + 1 >> 0] = HEAP8[i11 >> 0] | 0;
   HEAP8[i5 + 2 >> 0] = HEAP8[i11 + 1 >> 0] | 0;
   HEAP8[i5 + 3 >> 0] = HEAP8[i11 + 2 >> 0] | 0;
   HEAP8[i5 + 4 >> 0] = HEAP8[i11 + 3 >> 0] | 0;
   HEAP8[i5 + 5 >> 0] = HEAP8[i11 + 4 >> 0] | 0;
   HEAP8[i5 + 6 >> 0] = HEAP8[i11 + 5 >> 0] | 0;
   HEAP8[i5 + 7 >> 0] = HEAP8[i11 + 6 >> 0] | 0;
   HEAP8[i5 + 8 >> 0] = HEAP8[i11 + 7 >> 0] | 0;
   i1 = i1 + 9 | 0;
   i2 = i2 + 8 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i6) {
  i3 = i4;
  HEAP32[i3 >> 2] = 0;
  HEAP32[i3 + 4 >> 2] = 0;
  _memcpy(i4 | 0, i7 + i2 | 0, i10 & 7 | 0) | 0;
  HEAP8[i8 + i1 >> 0] = _fec_secded7264_compute_parity(i4) | 0;
  i3 = i1 + 1 | 0;
  i4 = i10 & 7;
  i5 = 0;
  do {
   HEAP8[i8 + (i3 + i5) >> 0] = HEAP8[i7 + (i5 + i2) >> 0] | 0;
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i4 | 0));
  i2 = i2 | i6;
  i1 = i6 + 1 + i1 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(10, i10) | 0)) ___assert_fail(gb + 18756 | 0, gb + 18820 | 0, 286, gb + 18849 | 0);
 if ((i2 | 0) == (i10 | 0)) {
  STACKTOP = i9;
  return;
 } else ___assert_fail(gb + 18871 | 0, gb + 18820 | 0, 287, gb + 18849 | 0);
}

function _ofdmframesync_S0_metrics(i20, i18, i21) {
 i20 = i20 | 0;
 i18 = i18 | 0;
 i21 = i21 | 0;
 var d1 = 0.0, d2 = 0.0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0, i22 = 0, i23 = 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i11 = i22 + 32 | 0;
 i12 = i22 + 24 | 0;
 i13 = i22 + 16 | 0;
 i14 = i22 + 8 | 0;
 i19 = i22;
 i3 = HEAP32[i20 >> 2] | 0;
 if (!i3) {
  d2 = 0.0;
  d1 = 0.0;
 } else {
  i15 = i13 + 4 | 0;
  i16 = i12 + 4 | 0;
  i17 = i14 + 4 | 0;
  i10 = 0;
  d2 = 0.0;
  d1 = 0.0;
  do {
   i23 = i10;
   i10 = i10 + 2 | 0;
   i3 = (i10 >>> 0) % (i3 >>> 0) | 0;
   d6 = +HEAPF32[i18 + (i3 << 3) >> 2];
   d7 = +HEAPF32[i18 + (i3 << 3) + 4 >> 2];
   i3 = HEAP32[i18 + (i23 << 3) + 4 >> 2] | 0;
   HEAP32[i13 >> 2] = HEAP32[i18 + (i23 << 3) >> 2];
   HEAP32[i15 >> 2] = i3;
   HEAP32[i11 >> 2] = HEAP32[i13 >> 2];
   HEAP32[i11 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
   _conjf(i12, i11);
   d8 = +HEAPF32[i12 >> 2];
   d9 = +HEAPF32[i16 >> 2];
   d4 = d6 * d8 - d7 * d9;
   d5 = d7 * d8 + d6 * d9;
   if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
    ___mulsc3(i14, d6, d7, d8, d9);
    d4 = +HEAPF32[i14 >> 2];
    d5 = +HEAPF32[i17 >> 2];
   }
   d2 = d2 + d4;
   d1 = d1 + d5;
   i3 = HEAP32[i20 >> 2] | 0;
  } while (i10 >>> 0 < i3 >>> 0);
 }
 ___divsc3(i19, d2, d1, +((HEAP32[i20 + 28 >> 2] | 0) >>> 0), 0.0);
 i23 = HEAP32[i19 + 4 >> 2] | 0;
 HEAP32[i21 >> 2] = HEAP32[i19 >> 2];
 HEAP32[i21 + 4 >> 2] = i23;
 STACKTOP = i22;
 return;
}

function _flexframesync_execute_seekpn(i9, i1) {
 i9 = i9 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i10 + 8 | 0;
 i5 = i10;
 i8 = i9 + 72 | 0;
 i6 = HEAP32[i8 >> 2] | 0;
 i4 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i5 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i5 + 4 >> 2] = i4;
 HEAP32[i7 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i7 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 i7 = _qdetector_cccf_execute(i6, i7) | 0;
 if (!i7) {
  STACKTOP = i10;
  return;
 }
 i6 = i9 + 76 | 0;
 HEAPF32[i6 >> 2] = +_qdetector_cccf_get_tau(HEAP32[i8 >> 2] | 0);
 i3 = i9 + 88 | 0;
 HEAPF32[i3 >> 2] = +_qdetector_cccf_get_gamma(HEAP32[i8 >> 2] | 0);
 i4 = i9 + 80 | 0;
 HEAPF32[i4 >> 2] = +_qdetector_cccf_get_dphi(HEAP32[i8 >> 2] | 0);
 i5 = i9 + 84 | 0;
 HEAPF32[i5 >> 2] = +_qdetector_cccf_get_phi(HEAP32[i8 >> 2] | 0);
 d2 = +HEAPF32[i6 >> 2];
 i6 = HEAP32[i9 + 104 >> 2] | 0;
 if (d2 > 0.0) {
  d2 = d2 * +(i6 >>> 0);
  i1 = 0;
 } else {
  d2 = (d2 + 1.0) * +(i6 >>> 0);
  i1 = 1;
 }
 HEAP32[i9 + 112 >> 2] = (~~d2 >>> 0 >>> 0) % (i6 >>> 0) | 0;
 HEAP32[i9 + 108 >> 2] = i1;
 _firpfb_crcf_set_scale(HEAP32[i9 + 100 >> 2] | 0, .5 / +HEAPF32[i3 >> 2]);
 i6 = i9 + 92 | 0;
 _nco_crcf_set_frequency(HEAP32[i6 >> 2] | 0, +HEAPF32[i4 >> 2]);
 _nco_crcf_set_phase(HEAP32[i6 >> 2] | 0, +HEAPF32[i5 >> 2]);
 HEAP32[i9 + 200 >> 2] = 1;
 i6 = i9 + 212 | 0;
 HEAP32[i6 >> 2] = 1;
 _flexframesync_execute(i9, i7, _qdetector_cccf_get_buf_len(HEAP32[i8 >> 2] | 0) | 0);
 HEAP32[i6 >> 2] = 0;
 STACKTOP = i10;
 return;
}

function _vfprintf(i15, i11, i1) {
 i15 = i15 | 0;
 i11 = i11 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 i10 = i16 + 120 | 0;
 i14 = i16 + 80 | 0;
 i13 = i16;
 i12 = i16 + 136 | 0;
 i2 = i14;
 i3 = i2 + 40 | 0;
 do {
  HEAP32[i2 >> 2] = 0;
  i2 = i2 + 4 | 0;
 } while ((i2 | 0) < (i3 | 0));
 HEAP32[i10 >> 2] = HEAP32[i1 >> 2];
 if ((_printf_core(0, i11, i10, i13, i14) | 0) < 0) i1 = -1; else {
  if ((HEAP32[i15 + 76 >> 2] | 0) > -1) i8 = ___lockfile(i15) | 0; else i8 = 0;
  i1 = HEAP32[i15 >> 2] | 0;
  i9 = i1 & 32;
  if ((HEAP8[i15 + 74 >> 0] | 0) < 1) HEAP32[i15 >> 2] = i1 & -33;
  i1 = i15 + 48 | 0;
  if (!(HEAP32[i1 >> 2] | 0)) {
   i3 = i15 + 44 | 0;
   i4 = HEAP32[i3 >> 2] | 0;
   HEAP32[i3 >> 2] = i12;
   i5 = i15 + 28 | 0;
   HEAP32[i5 >> 2] = i12;
   i6 = i15 + 20 | 0;
   HEAP32[i6 >> 2] = i12;
   HEAP32[i1 >> 2] = 80;
   i7 = i15 + 16 | 0;
   HEAP32[i7 >> 2] = i12 + 80;
   i2 = _printf_core(i15, i11, i10, i13, i14) | 0;
   if (i4) {
    mftCall_iiii(HEAP32[i15 + 36 >> 2] | 0, i15 | 0, 0, 0) | 0;
    i2 = (HEAP32[i6 >> 2] | 0) == 0 ? -1 : i2;
    HEAP32[i3 >> 2] = i4;
    HEAP32[i1 >> 2] = 0;
    HEAP32[i7 >> 2] = 0;
    HEAP32[i5 >> 2] = 0;
    HEAP32[i6 >> 2] = 0;
   }
  } else i2 = _printf_core(i15, i11, i10, i13, i14) | 0;
  i1 = HEAP32[i15 >> 2] | 0;
  HEAP32[i15 >> 2] = i1 | i9;
  if (i8 | 0) ___unlockfile(i15);
  i1 = (i1 & 32 | 0) == 0 ? i2 : -1;
 }
 STACKTOP = i16;
 return i1 | 0;
}

function _parse_json(i7, i6, i5) {
 i7 = i7 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i10 = i11 + 8 | 0;
 i9 = i11;
 i1 = i11 + 28 | 0;
 i2 = i11 + 24 | 0;
 i3 = i11 + 20 | 0;
 i4 = i11 + 16 | 0;
 i8 = i11 + 12 | 0;
 HEAP32[i2 >> 2] = i7;
 HEAP32[i3 >> 2] = i6;
 HEAP32[i4 >> 2] = i5;
 _lex_scan(HEAP32[i2 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
 if (((HEAP32[i3 >> 2] & 4 | 0) == 0 ? (HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) != 91 : 0) ? (HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) != 123 : 0) {
  _error_set(HEAP32[i4 >> 2] | 0, HEAP32[i2 >> 2] | 0, gb + 41121 | 0, i9);
  HEAP32[i1 >> 2] = 0;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 HEAP32[i8 >> 2] = _parse_value(HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
 if (!(HEAP32[i8 >> 2] | 0)) {
  HEAP32[i1 >> 2] = 0;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 if ((HEAP32[i3 >> 2] & 2 | 0) == 0 ? (_lex_scan(HEAP32[i2 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0, HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] | 0) : 0) {
  _error_set(HEAP32[i4 >> 2] | 0, HEAP32[i2 >> 2] | 0, gb + 41337 | 0, i10);
  _json_decref(HEAP32[i8 >> 2] | 0);
  HEAP32[i1 >> 2] = 0;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 if (HEAP32[i4 >> 2] | 0) HEAP32[(HEAP32[i4 >> 2] | 0) + 8 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 36 >> 2];
 HEAP32[i1 >> 2] = HEAP32[i8 >> 2];
 i10 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i11;
 return i10 | 0;
}

function _modem_demodulate_dpsk(i12, i1, i13) {
 i12 = i12 | 0;
 i1 = i1 | 0;
 i13 = i13 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, i11 = 0, i14 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i8 = i14 + 16 | 0;
 i6 = i14 + 8 | 0;
 i7 = i14;
 i11 = HEAP32[i1 >> 2] | 0;
 i9 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i6 >> 2] = i11;
 HEAP32[i6 + 4 >> 2] = i9;
 HEAP32[i8 >> 2] = HEAP32[i6 >> 2];
 HEAP32[i8 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
 d10 = +_cargf(i8);
 HEAP32[i7 >> 2] = i11;
 HEAP32[i7 + 4 >> 2] = i9;
 HEAP32[i8 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i8 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 d2 = +_cargf(i8);
 i8 = i12 + 104 | 0;
 d2 = d2 - +HEAPF32[i8 >> 2];
 HEAPF32[i8 >> 2] = d10;
 d2 = d2 - +HEAPF32[i12 + 100 >> 2];
 d3 = d2;
 if (!(d3 > 3.141592653589793)) {
  if (d3 < -3.141592653589793) d2 = d3 + 6.283185307179586;
 } else d2 = d3 + -6.283185307179586;
 i7 = HEAP32[i12 + 4 >> 2] | 0;
 if (!i7) i1 = 0; else {
  i8 = i7 + -1 | 0;
  i5 = 0;
  i6 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i12 + 12 + (i5 + i8 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i12 + 12 + (i5 + i8 << 2) >> 2];
   i4 = i6 + 1 | 0;
   if ((i4 | 0) == (i7 | 0)) break; else {
    i5 = ~i6;
    i6 = i4;
   }
  }
 }
 HEAP32[i13 >> 2] = _gray_encode(i1) | 0;
 d3 = d10 - d2;
 d10 = +Math_sin(+d3);
 HEAPF32[i12 + 92 >> 2] = +Math_cos(+d3) + d10 * 0.0;
 HEAPF32[i12 + 96 >> 2] = d10;
 HEAP32[i12 + 84 >> 2] = i11;
 HEAP32[i12 + 88 >> 2] = i9;
 STACKTOP = i14;
 return;
}

function ___divsc3(i13, d11, d12, d2, d1) {
 i13 = i13 | 0;
 d11 = +d11;
 d12 = +d12;
 d2 = +d2;
 d1 = +d1;
 var d3 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 d9 = +_logbf(+_fmaxf(+Math_abs(+d2), +Math_abs(+d1)));
 d10 = +Math_abs(+d9);
 if (d9 == d9 & 0.0 == 0.0 & d10 != inf) {
  i4 = ~~d9;
  i7 = 0 - i4 | 0;
  d2 = +_scalbnf(d2, i7);
  d8 = +_scalbnf(d1, i7);
 } else {
  d8 = d1;
  i4 = 0;
 }
 d5 = d2 * d2 + d8 * d8;
 i7 = 0 - i4 | 0;
 d3 = +_scalbnf((d2 * d11 + d8 * d12) / d5, i7);
 d1 = +_scalbnf((d2 * d12 - d8 * d11) / d5, i7);
 do if ((d3 != d3 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  if (d5 == 0.0 ? !((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) : 0) {
   d1 = +_copysignf(inf, d2);
   d3 = d1 * d11;
   d1 = d1 * d12;
   break;
  }
  d5 = +Math_abs(+d11);
  i4 = d5 == inf;
  d6 = +Math_abs(+d12);
  i7 = d6 == inf;
  if ((i4 | i7 ? d2 == d2 & 0.0 == 0.0 & +Math_abs(+d2) != inf : 0) ? d8 == d8 & 0.0 == 0.0 & +Math_abs(+d8) != inf : 0) {
   d1 = +_copysignf(+(i4 & 1), d11);
   d12 = +_copysignf(+(i7 & 1), d12);
   d3 = (d2 * d1 + d8 * d12) * inf;
   d1 = (d2 * d12 - d8 * d1) * inf;
   break;
  }
  if ((d9 > 0.0 & d10 == inf ? d11 == d11 & 0.0 == 0.0 & d5 != inf : 0) ? d12 == d12 & 0.0 == 0.0 & d6 != inf : 0) {
   d10 = +_copysignf(+(+Math_abs(+d2) == inf & 1), d2);
   d1 = +_copysignf(+(+Math_abs(+d8) == inf & 1), d8);
   d3 = (d10 * d11 + d1 * d12) * 0.0;
   d1 = (d10 * d12 - d1 * d11) * 0.0;
  }
 } while (0);
 HEAPF32[i13 >> 2] = d3;
 HEAPF32[i13 + 4 >> 2] = d1;
 return;
}

function _liquid_primitive_root_prime(i9) {
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 i10 = i12;
 i8 = i9 + -1 | 0;
 i1 = i8;
 i3 = 0;
 while (1) {
  if (i1 >>> 0 < 2) {
   i6 = i3;
   break;
  } else i2 = 2;
  while (1) {
   if (!((i1 >>> 0) % (i2 >>> 0) | 0)) {
    i11 = 4;
    break;
   }
   i2 = i2 + 1 | 0;
   if (i2 >>> 0 > i1 >>> 0) {
    i2 = i3;
    break;
   }
  }
  if ((i11 | 0) == 4) {
   i11 = 0;
   i1 = (i1 >>> 0) / (i2 >>> 0) | 0;
   HEAP32[i10 + (i3 << 2) >> 2] = i2;
   if (!i3) i2 = 1; else i2 = ((HEAP32[i10 + (i3 + -1 << 2) >> 2] | 0) != (i2 | 0) & 1) + i3 | 0;
  }
  if (i1 >>> 0 > 1 & i2 >>> 0 < 40) i3 = i2; else {
   i6 = i2;
   break;
  }
 }
 if (i9 >>> 0 < 3 | (i6 | 0) == 0) {
  i11 = 2;
  STACKTOP = i12;
  return i11 | 0;
 } else i1 = 2;
 while (1) {
  i5 = 0;
  while (1) {
   i4 = (i8 >>> 0) / ((HEAP32[i10 + (i5 << 2) >> 2] | 0) >>> 0) | 0;
   if (!i4) break; else {
    i2 = 1;
    i3 = 0;
   }
   do {
    i2 = ((Math_imul(i2, i1) | 0) >>> 0) % (i9 >>> 0) | 0;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i4 | 0));
   i7 = (i2 | 0) == 1;
   i5 = i5 + 1 | 0;
   if (!(i5 >>> 0 < i6 >>> 0 & (i7 ^ 1))) {
    i11 = 12;
    break;
   }
  }
  if ((i11 | 0) == 12 ? (i11 = 0, !i7) : 0) {
   i11 = 15;
   break;
  }
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i9 >>> 0) {
   i11 = 15;
   break;
  }
 }
 if ((i11 | 0) == 15) {
  STACKTOP = i12;
  return i1 | 0;
 }
 return 0;
}

function _decode_unicode_escape(i5) {
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0, i8 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i8 + 12 | 0;
 i2 = i8 + 8 | 0;
 i4 = i8 + 4 | 0;
 i6 = i8;
 i3 = i8 + 16 | 0;
 HEAP32[i2 >> 2] = i5;
 HEAP32[i6 >> 2] = 0;
 if ((HEAP8[HEAP32[i2 >> 2] >> 0] | 0) != 117) ___assert_fail(gb + 40844 | 0, gb + 40619 | 0, 299, gb + 40858 | 0);
 HEAP32[i4 >> 2] = 1;
 L4 : while (1) {
  if ((HEAP32[i4 >> 2] | 0) > 4) {
   i7 = 16;
   break;
  }
  HEAP8[i3 >> 0] = HEAP8[(HEAP32[i2 >> 2] | 0) + (HEAP32[i4 >> 2] | 0) >> 0] | 0;
  HEAP32[i6 >> 2] = HEAP32[i6 >> 2] << 4;
  if (48 <= (HEAP8[i3 >> 0] | 0) ? (HEAP8[i3 >> 0] | 0) <= 57 : 0) HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + ((HEAP8[i3 >> 0] | 0) - 48); else i7 = 8;
  do if ((i7 | 0) == 8) {
   i7 = 0;
   if (97 <= (HEAP8[i3 >> 0] | 0) ? (HEAP8[i3 >> 0] | 0) <= 122 : 0) {
    HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + ((HEAP8[i3 >> 0] | 0) - 97 + 10);
    break;
   }
   if (65 > (HEAP8[i3 >> 0] | 0)) {
    i7 = 14;
    break L4;
   }
   if ((HEAP8[i3 >> 0] | 0) > 90) {
    i7 = 14;
    break L4;
   }
   HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + ((HEAP8[i3 >> 0] | 0) - 65 + 10);
  } while (0);
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + 1;
 }
 if ((i7 | 0) == 14) {
  HEAP32[i1 >> 2] = -1;
  i7 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i8;
  return i7 | 0;
 } else if ((i7 | 0) == 16) {
  HEAP32[i1 >> 2] = HEAP32[i6 >> 2];
  i7 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i8;
  return i7 | 0;
 }
 return 0;
}

function _fec_rs_decode(i15, i1, i14, i13) {
 i15 = i15 | 0;
 i1 = i1 | 0;
 i14 = i14 | 0;
 i13 = i13 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 if (!i1) {
  _fwrite(gb + 18012 | 0, 49, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 _fec_rs_setlength(i15, i1);
 i12 = i15 + 88 | 0;
 _memset(HEAP32[i15 + 124 >> 2] | 0, 0, HEAP32[i12 >> 2] | 0) | 0;
 i11 = i15 + 128 | 0;
 _memset(HEAP32[i11 >> 2] | 0, 0, HEAP32[i12 >> 2] | 0) | 0;
 i12 = i15 + 132 | 0;
 HEAP32[i12 >> 2] = 0;
 i6 = i15 + 100 | 0;
 i1 = HEAP32[i6 >> 2] | 0;
 if (!i1) {
  i2 = 0;
  i1 = 0;
 } else {
  i7 = i15 + 112 | 0;
  i8 = i15 + 120 | 0;
  i9 = i15 + 108 | 0;
  i10 = i15 + 96 | 0;
  i4 = i1;
  i3 = HEAP32[i15 + 104 >> 2] | 0;
  i5 = 0;
  i2 = 0;
  i1 = 0;
  do {
   if ((i5 | 0) == (i4 + -1 | 0)) i3 = i3 - (HEAP32[i7 >> 2] | 0) | 0;
   _memmove(HEAP32[i8 >> 2] | 0, i14 + i2 | 0, HEAP32[i9 >> 2] | 0) | 0;
   _decode_rs_char(HEAP32[i10 >> 2] | 0, HEAP32[i8 >> 2] | 0, HEAP32[i11 >> 2] | 0, HEAP32[i12 >> 2] | 0) | 0;
   _memmove(i13 + i1 | 0, HEAP32[i8 >> 2] | 0, i3 | 0) | 0;
   i2 = (HEAP32[i9 >> 2] | 0) + i2 | 0;
   i1 = i3 + i1 | 0;
   i5 = i5 + 1 | 0;
   i4 = HEAP32[i6 >> 2] | 0;
  } while (i5 >>> 0 < i4 >>> 0);
 }
 if ((i2 | 0) != (HEAP32[i15 + 12 >> 2] | 0)) ___assert_fail(gb + 18145 | 0, gb + 18086 | 0, 185, gb + 18169 | 0);
 if ((i1 | 0) == (HEAP32[i15 + 8 >> 2] | 0)) return; else ___assert_fail(gb + 18183 | 0, gb + 18086 | 0, 186, gb + 18169 | 0);
}

function _liquid_firdes_farcsech_freqresponse(i2, i3, d1, i13) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 i13 = i13 | 0;
 var d4 = 0.0, d5 = 0.0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0;
 d7 = 1.0 - d1;
 d8 = +(i2 >>> 0);
 d11 = d7 * .5 / d8;
 d12 = .5 / d8;
 d5 = d1 + 1.0;
 d8 = d5 * .5 / d8;
 d9 = 1.0 / (d12 * (d1 * 2.0));
 d10 = +((Math_imul(i2 << 1, i3) | 0 | 1) >>> 0);
 d4 = d9 / (1.316957950592041 / (d12 * d1));
 d5 = d12 * d5;
 i6 = HEAP32[gb + 8808 >> 2] | 0;
 d7 = d12 * d7;
 i2 = (Math_imul(i3, i2) | 0) << 1 | 1;
 i3 = 0;
 do {
  d1 = +(i3 >>> 0) / d10;
  d1 = +Math_abs(+(d1 > .5 ? d1 + -1.0 : d1));
  do if (!(d1 < d11)) {
   if (!(d1 > d11 & d1 < d8)) {
    HEAPF32[i13 + (i3 << 2) >> 2] = 0.0;
    break;
   }
   if (d1 < d12) {
    d1 = d9 * (d5 - d1);
    if (d1 <= 0.0 | d1 > 1.0) {
     _fwrite(gb + 22527 | 0, 45, 1, i6) | 0;
     d1 = 0.0;
    } else {
     d1 = 1.0 / d1;
     d1 = +Math_log(+(d1 + +Math_sqrt(+(d1 + -1.0)) * +Math_sqrt(+(d1 + 1.0))));
    }
    HEAPF32[i13 + (i3 << 2) >> 2] = 1.0 - d4 * d1;
    break;
   } else {
    d1 = d9 * (d1 - d7);
    if (d1 <= 0.0 | d1 > 1.0) {
     _fwrite(gb + 22527 | 0, 45, 1, i6) | 0;
     d1 = 0.0;
    } else {
     d1 = 1.0 / d1;
     d1 = +Math_log(+(d1 + +Math_sqrt(+(d1 + -1.0)) * +Math_sqrt(+(d1 + 1.0))));
    }
    HEAPF32[i13 + (i3 << 2) >> 2] = d4 * d1;
    break;
   }
  } else HEAPF32[i13 + (i3 << 2) >> 2] = 1.0; while (0);
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i2 | 0));
 return;
}

function _liquid_firdes_rrcos(i2, i3, d1, d17, i18) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 d17 = +d17;
 i18 = i18 | 0;
 var d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, d15 = 0.0, d16 = 0.0;
 if (!i2) {
  _fwrite(gb + 24643 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i3) {
  _fwrite(gb + 24699 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  _fwrite(gb + 24755 | 0, 52, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 d15 = +(i2 >>> 0);
 d16 = +(i3 >>> 0);
 d8 = (d1 + 1.0) * 3.141592653589793;
 d12 = 1.0 - d1;
 d9 = d12 * 3.141592653589793;
 d10 = d1 * 4.0;
 d11 = d10;
 d12 = d12 + d11 / 3.141592653589793;
 d13 = d1 * 16.0 * d1;
 d14 = .7853981633974483 / d1;
 d7 = d1 / 1.4142135381698608;
 i2 = (Math_imul(i3, i2) | 0) << 1 | 1;
 i3 = 0;
 do {
  d1 = (+(i3 >>> 0) + d17) / d15 - d16;
  d5 = d1;
  d4 = +Math_cos(+(d8 * d5));
  d5 = +Math_sin(+(d9 * d5));
  do if (!(+Math_abs(+d1) < 1.0e-05)) {
   d6 = 1.0 - d1 * (d13 * d1);
   if (d6 * d6 < 1.0e-05) {
    HEAPF32[i18 + (i3 << 2) >> 2] = d7 * (+Math_sin(+d14) * 1.6366198062896729 + +Math_cos(+d14) * .36338022351264954);
    break;
   } else {
    HEAPF32[i18 + (i3 << 2) >> 2] = d11 / (d6 * 3.141592653589793) * (d4 + 1.0 / (d10 * d1) * d5);
    break;
   }
  } else HEAPF32[i18 + (i3 << 2) >> 2] = d12; while (0);
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i2 | 0));
 return;
}

function _fec_conv_decode_hard(i9, i1, i5, i8) {
 i9 = i9 | 0;
 i1 = i1 | 0;
 i5 = i5 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i10;
 i7 = i9 + 8 | 0;
 if ((HEAP32[i7 >> 2] | 0) == (i1 | 0)) {
  i1 = i9 + 16 | 0;
  i3 = i1;
  i2 = i9 + 12 | 0;
  i1 = HEAP32[i1 >> 2] | 0;
 } else {
  HEAP32[i7 >> 2] = i1;
  i4 = i9 + 12 | 0;
  HEAP32[i4 >> 2] = _fec_get_enc_msg_length(HEAP32[i9 >> 2] | 0, i1) | 0;
  i1 = i9 + 20 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  if (i2 | 0) mftCall_vi(HEAP32[i9 + 60 >> 2] | 0, i2 | 0);
  HEAP32[i1 >> 2] = mftCall_ii(HEAP32[i9 + 44 >> 2] | 0, HEAP32[i7 >> 2] << 3 | 0) | 0;
  i3 = i9 + 16 | 0;
  i1 = _realloc(HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] << 3) | 0;
  HEAP32[i3 >> 2] = i1;
  i2 = i4;
 }
 i4 = HEAP32[i2 >> 2] | 0;
 _liquid_unpack_bytes(i5, i4, i1, i4 << 3, i6);
 if (HEAP32[i2 >> 2] & 536870911 | 0) {
  i1 = 0;
  do {
   i6 = (HEAP32[i3 >> 2] | 0) + i1 | 0;
   HEAP8[i6 >> 0] = ((HEAP8[i6 >> 0] | 0) != 0) << 31 >> 31;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < HEAP32[i2 >> 2] << 3 >>> 0);
 }
 i6 = i9 + 20 | 0;
 mftCall_iii(HEAP32[i9 + 48 >> 2] | 0, HEAP32[i6 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i9 + 52 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] | 0, (HEAP32[i9 + 32 >> 2] | 0) + -1 + (HEAP32[i7 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i9 + 56 >> 2] | 0, HEAP32[i6 >> 2] | 0, i8 | 0, HEAP32[i7 >> 2] << 3 | 0, 0) | 0;
 STACKTOP = i10;
 return;
}

function _ofdmframe_init_S0(i4, i10, i8, i11, i7) {
 i4 = i4 | 0;
 i10 = i10 | 0;
 i8 = i8 | 0;
 i11 = i11 | 0;
 i7 = i7 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i5 = 0, i6 = 0, i9 = 0, d12 = 0.0;
 i6 = _liquid_nextpow2(i10) | 0;
 i6 = _msequence_create_default(i6 >>> 0 < 4 ? 4 : i6 >>> 0 > 8 ? 8 : i6) | 0;
 i9 = (i10 | 0) == 0;
 if (i9) {
  _msequence_destroy(i6);
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 34700 | 0, 69, 1, i3) | 0;
  _exit(1);
 } else {
  i1 = 0;
  i5 = 0;
 }
 do {
  i3 = (_msequence_generate_symbol(i6, 3) | 0) & 1;
  do if (HEAP8[i4 + i5 >> 0] | 0) if (!(i5 & 1)) {
   HEAPF32[i8 + (i5 << 3) >> 2] = i3 | 0 ? 1.0 : -1.0;
   HEAPF32[i8 + (i5 << 3) + 4 >> 2] = 0.0;
   i1 = i1 + 1 | 0;
   break;
  } else {
   HEAPF32[i8 + (i5 << 3) >> 2] = 0.0;
   HEAPF32[i8 + (i5 << 3) + 4 >> 2] = 0.0;
   break;
  } else {
   HEAPF32[i8 + (i5 << 3) >> 2] = 0.0;
   HEAPF32[i8 + (i5 << 3) + 4 >> 2] = 0.0;
  } while (0);
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i10 | 0));
 _msequence_destroy(i6);
 if (!i1) {
  i6 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 34700 | 0, 69, 1, i6) | 0;
  _exit(1);
 }
 HEAP32[i7 >> 2] = i1;
 _fft_run(i10, i8, i11, -1, 0);
 d2 = 1.0 / +Math_sqrt(+(+(i1 >>> 0)));
 if (i9) return; else i1 = 0;
 do {
  i8 = i11 + (i1 << 3) | 0;
  i9 = i11 + (i1 << 3) + 4 | 0;
  d12 = d2 * +HEAPF32[i9 >> 2];
  HEAPF32[i8 >> 2] = d2 * +HEAPF32[i8 >> 2];
  HEAPF32[i9 >> 2] = d12;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i10 | 0));
 return;
}

function _fec_secded3932_estimate_ehat(i1, i8) {
 i1 = i1 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i9 = i11;
 HEAP8[i8 >> 0] = 0;
 HEAP8[i8 + 1 >> 0] = 0;
 HEAP8[i8 + 2 >> 0] = 0;
 HEAP8[i8 + 3 >> 0] = 0;
 HEAP8[i8 + 4 >> 0] = 0;
 i4 = HEAPU8[i1 >> 0] | 0;
 i5 = HEAP8[i1 + 1 >> 0] | 0;
 i6 = HEAP8[i1 + 2 >> 0] | 0;
 i7 = HEAP8[i1 + 3 >> 0] | 0;
 i2 = HEAP8[i1 + 4 >> 0] | 0;
 i3 = 0;
 i1 = 0;
 do {
  i12 = i3 << 2;
  i1 = ((1 << 6 - i3 & i4 | 0) != 0 & 1) + (HEAPU8[(HEAP8[gb + 18416 + i12 >> 0] & i5 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 1) + (gb + 18416) >> 0] & i6 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 2) + (gb + 18416) >> 0] & i7 & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 3) + (gb + 18416) >> 0] & i2 & 255) + (gb + 38499) >> 0] | 0) & 1 | i1 << 1 & 510;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 7);
 i2 = i1 & 255;
 if (!(HEAP8[(i1 & 255) + (gb + 38499) >> 0] | 0)) {
  i12 = 0;
  STACKTOP = i11;
  return i12 | 0;
 } else i1 = 0;
 while (1) {
  if (i2 << 24 >> 24 == (HEAP8[gb + 18444 + i1 >> 0] | 0)) break;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= 39) {
   i1 = 2;
   i10 = 7;
   break;
  }
 }
 if ((i10 | 0) == 7) {
  STACKTOP = i11;
  return i1 | 0;
 }
 _div(i9, i1, 8);
 HEAP8[i8 + (4 - (HEAP32[i9 >> 2] | 0)) >> 0] = 1 << HEAP32[i9 + 4 >> 2];
 i12 = 1;
 STACKTOP = i11;
 return i12 | 0;
}

function _qpilotgen_create(i3, i1) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, d13 = 0.0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i7 = i11 + 24 | 0;
 i2 = i11 + 16 | 0;
 i8 = i11 + 8 | 0;
 i9 = i11;
 if (!i3) {
  _fwrite(gb + 29516 | 0, 66, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i1 >>> 0 < 2) {
  _fwrite(gb + 29583 | 0, 68, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i10 = _malloc(20) | 0;
 HEAP32[i10 >> 2] = i3;
 HEAP32[i10 + 4 >> 2] = i1;
 _div(i2, i3, i1 + -1 | 0);
 i6 = ((HEAP32[i2 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i2 >> 2] | 0) | 0;
 HEAP32[i10 + 8 >> 2] = i6;
 HEAP32[i10 + 12 >> 2] = i6 + i3;
 i1 = _malloc(i6 << 3) | 0;
 HEAP32[i10 + 16 >> 2] = i1;
 i2 = _msequence_create_default(_liquid_nextpow2(i6) | 0) | 0;
 if (!i6) {
  _msequence_destroy(i2);
  STACKTOP = i11;
  return i10 | 0;
 }
 i3 = i9 + 4 | 0;
 i4 = i8 + 4 | 0;
 i5 = 0;
 do {
  d13 = +((_msequence_generate_symbol(i2, 2) | 0) >>> 0) * 6.283185307179586 * .25 + .7853981633974483;
  HEAPF32[i9 >> 2] = d13 * 0.0;
  HEAPF32[i3 >> 2] = d13;
  HEAP32[i7 >> 2] = HEAP32[i9 >> 2];
  HEAP32[i7 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
  _cexpf(i8, i7);
  i12 = HEAP32[i4 >> 2] | 0;
  HEAP32[i1 + (i5 << 3) >> 2] = HEAP32[i8 >> 2];
  HEAP32[i1 + (i5 << 3) + 4 >> 2] = i12;
  i5 = i5 + 1 | 0;
 } while (i5 >>> 0 < i6 >>> 0);
 _msequence_destroy(i2);
 STACKTOP = i11;
 return i10 | 0;
}

function _ofdmframegen_write_S1(i1, i6) {
 i1 = i1 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, d8 = 0.0, i9 = 0, d10 = 0.0, i11 = 0, d12 = 0.0;
 i7 = i1 + 56 | 0;
 _memmove(HEAP32[i7 >> 2] | 0, HEAP32[i1 + 72 >> 2] | 0, HEAP32[i1 >> 2] << 3 | 0) | 0;
 i3 = i1 + 4 | 0;
 i5 = HEAP32[i3 >> 2] | 0;
 _memmove(i6 | 0, (HEAP32[i7 >> 2] | 0) + ((HEAP32[i1 >> 2] | 0) - i5 << 3) | 0, i5 << 3 | 0) | 0;
 _memmove(i6 + (HEAP32[i3 >> 2] << 3) | 0, HEAP32[i7 >> 2] | 0, HEAP32[i1 >> 2] << 3 | 0) | 0;
 i3 = i1 + 12 | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  i6 = 0;
  i5 = i1 + 20 | 0;
  i5 = HEAP32[i5 >> 2] | 0;
  i7 = HEAP32[i7 >> 2] | 0;
  _memmove(i5 | 0, i7 | 0, i6 | 0) | 0;
  return;
 }
 i4 = i1 + 16 | 0;
 i5 = i1 + 20 | 0;
 i2 = 0;
 do {
  d8 = +HEAPF32[(HEAP32[i4 >> 2] | 0) + (i2 << 2) >> 2];
  i9 = i6 + (i2 << 3) | 0;
  i1 = i6 + (i2 << 3) + 4 | 0;
  d12 = d8 * +HEAPF32[i9 >> 2];
  d8 = d8 * +HEAPF32[i1 >> 2];
  HEAPF32[i9 >> 2] = d12;
  HEAPF32[i1 >> 2] = d8;
  i11 = HEAP32[i5 >> 2] | 0;
  d10 = +HEAPF32[(HEAP32[i4 >> 2] | 0) + ((HEAP32[i3 >> 2] | 0) + ~i2 << 2) >> 2];
  d8 = d8 + +HEAPF32[i11 + (i2 << 3) + 4 >> 2] * d10;
  HEAPF32[i9 >> 2] = d12 + +HEAPF32[i11 + (i2 << 3) >> 2] * d10;
  HEAPF32[i1 >> 2] = d8;
  i2 = i2 + 1 | 0;
  i1 = HEAP32[i3 >> 2] | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 i11 = i1 << 3;
 i6 = i5;
 i6 = HEAP32[i6 >> 2] | 0;
 i9 = HEAP32[i7 >> 2] | 0;
 _memmove(i6 | 0, i9 | 0, i11 | 0) | 0;
 return;
}

function _csqrtf(i6, i1) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, d4 = 0.0, d5 = 0.0;
 d5 = +HEAPF32[i1 >> 2];
 d4 = +HEAPF32[i1 + 4 >> 2];
 do if (!(d5 == 0.0 & d4 == 0.0)) {
  d2 = +Math_abs(+d4);
  if (((HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0) | 0) == 2139095040) {
   HEAPF32[i6 >> 2] = inf;
   HEAPF32[i6 + 4 >> 2] = d4;
   break;
  }
  i3 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
  d2 = +Math_abs(+d5);
  i1 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
  if (i1 >>> 0 > 2139095040) {
   d4 = d4 - d4;
   HEAPF32[i6 >> 2] = d5;
   HEAPF32[i6 + 4 >> 2] = d4 / d4;
   break;
  }
  if ((i1 | 0) == 2139095040) {
   d2 = d4 - d4;
   if ((i3 | 0) < 0) {
    d2 = +Math_abs(+d2);
    d5 = +_copysignf(d5, d4);
    HEAPF32[i6 >> 2] = d2;
    HEAPF32[i6 + 4 >> 2] = d5;
    break;
   } else {
    d4 = +_copysignf(d2, d4);
    HEAPF32[i6 >> 2] = d5;
    HEAPF32[i6 + 4 >> 2] = d4;
    break;
   }
  } else if (!(d5 >= 0.0)) {
   d5 = +Math_sqrt(+((-d5 + +_hypot(d5, d4)) * .5));
   d2 = +Math_abs(+d4) / (d5 * 2.0);
   d5 = +_copysignf(d5, d4);
   HEAPF32[i6 >> 2] = d2;
   HEAPF32[i6 + 4 >> 2] = d5;
   break;
  } else {
   d5 = +Math_sqrt(+((d5 + +_hypot(d5, d4)) * .5));
   HEAPF32[i6 >> 2] = d5;
   HEAPF32[i6 + 4 >> 2] = d4 / (d5 * 2.0);
   break;
  }
 } else {
  HEAPF32[i6 >> 2] = 0.0;
  HEAPF32[i6 + 4 >> 2] = d4;
 } while (0);
 return;
}

function _fec_secded2216_decode(i1, i12, i10, i9) {
 i1 = i1 | 0;
 i12 = i12 | 0;
 i10 = i10 | 0;
 i9 = i9 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i11 = 0, i13 = 0, i14 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i11 + 3 | 0;
 i7 = i11;
 i8 = i12 & 1;
 i3 = i12 - i8 | 0;
 if ((i8 | 0) == (i12 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i4 = i6 + 1 | 0;
  i5 = i6 + 2 | 0;
  i2 = 0;
  i1 = 0;
  do {
   i14 = i10 + i1 | 0;
   i13 = i9 + i2 | 0;
   HEAP8[i6 >> 0] = 0;
   HEAP8[i6 + 1 >> 0] = 0;
   HEAP8[i6 + 2 >> 0] = 0;
   _fec_secded2216_estimate_ehat(i14, i6) | 0;
   HEAP8[i13 >> 0] = HEAP8[i4 >> 0] ^ HEAP8[i14 + 1 >> 0];
   HEAP8[i13 + 1 >> 0] = HEAP8[i5 >> 0] ^ HEAP8[i14 + 2 >> 0];
   i1 = i1 + 3 | 0;
   i2 = i2 + 2 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i8) {
  HEAP8[i7 >> 0] = HEAP8[i10 + i1 >> 0] | 0;
  i14 = HEAP8[i10 + (i1 + 1) >> 0] | 0;
  HEAP8[i7 + 1 >> 0] = i14;
  HEAP8[i7 + 2 >> 0] = 0;
  HEAP8[i6 >> 0] = 0;
  HEAP8[i6 + 1 >> 0] = 0;
  HEAP8[i6 + 2 >> 0] = 0;
  _fec_secded2216_estimate_ehat(i7, i6) | 0;
  HEAP8[i9 + i2 >> 0] = HEAP8[i6 + 1 >> 0] ^ i14;
  i2 = i2 | i8;
  i1 = i8 + 1 + i1 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(8, i12) | 0)) ___assert_fail(gb + 18279 | 0, gb + 18343 | 0, 323, gb + 18394 | 0);
 if ((i2 | 0) == (i12 | 0)) {
  STACKTOP = i11;
  return;
 } else ___assert_fail(gb + 18871 | 0, gb + 18343 | 0, 324, gb + 18394 | 0);
}

function _firinterp_crcf_execute(i1, i2, i8) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i8 = i8 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i9 + 16 | 0;
 i10 = i9;
 i4 = i9 + 8 | 0;
 i7 = i1 + 16 | 0;
 i3 = HEAP32[i2 + 4 >> 2] | 0;
 i5 = HEAP32[(HEAP32[i7 >> 2] | 0) + 16 >> 2] | 0;
 HEAP32[i4 >> 2] = HEAP32[i2 >> 2];
 HEAP32[i4 + 4 >> 2] = i3;
 HEAP32[i6 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i6 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 _windowcf_push(i5, i6);
 i5 = i1 + 12 | 0;
 if (!(HEAP32[i5 >> 2] | 0)) {
  STACKTOP = i9;
  return;
 }
 i1 = 0;
 while (1) {
  i3 = HEAP32[i7 >> 2] | 0;
  i4 = i8 + (i1 << 3) | 0;
  i2 = HEAP32[i3 + 12 >> 2] | 0;
  if (i2 >>> 0 <= i1 >>> 0) {
   i3 = 4;
   break;
  }
  _windowcf_read(HEAP32[i3 + 16 >> 2] | 0, i6);
  _dotprod_crcf_execute(HEAP32[(HEAP32[i3 + 20 >> 2] | 0) + (i1 << 2) >> 2] | 0, HEAP32[i6 >> 2] | 0, i4);
  d12 = +HEAPF32[i3 + 24 >> 2];
  i3 = i8 + (i1 << 3) + 4 | 0;
  d11 = d12 * +HEAPF32[i3 >> 2];
  HEAPF32[i4 >> 2] = d12 * +HEAPF32[i4 >> 2];
  HEAPF32[i3 >> 2] = d11;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= (HEAP32[i5 >> 2] | 0) >>> 0) {
   i3 = 6;
   break;
  }
 }
 if ((i3 | 0) == 4) {
  i9 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i10 >> 2] = i1;
  HEAP32[i10 + 4 >> 2] = i2;
  _fprintf(i9, gb + 20859 | 0, i10) | 0;
  _exit(1);
 } else if ((i3 | 0) == 6) {
  STACKTOP = i9;
  return;
 }
}

function _modem_demodulate_qam(i13, i8, i14) {
 i13 = i13 | 0;
 i8 = i8 | 0;
 i14 = i14 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, d9 = 0.0, i10 = 0, d11 = 0.0, d12 = 0.0;
 d12 = +HEAPF32[i8 >> 2];
 i5 = HEAP32[i13 + 100 >> 2] | 0;
 if (!i5) {
  d11 = d12;
  i10 = 0;
 } else {
  i6 = i5 + -1 | 0;
  d2 = d12;
  i4 = 0;
  i7 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i13 + 12 + (i4 + i6 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i13 + 12 + (i4 + i6 << 2) >> 2];
   i3 = i7 + 1 | 0;
   if ((i3 | 0) == (i5 | 0)) {
    d11 = d2;
    i10 = i1;
    break;
   } else {
    i4 = ~i7;
    i7 = i3;
   }
  }
 }
 d9 = +HEAPF32[i8 + 4 >> 2];
 i8 = i13 + 104 | 0;
 i5 = HEAP32[i8 >> 2] | 0;
 if (!i5) {
  d2 = d9;
  i1 = 0;
 } else {
  i6 = i5 + -1 | 0;
  d2 = d9;
  i4 = 0;
  i7 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i13 + 12 + (i4 + i6 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i13 + 12 + (i4 + i6 << 2) >> 2];
   i3 = i7 + 1 | 0;
   if ((i3 | 0) == (i5 | 0)) break; else {
    i4 = ~i7;
    i7 = i3;
   }
  }
 }
 i7 = _gray_encode(i10) | 0;
 i10 = _gray_encode(i1) | 0;
 HEAP32[i14 >> 2] = (i7 << HEAP32[i8 >> 2]) + i10;
 HEAPF32[i13 + 92 >> 2] = d12 - (d11 + d2 * 0.0);
 HEAPF32[i13 + 96 >> 2] = d9 - d2;
 HEAPF32[i13 + 84 >> 2] = d12;
 HEAPF32[i13 + 88 >> 2] = d9;
 return;
}

function _modem_demodulate_arb(i13, i15, i14) {
 i13 = i13 | 0;
 i15 = i15 | 0;
 i14 = i14 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i16 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i16 + 8 | 0;
 i3 = i16;
 i12 = i13 + 8 | 0;
 if (!(HEAP32[i12 >> 2] | 0)) i1 = 0; else {
  d5 = +HEAPF32[i15 >> 2];
  d6 = +HEAPF32[i15 + 4 >> 2];
  i7 = i13 + 76 | 0;
  i8 = i3 + 4 | 0;
  d9 = 0.0;
  i10 = 0;
  i1 = 0;
  while (1) {
   i11 = HEAP32[i7 >> 2] | 0;
   d4 = d6 - +HEAPF32[i11 + (i10 << 3) + 4 >> 2];
   HEAPF32[i3 >> 2] = d5 - +HEAPF32[i11 + (i10 << 3) >> 2];
   HEAPF32[i8 >> 2] = d4;
   HEAP32[i2 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i2 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   d4 = +_cabsf(i2);
   i11 = (i10 | 0) == 0 | d4 < d9;
   i1 = i11 ? i10 : i1;
   i10 = i10 + 1 | 0;
   if (i10 >>> 0 >= (HEAP32[i12 >> 2] | 0) >>> 0) break; else d9 = i11 ? d4 : d9;
  }
 }
 HEAP32[i14 >> 2] = i1;
 if ((HEAP32[i12 >> 2] | 0) >>> 0 > i1 >>> 0) {
  i12 = HEAP32[i13 + 76 >> 2] | 0;
  i14 = HEAP32[i12 + (i1 << 3) + 4 >> 2] | 0;
  HEAP32[i13 + 92 >> 2] = HEAP32[i12 + (i1 << 3) >> 2];
  HEAP32[i13 + 96 >> 2] = i14;
  i14 = HEAP32[i15 + 4 >> 2] | 0;
  HEAP32[i13 + 84 >> 2] = HEAP32[i15 >> 2];
  HEAP32[i13 + 88 >> 2] = i14;
  STACKTOP = i16;
  return;
 } else {
  _fwrite(gb + 31527 | 0, 52, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
}

function ___stdio_read(i8, i7, i9) {
 i8 = i8 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i3 = i10 + 16 | 0;
 i2 = i10;
 i1 = i10 + 32 | 0;
 HEAP32[i1 >> 2] = i7;
 i4 = i1 + 4 | 0;
 i6 = i8 + 48 | 0;
 i11 = HEAP32[i6 >> 2] | 0;
 HEAP32[i4 >> 2] = i9 - ((i11 | 0) != 0 & 1);
 i5 = i8 + 44 | 0;
 HEAP32[i1 + 8 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i1 + 12 >> 2] = i11;
 if (!(HEAP32[gb + 44304 >> 2] | 0)) {
  HEAP32[i3 >> 2] = HEAP32[i8 + 60 >> 2];
  HEAP32[i3 + 4 >> 2] = i1;
  HEAP32[i3 + 8 >> 2] = 2;
  i1 = ___syscall_ret(___syscall145(145, i3 | 0) | 0) | 0;
 } else {
  _pthread_cleanup_push(fb + 22 | 0, i8 | 0);
  HEAP32[i2 >> 2] = HEAP32[i8 + 60 >> 2];
  HEAP32[i2 + 4 >> 2] = i1;
  HEAP32[i2 + 8 >> 2] = 2;
  i1 = ___syscall_ret(___syscall145(145, i2 | 0) | 0) | 0;
  _pthread_cleanup_pop(0);
 }
 if ((i1 | 0) >= 1) {
  i4 = HEAP32[i4 >> 2] | 0;
  if (i1 >>> 0 > i4 >>> 0) {
   i2 = HEAP32[i5 >> 2] | 0;
   i3 = i8 + 4 | 0;
   HEAP32[i3 >> 2] = i2;
   HEAP32[i8 + 8 >> 2] = i2 + (i1 - i4);
   if (!(HEAP32[i6 >> 2] | 0)) i1 = i9; else {
    HEAP32[i3 >> 2] = i2 + 1;
    HEAP8[i7 + (i9 + -1) >> 0] = HEAP8[i2 >> 0] | 0;
    i1 = i9;
   }
  }
 } else {
  HEAP32[i8 >> 2] = HEAP32[i8 >> 2] | i1 & 48 ^ 16;
  HEAP32[i8 + 8 >> 2] = 0;
  HEAP32[i8 + 4 >> 2] = 0;
 }
 STACKTOP = i10;
 return i1 | 0;
}

function _log10f(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0;
 i2 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 i3 = (i2 | 0) < 0;
 do if (i2 >>> 0 < 8388608 | i3) {
  d5 = +Math_abs(+d1);
  if (!((HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
   d1 = -1.0 / (d1 * d1);
   break;
  }
  if (i3) {
   d1 = (d1 - d1) / 0.0;
   break;
  } else {
   i2 = (HEAPF32[tempDoublePtr >> 2] = d1 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
   i3 = -152;
   i4 = 9;
   break;
  }
 } else if (i2 >>> 0 <= 2139095039) if ((i2 | 0) == 1065353216) d1 = 0.0; else {
  i3 = -127;
  i4 = 9;
 } while (0);
 if ((i4 | 0) == 9) {
  i4 = i2 + 4913933 | 0;
  d9 = (HEAP32[tempDoublePtr >> 2] = (i4 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
  d8 = d9 / (d9 + 2.0);
  d6 = d8 * d8;
  d1 = d6 * d6;
  d7 = d9 * (d9 * .5);
  d5 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d9 - d7, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
  d1 = d9 - d5 - d7 + d8 * (d7 + (d6 * (d1 * .2849878668785095 + .6666666269302368) + d1 * (d1 * .24279078841209412 + .40000972151756287)));
  d6 = +(i3 + (i4 >>> 23) | 0);
  d1 = d6 * .3010292053222656 + (d5 * .434326171875 + (d1 * .434326171875 + (d6 * 7.903415166765626e-07 - (d5 + d1) * 3.168997136526741e-05)));
 }
 return +d1;
}

function _packetizer_decode(i8, i1, i7) {
 i8 = i8 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = i8 + 28 | 0;
 _memmove(HEAP32[i6 >> 2] | 0, i1 | 0, HEAP32[i8 + 4 >> 2] | 0) | 0;
 i1 = HEAP32[i8 + 20 >> 2] | 0;
 if (i1 | 0) {
  i2 = i8 + 16 | 0;
  i3 = i8 + 32 | 0;
  do {
   i1 = i1 + -1 | 0;
   _interleaver_decode(HEAP32[(HEAP32[i2 >> 2] | 0) + (i1 * 20 | 0) + 16 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] | 0);
   i5 = HEAP32[i2 >> 2] | 0;
   _fec_decode(HEAP32[i5 + (i1 * 20 | 0) + 12 >> 2] | 0, HEAP32[i5 + (i1 * 20 | 0) >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i6 >> 2] | 0);
  } while ((i1 | 0) != 0);
 }
 i3 = HEAP32[i8 + 12 >> 2] | 0;
 if (!i3) {
  i3 = i8;
  i2 = HEAP32[i6 >> 2] | 0;
  i4 = HEAP32[i8 >> 2] | 0;
  i5 = 0;
  _memmove(i7 | 0, i2 | 0, i4 | 0) | 0;
  i4 = i8 + 8 | 0;
  i4 = HEAP32[i4 >> 2] | 0;
  i7 = HEAP32[i6 >> 2] | 0;
  i8 = HEAP32[i3 >> 2] | 0;
  i8 = _crc_validate_message(i4, i7, i8, i5) | 0;
  return i8 | 0;
 }
 i2 = HEAP32[i8 >> 2] | 0;
 i5 = HEAP32[i6 >> 2] | 0;
 i4 = 0;
 i1 = 0;
 do {
  i1 = HEAPU8[i5 + (i2 + i4) >> 0] | 0 | i1 << 8;
  i4 = i4 + 1 | 0;
 } while (i4 >>> 0 < i3 >>> 0);
 i4 = i8;
 i3 = i5;
 _memmove(i7 | 0, i3 | 0, i2 | 0) | 0;
 i5 = i8 + 8 | 0;
 i5 = HEAP32[i5 >> 2] | 0;
 i7 = HEAP32[i6 >> 2] | 0;
 i8 = HEAP32[i4 >> 2] | 0;
 i8 = _crc_validate_message(i5, i7, i8, i1) | 0;
 return i8 | 0;
}

function _packetizer_create(i2, i1, i3, i5) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 var i4 = 0, i6 = 0, i7 = 0;
 i6 = _malloc(36) | 0;
 HEAP32[i6 >> 2] = i2;
 i4 = _fec_get_enc_msg_length(i5, _fec_get_enc_msg_length(i3, (_crc_get_length(i1) | 0) + i2 | 0) | 0) | 0;
 HEAP32[i6 + 4 >> 2] = i4;
 HEAP32[i6 + 8 >> 2] = i1;
 i1 = _crc_get_length(i1) | 0;
 HEAP32[i6 + 12 >> 2] = i1;
 HEAP32[i6 + 24 >> 2] = i4;
 i4 = i4 << 3;
 HEAP32[i6 + 28 >> 2] = _malloc(i4) | 0;
 HEAP32[i6 + 32 >> 2] = _malloc(i4) | 0;
 HEAP32[i6 + 20 >> 2] = 2;
 i4 = _malloc(40) | 0;
 HEAP32[i6 + 16 >> 2] = i4;
 i1 = i1 + i2 | 0;
 i7 = i4 + 8 | 0;
 HEAP32[i7 >> 2] = i3;
 HEAP32[i4 >> 2] = i1;
 i2 = i4 + 4 | 0;
 HEAP32[i2 >> 2] = _fec_get_enc_msg_length(i3, i1) | 0;
 HEAP32[i4 + 12 >> 2] = _fec_create(HEAP32[i7 >> 2] | 0, 0) | 0;
 i1 = _interleaver_create(HEAP32[i2 >> 2] | 0) | 0;
 HEAP32[i4 + 16 >> 2] = i1;
 if ((HEAP32[i7 >> 2] | 0) == 1) _interleaver_set_depth(i1, 0);
 i3 = HEAP32[i2 >> 2] | 0;
 i7 = i4 + 28 | 0;
 HEAP32[i7 >> 2] = i5;
 HEAP32[i4 + 20 >> 2] = i3;
 i1 = i4 + 24 | 0;
 HEAP32[i1 >> 2] = _fec_get_enc_msg_length(i5, i3) | 0;
 HEAP32[i4 + 32 >> 2] = _fec_create(HEAP32[i7 >> 2] | 0, 0) | 0;
 i1 = _interleaver_create(HEAP32[i1 >> 2] | 0) | 0;
 HEAP32[i4 + 36 >> 2] = i1;
 if ((HEAP32[i7 >> 2] | 0) != 1) return i6 | 0;
 _interleaver_set_depth(i1, 0);
 return i6 | 0;
}

function _fec_golay2412_decode(i1, i7, i6, i5) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0;
 i4 = (i7 >>> 0) % 3 | 0;
 i2 = i7 - i4 | 0;
 if ((i4 | 0) == (i7 | 0)) i1 = 0; else {
  i3 = 0;
  i1 = 0;
  do {
   i8 = (HEAPU8[i6 + (i1 + 4) >> 0] | 0) << 8 | (HEAPU8[i6 + (i1 + 3) >> 0] | 0) << 16 | (HEAPU8[i6 + (i1 + 5) >> 0] | 0);
   i9 = _fec_golay2412_decode_symbol((HEAPU8[i6 + (i1 | 1) >> 0] | 0) << 8 | (HEAPU8[i6 + i1 >> 0] | 0) << 16 | (HEAPU8[i6 + (i1 + 2) >> 0] | 0)) | 0;
   i8 = _fec_golay2412_decode_symbol(i8) | 0;
   HEAP8[i5 + i3 >> 0] = i9 >>> 4;
   HEAP8[i5 + (i3 + 1) >> 0] = i8 >>> 8 & 15 | i9 << 4;
   HEAP8[i5 + (i3 + 2) >> 0] = i8;
   i1 = i1 + 6 | 0;
   i3 = i3 + 3 | 0;
  } while (i3 >>> 0 < i2 >>> 0);
 }
 if (i2 >>> 0 < i7 >>> 0) {
  i4 = i4 * 3 | 0;
  i3 = i1;
  while (1) {
   HEAP8[i5 + i2 >> 0] = _fec_golay2412_decode_symbol((HEAPU8[i6 + (i3 + 1) >> 0] | 0) << 8 | (HEAPU8[i6 + i3 >> 0] | 0) << 16 | (HEAPU8[i6 + (i3 + 2) >> 0] | 0)) | 0;
   i2 = i2 + 1 | 0;
   if ((i2 | 0) == (i7 | 0)) break; else i3 = i3 + 3 | 0;
  }
  i2 = i7;
  i1 = i1 + i4 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(7, i7) | 0)) ___assert_fail(gb + 12815 | 0, gb + 12766 | 0, 396, gb + 12877 | 0);
 if ((i2 | 0) == (i7 | 0)) return; else ___assert_fail(gb + 18871 | 0, gb + 12766 | 0, 397, gb + 12877 | 0);
}

function _bessel_azpkf(i13, i1, i14, i12) {
 i13 = i13 | 0;
 i1 = i1 | 0;
 i14 = i14 | 0;
 i12 = i12 | 0;
 var d2 = 0.0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i15 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i10 = i11;
 _fpoly_bessel_roots_orchard(i13 + 1 | 0, i14);
 d2 = +Math_sqrt(+(+(((i13 << 1) + -1 | 0) >>> 0) * .6931471824645996));
 i3 = (i13 | 0) == 0;
 if (i3) {
  HEAPF32[i12 >> 2] = 1.0;
  HEAPF32[i12 + 4 >> 2] = 0.0;
  STACKTOP = i11;
  return;
 } else i1 = 0;
 do {
  i15 = i14 + (i1 << 3) | 0;
  i9 = i14 + (i1 << 3) + 4 | 0;
  d8 = +HEAPF32[i9 >> 2] / d2;
  HEAPF32[i15 >> 2] = +HEAPF32[i15 >> 2] / d2;
  HEAPF32[i9 >> 2] = d8;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i13 | 0));
 i9 = i12 + 4 | 0;
 HEAPF32[i12 >> 2] = 1.0;
 HEAPF32[i9 >> 2] = 0.0;
 if (i3) {
  STACKTOP = i11;
  return;
 }
 i1 = i10 + 4 | 0;
 d2 = 1.0;
 d4 = 0.0;
 i3 = 0;
 do {
  d5 = +HEAPF32[i14 + (i3 << 3) >> 2];
  d6 = +HEAPF32[i14 + (i3 << 3) + 4 >> 2];
  d7 = d5 * d2 - d6 * d4;
  d8 = d6 * d2 + d5 * d4;
  if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
   ___mulsc3(i10, d2, d4, d5, d6);
   d2 = +HEAPF32[i10 >> 2];
   d4 = +HEAPF32[i1 >> 2];
  } else {
   d2 = d7;
   d4 = d8;
  }
  HEAPF32[i12 >> 2] = d2;
  HEAPF32[i9 >> 2] = d4;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i13 | 0));
 STACKTOP = i11;
 return;
}

function _fec_create(i3, i2) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i1 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5;
 do switch (i3 | 0) {
 case 0:
  {
   _puts(gb + 12161 | 0) | 0;
   _exit(-1);
   break;
  }
 case 1:
  {
   i1 = _fec_pass_create(0) | 0;
   break;
  }
 case 2:
  {
   i1 = _fec_rep3_create(i2) | 0;
   break;
  }
 case 3:
  {
   i1 = _fec_rep5_create(i2) | 0;
   break;
  }
 case 4:
  {
   i1 = _fec_hamming74_create(i2) | 0;
   break;
  }
 case 5:
  {
   i1 = _fec_hamming84_create(i2) | 0;
   break;
  }
 case 6:
  {
   i1 = _fec_hamming128_create(i2) | 0;
   break;
  }
 case 7:
  {
   i1 = _fec_golay2412_create(i2) | 0;
   break;
  }
 case 8:
  {
   i1 = _fec_secded2216_create(i2) | 0;
   break;
  }
 case 9:
  {
   i1 = _fec_secded3932_create(i2) | 0;
   break;
  }
 case 10:
  {
   i1 = _fec_secded7264_create(i2) | 0;
   break;
  }
 case 14:
 case 13:
 case 12:
 case 11:
  {
   i1 = _fec_conv_create(i3) | 0;
   break;
  }
 case 26:
 case 25:
 case 24:
 case 23:
 case 22:
 case 21:
 case 20:
 case 19:
 case 18:
 case 17:
 case 16:
 case 15:
  {
   i1 = _fec_conv_punctured_create(i3) | 0;
   break;
  }
 case 27:
  {
   i1 = _fec_rs_create(27) | 0;
   break;
  }
 default:
  {
   HEAP32[i4 >> 2] = i3;
   _printf(gb + 12225 | 0, i4) | 0;
   _exit(-1);
  }
 } while (0);
 STACKTOP = i5;
 return i1 | 0;
}

function _firpfb_rrrf_create_rnyquist(i5, i1, i3, i4, d2) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 d2 = +d2;
 var i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i10 + 24 | 0;
 i8 = i10 + 16 | 0;
 i7 = i10 + 8 | 0;
 i6 = i10;
 if (!i1) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 18911;
  _fprintf(i11, gb + 20928 | 0, i6) | 0;
  _exit(1);
 }
 if (i3 >>> 0 < 2) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i7 >> 2] = gb + 18911;
  _fprintf(i11, gb + 21009 | 0, i7) | 0;
  _exit(1);
 }
 if (!i4) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = gb + 18911;
  _fprintf(i11, gb + 21091 | 0, i8) | 0;
  _exit(1);
 }
 if (d2 < 0.0 | d2 > 1.0) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i9 >> 2] = gb + 18911;
  _fprintf(i11, gb + 21164 | 0, i9) | 0;
  _exit(1);
 } else {
  i11 = Math_imul(Math_imul(i1 << 1, i3) | 0, i4) | 0 | 1;
  i8 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(i5, Math_imul(i3, i1) | 0, i4, d2, 0.0, i8);
  i9 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i9 | 0, i8 | 0, (Math_imul(Math_imul(i4, i3) | 0, i1) | 0) << 3 | 4 | 0) | 0;
  i11 = _firpfb_rrrf_create(i1, i9, i11) | 0;
  STACKTOP = i10;
  return i11 | 0;
 }
 return 0;
}

function _firpfb_crcf_create_rnyquist(i5, i1, i3, i4, d2) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 d2 = +d2;
 var i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i10 + 24 | 0;
 i8 = i10 + 16 | 0;
 i7 = i10 + 8 | 0;
 i6 = i10;
 if (!i1) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 19656;
  _fprintf(i11, gb + 20928 | 0, i6) | 0;
  _exit(1);
 }
 if (i3 >>> 0 < 2) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i7 >> 2] = gb + 19656;
  _fprintf(i11, gb + 21009 | 0, i7) | 0;
  _exit(1);
 }
 if (!i4) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = gb + 19656;
  _fprintf(i11, gb + 21091 | 0, i8) | 0;
  _exit(1);
 }
 if (d2 < 0.0 | d2 > 1.0) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i9 >> 2] = gb + 19656;
  _fprintf(i11, gb + 21164 | 0, i9) | 0;
  _exit(1);
 } else {
  i11 = Math_imul(Math_imul(i1 << 1, i3) | 0, i4) | 0 | 1;
  i8 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(i5, Math_imul(i3, i1) | 0, i4, d2, 0.0, i8);
  i9 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i9 | 0, i8 | 0, (Math_imul(Math_imul(i4, i3) | 0, i1) | 0) << 3 | 4 | 0) | 0;
  i11 = _firpfb_crcf_create(i1, i9, i11) | 0;
  STACKTOP = i10;
  return i11 | 0;
 }
 return 0;
}

function _polyf_fit(i8, i9, i6, i7, i5) {
 i8 = i8 | 0;
 i9 = i9 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0;
 i13 = STACKTOP;
 i1 = Math_imul(i5, i6) | 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 if (!((i6 | 0) == 0 | (i5 | 0) == 0)) {
  i11 = 0;
  do {
   i3 = Math_imul(i11, i5) | 0;
   d4 = +HEAPF32[i8 + (i11 << 2) >> 2];
   i10 = 0;
   d12 = 1.0;
   while (1) {
    HEAPF32[i2 + (i10 + i3 << 2) >> 2] = d12;
    i10 = i10 + 1 | 0;
    if ((i10 | 0) == (i5 | 0)) break; else d12 = d12 * d4;
   }
   i11 = i11 + 1 | 0;
  } while ((i11 | 0) != (i6 | 0));
 }
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i10 | 0, i2 | 0, i1 << 2 | 0) | 0;
 _matrixf_trans(i10, i6, i5);
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 2) | 0) + 15 & -16) | 0;
 _matrixf_mul(i10, i5, i6, i9, i6, 1, i11, i5, 1);
 i9 = Math_imul(i5, i5) | 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 _matrixf_mul(i10, i5, i6, i2, i6, i5, i8, i5, i5);
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i10 | 0, i8 | 0, i9 << 2 | 0) | 0;
 _matrixf_inv(i10, i5, i5);
 _matrixf_mul(i10, i5, i5, i11, i5, 1, i7, i5, 1);
 STACKTOP = i13;
 return;
}

function _flexframegen_assemble(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i5 = 0, i6 = 0;
 i6 = i4 + 104 | 0;
 HEAP32[i6 >> 2] = 0;
 HEAP32[i6 + 4 >> 2] = 0;
 HEAP32[i6 + 8 >> 2] = 0;
 HEAP32[i6 + 12 >> 2] = 0;
 HEAP32[i6 + 16 >> 2] = 0;
 i6 = i4 + 88 | 0;
 HEAP32[i6 >> 2] = i3;
 i5 = i4 + 52 | 0;
 i3 = i4 + 56 | 0;
 _memmove(HEAP32[i5 >> 2] | 0, i1 | 0, HEAP32[i3 >> 2] | 0) | 0;
 i3 = HEAP32[i3 >> 2] | 0;
 HEAP8[(HEAP32[i5 >> 2] | 0) + i3 >> 0] = 101;
 HEAP8[(HEAP32[i5 >> 2] | 0) + (i3 + 1) >> 0] = (HEAP32[i6 >> 2] | 0) >>> 8;
 HEAP8[(HEAP32[i5 >> 2] | 0) + (i3 + 2) >> 0] = HEAP32[i6 >> 2];
 HEAP8[(HEAP32[i5 >> 2] | 0) + (i3 + 3) >> 0] = HEAP32[i4 + 44 >> 2];
 i1 = i3 + 4 | 0;
 HEAP8[(HEAP32[i5 >> 2] | 0) + i1 >> 0] = HEAP32[i4 + 32 >> 2] << 5;
 i1 = (HEAP32[i5 >> 2] | 0) + i1 | 0;
 HEAP8[i1 >> 0] = HEAPU8[i1 >> 0] | 0 | HEAP32[i4 + 36 >> 2] & 31;
 HEAP8[(HEAP32[i5 >> 2] | 0) + (i3 + 5) >> 0] = HEAP32[i4 + 40 >> 2] & 31;
 i3 = i4 + 72 | 0;
 _qpacketmodem_encode(HEAP32[i4 + 64 >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i3 >> 2] | 0);
 _qpilotgen_execute(HEAP32[i4 + 76 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i4 + 84 >> 2] | 0);
 _flexframegen_reconfigure(i4);
 _qpacketmodem_encode(HEAP32[i4 + 92 >> 2] | 0, i2, HEAP32[i4 + 100 >> 2] | 0);
 HEAP32[i4 + 112 >> 2] = 1;
 return;
}

function _modem_modulate_sqam128(i1, i9, i10) {
 i1 = i1 | 0;
 i9 = i9 | 0;
 i10 = i10 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i11 = 0, i12 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i4 = i11 + 32 | 0;
 i5 = i11 + 24 | 0;
 i6 = i11 + 16 | 0;
 i7 = i11 + 8 | 0;
 i8 = i11;
 i12 = i9 & 31;
 i1 = HEAP32[i1 + 100 >> 2] | 0;
 d2 = +HEAPF32[i1 + (i12 << 3) >> 2];
 d3 = +HEAPF32[i1 + (i12 << 3) + 4 >> 2];
 switch (i9 >>> 5 & 3 | 0) {
 case 0:
  {
   HEAPF32[i10 >> 2] = d2;
   HEAPF32[i10 + 4 >> 2] = d3;
   STACKTOP = i11;
   return;
  }
 case 1:
  {
   HEAPF32[i6 >> 2] = d2;
   HEAPF32[i6 + 4 >> 2] = d3;
   HEAP32[i4 >> 2] = HEAP32[i6 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
   _conjf(i5, i4);
   i12 = HEAP32[i5 + 4 >> 2] | 0;
   HEAP32[i10 >> 2] = HEAP32[i5 >> 2];
   HEAP32[i10 + 4 >> 2] = i12;
   STACKTOP = i11;
   return;
  }
 case 2:
  {
   HEAPF32[i8 >> 2] = d2;
   HEAPF32[i8 + 4 >> 2] = d3;
   HEAP32[i4 >> 2] = HEAP32[i8 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
   _conjf(i7, i4);
   d3 = -+HEAPF32[i7 + 4 >> 2];
   HEAPF32[i10 >> 2] = -+HEAPF32[i7 >> 2];
   HEAPF32[i10 + 4 >> 2] = d3;
   STACKTOP = i11;
   return;
  }
 case 3:
  {
   HEAPF32[i10 >> 2] = -d2;
   HEAPF32[i10 + 4 >> 2] = -d3;
   STACKTOP = i11;
   return;
  }
 default:
  {}
 }
}

function _modem_modulate_sqam32(i1, i9, i10) {
 i1 = i1 | 0;
 i9 = i9 | 0;
 i10 = i10 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i11 = 0, i12 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i4 = i11 + 32 | 0;
 i5 = i11 + 24 | 0;
 i6 = i11 + 16 | 0;
 i7 = i11 + 8 | 0;
 i8 = i11;
 i12 = i9 & 7;
 i1 = HEAP32[i1 + 100 >> 2] | 0;
 d2 = +HEAPF32[i1 + (i12 << 3) >> 2];
 d3 = +HEAPF32[i1 + (i12 << 3) + 4 >> 2];
 switch (i9 >>> 3 & 3 | 0) {
 case 0:
  {
   HEAPF32[i10 >> 2] = d2;
   HEAPF32[i10 + 4 >> 2] = d3;
   STACKTOP = i11;
   return;
  }
 case 1:
  {
   HEAPF32[i6 >> 2] = d2;
   HEAPF32[i6 + 4 >> 2] = d3;
   HEAP32[i4 >> 2] = HEAP32[i6 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
   _conjf(i5, i4);
   i12 = HEAP32[i5 + 4 >> 2] | 0;
   HEAP32[i10 >> 2] = HEAP32[i5 >> 2];
   HEAP32[i10 + 4 >> 2] = i12;
   STACKTOP = i11;
   return;
  }
 case 2:
  {
   HEAPF32[i8 >> 2] = d2;
   HEAPF32[i8 + 4 >> 2] = d3;
   HEAP32[i4 >> 2] = HEAP32[i8 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
   _conjf(i7, i4);
   d3 = -+HEAPF32[i7 + 4 >> 2];
   HEAPF32[i10 >> 2] = -+HEAPF32[i7 >> 2];
   HEAPF32[i10 + 4 >> 2] = d3;
   STACKTOP = i11;
   return;
  }
 case 3:
  {
   HEAPF32[i10 >> 2] = -d2;
   HEAPF32[i10 + 4 >> 2] = -d3;
   STACKTOP = i11;
   return;
  }
 default:
  {}
 }
}

function _hashtable_find_pair(i6, i4, i7, i5) {
 i6 = i6 | 0;
 i4 = i4 | 0;
 i7 = i7 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i11 + 24 | 0;
 i12 = i11 + 20 | 0;
 i1 = i11 + 16 | 0;
 i2 = i11 + 12 | 0;
 i3 = i11 + 8 | 0;
 i8 = i11 + 4 | 0;
 i10 = i11;
 HEAP32[i12 >> 2] = i6;
 HEAP32[i1 >> 2] = i4;
 HEAP32[i2 >> 2] = i7;
 HEAP32[i3 >> 2] = i5;
 if (_bucket_is_empty(HEAP32[i12 >> 2] | 0, HEAP32[i1 >> 2] | 0) | 0) {
  HEAP32[i9 >> 2] = 0;
  i12 = HEAP32[i9 >> 2] | 0;
  STACKTOP = i11;
  return i12 | 0;
 }
 HEAP32[i8 >> 2] = HEAP32[HEAP32[i1 >> 2] >> 2];
 while (1) {
  HEAP32[i10 >> 2] = HEAP32[i8 >> 2];
  if ((HEAP32[(HEAP32[i10 >> 2] | 0) + 8 >> 2] | 0) == (HEAP32[i3 >> 2] | 0) ? (_strcmp((HEAP32[i10 >> 2] | 0) + 20 | 0, HEAP32[i2 >> 2] | 0) | 0) == 0 : 0) {
   i1 = 6;
   break;
  }
  if ((HEAP32[i8 >> 2] | 0) == (HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] | 0)) {
   i1 = 9;
   break;
  }
  HEAP32[i8 >> 2] = HEAP32[(HEAP32[i8 >> 2] | 0) + 4 >> 2];
 }
 if ((i1 | 0) == 6) {
  HEAP32[i9 >> 2] = HEAP32[i10 >> 2];
  i12 = HEAP32[i9 >> 2] | 0;
  STACKTOP = i11;
  return i12 | 0;
 } else if ((i1 | 0) == 9) {
  HEAP32[i9 >> 2] = 0;
  i12 = HEAP32[i9 >> 2] | 0;
  STACKTOP = i11;
  return i12 | 0;
 }
 return 0;
}

function _firinterp_rrrf_create_prototype(i5, i3, i4, d1, d2) {
 i5 = i5 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 d1 = +d1;
 d2 = +d2;
 var i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i10 + 24 | 0;
 i8 = i10 + 16 | 0;
 i7 = i10 + 8 | 0;
 i6 = i10;
 if (i3 >>> 0 < 2) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 18911;
  _fprintf(i11, gb + 20525 | 0, i6) | 0;
  _exit(1);
 }
 if (!i4) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i7 >> 2] = gb + 18911;
  _fprintf(i11, gb + 20603 | 0, i7) | 0;
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = gb + 18911;
  _fprintf(i11, gb + 20680 | 0, i8) | 0;
  _exit(1);
 }
 if (d2 < -1.0 | d2 > 1.0) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i9 >> 2] = gb + 18911;
  _fprintf(i11, gb + 20769 | 0, i9) | 0;
  _exit(1);
 } else {
  i11 = Math_imul(i3 << 1, i4) | 0 | 1;
  i8 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(i5, i3, i4, d1, d2, i8);
  i9 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i9 | 0, i8 | 0, (Math_imul(i4, i3) | 0) << 3 | 4 | 0) | 0;
  i11 = _firinterp_rrrf_create(i3, i9, i11) | 0;
  STACKTOP = i10;
  return i11 | 0;
 }
 return 0;
}

function _firinterp_crcf_create_prototype(i5, i3, i4, d1, d2) {
 i5 = i5 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 d1 = +d1;
 d2 = +d2;
 var i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i9 = i10 + 24 | 0;
 i8 = i10 + 16 | 0;
 i7 = i10 + 8 | 0;
 i6 = i10;
 if (i3 >>> 0 < 2) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 19656;
  _fprintf(i11, gb + 20525 | 0, i6) | 0;
  _exit(1);
 }
 if (!i4) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i7 >> 2] = gb + 19656;
  _fprintf(i11, gb + 20603 | 0, i7) | 0;
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = gb + 19656;
  _fprintf(i11, gb + 20680 | 0, i8) | 0;
  _exit(1);
 }
 if (d2 < -1.0 | d2 > 1.0) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i9 >> 2] = gb + 19656;
  _fprintf(i11, gb + 20769 | 0, i9) | 0;
  _exit(1);
 } else {
  i11 = Math_imul(i3 << 1, i4) | 0 | 1;
  i8 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(i5, i3, i4, d1, d2, i8);
  i9 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i9 | 0, i8 | 0, (Math_imul(i4, i3) | 0) << 3 | 4 | 0) | 0;
  i11 = _firinterp_crcf_create(i3, i9, i11) | 0;
  STACKTOP = i10;
  return i11 | 0;
 }
 return 0;
}

function _flexframegen_create(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0;
 i1 = _malloc(124) | 0;
 HEAP32[i1 >> 2] = 2;
 HEAP32[i1 + 4 >> 2] = 7;
 HEAPF32[i1 + 8 >> 2] = .25;
 HEAP32[i1 + 12 >> 2] = _firinterp_crcf_create_prototype(7, 2, 7, .25, 0.0) | 0;
 i2 = _malloc(512) | 0;
 HEAP32[i1 + 48 >> 2] = i2;
 i3 = _msequence_create(7, 137, 1) | 0;
 i5 = 0;
 do {
  i7 = (_msequence_advance(i3) | 0) != 0;
  i6 = (_msequence_advance(i3) | 0) != 0;
  HEAPF32[i2 + (i5 << 3) >> 2] = (i7 ? .7071067811865476 : -.7071067811865476) + (i6 ? 0.0 : -0.0);
  HEAPF32[i2 + (i5 << 3) + 4 >> 2] = i6 ? .7071067690849304 : -.7071067690849304;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != 64);
 _msequence_destroy(i3);
 i7 = i1 + 104 | 0;
 HEAP32[i7 >> 2] = 0;
 HEAP32[i7 + 4 >> 2] = 0;
 HEAP32[i7 + 8 >> 2] = 0;
 HEAP32[i7 + 12 >> 2] = 0;
 HEAP32[i7 + 16 >> 2] = 0;
 HEAP32[i1 + 52 >> 2] = 0;
 HEAP32[i1 + 72 >> 2] = 0;
 HEAP32[i1 + 84 >> 2] = 0;
 HEAP32[i1 + 64 >> 2] = 0;
 HEAP32[i1 + 76 >> 2] = 0;
 _flexframegen_set_header_len(i1, 14);
 i7 = _qpacketmodem_create() | 0;
 HEAP32[i1 + 92 >> 2] = i7;
 HEAP32[i1 + 88 >> 2] = 64;
 i7 = _qpacketmodem_get_frame_len(i7) | 0;
 HEAP32[i1 + 96 >> 2] = i7;
 HEAP32[i1 + 100 >> 2] = _malloc(i7 << 3) | 0;
 _flexframegen_setprops(i1, i4) | 0;
 return i1 | 0;
}

function _flexframegen_write_samples(i12, i10, i11) {
 i12 = i12 | 0;
 i10 = i10 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i13 = 0, i14 = 0, i15 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i2 = i14 + 16 | 0;
 i3 = i14 + 8 | 0;
 i4 = i14;
 if (!i11) {
  i13 = i12 + 116 | 0;
  i13 = HEAP32[i13 >> 2] | 0;
  STACKTOP = i14;
  return i13 | 0;
 }
 i5 = i12 + 108 | 0;
 i6 = i3 + 4 | 0;
 i7 = i12 + 12 | 0;
 i8 = i12 + 16 | 0;
 i9 = i4 + 4 | 0;
 i1 = HEAP32[i5 >> 2] | 0;
 i13 = 0;
 do {
  if (!i1) {
   _flexframegen_generate_symbol(i3, i12);
   i15 = HEAP32[i6 >> 2] | 0;
   i1 = HEAP32[i7 >> 2] | 0;
   HEAP32[i4 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i9 >> 2] = i15;
   HEAP32[i2 >> 2] = HEAP32[i4 >> 2];
   HEAP32[i2 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   _firinterp_crcf_execute(i1, i2, i8);
   i1 = HEAP32[i5 >> 2] | 0;
  }
  i15 = HEAP32[i12 + 16 + (i1 << 3) + 4 >> 2] | 0;
  HEAP32[i10 + (i13 << 3) >> 2] = HEAP32[i12 + 16 + (i1 << 3) >> 2];
  HEAP32[i10 + (i13 << 3) + 4 >> 2] = i15;
  i1 = (((HEAP32[i5 >> 2] | 0) + 1 | 0) >>> 0) % ((HEAP32[i12 >> 2] | 0) >>> 0) | 0;
  HEAP32[i5 >> 2] = i1;
  i13 = i13 + 1 | 0;
 } while ((i13 | 0) != (i11 | 0));
 i15 = i12 + 116 | 0;
 i15 = HEAP32[i15 >> 2] | 0;
 STACKTOP = i14;
 return i15 | 0;
}

function _fec_rs_encode(i14, i1, i12, i13) {
 i14 = i14 | 0;
 i1 = i1 | 0;
 i12 = i12 | 0;
 i13 = i13 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 if (!i1) {
  _fwrite(gb + 18012 | 0, 49, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 _fec_rs_setlength(i14, i1);
 i7 = i14 + 104 | 0;
 i8 = i14 + 100 | 0;
 i1 = HEAP32[i8 >> 2] | 0;
 if (!i1) {
  i2 = 0;
  i1 = 0;
 } else {
  i9 = i14 + 112 | 0;
  i10 = i14 + 120 | 0;
  i11 = i14 + 96 | 0;
  i6 = i14 + 108 | 0;
  i4 = i1;
  i3 = HEAP32[i7 >> 2] | 0;
  i5 = 0;
  i2 = 0;
  i1 = 0;
  do {
   if ((i5 | 0) == (i4 + -1 | 0)) i3 = i3 - (HEAP32[i9 >> 2] | 0) | 0;
   _memmove(HEAP32[i10 >> 2] | 0, i12 + i2 | 0, i3 | 0) | 0;
   i4 = HEAP32[i10 >> 2] | 0;
   _encode_rs_char(HEAP32[i11 >> 2] | 0, i4 | 0, i4 + (HEAP32[i7 >> 2] | 0) | 0);
   _memmove(i13 + i1 | 0, HEAP32[i10 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
   i2 = i3 + i2 | 0;
   i1 = (HEAP32[i6 >> 2] | 0) + i1 | 0;
   i5 = i5 + 1 | 0;
   i4 = HEAP32[i8 >> 2] | 0;
  } while (i5 >>> 0 < i4 >>> 0);
 }
 if ((i2 | 0) != (HEAP32[i14 + 8 >> 2] | 0)) ___assert_fail(gb + 18062 | 0, gb + 18086 | 0, 131, gb + 18107 | 0);
 if ((i1 | 0) == (HEAP32[i14 + 12 >> 2] | 0)) return; else ___assert_fail(gb + 18121 | 0, gb + 18086 | 0, 132, gb + 18107 | 0);
}

function _packetizer_encode(i6, i1, i7) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0;
 i5 = i6 + 28 | 0;
 _memmove(HEAP32[i5 >> 2] | 0, i1 | 0, HEAP32[i6 >> 2] | 0) | 0;
 i2 = _crc_generate_key(HEAP32[i6 + 8 >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
 i4 = i6 + 12 | 0;
 i1 = HEAP32[i4 >> 2] | 0;
 if (i1 | 0) {
  i3 = 0;
  while (1) {
   HEAP8[(HEAP32[i5 >> 2] | 0) + (i1 + ~i3 + (HEAP32[i6 >> 2] | 0)) >> 0] = i2;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i4 >> 2] | 0;
   if (i3 >>> 0 >= i1 >>> 0) break; else i2 = i2 >>> 8;
  }
 }
 i1 = i6 + 20 | 0;
 if (!(HEAP32[i1 >> 2] | 0)) {
  i5 = HEAP32[i5 >> 2] | 0;
  i6 = i6 + 4 | 0;
  i6 = HEAP32[i6 >> 2] | 0;
  _memmove(i7 | 0, i5 | 0, i6 | 0) | 0;
  return;
 }
 i2 = i6 + 16 | 0;
 i3 = i6 + 32 | 0;
 i4 = 0;
 do {
  i8 = HEAP32[i2 >> 2] | 0;
  _fec_encode(HEAP32[i8 + (i4 * 20 | 0) + 12 >> 2] | 0, HEAP32[i8 + (i4 * 20 | 0) >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i3 >> 2] | 0);
  _interleaver_encode(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 * 20 | 0) + 16 >> 2] | 0, HEAP32[i3 >> 2] | 0, HEAP32[i5 >> 2] | 0);
  i4 = i4 + 1 | 0;
 } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 i5 = HEAP32[i5 >> 2] | 0;
 i8 = i6 + 4 | 0;
 i8 = HEAP32[i8 >> 2] | 0;
 _memmove(i7 | 0, i5 | 0, i8 | 0) | 0;
 return;
}

function _modem_demodulate_psk(i11, i1, i12) {
 i11 = i11 | 0;
 i1 = i1 | 0;
 i12 = i12 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i13 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i13 + 8 | 0;
 i8 = i13;
 i10 = HEAP32[i1 >> 2] | 0;
 i9 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i8 >> 2] = i10;
 HEAP32[i8 + 4 >> 2] = i9;
 HEAP32[i7 >> 2] = HEAP32[i8 >> 2];
 HEAP32[i7 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
 d2 = +_cargf(i7);
 d2 = d2 - +HEAPF32[i11 + 100 >> 2];
 d3 = d2;
 i7 = HEAP32[i11 + 4 >> 2] | 0;
 if (!i7) i1 = 0; else {
  i8 = i7 + -1 | 0;
  d2 = d3 < -3.141592653589793 ? d3 + 6.283185307179586 : d2;
  i5 = 0;
  i6 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i11 + 12 + (i5 + i8 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i11 + 12 + (i5 + i8 << 2) >> 2];
   i4 = i6 + 1 | 0;
   if ((i4 | 0) == (i7 | 0)) break; else {
    i5 = ~i6;
    i6 = i4;
   }
  }
 }
 i8 = _gray_encode(i1) | 0;
 HEAP32[i12 >> 2] = i8;
 d2 = +((_gray_decode(i8) | 0) << 1 >>> 0);
 d2 = +HEAPF32[i11 + 104 >> 2] * d2;
 d3 = +Math_sin(+d2);
 HEAPF32[i11 + 92 >> 2] = +Math_cos(+d2) + d3 * 0.0;
 HEAPF32[i11 + 96 >> 2] = d3;
 HEAP32[i11 + 84 >> 2] = i10;
 HEAP32[i11 + 88 >> 2] = i9;
 STACKTOP = i13;
 return;
}

function _fec_rs_setlength(i7, i3) {
 i7 = i7 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i8 + 8 | 0;
 i2 = i8;
 i4 = i7 + 8 | 0;
 if ((HEAP32[i4 >> 2] | 0) == (i3 | 0)) {
  STACKTOP = i8;
  return;
 }
 HEAP32[i4 >> 2] = i3;
 i9 = i7 + 92 | 0;
 _div(i1, i3, HEAP32[i9 >> 2] | 0);
 i1 = ((HEAP32[i1 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i1 >> 2] | 0) | 0;
 i10 = i7 + 100 | 0;
 HEAP32[i10 >> 2] = i1;
 _div(i2, i3, i1);
 i1 = ((HEAP32[i2 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i2 >> 2] | 0) | 0;
 HEAP32[i7 + 104 >> 2] = i1;
 i5 = i7 + 80 | 0;
 i2 = HEAP32[i5 >> 2] | 0;
 i6 = i1 + i2 | 0;
 HEAP32[i7 + 108 >> 2] = i6;
 i3 = HEAP32[i10 >> 2] | 0;
 i10 = Math_imul(i1, i3) | 0;
 HEAP32[i7 + 112 >> 2] = (i10 >>> 0) % ((HEAP32[i4 >> 2] | 0) >>> 0) | 0;
 i1 = (HEAP32[i9 >> 2] | 0) - i1 | 0;
 i4 = i7 + 116 | 0;
 HEAP32[i4 >> 2] = i1;
 HEAP32[i7 + 12 >> 2] = Math_imul(i3, i6) | 0;
 i6 = i7 + 96 | 0;
 i3 = HEAP32[i6 >> 2] | 0;
 if (i3) {
  _free_rs_char(i3 | 0);
  i2 = HEAP32[i5 >> 2] | 0;
  i1 = HEAP32[i4 >> 2] | 0;
 }
 HEAP32[i6 >> 2] = _init_rs_char(HEAP32[i7 + 64 >> 2] | 0, HEAP32[i7 + 68 >> 2] | 0, HEAP32[i7 + 72 >> 2] | 0, HEAP32[i7 + 76 >> 2] | 0, i2 | 0, i1 | 0) | 0;
 STACKTOP = i8;
 return;
}

function _firinterp_rrrf_create(i9, i7, i8) {
 i9 = i9 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i10 + 8 | 0;
 i1 = i10;
 if (i9 >>> 0 < 2) {
  i6 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 18911;
  _fprintf(i6, gb + 20012 | 0, i1) | 0;
  _exit(1);
 }
 if (i8 >>> 0 < i9 >>> 0) {
  i6 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 18911;
  _fprintf(i6, gb + 20080 | 0, i2) | 0;
  _exit(1);
 }
 i6 = _malloc(20) | 0;
 HEAP32[i6 + 12 >> 2] = i9;
 i4 = i6 + 4 | 0;
 HEAP32[i4 >> 2] = i8;
 i5 = i6 + 8 | 0;
 i2 = 0;
 while (1) {
  i1 = Math_imul(i2, i9) | 0;
  if (i1 >>> 0 < i8 >>> 0) i2 = i2 + 1 | 0; else break;
 }
 HEAP32[i5 >> 2] = i2;
 HEAP32[i4 >> 2] = i1;
 i4 = _malloc(i1 << 2) | 0;
 HEAP32[i6 >> 2] = i4;
 if (!i1) {
  i8 = 0;
  i8 = _firpfb_rrrf_create(i9, i4, i8) | 0;
  i9 = i6 + 16 | 0;
  HEAP32[i9 >> 2] = i8;
  STACKTOP = i10;
  return i6 | 0;
 } else i2 = 0;
 do {
  if (i2 >>> 0 < i8 >>> 0) d3 = +HEAPF32[i7 + (i2 << 2) >> 2]; else d3 = 0.0;
  HEAPF32[i4 + (i2 << 2) >> 2] = d3;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 i8 = _firpfb_rrrf_create(i9, i4, i1) | 0;
 i9 = i6 + 16 | 0;
 HEAP32[i9 >> 2] = i8;
 STACKTOP = i10;
 return i6 | 0;
}

function _firinterp_crcf_create(i9, i7, i8) {
 i9 = i9 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i10 + 8 | 0;
 i1 = i10;
 if (i9 >>> 0 < 2) {
  i6 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 19656;
  _fprintf(i6, gb + 20012 | 0, i1) | 0;
  _exit(1);
 }
 if (i8 >>> 0 < i9 >>> 0) {
  i6 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 19656;
  _fprintf(i6, gb + 20080 | 0, i2) | 0;
  _exit(1);
 }
 i6 = _malloc(20) | 0;
 HEAP32[i6 + 12 >> 2] = i9;
 i4 = i6 + 4 | 0;
 HEAP32[i4 >> 2] = i8;
 i5 = i6 + 8 | 0;
 i2 = 0;
 while (1) {
  i1 = Math_imul(i2, i9) | 0;
  if (i1 >>> 0 < i8 >>> 0) i2 = i2 + 1 | 0; else break;
 }
 HEAP32[i5 >> 2] = i2;
 HEAP32[i4 >> 2] = i1;
 i4 = _malloc(i1 << 2) | 0;
 HEAP32[i6 >> 2] = i4;
 if (!i1) {
  i8 = 0;
  i8 = _firpfb_crcf_create(i9, i4, i8) | 0;
  i9 = i6 + 16 | 0;
  HEAP32[i9 >> 2] = i8;
  STACKTOP = i10;
  return i6 | 0;
 } else i2 = 0;
 do {
  if (i2 >>> 0 < i8 >>> 0) d3 = +HEAPF32[i7 + (i2 << 2) >> 2]; else d3 = 0.0;
  HEAPF32[i4 + (i2 << 2) >> 2] = d3;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 i8 = _firpfb_crcf_create(i9, i4, i1) | 0;
 i9 = i6 + 16 | 0;
 HEAP32[i9 >> 2] = i8;
 STACKTOP = i10;
 return i6 | 0;
}

function _ofdmflexframegen_write_header(i11, i10) {
 i11 = i11 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 if (!(HEAP32[i11 >> 2] | 0)) i1 = i11 + 36 | 0; else {
  i4 = i11 + 12 | 0;
  i5 = i11 + 132 | 0;
  i6 = i11 + 84 | 0;
  i7 = i11 + 52 | 0;
  i8 = i11 + 68 | 0;
  i1 = i11 + 36 | 0;
  i9 = 0;
  do {
   do if ((HEAP8[(HEAP32[i4 >> 2] | 0) + i9 >> 0] | 0) == 2) {
    i2 = HEAP32[i5 >> 2] | 0;
    i3 = HEAP32[i7 >> 2] | 0;
    if (i2 >>> 0 < (HEAP32[i6 >> 2] | 0) >>> 0) {
     HEAP32[i5 >> 2] = i2 + 1;
     _modem_modulate(i3, HEAPU8[(HEAP32[i8 >> 2] | 0) + i2 >> 0] | 0, (HEAP32[i1 >> 2] | 0) + (i9 << 3) | 0);
     break;
    } else {
     i3 = _modem_gen_rand_sym(i3) | 0;
     _modem_modulate(HEAP32[i7 >> 2] | 0, i3, (HEAP32[i1 >> 2] | 0) + (i9 << 3) | 0);
     break;
    }
   } else {
    i3 = HEAP32[i1 >> 2] | 0;
    HEAPF32[i3 + (i9 << 3) >> 2] = 0.0;
    HEAPF32[i3 + (i9 << 3) + 4 >> 2] = 0.0;
   } while (0);
   i9 = i9 + 1 | 0;
  } while (i9 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0);
 }
 _ofdmframegen_writesymbol(HEAP32[i11 + 40 >> 2] | 0, HEAP32[i1 >> 2] | 0, i10);
 i1 = i11 + 116 | 0;
 if ((HEAP32[i1 >> 2] | 0) != (HEAP32[i11 + 44 >> 2] | 0)) return;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i11 + 120 >> 2] = 4;
 return;
}

function _fec_secded7264_compute_syndrome(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i4 = HEAPU8[i1 >> 0] | 0;
 i8 = HEAP8[i1 + 1 >> 0] | 0;
 i9 = HEAP8[i1 + 2 >> 0] | 0;
 i10 = HEAP8[i1 + 3 >> 0] | 0;
 i11 = HEAP8[i1 + 4 >> 0] | 0;
 i5 = HEAP8[i1 + 5 >> 0] | 0;
 i6 = HEAP8[i1 + 6 >> 0] | 0;
 i7 = HEAP8[i1 + 7 >> 0] | 0;
 i2 = HEAP8[i1 + 8 >> 0] | 0;
 i3 = 0;
 i1 = 0;
 do {
  i12 = i3 << 3;
  i1 = ((i4 & 1 << 7 - i3 | 0) != 0 & 1) + (HEAPU8[(i8 & HEAP8[gb + 18620 + i12 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i9 & HEAP8[(i12 | 1) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i10 & HEAP8[(i12 | 2) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i11 & HEAP8[(i12 | 3) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i5 & HEAP8[(i12 | 4) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i6 & HEAP8[(i12 | 5) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i7 & HEAP8[(i12 | 6) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[(i12 | 7) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | i1 << 1 & 510;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 8);
 return i1 & 255 | 0;
}

function _quiet_encoder_set_payload(i5, i6, i7) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0;
 i3 = i5 + 136 | 0;
 i4 = i5 + 60 | 0;
 do if (!(HEAP32[i3 >> 2] | 0)) {
  switch (HEAP32[i4 >> 2] | 0) {
  case 0:
   {
    i1 = _ofdmflexframegen_is_assembled(HEAP32[i5 + 96 >> 2] | 0) | 0;
    i2 = 6;
    break;
   }
  case 1:
   {
    i1 = _flexframegen_is_assembled(HEAP32[i5 + 96 >> 2] | 0) | 0;
    i2 = 6;
    break;
   }
  case 2:
   {
    i1 = _gmskframegen_is_assembled(HEAP32[i5 + 96 >> 2] | 0) | 0;
    i2 = 6;
    break;
   }
  default:
   {}
  }
  if ((i2 | 0) == 6 ? i1 | 0 : 0) {
   i1 = 1;
   break;
  }
  i1 = (HEAP32[i5 + 124 >> 2] | 0) != 0;
 } else i1 = 1; while (0);
 i1 = i1 & 1;
 HEAP32[i5 + 132 >> 2] = i6;
 HEAP32[i3 >> 2] = i7;
 HEAP32[i5 + 124 >> 2] = 0;
 HEAP32[i5 + 128 >> 2] = 0;
 HEAP8[i5 + 140 >> 0] = 0;
 _modulator_reset(HEAP32[i5 + 104 >> 2] | 0);
 switch (HEAP32[i4 >> 2] | 0) {
 case 0:
  {
   _ofdmflexframegen_reset(HEAP32[i5 + 96 >> 2] | 0);
   return i1 | 0;
  }
 case 1:
  {
   _flexframegen_reset(HEAP32[i5 + 96 >> 2] | 0);
   HEAP32[i5 + 100 >> 2] = 0;
   return i1 | 0;
  }
 case 2:
  {
   _gmskframegen_reset(HEAP32[i5 + 96 >> 2] | 0);
   return i1 | 0;
  }
 default:
  return i1 | 0;
 }
 return 0;
}

function _qpacketmodem_decode(i12, i8, i11) {
 i12 = i12 | 0;
 i8 = i8 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0, i13 = 0, i14 = 0, i15 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i2 = i13 + 16 | 0;
 i10 = i13 + 8 | 0;
 i3 = i13;
 i4 = i12 + 32 | 0;
 if (!(HEAP32[i4 >> 2] | 0)) {
  i9 = i12 + 16 | 0;
  i10 = i12 + 4 | 0;
  i10 = HEAP32[i10 >> 2] | 0;
  i12 = HEAP32[i9 >> 2] | 0;
  i12 = _packetizer_decode(i10, i12, i11) | 0;
  STACKTOP = i13;
  return i12 | 0;
 }
 i5 = i3 + 4 | 0;
 i1 = i12 + 16 | 0;
 i6 = i12 + 24 | 0;
 i7 = i12 + 8 | 0;
 i9 = 0;
 do {
  i14 = HEAP32[i12 >> 2] | 0;
  i15 = HEAP32[i8 + (i9 << 3) + 4 >> 2] | 0;
  HEAP32[i3 >> 2] = HEAP32[i8 + (i9 << 3) >> 2];
  HEAP32[i5 >> 2] = i15;
  HEAP32[i2 >> 2] = HEAP32[i3 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
  _modem_demodulate(i14, i2, i10);
  i14 = HEAP32[i7 >> 2] | 0;
  i15 = Math_imul(i14, i9) | 0;
  _liquid_pack_array(HEAP32[i1 >> 2] | 0, HEAP32[i6 >> 2] | 0, i15, i14, HEAP32[i10 >> 2] | 0);
  i9 = i9 + 1 | 0;
 } while (i9 >>> 0 < (HEAP32[i4 >> 2] | 0) >>> 0);
 i14 = i12 + 4 | 0;
 i14 = HEAP32[i14 >> 2] | 0;
 i15 = HEAP32[i1 >> 2] | 0;
 i15 = _packetizer_decode(i14, i15, i11) | 0;
 STACKTOP = i13;
 return i15 | 0;
}

function _ofdmframe_init_S1(i4, i10, i8, i11, i7) {
 i4 = i4 | 0;
 i10 = i10 | 0;
 i8 = i8 | 0;
 i11 = i11 | 0;
 i7 = i7 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i5 = 0, i6 = 0, i9 = 0, d12 = 0.0;
 i6 = _liquid_nextpow2(i10) | 0;
 i6 = _msequence_create_default(i6 >>> 0 < 4 ? 5 : (i6 >>> 0 > 8 ? 8 : i6) + 1 | 0) | 0;
 i9 = (i10 | 0) == 0;
 if (i9) {
  _msequence_destroy(i6);
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 34770 | 0, 69, 1, i3) | 0;
  _exit(1);
 } else {
  i1 = 0;
  i5 = 0;
 }
 do {
  i3 = _msequence_generate_symbol(i6, 3) | 0;
  if (!(HEAP8[i4 + i5 >> 0] | 0)) d2 = 0.0; else {
   d2 = i3 & 1 | 0 ? 1.0 : -1.0;
   i1 = i1 + 1 | 0;
  }
  HEAPF32[i8 + (i5 << 3) >> 2] = d2;
  HEAPF32[i8 + (i5 << 3) + 4 >> 2] = 0.0;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i10 | 0));
 _msequence_destroy(i6);
 if (!i1) {
  i6 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 34770 | 0, 69, 1, i6) | 0;
  _exit(1);
 }
 HEAP32[i7 >> 2] = i1;
 _fft_run(i10, i8, i11, -1, 0);
 d2 = 1.0 / +Math_sqrt(+(+(i1 >>> 0)));
 if (i9) return; else i1 = 0;
 do {
  i8 = i11 + (i1 << 3) | 0;
  i9 = i11 + (i1 << 3) + 4 | 0;
  d12 = d2 * +HEAPF32[i9 >> 2];
  HEAPF32[i8 >> 2] = d2 * +HEAPF32[i8 >> 2];
  HEAPF32[i9 >> 2] = d12;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i10 | 0));
 return;
}

function _ofdmflexframegen_write_payload(i11, i10) {
 i11 = i11 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 if (!(HEAP32[i11 >> 2] | 0)) i1 = i11 + 36 | 0; else {
  i4 = i11 + 12 | 0;
  i5 = i11 + 136 | 0;
  i6 = i11 + 112 | 0;
  i7 = i11 + 96 | 0;
  i8 = i11 + 104 | 0;
  i1 = i11 + 36 | 0;
  i9 = 0;
  do {
   do if ((HEAP8[(HEAP32[i4 >> 2] | 0) + i9 >> 0] | 0) == 2) {
    i2 = HEAP32[i5 >> 2] | 0;
    i3 = HEAP32[i7 >> 2] | 0;
    if (i2 >>> 0 < (HEAP32[i6 >> 2] | 0) >>> 0) {
     HEAP32[i5 >> 2] = i2 + 1;
     _modem_modulate(i3, HEAP32[(HEAP32[i8 >> 2] | 0) + (i2 << 2) >> 2] | 0, (HEAP32[i1 >> 2] | 0) + (i9 << 3) | 0);
     break;
    } else {
     i3 = _modem_gen_rand_sym(i3) | 0;
     _modem_modulate(HEAP32[i7 >> 2] | 0, i3, (HEAP32[i1 >> 2] | 0) + (i9 << 3) | 0);
     break;
    }
   } else {
    i3 = HEAP32[i1 >> 2] | 0;
    HEAPF32[i3 + (i9 << 3) >> 2] = 0.0;
    HEAPF32[i3 + (i9 << 3) + 4 >> 2] = 0.0;
   } while (0);
   i9 = i9 + 1 | 0;
  } while (i9 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0);
 }
 _ofdmframegen_writesymbol(HEAP32[i11 + 40 >> 2] | 0, HEAP32[i1 >> 2] | 0, i10);
 if ((HEAP32[i11 + 116 >> 2] | 0) != (HEAP32[i11 + 48 >> 2] | 0)) return;
 HEAP32[i11 + 128 >> 2] = 1;
 return;
}

function _fec_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i4;
 i1 = HEAP32[i2 >> 2] | 0;
 do switch (i1 | 0) {
 case 0:
  {
   _puts(gb + 12278 | 0) | 0;
   _exit(-1);
   break;
  }
 case 1:
  {
   _fec_pass_destroy(i2);
   break;
  }
 case 2:
  {
   _fec_rep3_destroy(i2);
   break;
  }
 case 3:
  {
   _fec_rep5_destroy(i2);
   break;
  }
 case 4:
  {
   _fec_hamming74_destroy(i2);
   break;
  }
 case 5:
  {
   _fec_hamming84_destroy(i2);
   break;
  }
 case 6:
  {
   _fec_hamming128_destroy(i2);
   break;
  }
 case 7:
  {
   _fec_golay2412_destroy(i2);
   break;
  }
 case 8:
  {
   _fec_secded2216_destroy(i2);
   break;
  }
 case 9:
  {
   _fec_secded3932_destroy(i2);
   break;
  }
 case 10:
  {
   _fec_secded7264_destroy(i2);
   break;
  }
 case 14:
 case 13:
 case 12:
 case 11:
  {
   _fec_conv_destroy(i2);
   break;
  }
 case 26:
 case 25:
 case 24:
 case 23:
 case 22:
 case 21:
 case 20:
 case 19:
 case 18:
 case 17:
 case 16:
 case 15:
  {
   _fec_conv_punctured_destroy(i2);
   break;
  }
 case 27:
  {
   _fec_rs_destroy(i2);
   break;
  }
 default:
  {
   HEAP32[i3 >> 2] = i1;
   _printf(gb + 12344 | 0, i3) | 0;
   _exit(-1);
  }
 } while (0);
 STACKTOP = i4;
 return;
}

function _fpoly_bessel_roots_orchard_recursion(i15, d3, d1, i17, i18) {
 i15 = i15 | 0;
 d3 = +d3;
 d1 = +d1;
 i17 = i17 | 0;
 i18 = i18 | 0;
 var i2 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, i16 = 0;
 if (i15 >>> 0 < 2) {
  _fwrite(gb + 40043 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i16 = 0;
 while (1) {
  d6 = d3 * d3 - d1 * d1;
  d9 = d3 * 2.0 * d1;
  i10 = 2;
  d11 = 1.0;
  d12 = d3 + 1.0;
  d13 = 0.0;
  d14 = d1;
  while (1) {
   d7 = +(((i10 << 1) + -1 | 0) >>> 0);
   d8 = d12 * d7 + d6 * d11 - d9 * d13;
   d7 = d9 * d11 + (d6 * d13 + d14 * d7);
   i2 = i10 >>> 0 < i15 >>> 0;
   d4 = i2 ? d7 : d14;
   d5 = i2 ? d8 : d12;
   i10 = i10 + 1 | 0;
   if (i10 >>> 0 > i15 >>> 0) break; else {
    d11 = i2 ? d12 : d11;
    d12 = d5;
    d13 = i2 ? d14 : d13;
    d14 = d4;
   }
  }
  d6 = d1 * d4 + (d8 - d3 * d5);
  d4 = d7 - d3 * d4 - d1 * d5;
  d5 = d4 * d4 + d6 * d6;
  if (d5 == 0.0) {
   i2 = 8;
   break;
  }
  d3 = d3 + -(d7 * d4 + d8 * d6) / d5;
  d1 = d1 + -(d7 * d6 - d8 * d4) / d5;
  i16 = i16 + 1 | 0;
  if (i16 >>> 0 >= 50) {
   i2 = 8;
   break;
  }
 }
 if ((i2 | 0) == 8) {
  HEAPF32[i17 >> 2] = d3;
  HEAPF32[i18 >> 2] = d1;
  return;
 }
}

function _json_object_set_new_nocheck(i5, i6, i8) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i9 + 16 | 0;
 i2 = i9 + 12 | 0;
 i3 = i9 + 8 | 0;
 i4 = i9 + 4 | 0;
 i7 = i9;
 HEAP32[i2 >> 2] = i5;
 HEAP32[i3 >> 2] = i6;
 HEAP32[i4 >> 2] = i8;
 if (!(HEAP32[i4 >> 2] | 0)) {
  HEAP32[i1 >> 2] = -1;
  i8 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i9;
  return i8 | 0;
 }
 if (((HEAP32[i3 >> 2] | 0) != 0 & (HEAP32[i2 >> 2] | 0) != 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 0 : 0) ? (HEAP32[i2 >> 2] | 0) != (HEAP32[i4 >> 2] | 0) : 0) {
  HEAP32[i7 >> 2] = HEAP32[i2 >> 2];
  i5 = (HEAP32[i7 >> 2] | 0) + 8 | 0;
  i6 = HEAP32[i3 >> 2] | 0;
  i7 = (HEAP32[i7 >> 2] | 0) + 28 | 0;
  i8 = HEAP32[i7 >> 2] | 0;
  HEAP32[i7 >> 2] = i8 + 1;
  if (_hashtable_set(i5, i6, i8, HEAP32[i4 >> 2] | 0) | 0) {
   _json_decref_1902(HEAP32[i4 >> 2] | 0);
   HEAP32[i1 >> 2] = -1;
   i8 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i9;
   return i8 | 0;
  } else {
   HEAP32[i1 >> 2] = 0;
   i8 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i9;
   return i8 | 0;
  }
 }
 _json_decref_1902(HEAP32[i4 >> 2] | 0);
 HEAP32[i1 >> 2] = -1;
 i8 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i9;
 return i8 | 0;
}

function _string_create(i4, i2, i3) {
 i4 = i4 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i10 + 20 | 0;
 i1 = i10 + 16 | 0;
 i6 = i10 + 12 | 0;
 i7 = i10 + 8 | 0;
 i9 = i10 + 4 | 0;
 i8 = i10;
 HEAP32[i1 >> 2] = i4;
 HEAP32[i6 >> 2] = i2;
 HEAP32[i7 >> 2] = i3;
 if (!(HEAP32[i1 >> 2] | 0)) {
  HEAP32[i5 >> 2] = 0;
  i9 = HEAP32[i5 >> 2] | 0;
  STACKTOP = i10;
  return i9 | 0;
 }
 i1 = HEAP32[i1 >> 2] | 0;
 if (!(HEAP32[i7 >> 2] | 0)) {
  HEAP32[i9 >> 2] = _jsonp_strndup(i1, HEAP32[i6 >> 2] | 0) | 0;
  if (!(HEAP32[i9 >> 2] | 0)) {
   HEAP32[i5 >> 2] = 0;
   i9 = HEAP32[i5 >> 2] | 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 } else HEAP32[i9 >> 2] = i1;
 HEAP32[i8 >> 2] = _jsonp_malloc(16) | 0;
 if (HEAP32[i8 >> 2] | 0) {
  _json_init(HEAP32[i8 >> 2] | 0, 2);
  HEAP32[(HEAP32[i8 >> 2] | 0) + 8 >> 2] = HEAP32[i9 >> 2];
  HEAP32[(HEAP32[i8 >> 2] | 0) + 12 >> 2] = HEAP32[i6 >> 2];
  HEAP32[i5 >> 2] = HEAP32[i8 >> 2];
  i9 = HEAP32[i5 >> 2] | 0;
  STACKTOP = i10;
  return i9 | 0;
 }
 if (!(HEAP32[i7 >> 2] | 0)) _jsonp_free(HEAP32[i9 >> 2] | 0);
 HEAP32[i5 >> 2] = 0;
 i9 = HEAP32[i5 >> 2] | 0;
 STACKTOP = i10;
 return i9 | 0;
}

function _ofdmflexframegen_set_header_len(i5, i1) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i7 + 8 | 0;
 i6 = i7;
 HEAP32[i5 + 72 >> 2] = i1;
 i3 = i1 + 6 | 0;
 i1 = i5 + 76 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i5 + 60 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i5 + 56 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _packetizer_destroy(i3);
 i3 = _packetizer_create(HEAP32[i1 >> 2] | 0, 6, 7, 1) | 0;
 HEAP32[i2 >> 2] = i3;
 i2 = _packetizer_get_enc_msg_len(i3) | 0;
 i3 = i5 + 80 | 0;
 HEAP32[i3 >> 2] = i2;
 i1 = i5 + 64 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i2) | 0;
 _div(i4, HEAP32[i3 >> 2] << 3, HEAP32[gb + 580 + 764 >> 2] | 0);
 i3 = ((HEAP32[i4 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i4 >> 2] | 0) | 0;
 i1 = i5 + 84 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i5 + 68 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i5 + 52 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _modem_destroy(i3);
 HEAP32[i2 >> 2] = _modem_create(47) | 0;
 _div(i6, HEAP32[i1 >> 2] | 0, HEAP32[i5 + 24 >> 2] | 0);
 HEAP32[i5 + 44 >> 2] = ((HEAP32[i6 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i6 >> 2] | 0);
 STACKTOP = i7;
 return;
}

function _ofdmflexframegen_writesymbol(i4, i3) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0;
 if (!(HEAP32[i4 + 124 >> 2] | 0)) {
  _fwrite(gb + 28173 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  i4 = 1;
  return i4 | 0;
 }
 i1 = i4 + 116 | 0;
 HEAP32[i1 >> 2] = (HEAP32[i1 >> 2] | 0) + 1;
 i2 = i4 + 120 | 0;
 switch (HEAP32[i2 >> 2] | 0) {
 case 0:
  {
   _ofdmframegen_write_S0a(HEAP32[i4 + 40 >> 2] | 0, i3);
   HEAP32[i2 >> 2] = 1;
   break;
  }
 case 1:
  {
   _ofdmframegen_write_S0b(HEAP32[i4 + 40 >> 2] | 0, i3);
   HEAP32[i2 >> 2] = 2;
   break;
  }
 case 2:
  {
   _ofdmframegen_write_S1(HEAP32[i4 + 40 >> 2] | 0, i3);
   HEAP32[i1 >> 2] = 0;
   HEAP32[i2 >> 2] = 3;
   break;
  }
 case 3:
  {
   _ofdmflexframegen_write_header(i4, i3);
   break;
  }
 case 4:
  {
   _ofdmflexframegen_write_payload(i4, i3);
   break;
  }
 default:
  {
   _fwrite(gb + 28235 | 0, 74, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 if (!(HEAP32[i4 + 128 >> 2] | 0)) {
  i4 = 0;
  return i4 | 0;
 }
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 HEAP32[i1 + 16 >> 2] = 0;
 HEAP32[i1 + 20 >> 2] = 0;
 _ofdmframegen_reset(HEAP32[i4 + 40 >> 2] | 0);
 i4 = 1;
 return i4 | 0;
}

function _liquid_unpack_array_block(i11, i10, i9, i14, i15) {
 i11 = i11 | 0;
 i10 = i10 | 0;
 i9 = i9 | 0;
 i14 = i14 | 0;
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i12 = 0, i13 = 0, i16 = 0;
 i7 = i10 << 3;
 if (!((i14 | 0) != 0 & (i7 | 0) != 0)) return;
 if (!i9) {
  i1 = (i7 | 0) != 0;
  i2 = 0;
  do {
   HEAP32[i15 + (i2 << 2) >> 2] = 0;
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < i14 >>> 0 & i1);
  return;
 } else {
  i12 = 0;
  i13 = 0;
 }
 do {
  i8 = i15 + (i12 << 2) | 0;
  i1 = i13 >>> 3;
  if (i1 >>> 0 < i10 >>> 0) {
   i6 = i9;
   i2 = i13 - (i1 << 3) | 0;
   i5 = i1;
   i1 = 0;
   while (1) {
    i3 = 8 - i2 | 0;
    i16 = i6 >>> 0 < i3 >>> 0 ? i6 : i3;
    i1 = 255 >>> (8 - i16 | 0) & 255 & (HEAPU8[i11 + i5 >> 0] | 0) >>> (i3 - i16 | 0) | i1 << i16;
    i3 = i16 + i2 | 0;
    i4 = i3 >>> 0 > 7;
    i5 = (i4 & 1) + i5 | 0;
    i2 = i6 - i16 | 0;
    if (!((i6 | 0) != (i16 | 0) & i5 >>> 0 < i10 >>> 0)) break; else {
     i6 = i2;
     i2 = i4 ? i3 & 7 : i3;
    }
   }
  } else {
   i2 = i9;
   i1 = 0;
  }
  HEAP32[i8 >> 2] = i1 << i2;
  i12 = i12 + 1 | 0;
  i13 = i13 + i9 | 0;
 } while (i12 >>> 0 < i14 >>> 0 & i13 >>> 0 < i7 >>> 0);
 return;
}

function _json_array_append_new(i3, i4) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i7 + 12 | 0;
 i1 = i7 + 8 | 0;
 i2 = i7 + 4 | 0;
 i6 = i7;
 HEAP32[i1 >> 2] = i3;
 HEAP32[i2 >> 2] = i4;
 if (!(HEAP32[i2 >> 2] | 0)) {
  HEAP32[i5 >> 2] = -1;
  i6 = HEAP32[i5 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 if ((HEAP32[i1 >> 2] | 0 ? (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) == 1 : 0) ? (HEAP32[i1 >> 2] | 0) != (HEAP32[i2 >> 2] | 0) : 0) {
  HEAP32[i6 >> 2] = HEAP32[i1 >> 2];
  i4 = (_json_array_grow(HEAP32[i6 >> 2] | 0, 1, 1) | 0) != 0;
  i1 = HEAP32[i2 >> 2] | 0;
  if (i4) {
   HEAP32[(HEAP32[(HEAP32[i6 >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[(HEAP32[i6 >> 2] | 0) + 12 >> 2] << 2) >> 2] = i1;
   i6 = (HEAP32[i6 >> 2] | 0) + 12 | 0;
   HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + 1;
   HEAP32[i5 >> 2] = 0;
   i6 = HEAP32[i5 >> 2] | 0;
   STACKTOP = i7;
   return i6 | 0;
  } else {
   _json_decref_1902(i1);
   HEAP32[i5 >> 2] = -1;
   i6 = HEAP32[i5 >> 2] | 0;
   STACKTOP = i7;
   return i6 | 0;
  }
 }
 _json_decref_1902(HEAP32[i2 >> 2] | 0);
 HEAP32[i5 >> 2] = -1;
 i6 = HEAP32[i5 >> 2] | 0;
 STACKTOP = i7;
 return i6 | 0;
}

function _fec_conv_decode_soft(i7, i1, i6, i5) {
 i7 = i7 | 0;
 i1 = i1 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i4 = i7 + 8 | 0;
 if ((HEAP32[i4 >> 2] | 0) == (i1 | 0)) i1 = i7 + 12 | 0; else {
  HEAP32[i4 >> 2] = i1;
  i3 = i7 + 12 | 0;
  HEAP32[i3 >> 2] = _fec_get_enc_msg_length(HEAP32[i7 >> 2] | 0, i1) | 0;
  i1 = i7 + 20 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  if (i2 | 0) mftCall_vi(HEAP32[i7 + 60 >> 2] | 0, i2 | 0);
  HEAP32[i1 >> 2] = mftCall_ii(HEAP32[i7 + 44 >> 2] | 0, HEAP32[i4 >> 2] << 3 | 0) | 0;
  i1 = i7 + 16 | 0;
  HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, HEAP32[i3 >> 2] << 3) | 0;
  i1 = i3;
 }
 i2 = i7 + 16 | 0;
 if (HEAP32[i1 >> 2] & 536870911 | 0) {
  i3 = 0;
  do {
   HEAP8[(HEAP32[i2 >> 2] | 0) + i3 >> 0] = HEAP8[i6 + i3 >> 0] | 0;
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < HEAP32[i1 >> 2] << 3 >>> 0);
 }
 i6 = i7 + 20 | 0;
 mftCall_iii(HEAP32[i7 + 48 >> 2] | 0, HEAP32[i6 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i7 + 52 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i2 >> 2] | 0, (HEAP32[i7 + 32 >> 2] | 0) + -1 + (HEAP32[i4 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i7 + 56 >> 2] | 0, HEAP32[i6 >> 2] | 0, i5 | 0, HEAP32[i4 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _fec_secded7264_compute_parity(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i4 = HEAP8[i1 >> 0] | 0;
 i7 = HEAP8[i1 + 1 >> 0] | 0;
 i8 = HEAP8[i1 + 2 >> 0] | 0;
 i9 = HEAP8[i1 + 3 >> 0] | 0;
 i10 = HEAP8[i1 + 4 >> 0] | 0;
 i5 = HEAP8[i1 + 5 >> 0] | 0;
 i6 = HEAP8[i1 + 6 >> 0] | 0;
 i2 = HEAP8[i1 + 7 >> 0] | 0;
 i3 = 0;
 i1 = 0;
 do {
  i11 = i3 << 3;
  i1 = (HEAPU8[(i7 & HEAP8[(i11 | 1) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i4 & HEAP8[gb + 18620 + i11 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i8 & HEAP8[(i11 | 2) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i9 & HEAP8[(i11 | 3) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i10 & HEAP8[(i11 | 4) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i5 & HEAP8[(i11 | 5) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i6 & HEAP8[(i11 | 6) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[(i11 | 7) + (gb + 18620) >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | i1 << 1 & 510;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 8);
 return i1 & 255 | 0;
}

function _ofdmframesync_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 176 >> 2] | 0;
 if (i1 | 0) _windowcf_destroy(i1);
 i1 = HEAP32[i2 + 180 >> 2] | 0;
 if (i1 | 0) _windowf_destroy(i1);
 i1 = HEAP32[i2 + 184 >> 2] | 0;
 if (i1 | 0) _windowcf_destroy(i1);
 i1 = HEAP32[i2 + 188 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 + 192 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 + 196 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 + 208 >> 2] | 0;
 if (i1 | 0) _windowf_destroy(i1);
 i1 = HEAP32[i2 + 212 >> 2] | 0;
 if (i1 | 0) _windowf_destroy(i1);
 _free(HEAP32[i2 + 12 >> 2] | 0);
 _windowcf_destroy(HEAP32[i2 + 60 >> 2] | 0);
 _free(HEAP32[i2 + 52 >> 2] | 0);
 _free(HEAP32[i2 + 56 >> 2] | 0);
 _fft_destroy_plan(HEAP32[i2 + 48 >> 2] | 0);
 _free(HEAP32[i2 + 64 >> 2] | 0);
 _free(HEAP32[i2 + 68 >> 2] | 0);
 _free(HEAP32[i2 + 72 >> 2] | 0);
 _free(HEAP32[i2 + 76 >> 2] | 0);
 _free(HEAP32[i2 + 84 >> 2] | 0);
 _free(HEAP32[i2 + 88 >> 2] | 0);
 _free(HEAP32[i2 + 92 >> 2] | 0);
 _free(HEAP32[i2 + 96 >> 2] | 0);
 _free(HEAP32[i2 + 100 >> 2] | 0);
 _nco_crcf_destroy(HEAP32[i2 + 108 >> 2] | 0);
 _msequence_destroy(HEAP32[i2 + 112 >> 2] | 0);
 _free(i2);
 return;
}

function _stream_unget(i4, i3) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 4 | 0;
 i2 = i5;
 HEAP32[i1 >> 2] = i4;
 HEAP32[i2 >> 2] = i3;
 if ((HEAP32[i2 >> 2] | 0) == -1 | (HEAP32[i2 >> 2] | 0) == -2) {
  STACKTOP = i5;
  return;
 }
 i4 = (HEAP32[i1 >> 2] | 0) + 36 | 0;
 HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + -1;
 if ((HEAP32[i2 >> 2] | 0) != 10) {
  if (_utf8_check_first(HEAP32[i2 >> 2] & 255) | 0) {
   i4 = (HEAP32[i1 >> 2] | 0) + 28 | 0;
   HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + -1;
  }
 } else {
  i4 = (HEAP32[i1 >> 2] | 0) + 24 | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + -1;
  HEAP32[(HEAP32[i1 >> 2] | 0) + 28 >> 2] = HEAP32[(HEAP32[i1 >> 2] | 0) + 32 >> 2];
 }
 if ((HEAP32[(HEAP32[i1 >> 2] | 0) + 16 >> 2] | 0) >>> 0 <= 0) ___assert_fail(gb + 40687 | 0, gb + 40619 | 0, 228, gb + 40710 | 0);
 i4 = (HEAP32[i1 >> 2] | 0) + 16 | 0;
 HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + -1;
 if ((HEAP8[(HEAP32[i1 >> 2] | 0) + 8 + (HEAP32[(HEAP32[i1 >> 2] | 0) + 16 >> 2] | 0) >> 0] | 0) != (HEAP32[i2 >> 2] | 0)) ___assert_fail(gb + 40723 | 0, gb + 40619 | 0, 230, gb + 40710 | 0);
 STACKTOP = i5;
 return;
}

function _ofdmflexframegen_reconfigure(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i2 + 8 | 0;
 i4 = i2;
 i5 = i1 + 88 | 0;
 i3 = _packetizer_recreate(HEAP32[i5 >> 2] | 0, HEAP32[i1 + 92 >> 2] | 0, HEAP32[i1 + 140 >> 2] | 0, HEAP32[i1 + 144 >> 2] | 0, HEAP32[i1 + 148 >> 2] | 0) | 0;
 HEAP32[i5 >> 2] = i3;
 i3 = _packetizer_get_enc_msg_len(i3) | 0;
 i5 = i1 + 108 | 0;
 HEAP32[i5 >> 2] = i3;
 i7 = i1 + 100 | 0;
 HEAP32[i7 >> 2] = _realloc(HEAP32[i7 >> 2] | 0, i3) | 0;
 i7 = i1 + 96 | 0;
 i3 = i1 + 152 | 0;
 HEAP32[i7 >> 2] = _modem_recreate(HEAP32[i7 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
 _div(i6, HEAP32[i5 >> 2] << 3, HEAP32[gb + 580 + (HEAP32[i3 >> 2] << 4) + 12 >> 2] | 0);
 i6 = ((HEAP32[i6 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i6 >> 2] | 0) | 0;
 i3 = i1 + 112 | 0;
 HEAP32[i3 >> 2] = i6;
 i5 = i1 + 104 | 0;
 HEAP32[i5 >> 2] = _realloc(HEAP32[i5 >> 2] | 0, i6 << 2) | 0;
 _div(i4, HEAP32[i3 >> 2] | 0, HEAP32[i1 + 24 >> 2] | 0);
 i3 = HEAP32[i4 >> 2] | 0;
 i4 = HEAP32[i4 + 4 >> 2] | 0;
 HEAP32[i1 + 48 >> 2] = ((i4 >>> 0 > 0 | (i4 | 0) == 0 & i3 >>> 0 > 4294967295) & 1) + i3;
 STACKTOP = i2;
 return;
}

function _memchr(i1, i5, i2) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i6 = 0, i7 = 0;
 i6 = i5 & 255;
 i3 = (i2 | 0) != 0;
 L1 : do if (i3 & (i1 & 3 | 0) != 0) {
  i4 = i5 & 255;
  while (1) {
   if ((HEAP8[i1 >> 0] | 0) == i4 << 24 >> 24) {
    i7 = 6;
    break L1;
   }
   i1 = i1 + 1 | 0;
   i2 = i2 + -1 | 0;
   i3 = (i2 | 0) != 0;
   if (!(i3 & (i1 & 3 | 0) != 0)) {
    i7 = 5;
    break;
   }
  }
 } else i7 = 5; while (0);
 if ((i7 | 0) == 5) if (i3) i7 = 6; else i2 = 0;
 L8 : do if ((i7 | 0) == 6) {
  i4 = i5 & 255;
  if ((HEAP8[i1 >> 0] | 0) != i4 << 24 >> 24) {
   i3 = Math_imul(i6, 16843009) | 0;
   L11 : do if (i2 >>> 0 > 3) while (1) {
    i6 = HEAP32[i1 >> 2] ^ i3;
    if ((i6 & -2139062144 ^ -2139062144) & i6 + -16843009 | 0) break;
    i1 = i1 + 4 | 0;
    i2 = i2 + -4 | 0;
    if (i2 >>> 0 <= 3) {
     i7 = 11;
     break L11;
    }
   } else i7 = 11; while (0);
   if ((i7 | 0) == 11) if (!i2) {
    i2 = 0;
    break;
   }
   while (1) {
    if ((HEAP8[i1 >> 0] | 0) == i4 << 24 >> 24) break L8;
    i1 = i1 + 1 | 0;
    i2 = i2 + -1 | 0;
    if (!i2) {
     i2 = 0;
     break;
    }
   }
  }
 } while (0);
 return (i2 | 0 ? i1 : 0) | 0;
}

function ___stpncpy(i2, i3, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0, i6 = 0;
 i5 = i3;
 do if (!((i5 ^ i2) & 3)) {
  i4 = (i1 | 0) != 0;
  L3 : do if (i4 & (i5 & 3 | 0) != 0) while (1) {
   i5 = HEAP8[i3 >> 0] | 0;
   HEAP8[i2 >> 0] = i5;
   if (!(i5 << 24 >> 24)) break L3;
   i1 = i1 + -1 | 0;
   i3 = i3 + 1 | 0;
   i2 = i2 + 1 | 0;
   i4 = (i1 | 0) != 0;
   if (!(i4 & (i3 & 3 | 0) != 0)) {
    i6 = 5;
    break;
   }
  } else i6 = 5; while (0);
  if ((i6 | 0) == 5) if (!i4) {
   i1 = 0;
   break;
  }
  if (HEAP8[i3 >> 0] | 0) {
   L11 : do if (i1 >>> 0 > 3) do {
    i4 = HEAP32[i3 >> 2] | 0;
    if ((i4 & -2139062144 ^ -2139062144) & i4 + -16843009 | 0) break L11;
    HEAP32[i2 >> 2] = i4;
    i1 = i1 + -4 | 0;
    i3 = i3 + 4 | 0;
    i2 = i2 + 4 | 0;
   } while (i1 >>> 0 > 3); while (0);
   i6 = 11;
  }
 } else i6 = 11; while (0);
 L16 : do if ((i6 | 0) == 11) if (!i1) i1 = 0; else while (1) {
  i6 = HEAP8[i3 >> 0] | 0;
  HEAP8[i2 >> 0] = i6;
  if (!(i6 << 24 >> 24)) break L16;
  i1 = i1 + -1 | 0;
  i2 = i2 + 1 | 0;
  if (!i1) {
   i1 = 0;
   break;
  } else i3 = i3 + 1 | 0;
 } while (0);
 _memset(i2 | 0, 0, i1 | 0) | 0;
 return i2 | 0;
}

function _liquid_filter_isi(i10, i11, i4, i13, i12) {
 i10 = i10 | 0;
 i11 = i11 | 0;
 i4 = i4 | 0;
 i13 = i13 | 0;
 i12 = i12 | 0;
 var d1 = 0.0, d2 = 0.0, i3 = 0, d5 = 0.0, i6 = 0, d7 = 0.0, i8 = 0, i9 = 0;
 i9 = Math_imul(i11 << 1, i4) | 0 | 1;
 i3 = 0;
 d1 = 0.0;
 do {
  d7 = +HEAPF32[i10 + (i3 << 2) >> 2];
  d1 = d1 + d7 * d7;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i9 | 0));
 d7 = d1;
 i8 = i4 << 1;
 if (!i8) {
  d7 = 0.0;
  d2 = 0.0;
  d5 = +(i8 >>> 0);
  d5 = d2 / d5;
  d5 = +Math_sqrt(+d5);
  HEAPF32[i13 >> 2] = d5;
  HEAPF32[i12 >> 2] = d7;
  return;
 } else {
  i6 = 1;
  d2 = 0.0;
  d1 = 0.0;
 }
 do {
  i3 = Math_imul(i6, i11) | 0;
  i3 = (i3 | 0) > -1 ? i3 : 0 - i3 | 0;
  if (i3 >>> 0 < i9 >>> 0) {
   i4 = i3;
   d5 = 0.0;
   do {
    d5 = d5 + +HEAPF32[i10 + (i4 << 2) >> 2] * +HEAPF32[i10 + (i4 - i3 << 2) >> 2];
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != (i9 | 0));
  } else d5 = 0.0;
  d5 = +Math_abs(+(d5 / d7));
  d1 = d1 + d5 * d5;
  d2 = (i6 | 0) == 1 | d5 > d2 ? d5 : d2;
  i6 = i6 + 1 | 0;
 } while (i6 >>> 0 <= i8 >>> 0);
 d7 = +(i8 >>> 0);
 d7 = d1 / d7;
 d7 = +Math_sqrt(+d7);
 HEAPF32[i13 >> 2] = d7;
 HEAPF32[i12 >> 2] = d2;
 return;
}

function _liquid_pack_bytes(i4, i5, i8, i1, i7) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 i8 = i8 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i6 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i10;
 _div(i6, i5, 8);
 if ((((HEAP32[i6 + 4 >> 2] | 0) > 0 & 1) + (HEAP32[i6 >> 2] | 0) | 0) >>> 0 > i1 >>> 0) {
  _fwrite(gb + 39389 | 0, 38, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(-1);
 }
 if (!i5) {
  i9 = 0;
  HEAP32[i7 >> 2] = i9;
  STACKTOP = i10;
  return;
 } else {
  i6 = 0;
  i1 = 0;
 }
 L6 : while (1) {
  i2 = 0;
  while (1) {
   i2 = (HEAPU8[i4 + i1 >> 0] | 0) & 1 | i2 & 254;
   i1 = i1 + 1 | 0;
   if (!(i1 & 7)) {
    i3 = i2;
    break;
   }
   if (i1 >>> 0 < i5 >>> 0) i2 = i2 << 1; else {
    i4 = i2;
    i2 = i6;
    i9 = 8;
    break L6;
   }
  }
  i2 = i6 + 1 | 0;
  HEAP8[i8 + i6 >> 0] = i3;
  if (i1 >>> 0 < i5 >>> 0) i6 = i2; else {
   i3 = i1;
   i1 = 0;
   break;
  }
 }
 if ((i9 | 0) == 8) {
  i3 = i1;
  i1 = i4 & 127;
 }
 if (!(i3 & 7)) {
  i9 = i2;
  HEAP32[i7 >> 2] = i9;
  STACKTOP = i10;
  return;
 }
 HEAP8[i8 + i2 >> 0] = i1;
 i9 = i2 + 1 | 0;
 HEAP32[i7 >> 2] = i9;
 STACKTOP = i10;
 return;
}

function _ofdmflexframesync_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i6;
 HEAP32[i4 + 56 >> 2] = i1;
 i3 = i1 + 6 | 0;
 i1 = i4 + 60 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 44 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i4 + 40 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _packetizer_destroy(i3);
 i3 = _packetizer_create(HEAP32[i1 >> 2] | 0, 6, 7, 1) | 0;
 HEAP32[i2 >> 2] = i3;
 i3 = _packetizer_get_enc_msg_len(i3) | 0;
 i2 = i4 + 64 | 0;
 HEAP32[i2 >> 2] = i3;
 i1 = i4 + 48 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i3) | 0;
 _div(i5, HEAP32[i2 >> 2] << 3, HEAP32[gb + 580 + 764 >> 2] | 0);
 i2 = ((HEAP32[i5 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i5 >> 2] | 0) | 0;
 HEAP32[i4 + 68 >> 2] = i2;
 i1 = i4 + 52 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i2) | 0;
 i1 = i4 + 36 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (!i2) {
  i5 = _modem_create(47) | 0;
  HEAP32[i1 >> 2] = i5;
  STACKTOP = i6;
  return;
 }
 _modem_destroy(i2);
 i5 = _modem_create(47) | 0;
 HEAP32[i1 >> 2] = i5;
 STACKTOP = i6;
 return;
}

function _fec_secded2216_compute_parity(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = HEAP8[i1 >> 0] | 0;
 i1 = HEAP8[i1 + 1 >> 0] | 0;
 return ((HEAPU8[(i1 & HEAP8[gb + 18245 + 11 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[gb + 18245 + 10 >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | ((HEAPU8[(i1 & HEAP8[gb + 18245 + 9 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[gb + 18245 + 8 >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | ((HEAPU8[(i1 & HEAP8[gb + 18245 + 7 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[gb + 18245 + 6 >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | ((HEAPU8[(i1 & HEAP8[gb + 18245 + 5 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[gb + 18245 + 4 >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | ((HEAPU8[(i1 & HEAP8[gb + 18245 + 3 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[gb + 18245 + 2 >> 0] & 255) + (gb + 38499) >> 0] | 0) & 1 | (HEAPU8[(i1 & HEAP8[gb + 18245 + 1 >> 0] & 255) + (gb + 38499) >> 0] | 0) + (HEAPU8[(i2 & HEAP8[gb + 18245 >> 0] & 255) + (gb + 38499) >> 0] | 0) << 1 & 2) << 1 & 6) << 1 & 14) << 1 & 30) << 1 & 62) & 255 | 0;
}

function _matrixf_inv(i8, i9, i1) {
 i8 = i8 | 0;
 i9 = i9 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i10 = 0;
 i10 = STACKTOP;
 if ((i9 | 0) != (i1 | 0)) {
  _fwrite(gb + 30212 | 0, 40, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i6 = i9 << 1;
 i2 = (Math_imul(i6, i9) | 0) << 2;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * i2 | 0) + 15 & -16) | 0;
 i2 = (i9 | 0) == 0;
 if (i2) {
  _matrixf_gjelim(i7, i9, i6);
  STACKTOP = i10;
  return;
 }
 i3 = i9 << 2;
 i5 = 0;
 do {
  i1 = Math_imul(i6, i5) | 0;
  _memcpy(i7 + (i1 << 2) | 0, i8 + ((Math_imul(i5, i9) | 0) << 2) | 0, i3 | 0) | 0;
  i1 = i1 + i9 | 0;
  i4 = 0;
  do {
   HEAPF32[i7 + (i1 + i4 << 2) >> 2] = +((i5 | 0) == (i4 | 0) & 1);
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i9 | 0));
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i9 | 0));
 _matrixf_gjelim(i7, i9, i6);
 if (i2) {
  STACKTOP = i10;
  return;
 }
 i1 = i9 << 2;
 i2 = 0;
 do {
  _memcpy(i8 + ((Math_imul(i2, i9) | 0) << 2) | 0, i7 + ((Math_imul(i6, i2) | 0) + i9 << 2) | 0, i1 | 0) | 0;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i9 | 0));
 STACKTOP = i10;
 return;
}

function _fec_secded7264_decode(i1, i10, i8, i7) {
 i1 = i1 | 0;
 i10 = i10 | 0;
 i8 = i8 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i9 = 0, i11 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i9 + 8 | 0;
 i4 = i9;
 i6 = i10 & 7;
 i3 = i10 - i6 | 0;
 if ((i6 | 0) == (i10 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   _fec_secded7264_decode_symbol(i8 + i1 | 0, i7 + i2 | 0) | 0;
   i1 = i1 + 9 | 0;
   i2 = i2 + 8 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i6) {
  i3 = i4;
  HEAP32[i3 >> 2] = 0;
  HEAP32[i3 + 4 >> 2] = 0;
  i3 = i10 & 7;
  i11 = i3 + 1 | 0;
  _memset(i5 + i11 | 0, 0, (i11 >>> 0 > 8 ? 0 : 8 - i3 | 0) | 0) | 0;
  _memcpy(i5 | 0, i8 + i1 | 0, i11 | 0) | 0;
  _fec_secded7264_decode_symbol(i5, i4) | 0;
  _memcpy(i7 + i2 | 0, i4 | 0, i3 | 0) | 0;
  i2 = i2 | i6;
  i1 = i1 + (i6 + 1) | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(10, i10) | 0)) ___assert_fail(gb + 18756 | 0, gb + 18820 | 0, 338, gb + 18889 | 0);
 if ((i2 | 0) == (i10 | 0)) {
  STACKTOP = i9;
  return;
 } else ___assert_fail(gb + 18871 | 0, gb + 18820 | 0, 339, gb + 18889 | 0);
}

function _gmskframegen_write_preamble(i10, i7) {
 i10 = i10 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, d11 = 0.0, d12 = 0.0;
 i8 = i10 + 32 | 0;
 i9 = _msequence_advance(HEAP32[i8 >> 2] | 0) | 0;
 _gmskmod_modulate(HEAP32[i10 >> 2] | 0, i9 & 255, i7);
 i9 = i10 + 96 | 0;
 i1 = HEAP32[i9 >> 2] | 0;
 i6 = i10 + 8 | 0;
 i4 = HEAP32[i6 >> 2] | 0;
 L1 : do if (i1 >>> 0 < i4 >>> 0 ? (i5 = i10 + 4 | 0, i2 = HEAP32[i5 >> 2] | 0, (i2 | 0) != 0) : 0) {
  i3 = 0;
  while (1) {
   d12 = +_hamming((Math_imul(i1, i2) | 0) + i3 | 0, Math_imul(i2 << 1, i4) | 0);
   i1 = i7 + (i3 << 3) | 0;
   i2 = i7 + (i3 << 3) + 4 | 0;
   d11 = d12 * +HEAPF32[i2 >> 2];
   HEAPF32[i1 >> 2] = d12 * +HEAPF32[i1 >> 2];
   HEAPF32[i2 >> 2] = d11;
   i3 = i3 + 1 | 0;
   i2 = HEAP32[i5 >> 2] | 0;
   i1 = HEAP32[i9 >> 2] | 0;
   if (i3 >>> 0 >= i2 >>> 0) break L1;
   i4 = HEAP32[i6 >> 2] | 0;
  }
 } while (0);
 i7 = i1 + 1 | 0;
 HEAP32[i9 >> 2] = i7;
 if ((i7 | 0) != (HEAP32[i10 + 16 >> 2] | 0)) return;
 _msequence_reset(HEAP32[i8 >> 2] | 0);
 HEAP32[i9 >> 2] = 0;
 HEAP32[i10 + 84 >> 2] = 1;
 return;
}

function _liquid_firdes_kaiser(i9, d6, d1, d8, i7) {
 i9 = i9 | 0;
 d6 = +d6;
 d1 = +d1;
 d8 = +d8;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i10 + 8 | 0;
 i2 = i10;
 if (d8 < -.5 | d8 > .5) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i2 >> 3] = d8;
  _fprintf(i11, gb + 21582 | 0, i2) | 0;
  _exit(1);
 }
 if (d6 < 0.0 | d6 > .5) {
  i11 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i3 >> 3] = d6;
  _fprintf(i11, gb + 21651 | 0, i3) | 0;
  _exit(1);
 }
 if (!i9) {
  _fwrite(gb + 21731 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 d1 = +Math_abs(+d1);
 if (!(d1 > 50.0)) if (d1 > 21.0) {
  d5 = d1 + -21.0;
  d5 = d5 * .07885999977588654 + +Math_pow(+d5, .4000000059604645) * .5842;
 } else d5 = 0.0; else d5 = (d1 + -8.699999809265137) * .11020000278949738;
 d4 = +((i9 + -1 | 0) >>> 0) * .5;
 d1 = d6 * 2.0;
 i2 = 0;
 do {
  d6 = +_sincf(d1 * (+(i2 >>> 0) - d4 + d8));
  HEAPF32[i7 + (i2 << 2) >> 2] = d6 * +_kaiser(i2, i9, d5, d8);
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i9 | 0));
 STACKTOP = i10;
 return;
}

function _firinterp_rrrf_execute(i1, d4, i8) {
 i1 = i1 | 0;
 d4 = +d4;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0, i11 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i11 = i10;
 i9 = i10 + 8 | 0;
 i7 = i1 + 16 | 0;
 _windowf_push(HEAP32[(HEAP32[i7 >> 2] | 0) + 16 >> 2] | 0, d4);
 i3 = i1 + 12 | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  STACKTOP = i10;
  return;
 }
 i1 = 0;
 while (1) {
  i5 = HEAP32[i7 >> 2] | 0;
  i6 = i8 + (i1 << 2) | 0;
  i2 = HEAP32[i5 + 12 >> 2] | 0;
  if (i2 >>> 0 <= i1 >>> 0) {
   i3 = 4;
   break;
  }
  _windowf_read(HEAP32[i5 + 16 >> 2] | 0, i9);
  _dotprod_rrrf_execute(HEAP32[(HEAP32[i5 + 20 >> 2] | 0) + (i1 << 2) >> 2] | 0, HEAP32[i9 >> 2] | 0, i6);
  HEAPF32[i6 >> 2] = +HEAPF32[i5 + 24 >> 2] * +HEAPF32[i6 >> 2];
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) {
   i3 = 6;
   break;
  }
 }
 if ((i3 | 0) == 4) {
  i10 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i11 >> 2] = i1;
  HEAP32[i11 + 4 >> 2] = i2;
  _fprintf(i10, gb + 20859 | 0, i11) | 0;
  _exit(1);
 } else if ((i3 | 0) == 6) {
  STACKTOP = i10;
  return;
 }
}

function _fec_secded2216_encode(i1, i9, i6, i7) {
 i1 = i1 | 0;
 i9 = i9 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0, i10 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i8;
 i5 = i9 & 1;
 i3 = i9 - i5 | 0;
 if ((i5 | 0) == (i9 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i10 = i6 + i2 | 0;
   HEAP8[i7 + i1 >> 0] = _fec_secded2216_compute_parity(i10) | 0;
   HEAP8[i7 + (i1 + 1) >> 0] = HEAP8[i10 >> 0] | 0;
   HEAP8[i7 + (i1 + 2) >> 0] = HEAP8[i6 + (i2 | 1) >> 0] | 0;
   i1 = i1 + 3 | 0;
   i2 = i2 + 2 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i5) {
  i10 = HEAP8[i6 + i2 >> 0] | 0;
  HEAP8[i4 >> 0] = i10;
  HEAP8[i4 + 1 >> 0] = 0;
  HEAP8[i7 + i1 >> 0] = _fec_secded2216_compute_parity(i4) | 0;
  HEAP8[i7 + (i1 + 1) >> 0] = i10;
  i2 = i2 | i5;
  i1 = i5 + 1 + i1 | 0;
 }
 if ((i1 | 0) != (_fec_get_enc_msg_length(8, i9) | 0)) ___assert_fail(gb + 18279 | 0, gb + 18343 | 0, 274, gb + 18372 | 0);
 if ((i2 | 0) == (i9 | 0)) {
  STACKTOP = i8;
  return;
 } else ___assert_fail(gb + 18871 | 0, gb + 18343 | 0, 275, gb + 18372 | 0);
}

function _dotprod_cccf_execute(i3, i14, i15) {
 i3 = i3 | 0;
 i14 = i14 | 0;
 i15 = i15 | 0;
 var d1 = 0.0, d2 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i16 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i12 = i16;
 i13 = HEAP32[i3 >> 2] | 0;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 if (!i3) {
  d8 = 0.0;
  d9 = 0.0;
  i14 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d8;
  HEAPF32[i14 >> 2] = d9;
  STACKTOP = i16;
  return;
 }
 i10 = i12 + 4 | 0;
 i11 = 0;
 d2 = 0.0;
 d1 = 0.0;
 do {
  d8 = +HEAPF32[i13 + (i11 << 3) >> 2];
  d9 = +HEAPF32[i13 + (i11 << 3) + 4 >> 2];
  d6 = +HEAPF32[i14 + (i11 << 3) >> 2];
  d7 = +HEAPF32[i14 + (i11 << 3) + 4 >> 2];
  d4 = d8 * d6 - d9 * d7;
  d5 = d9 * d6 + d8 * d7;
  if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
   ___mulsc3(i12, d8, d9, d6, d7);
   d4 = +HEAPF32[i12 >> 2];
   d5 = +HEAPF32[i10 >> 2];
  }
  d2 = d2 + d4;
  d1 = d1 + d5;
  i11 = i11 + 1 | 0;
 } while ((i11 | 0) != (i3 | 0));
 i14 = i15 + 4 | 0;
 HEAPF32[i15 >> 2] = d2;
 HEAPF32[i14 >> 2] = d1;
 STACKTOP = i16;
 return;
}

function _iirfilt_crcf_create_prototype(i7, i1, i2, i8, d6, d5, d3, d4) {
 i7 = i7 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i8 = i8 | 0;
 d6 = +d6;
 d5 = +d5;
 d3 = +d3;
 d4 = +d4;
 var i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 i14 = STACKTOP;
 i9 = i8 << ((i1 | 1 | 0) == 3 & 1);
 i13 = i9 & 1;
 i12 = (i2 | 0) == 0;
 i13 = ((i9 - i13 | 0) >>> 1) + i13 | 0;
 i9 = i12 ? i13 * 3 | 0 : i9 + 1 | 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 _liquid_iirdes(i7, i1, i2, i8, d6, d5, d3, d4, i10, i11);
 i1 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 if (i9 | 0) {
  i8 = i9 << 2;
  _memcpy(i1 | 0, i10 | 0, i8 | 0) | 0;
  _memcpy(i2 | 0, i11 | 0, i8 | 0) | 0;
 }
 if (i12) {
  i13 = _iirfilt_crcf_create_sos(i1, i2, i13) | 0;
  STACKTOP = i14;
  return i13 | 0;
 } else {
  i13 = _iirfilt_crcf_create(i1, i9, i2, i9) | 0;
  STACKTOP = i14;
  return i13 | 0;
 }
 return 0;
}

function _fecsoft_hamming84_decode(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i8 = HEAPU8[i1 >> 0] | 0;
 i14 = i8 ^ 255;
 i19 = HEAPU8[i1 + 1 >> 0] | 0;
 i20 = i19 ^ 255;
 i21 = HEAPU8[i1 + 2 >> 0] | 0;
 i9 = i21 ^ 255;
 i10 = HEAPU8[i1 + 3 >> 0] | 0;
 i11 = i10 ^ 255;
 i12 = HEAPU8[i1 + 4 >> 0] | 0;
 i13 = i12 ^ 255;
 i15 = HEAPU8[i1 + 5 >> 0] | 0;
 i16 = i15 ^ 255;
 i17 = HEAPU8[i1 + 6 >> 0] | 0;
 i18 = i17 ^ 255;
 i2 = HEAPU8[i1 + 7 >> 0] | 0;
 i3 = i2 ^ 255;
 i5 = 0;
 i6 = 0;
 i1 = 0;
 while (1) {
  i4 = HEAPU8[gb + 13096 + i6 >> 0] | 0;
  i4 = (i4 & 64 | 0 ? i20 : i19) + (i4 & 128 | 0 ? i14 : i8) + (i4 & 32 | 0 ? i9 : i21) + (i4 & 16 | 0 ? i11 : i10) + (i4 & 8 | 0 ? i13 : i12) + (i4 & 4 | 0 ? i16 : i15) + (i4 & 2 | 0 ? i18 : i17) + (i4 & 1 | 0 ? i3 : i2) | 0;
  i7 = (i6 | 0) == 0 | i4 >>> 0 < i5 >>> 0;
  i1 = i7 ? i6 & 255 : i1;
  i6 = i6 + 1 | 0;
  if ((i6 | 0) == 16) break; else i5 = i7 ? i4 : i5;
 }
 return i1 | 0;
}

function _flexframegen_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 if (HEAP32[i4 + 112 >> 2] | 0) {
  _fwrite(gb + 24808 | 0, 81, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  return;
 }
 HEAP32[i4 + 56 >> 2] = i1;
 i2 = i1 + 6 | 0;
 i3 = i4 + 60 | 0;
 HEAP32[i3 >> 2] = i2;
 i1 = i4 + 52 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i2) | 0;
 i1 = i4 + 64 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (i2 | 0) _qpacketmodem_destroy(i2);
 i2 = _qpacketmodem_create() | 0;
 HEAP32[i1 >> 2] = i2;
 _qpacketmodem_configure(i2, HEAP32[i3 >> 2] | 0, 6, 10, 5, 48) | 0;
 i3 = _qpacketmodem_get_frame_len(HEAP32[i1 >> 2] | 0) | 0;
 i1 = i4 + 68 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 72 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3 << 3) | 0;
 i2 = i4 + 76 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _qpilotgen_destroy(i3);
 i3 = _qpilotgen_create(HEAP32[i1 >> 2] | 0, 16) | 0;
 HEAP32[i2 >> 2] = i3;
 i3 = _qpilotgen_get_frame_len(i3) | 0;
 HEAP32[i4 + 80 >> 2] = i3;
 i4 = i4 + 84 | 0;
 HEAP32[i4 >> 2] = _realloc(HEAP32[i4 >> 2] | 0, i3 << 3) | 0;
 return;
}

function _json_loads(i10, i6, i5) {
 i10 = i10 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i1 = i11 + 104 | 0;
 i2 = i11 + 100 | 0;
 i3 = i11 + 96 | 0;
 i4 = i11 + 92 | 0;
 i7 = i11;
 i8 = i11 + 88 | 0;
 i9 = i11 + 80 | 0;
 HEAP32[i2 >> 2] = i10;
 HEAP32[i3 >> 2] = i6;
 HEAP32[i4 >> 2] = i5;
 _jsonp_error_init(HEAP32[i4 >> 2] | 0, gb + 40547 | 0);
 if (!(HEAP32[i2 >> 2] | 0)) {
  _error_set(HEAP32[i4 >> 2] | 0, 0, gb + 40556 | 0, i11 + 72 | 0);
  HEAP32[i1 >> 2] = 0;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 HEAP32[i9 >> 2] = HEAP32[i2 >> 2];
 HEAP32[i9 + 4 >> 2] = 0;
 if (_lex_init(i7, fb + 7 | 0, HEAP32[i3 >> 2] | 0, i9) | 0) {
  HEAP32[i1 >> 2] = 0;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 } else {
  HEAP32[i8 >> 2] = _parse_json(i7, HEAP32[i3 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
  _lex_close(i7);
  HEAP32[i1 >> 2] = HEAP32[i8 >> 2];
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i11;
  return i10 | 0;
 }
 return 0;
}

function _firinterp_crcf_create_kaiser(i2, i3, d1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i7 + 16 | 0;
 i5 = i7 + 8 | 0;
 i4 = i7;
 if (i2 >>> 0 < 2) {
  i8 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i4 >> 2] = gb + 19656;
  _fprintf(i8, gb + 20299 | 0, i4) | 0;
  _exit(1);
 }
 if (!i3) {
  i8 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i5 >> 2] = gb + 19656;
  _fprintf(i8, gb + 20374 | 0, i5) | 0;
  _exit(1);
 }
 if (d1 < 0.0) {
  i8 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 19656;
  _fprintf(i8, gb + 20448 | 0, i6) | 0;
  _exit(1);
 } else {
  i8 = Math_imul(i2 << 1, i3) | 0;
  i4 = i8 | 1;
  i5 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_kaiser(i4, .5 / +(i2 >>> 0), d1, 0.0, i5);
  i6 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i6 | 0, i5 | 0, (Math_imul(i3, i2) | 0) << 3 | 4 | 0) | 0;
  i8 = _firinterp_crcf_create(i2, i6, i8) | 0;
  STACKTOP = i7;
  return i8 | 0;
 }
 return 0;
}

function _firdecim_crcf_create_kaiser(i2, i3, d1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i7 + 16 | 0;
 i5 = i7 + 8 | 0;
 i4 = i7;
 if (i2 >>> 0 < 2) {
  i8 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i4 >> 2] = gb + 19656;
  _fprintf(i8, gb + 19799 | 0, i4) | 0;
  _exit(1);
 }
 if (!i3) {
  i8 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i5 >> 2] = gb + 19656;
  _fprintf(i8, gb + 19869 | 0, i5) | 0;
  _exit(1);
 }
 if (d1 < 0.0) {
  i8 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = gb + 19656;
  _fprintf(i8, gb + 19939 | 0, i6) | 0;
  _exit(1);
 } else {
  i8 = Math_imul(i2 << 1, i3) | 0;
  i4 = i8 | 1;
  i5 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_kaiser(i4, .5 / +(i2 >>> 0), d1, 0.0, i5);
  i6 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i6 | 0, i5 | 0, (Math_imul(i3, i2) | 0) << 3 | 4 | 0) | 0;
  i8 = _firdecim_crcf_create(i2, i6, i8) | 0;
  STACKTOP = i7;
  return i8 | 0;
 }
 return 0;
}

function _qpilotgen_execute(i9, i7, i6) {
 i9 = i9 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0, i10 = 0, i11 = 0;
 i3 = i9 + 12 | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i4 = i9 + 4 | 0;
  i5 = i9 + 16 | 0;
  i8 = 0;
  i2 = 0;
  i1 = 0;
  do {
   if (!((i8 >>> 0) % ((HEAP32[i4 >> 2] | 0) >>> 0) | 0)) {
    i11 = HEAP32[i5 >> 2] | 0;
    i10 = HEAP32[i11 + (i1 << 3) + 4 >> 2] | 0;
    HEAP32[i6 + (i8 << 3) >> 2] = HEAP32[i11 + (i1 << 3) >> 2];
    HEAP32[i6 + (i8 << 3) + 4 >> 2] = i10;
    i1 = i1 + 1 | 0;
   } else {
    i11 = HEAP32[i7 + (i2 << 3) + 4 >> 2] | 0;
    HEAP32[i6 + (i8 << 3) >> 2] = HEAP32[i7 + (i2 << 3) >> 2];
    HEAP32[i6 + (i8 << 3) + 4 >> 2] = i11;
    i2 = i2 + 1 | 0;
   }
   i8 = i8 + 1 | 0;
  } while (i8 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
 }
 if ((i2 | 0) != (HEAP32[i9 >> 2] | 0)) ___assert_fail(gb + 29652 | 0, gb + 29673 | 0, 157, gb + 29701 | 0);
 if ((i1 | 0) == (HEAP32[i9 + 8 >> 2] | 0)) return; else ___assert_fail(gb + 29719 | 0, gb + 29673 | 0, 158, gb + 29701 | 0);
}

function ___fwritex(i3, i4, i6) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i7 = 0;
 i1 = i6 + 16 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (!i2) if (!(___towrite(i6) | 0)) {
  i2 = HEAP32[i1 >> 2] | 0;
  i5 = 5;
 } else i1 = 0; else i5 = 5;
 L5 : do if ((i5 | 0) == 5) {
  i7 = i6 + 20 | 0;
  i1 = HEAP32[i7 >> 2] | 0;
  i5 = i1;
  if ((i2 - i1 | 0) >>> 0 < i4 >>> 0) {
   i1 = mftCall_iiii(HEAP32[i6 + 36 >> 2] | 0, i6 | 0, i3 | 0, i4 | 0) | 0;
   break;
  }
  L10 : do if ((HEAP8[i6 + 75 >> 0] | 0) > -1) {
   i1 = i4;
   while (1) {
    if (!i1) {
     i2 = i5;
     i1 = 0;
     break L10;
    }
    i2 = i1 + -1 | 0;
    if ((HEAP8[i3 + i2 >> 0] | 0) == 10) break; else i1 = i2;
   }
   if ((mftCall_iiii(HEAP32[i6 + 36 >> 2] | 0, i6 | 0, i3 | 0, i1 | 0) | 0) >>> 0 < i1 >>> 0) break L5;
   i4 = i4 - i1 | 0;
   i3 = i3 + i1 | 0;
   i2 = HEAP32[i7 >> 2] | 0;
  } else {
   i2 = i5;
   i1 = 0;
  } while (0);
  _memcpy(i2 | 0, i3 | 0, i4 | 0) | 0;
  HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + i4;
  i1 = i1 + i4 | 0;
 } while (0);
 return i1 | 0;
}

function _hashtable_init(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 8 | 0;
 i2 = i5 + 4 | 0;
 i4 = i5;
 HEAP32[i2 >> 2] = i3;
 HEAP32[HEAP32[i2 >> 2] >> 2] = 0;
 HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2] = 3;
 i3 = _jsonp_malloc(1 << HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2] << 3) | 0;
 HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] = i3;
 if (!(HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] | 0)) {
  HEAP32[i1 >> 2] = -1;
  i4 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i5;
  return i4 | 0;
 }
 _list_init((HEAP32[i2 >> 2] | 0) + 12 | 0);
 HEAP32[i4 >> 2] = 0;
 while (1) {
  if ((HEAP32[i4 >> 2] | 0) >>> 0 >= 1 << HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2] >>> 0) break;
  i3 = (HEAP32[i2 >> 2] | 0) + 12 | 0;
  HEAP32[(HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i4 >> 2] << 3) + 4 >> 2] = i3;
  HEAP32[(HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[i4 >> 2] << 3) >> 2] = i3;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + 1;
 }
 HEAP32[i1 >> 2] = 0;
 i4 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i5;
 return i4 | 0;
}

function _ofdmframegen_write_S0a(i6, i7) {
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0;
 i1 = HEAP32[i6 >> 2] | 0;
 i4 = i6 + 4 | 0;
 i2 = HEAP32[i4 >> 2] | 0;
 if ((i2 | 0) != (0 - i1 | 0)) {
  i5 = i6 + 64 | 0;
  i3 = 0;
  do {
   i9 = ((i1 + i3 - (i2 << 1) | 0) >>> 0) % (i1 >>> 0) | 0;
   i10 = HEAP32[i5 >> 2] | 0;
   i8 = HEAP32[i10 + (i9 << 3) + 4 >> 2] | 0;
   HEAP32[i7 + (i3 << 3) >> 2] = HEAP32[i10 + (i9 << 3) >> 2];
   HEAP32[i7 + (i3 << 3) + 4 >> 2] = i8;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i6 >> 2] | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } while (i3 >>> 0 < (i2 + i1 | 0) >>> 0);
 }
 i3 = i6 + 12 | 0;
 if (!(HEAP32[i3 >> 2] | 0)) return;
 i1 = i6 + 16 | 0;
 i2 = 0;
 do {
  d12 = +HEAPF32[(HEAP32[i1 >> 2] | 0) + (i2 << 2) >> 2];
  i9 = i7 + (i2 << 3) | 0;
  i10 = i7 + (i2 << 3) + 4 | 0;
  d11 = d12 * +HEAPF32[i10 >> 2];
  HEAPF32[i9 >> 2] = d12 * +HEAPF32[i9 >> 2];
  HEAPF32[i10 >> 2] = d11;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
 return;
}

function _fmax(d1, d4) {
 d1 = +d1;
 d4 = +d4;
 var i2 = 0, i3 = 0, i5 = 0, d6 = 0.0, i7 = 0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i2 = HEAP32[tempDoublePtr >> 2] | 0;
 i3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 d6 = +Math_abs(+d1);
 HEAPF64[tempDoublePtr >> 3] = d6;
 i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 do if (!(i5 >>> 0 > 2146435072 | (i5 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0)) {
  d6 = +Math_abs(+d4);
  HEAPF64[tempDoublePtr >> 3] = d6;
  i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  if (!(i5 >>> 0 > 2146435072 | (i5 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0)) {
   HEAPF64[tempDoublePtr >> 3] = d4;
   i7 = HEAP32[tempDoublePtr >> 2] | 0;
   i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   i2 = _bitshift64Lshr(i2 | 0, i3 | 0, 63) | 0;
   getTempRet0() | 0;
   i5 = _bitshift64Lshr(i7 | 0, i5 | 0, 63) | 0;
   getTempRet0() | 0;
   if ((i2 | 0) == (i5 | 0)) {
    d1 = d1 < d4 ? d4 : d1;
    break;
   } else {
    d1 = (i3 | 0) < 0 ? d4 : d1;
    break;
   }
  }
 } else d1 = d4; while (0);
 return +d1;
}

function _ofdmframe_validate_sctype(i6, i5, i12, i13, i11) {
 i6 = i6 | 0;
 i5 = i5 | 0;
 i12 = i12 | 0;
 i13 = i13 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i14 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i14 = i15;
 L1 : do if (!i5) {
  i8 = 0;
  i9 = 0;
  i10 = 0;
 } else {
  i4 = 0;
  i2 = 0;
  i3 = 0;
  i7 = 0;
  L2 : while (1) {
   i1 = HEAP8[i6 + i7 >> 0] | 0;
   switch (i1 << 24 >> 24) {
   case 0:
    {
     i1 = i4;
     i2 = i2 + 1 | 0;
     break;
    }
   case 1:
    {
     i1 = i4;
     i3 = i3 + 1 | 0;
     break;
    }
   case 2:
    {
     i1 = i4 + 1 | 0;
     break;
    }
   default:
    break L2;
   }
   i7 = i7 + 1 | 0;
   if (i7 >>> 0 >= i5 >>> 0) {
    i8 = i1;
    i9 = i2;
    i10 = i3;
    break L1;
   } else i4 = i1;
  }
  i7 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i14 >> 2] = i1 & 255;
  _fprintf(i7, gb + 34907 | 0, i14) | 0;
  _exit(1);
 } while (0);
 HEAP32[i12 >> 2] = i9;
 HEAP32[i13 >> 2] = i10;
 HEAP32[i11 >> 2] = i8;
 STACKTOP = i15;
 return;
}

function _iirdes_dzpk2tff(i4, i2, i13, i7, i12, i3) {
 i4 = i4 | 0;
 i2 = i2 | 0;
 i13 = i13 | 0;
 i7 = i7 | 0;
 i12 = i12 | 0;
 i3 = i3 | 0;
 var d1 = 0.0, d5 = 0.0, d6 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i14 = 0, d15 = 0.0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i10 = i14;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i13 + 1 << 3) | 0) + 15 & -16) | 0;
 _polycf_expandroots(i2, i13, i11);
 i2 = 0;
 do {
  HEAP32[i3 + (i2 << 2) >> 2] = HEAP32[i11 + (i13 - i2 << 3) >> 2];
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 <= i13 >>> 0);
 _polycf_expandroots(i4, i13, i11);
 d9 = +HEAPF32[i7 >> 2];
 d8 = +HEAPF32[i7 + 4 >> 2];
 i2 = 0;
 do {
  i7 = i13 - i2 | 0;
  d5 = +HEAPF32[i11 + (i7 << 3) >> 2];
  d6 = +HEAPF32[i11 + (i7 << 3) + 4 >> 2];
  d1 = d5 * d9 - d6 * d8;
  d15 = d6 * d9 + d5 * d8;
  if ((d1 != d1 | 0.0 != 0.0) & (d15 != d15 | 0.0 != 0.0)) {
   ___mulsc3(i10, d5, d6, d9, d8);
   d1 = +HEAPF32[i10 >> 2];
  }
  HEAPF32[i12 + (i2 << 2) >> 2] = d1;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 <= i13 >>> 0);
 STACKTOP = i14;
 return;
}

function _vsnprintf(i3, i1, i10, i8) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 i10 = i10 | 0;
 i8 = i8 | 0;
 var i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i2 = i11 + 112 | 0;
 i9 = i11;
 i4 = i9;
 i5 = gb + 9044 | 0;
 i6 = i4 + 112 | 0;
 do {
  HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
  i4 = i4 + 4 | 0;
  i5 = i5 + 4 | 0;
 } while ((i4 | 0) < (i6 | 0));
 if ((i1 + -1 | 0) >>> 0 > 2147483646) if (!i1) {
  i1 = 1;
  i7 = 4;
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 75;
  i1 = -1;
 } else {
  i2 = i3;
  i7 = 4;
 }
 if ((i7 | 0) == 4) {
  i7 = -2 - i2 | 0;
  i7 = i1 >>> 0 > i7 >>> 0 ? i7 : i1;
  HEAP32[i9 + 48 >> 2] = i7;
  i3 = i9 + 20 | 0;
  HEAP32[i3 >> 2] = i2;
  HEAP32[i9 + 44 >> 2] = i2;
  i1 = i2 + i7 | 0;
  i2 = i9 + 16 | 0;
  HEAP32[i2 >> 2] = i1;
  HEAP32[i9 + 28 >> 2] = i1;
  i1 = _vfprintf(i9, i10, i8) | 0;
  if (i7) {
   i10 = HEAP32[i3 >> 2] | 0;
   HEAP8[i10 + (((i10 | 0) == (HEAP32[i2 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
  }
 }
 STACKTOP = i11;
 return i1 | 0;
}

function _qpacketmodem_configure(i6, i5, i1, i2, i3, i4) {
 i6 = i6 | 0;
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i9 = i7;
 i10 = i6 + 12 | 0;
 HEAP32[i10 >> 2] = i5;
 i5 = _modem_recreate(HEAP32[i6 >> 2] | 0, i4) | 0;
 HEAP32[i6 >> 2] = i5;
 i8 = i6 + 8 | 0;
 HEAP32[i8 >> 2] = _modem_get_bps(i5) | 0;
 i5 = i6 + 4 | 0;
 i3 = _packetizer_recreate(HEAP32[i5 >> 2] | 0, HEAP32[i10 >> 2] | 0, i1, i2, i3) | 0;
 HEAP32[i5 >> 2] = i3;
 i3 = _packetizer_get_enc_msg_len(i3) | 0;
 HEAP32[i6 + 24 >> 2] = i3;
 i3 = i3 << 3;
 HEAP32[i6 + 28 >> 2] = i3;
 _div(i9, i3, HEAP32[i8 >> 2] | 0);
 i3 = ((HEAP32[i9 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i9 >> 2] | 0) | 0;
 i5 = i6 + 32 | 0;
 HEAP32[i5 >> 2] = i3;
 i4 = i6 + 16 | 0;
 HEAP32[i4 >> 2] = _realloc(HEAP32[i4 >> 2] | 0, Math_imul(HEAP32[i8 >> 2] | 0, i3) | 0) | 0;
 i6 = i6 + 20 | 0;
 HEAP32[i6 >> 2] = _realloc(HEAP32[i6 >> 2] | 0, HEAP32[i5 >> 2] << 2) | 0;
 STACKTOP = i7;
 return 0;
}

function _hypotf(d1, d2) {
 d1 = +d1;
 d2 = +d2;
 var d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 d1 = +Math_abs(+d1);
 i6 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 d2 = +Math_abs(+d2);
 i5 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
 i7 = i6 >>> 0 < i5 >>> 0;
 i4 = i7 ? i5 : i6;
 i5 = i7 ? i6 : i5;
 d2 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d1 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i5 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i5 | 0) == 0 | (i4 - i5 | 0) >>> 0 > 209715199) {
   d1 = d2 + d1;
   break;
  }
  if (i4 >>> 0 <= 1568669695) if (i5 >>> 0 < 562036736) {
   d1 = d1 * 1237940039285380274899124.0e3;
   d2 = d2 * 1237940039285380274899124.0e3;
   d3 = 8.077935669463161e-28;
  } else d3 = 1.0; else {
   d1 = d1 * 8.077935669463161e-28;
   d2 = d2 * 8.077935669463161e-28;
   d3 = 1237940039285380274899124.0e3;
  }
  d1 = d3 * +Math_sqrt(+(d2 * d2 + d1 * d1));
 } while (0);
 return +d1;
}

function _gmskframegen_write_tail(i9, i7) {
 i9 = i9 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, d10 = 0.0, d11 = 0.0;
 i8 = (_rand() | 0) % 2 | 0;
 _gmskmod_modulate(HEAP32[i9 >> 2] | 0, i8 & 255, i7);
 i8 = i9 + 96 | 0;
 i1 = HEAP32[i8 >> 2] | 0;
 i5 = i9 + 8 | 0;
 i4 = HEAP32[i5 >> 2] | 0;
 if (i1 >>> 0 >= i4 >>> 0 ? (i6 = i9 + 4 | 0, i2 = HEAP32[i6 >> 2] | 0, (i2 | 0) != 0) : 0) {
  i3 = 0;
  while (1) {
   d11 = +_hamming((Math_imul(i1, i2) | 0) + i3 | 0, Math_imul(i2 << 1, i4) | 0);
   i4 = i7 + (i3 << 3) | 0;
   i2 = i7 + (i3 << 3) + 4 | 0;
   d10 = d11 * +HEAPF32[i2 >> 2];
   HEAPF32[i4 >> 2] = d11 * +HEAPF32[i4 >> 2];
   HEAPF32[i2 >> 2] = d10;
   i3 = i3 + 1 | 0;
   i2 = HEAP32[i6 >> 2] | 0;
   if (i3 >>> 0 >= i2 >>> 0) break;
   i1 = HEAP32[i8 >> 2] | 0;
   i4 = HEAP32[i5 >> 2] | 0;
  }
  i1 = HEAP32[i8 >> 2] | 0;
 }
 i7 = i1 + 1 | 0;
 HEAP32[i8 >> 2] = i7;
 if ((i7 | 0) != (HEAP32[i9 + 28 >> 2] | 0)) return;
 HEAP32[i8 >> 2] = 0;
 HEAP32[i9 + 92 >> 2] = 1;
 return;
}

function _gmskframegen_create() {
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0;
 i1 = _malloc(100) | 0;
 HEAP32[i1 + 4 >> 2] = 2;
 HEAP32[i1 + 8 >> 2] = 3;
 HEAPF32[i1 + 12 >> 2] = .5;
 HEAP32[i1 + 16 >> 2] = 63;
 i3 = i1 + 24 | 0;
 HEAP32[i3 >> 2] = 0;
 HEAP32[i1 + 28 >> 2] = 6;
 i4 = _gmskmod_create(2, 3, .5) | 0;
 HEAP32[i1 >> 2] = i4;
 i2 = i1 + 32 | 0;
 HEAP32[i2 >> 2] = _msequence_create(6, 109, 1) | 0;
 _gmskmod_reset(i4);
 HEAP32[i1 + 84 >> 2] = 0;
 _msequence_reset(HEAP32[i2 >> 2] | 0);
 HEAP32[i1 + 88 >> 2] = 0;
 HEAP32[i1 + 92 >> 2] = 0;
 HEAP32[i1 + 96 >> 2] = 0;
 HEAP32[i1 + 44 >> 2] = 0;
 HEAP32[i1 + 48 >> 2] = 0;
 HEAP32[i1 + 52 >> 2] = 0;
 _gmskframegen_set_header_len(i1, 8);
 HEAP32[i1 + 72 >> 2] = 0;
 HEAP32[i1 + 60 >> 2] = 6;
 HEAP32[i1 + 64 >> 2] = 1;
 HEAP32[i1 + 68 >> 2] = 1;
 i2 = _packetizer_create(0, 6, 1, 1) | 0;
 HEAP32[i1 + 56 >> 2] = i2;
 i2 = _packetizer_get_enc_msg_len(i2) | 0;
 HEAP32[i1 + 76 >> 2] = i2;
 HEAP32[i3 >> 2] = i2 << 3;
 HEAP32[i1 + 80 >> 2] = _malloc(i2) | 0;
 return i1 | 0;
}

function _detector_cccf_update_sumsq(i9, i2) {
 i9 = i9 | 0;
 i2 = i2 | 0;
 var d1 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, i6 = 0, d7 = 0.0, i8 = 0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i8 = i10 + 24 | 0;
 i12 = i10 + 16 | 0;
 i13 = i10 + 8 | 0;
 i6 = i10;
 d7 = +HEAPF32[i2 >> 2];
 d3 = +HEAPF32[i2 + 4 >> 2];
 HEAPF32[i13 >> 2] = d7;
 HEAPF32[i13 + 4 >> 2] = d3;
 HEAP32[i8 >> 2] = HEAP32[i13 >> 2];
 HEAP32[i8 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
 _conjf(i12, i8);
 d4 = +HEAPF32[i12 >> 2];
 d5 = +HEAPF32[i12 + 4 >> 2];
 d1 = d7 * d4 - d3 * d5;
 d11 = d3 * d4 + d7 * d5;
 if ((d1 != d1 | 0.0 != 0.0) & (d11 != d11 | 0.0 != 0.0)) {
  ___mulsc3(i6, d7, d3, d4, d5);
  d1 = +HEAPF32[i6 >> 2];
 }
 i13 = i9 + 60 | 0;
 _wdelayf_read(HEAP32[i13 >> 2] | 0, i8);
 _wdelayf_push(HEAP32[i13 >> 2] | 0, d1);
 i13 = i9 + 64 | 0;
 d11 = d1 + +HEAPF32[i13 >> 2] - +HEAPF32[i8 >> 2];
 HEAPF32[i13 >> 2] = d11;
 HEAPF32[i9 + 68 >> 2] = d11 * +HEAPF32[i9 + 12 >> 2];
 STACKTOP = i10;
 return;
}

function _matrixf_mul(i9, i1, i10, i11, i3, i2, i12, i14, i13) {
 i9 = i9 | 0;
 i1 = i1 | 0;
 i10 = i10 | 0;
 i11 = i11 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 i12 = i12 | 0;
 i14 = i14 | 0;
 i13 = i13 | 0;
 var d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 if (!((i10 | 0) == (i3 | 0) & ((i14 | 0) == (i1 | 0) & (i13 | 0) == (i2 | 0)))) {
  _fwrite(gb + 30171 | 0, 40, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i14) return;
 i2 = (i10 | 0) == 0;
 if (!i13) return;
 i3 = i13 << 2;
 i8 = 0;
 do {
  i5 = Math_imul(i8, i13) | 0;
  i6 = Math_imul(i8, i10) | 0;
  if (i2) _memset(i12 + (i5 << 2) | 0, 0, i3 | 0) | 0; else {
   i7 = 0;
   do {
    i1 = 0;
    d4 = 0.0;
    do {
     d4 = d4 + +HEAPF32[i9 + (i1 + i6 << 2) >> 2] * +HEAPF32[i11 + ((Math_imul(i1, i13) | 0) + i7 << 2) >> 2];
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i10 | 0));
    HEAPF32[i12 + (i7 + i5 << 2) >> 2] = d4;
    i7 = i7 + 1 | 0;
   } while ((i7 | 0) != (i13 | 0));
  }
  i8 = i8 + 1 | 0;
 } while ((i8 | 0) != (i14 | 0));
 return;
}

function _liquid_firdes_rcos(i1, i2, d11, d12, i13) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 d11 = +d11;
 d12 = +d12;
 i13 = i13 | 0;
 var d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 if (!i1) {
  _fwrite(gb + 23613 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i2) {
  _fwrite(gb + 23668 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d11 < 0.0 | d11 > 1.0) {
  _fwrite(gb + 23723 | 0, 51, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 d9 = +(i1 >>> 0);
 d10 = +(i2 >>> 0);
 d8 = d11;
 d6 = d11 * 4.0 * d11;
 d7 = 3.141592653589793 / (d8 * 2.0);
 d8 = d8 * 3.141592653589793;
 i1 = (Math_imul(i2, i1) | 0) << 1 | 1;
 i2 = 0;
 do {
  d3 = (+(i2 >>> 0) + d12) / d9 - d10;
  d4 = +_sincf(d3);
  d5 = 1.0 - d3 * (d6 * d3);
  if (+Math_abs(+d5) < 1.0000000474974513e-03) d3 = +Math_sin(+d7) * d11 * .5; else d3 = d4 * +Math_cos(+(d8 * d3)) / d5;
  HEAPF32[i13 + (i2 << 2) >> 2] = d3;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i1 | 0));
 return;
}

function _quiet_encoder_sample_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i5;
 i3 = _calloc(i1, 1) | 0;
 switch (HEAP32[i4 + 60 >> 2] | 0) {
 case 0:
  {
   i6 = i4 + 96 | 0;
   _ofdmflexframegen_assemble(HEAP32[i6 >> 2] | 0, i2, i3, i1);
   i1 = _ofdmflexframegen_getframelen(HEAP32[i6 >> 2] | 0) | 0;
   i1 = Math_imul(HEAP32[i4 + 112 >> 2] | 0, i1) | 0;
   break;
  }
 case 1:
  {
   i6 = i4 + 96 | 0;
   _flexframegen_assemble(HEAP32[i6 >> 2] | 0, i2, i3, i1);
   i1 = _flexframegen_getframelen(HEAP32[i6 >> 2] | 0) | 0;
   break;
  }
 case 2:
  {
   i6 = i4 + 96 | 0;
   _gmskframegen_assemble(HEAP32[i6 >> 2] | 0, i2, i3, i1, HEAP32[i4 + 64 >> 2] | 0, HEAP32[i4 + 68 >> 2] | 0, HEAP32[i4 + 72 >> 2] | 0);
   i1 = _gmskframegen_getframelen(HEAP32[i6 >> 2] | 0) | 0;
   break;
  }
 default:
  i1 = 0;
 }
 _free(i3);
 i6 = _modulator_sample_len(HEAP32[i4 + 104 >> 2] | 0, i1) | 0;
 STACKTOP = i5;
 return i6 | 0;
}

function _modem_demodulate_ask(i9, i11, i10) {
 i9 = i9 | 0;
 i11 = i11 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i6 = HEAP32[i9 + 4 >> 2] | 0;
 if (!i6) {
  i2 = HEAP32[i11 >> 2] | 0;
  i1 = 0;
 } else {
  d3 = +HEAPF32[i11 >> 2];
  i7 = i6 + -1 | 0;
  i2 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
  i5 = 0;
  i8 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d3 > 0.0) {
    d3 = d3 - +HEAPF32[i9 + 12 + (i5 + i7 << 2) >> 2];
    i1 = i1 | 1;
   } else d3 = d3 + +HEAPF32[i9 + 12 + (i5 + i7 << 2) >> 2];
   i4 = i8 + 1 | 0;
   if ((i4 | 0) == (i6 | 0)) break; else {
    i5 = ~i8;
    i8 = i4;
   }
  }
 }
 i8 = _gray_encode(i1) | 0;
 HEAP32[i10 >> 2] = i8;
 i10 = (_gray_decode(i8) | 0) << 1;
 HEAPF32[i9 + 92 >> 2] = +HEAPF32[i9 + 100 >> 2] * +(1 - (HEAP32[i9 + 8 >> 2] | 0) + i10 | 0);
 HEAPF32[i9 + 96 >> 2] = 0.0;
 i11 = HEAP32[i11 + 4 >> 2] | 0;
 HEAP32[i9 + 84 >> 2] = i2;
 HEAP32[i9 + 88 >> 2] = i11;
 return;
}

function _modem_modulate_apsk(i6, i1, i7) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 if ((HEAP32[i6 + 8 >> 2] | 0) >>> 0 <= i1 >>> 0) {
  _fwrite(gb + 31311 | 0, 59, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  return;
 }
 i5 = HEAPU8[(HEAP32[i6 + 232 >> 2] | 0) + i1 >> 0] | 0;
 i2 = HEAP32[i6 + 100 >> 2] | 0;
 L5 : do if (!i2) {
  i3 = 0;
  i1 = 0;
 } else {
  i3 = 0;
  i4 = 0;
  while (1) {
   i1 = (HEAP32[i6 + 104 + (i3 << 2) >> 2] | 0) + i4 | 0;
   if (i5 >>> 0 < i1 >>> 0) {
    i1 = i4;
    break L5;
   }
   i3 = i3 + 1 | 0;
   if (i3 >>> 0 >= i2 >>> 0) {
    i3 = 0;
    break;
   } else i4 = i1;
  }
 } while (0);
 d9 = +HEAPF32[i6 + 136 + (i3 << 2) >> 2];
 d10 = +HEAPF32[i6 + 200 + (i3 << 2) >> 2] + +((i5 - i1 | 0) >>> 0) * 2.0 * 3.141592653589793 / +((HEAP32[i6 + 104 + (i3 << 2) >> 2] | 0) >>> 0);
 d8 = +Math_sin(+d10);
 HEAPF32[i7 >> 2] = d9 * (+Math_cos(+d10) + d8 * 0.0);
 HEAPF32[i7 + 4 >> 2] = d9 * d8;
 return;
}

function _utf8_check_first(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4;
 i5 = i4 + 5 | 0;
 i3 = i4 + 4 | 0;
 HEAP8[i5 >> 0] = i2;
 HEAP8[i3 >> 0] = HEAP8[i5 >> 0] | 0;
 do if ((HEAPU8[i3 >> 0] | 0 | 0) < 128) HEAP32[i1 >> 2] = 1; else {
  if (128 <= (HEAPU8[i3 >> 0] | 0 | 0) ? (HEAPU8[i3 >> 0] | 0 | 0) <= 191 : 0) {
   HEAP32[i1 >> 2] = 0;
   break;
  }
  if ((HEAPU8[i3 >> 0] | 0 | 0) != 192 ? (HEAPU8[i3 >> 0] | 0 | 0) != 193 : 0) {
   if (194 <= (HEAPU8[i3 >> 0] | 0 | 0) ? (HEAPU8[i3 >> 0] | 0 | 0) <= 223 : 0) {
    HEAP32[i1 >> 2] = 2;
    break;
   }
   if (224 <= (HEAPU8[i3 >> 0] | 0 | 0) ? (HEAPU8[i3 >> 0] | 0 | 0) <= 239 : 0) {
    HEAP32[i1 >> 2] = 3;
    break;
   }
   if (240 <= (HEAPU8[i3 >> 0] | 0 | 0) ? (HEAPU8[i3 >> 0] | 0 | 0) <= 244 : 0) {
    HEAP32[i1 >> 2] = 4;
    break;
   }
   HEAP32[i1 >> 2] = 0;
   break;
  }
  HEAP32[i1 >> 2] = 0;
 } while (0);
 STACKTOP = i4;
 return HEAP32[i1 >> 2] | 0;
}

function _fecsoft_hamming74_decode(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0;
 i8 = HEAPU8[i1 >> 0] | 0;
 i14 = i8 ^ 255;
 i17 = HEAPU8[i1 + 1 >> 0] | 0;
 i18 = i17 ^ 255;
 i19 = HEAPU8[i1 + 2 >> 0] | 0;
 i9 = i19 ^ 255;
 i10 = HEAPU8[i1 + 3 >> 0] | 0;
 i11 = i10 ^ 255;
 i12 = HEAPU8[i1 + 4 >> 0] | 0;
 i13 = i12 ^ 255;
 i15 = HEAPU8[i1 + 5 >> 0] | 0;
 i16 = i15 ^ 255;
 i2 = HEAPU8[i1 + 6 >> 0] | 0;
 i3 = i2 ^ 255;
 i5 = 0;
 i6 = 0;
 i1 = 0;
 while (1) {
  i4 = HEAPU8[gb + 12898 + i6 >> 0] | 0;
  i4 = (i4 & 32 | 0 ? i18 : i17) + (i4 & 64 | 0 ? i14 : i8) + (i4 & 16 | 0 ? i9 : i19) + (i4 & 8 | 0 ? i11 : i10) + (i4 & 4 | 0 ? i13 : i12) + (i4 & 2 | 0 ? i16 : i15) + (i4 & 1 | 0 ? i3 : i2) | 0;
  i7 = (i6 | 0) == 0 | i4 >>> 0 < i5 >>> 0;
  i1 = i7 ? i6 & 255 : i1;
  i6 = i6 + 1 | 0;
  if ((i6 | 0) == 16) break; else i5 = i7 ? i4 : i5;
 }
 return i1 | 0;
}

function _hashtable_get(i2, i3) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i5 + 20 | 0;
 i9 = i5 + 16 | 0;
 i7 = i5 + 12 | 0;
 i4 = i5 + 8 | 0;
 i6 = i5 + 4 | 0;
 i8 = i5;
 HEAP32[i9 >> 2] = i2;
 HEAP32[i7 >> 2] = i3;
 i2 = HEAP32[i7 >> 2] | 0;
 i3 = _strlen(HEAP32[i7 >> 2] | 0) | 0;
 HEAP32[i6 >> 2] = _hashlittle(i2, i3, HEAP32[gb + 44300 >> 2] | 0) | 0;
 HEAP32[i8 >> 2] = (HEAP32[(HEAP32[i9 >> 2] | 0) + 4 >> 2] | 0) + ((HEAP32[i6 >> 2] & (1 << HEAP32[(HEAP32[i9 >> 2] | 0) + 8 >> 2]) - 1) << 3);
 HEAP32[i4 >> 2] = _hashtable_find_pair(HEAP32[i9 >> 2] | 0, HEAP32[i8 >> 2] | 0, HEAP32[i7 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
 if (HEAP32[i4 >> 2] | 0) {
  HEAP32[i1 >> 2] = HEAP32[(HEAP32[i4 >> 2] | 0) + 12 >> 2];
  i9 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i5;
  return i9 | 0;
 } else {
  HEAP32[i1 >> 2] = 0;
  i9 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i5;
  return i9 | 0;
 }
 return 0;
}

function _jsonp_error_vset(i9, i10, i8, i12, i11, i7) {
 i9 = i9 | 0;
 i10 = i10 | 0;
 i8 = i8 | 0;
 i12 = i12 | 0;
 i11 = i11 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i13 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i13 + 20 | 0;
 i2 = i13 + 16 | 0;
 i3 = i13 + 12 | 0;
 i4 = i13 + 8 | 0;
 i5 = i13 + 4 | 0;
 i6 = i13;
 HEAP32[i1 >> 2] = i9;
 HEAP32[i2 >> 2] = i10;
 HEAP32[i3 >> 2] = i8;
 HEAP32[i4 >> 2] = i12;
 HEAP32[i5 >> 2] = i11;
 HEAP32[i6 >> 2] = i7;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i13;
  return;
 }
 if (HEAP8[(HEAP32[i1 >> 2] | 0) + 92 >> 0] | 0) {
  STACKTOP = i13;
  return;
 }
 HEAP32[HEAP32[i1 >> 2] >> 2] = HEAP32[i2 >> 2];
 HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] = HEAP32[i3 >> 2];
 HEAP32[(HEAP32[i1 >> 2] | 0) + 8 >> 2] = HEAP32[i4 >> 2];
 _vsnprintf((HEAP32[i1 >> 2] | 0) + 92 | 0, 160, HEAP32[i5 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
 HEAP8[(HEAP32[i1 >> 2] | 0) + 92 + 159 >> 0] = 0;
 STACKTOP = i13;
 return;
}

function _flexframesync_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 HEAP32[i4 + 148 >> 2] = i1;
 i3 = i1 + 6 | 0;
 i1 = i4 + 152 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 156 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i4 + 144 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _qpacketmodem_destroy(i3);
 i3 = _qpacketmodem_create() | 0;
 HEAP32[i2 >> 2] = i3;
 _qpacketmodem_configure(i3, HEAP32[i1 >> 2] | 0, 6, 10, 5, 48) | 0;
 i3 = _qpacketmodem_get_frame_len(HEAP32[i2 >> 2] | 0) | 0;
 i1 = i4 + 140 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 136 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3 << 3) | 0;
 i2 = i4 + 132 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _qpilotsync_destroy(i3);
 i3 = _qpilotsync_create(HEAP32[i1 >> 2] | 0, 16) | 0;
 HEAP32[i2 >> 2] = i3;
 i3 = _qpilotsync_get_frame_len(i3) | 0;
 HEAP32[i4 + 128 >> 2] = i3;
 i4 = i4 + 124 | 0;
 HEAP32[i4 >> 2] = _realloc(HEAP32[i4 >> 2] | 0, i3 << 3) | 0;
 return;
}

function ___shgetc(i6) {
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0;
 i2 = i6 + 104 | 0;
 i5 = HEAP32[i2 >> 2] | 0;
 if ((i5 | 0) != 0 ? (HEAP32[i6 + 108 >> 2] | 0) >= (i5 | 0) : 0) i7 = 4; else {
  i1 = ___uflow(i6) | 0;
  if ((i1 | 0) >= 0) {
   i2 = HEAP32[i2 >> 2] | 0;
   i5 = HEAP32[i6 + 8 >> 2] | 0;
   if (i2) {
    i4 = HEAP32[i6 + 4 >> 2] | 0;
    i2 = i2 - (HEAP32[i6 + 108 >> 2] | 0) | 0;
    i3 = i5;
    if ((i5 - i4 | 0) < (i2 | 0)) i7 = 9; else HEAP32[i6 + 100 >> 2] = i4 + (i2 + -1);
   } else {
    i3 = i5;
    i7 = 9;
   }
   if ((i7 | 0) == 9) HEAP32[i6 + 100 >> 2] = i5;
   i2 = i6 + 4 | 0;
   if (!i3) i2 = HEAP32[i2 >> 2] | 0; else {
    i2 = HEAP32[i2 >> 2] | 0;
    i6 = i6 + 108 | 0;
    HEAP32[i6 >> 2] = i3 + 1 - i2 + (HEAP32[i6 >> 2] | 0);
   }
   i2 = i2 + -1 | 0;
   if ((HEAPU8[i2 >> 0] | 0 | 0) != (i1 | 0)) HEAP8[i2 >> 0] = i1;
  } else i7 = 4;
 }
 if ((i7 | 0) == 4) {
  HEAP32[i6 + 100 >> 2] = 0;
  i1 = -1;
 }
 return i1 | 0;
}

function _modulator_create(i3) {
 i3 = i3 | 0;
 var d1 = 0.0, i2 = 0, i4 = 0;
 if (!i3) {
  i4 = 0;
  return i4 | 0;
 }
 i4 = _malloc(36) | 0;
 HEAP32[i4 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i4 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
 HEAP32[i4 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
 HEAP32[i4 + 12 >> 2] = HEAP32[i3 + 12 >> 2];
 HEAP32[i4 + 16 >> 2] = HEAP32[i3 + 16 >> 2];
 HEAP32[i4 + 20 >> 2] = HEAP32[i3 + 20 >> 2];
 i2 = _nco_crcf_create(0) | 0;
 HEAP32[i4 + 24 >> 2] = i2;
 _nco_crcf_set_phase(i2, 0.0);
 _nco_crcf_set_frequency(i2, +HEAPF32[i3 + 12 >> 2]);
 i2 = HEAP32[i3 >> 2] | 0;
 if (i2 >>> 0 > 1) HEAP32[i4 + 28 >> 2] = _firinterp_crcf_create_kaiser(i2, HEAP32[i3 + 4 >> 2] | 0, 60.0) | 0; else {
  HEAP32[i4 >> 2] = 1;
  HEAP32[i4 + 4 >> 2] = 0;
  HEAP32[i4 + 28 >> 2] = 0;
 }
 d1 = +HEAPF32[i3 + 20 >> 2];
 if (d1 != 0.0) {
  HEAP32[i4 + 32 >> 2] = _iirfilt_crcf_create_dc_blocker(d1) | 0;
  return i4 | 0;
 } else {
  HEAP32[i4 + 32 >> 2] = 0;
  return i4 | 0;
 }
 return 0;
}

function _fec_hamming128_encode(i1, i7, i5, i6) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0;
 i4 = i7 & 1;
 i2 = i7 - i4 | 0;
 if ((i4 | 0) == (i7 | 0)) i1 = 0; else {
  i3 = 0;
  i1 = 0;
  do {
   i9 = HEAP16[gb + 9244 + ((HEAPU8[i5 + i3 >> 0] | 0) << 1) >> 1] | 0;
   i8 = HEAP16[gb + 9244 + ((HEAPU8[i5 + (i3 | 1) >> 0] | 0) << 1) >> 1] | 0;
   HEAP8[i6 + i1 >> 0] = (i9 & 65535) >>> 4;
   HEAP8[i6 + (i1 + 1) >> 0] = (i8 & 65535) >>> 8 & 15 | (i9 & 65535) << 4;
   HEAP8[i6 + (i1 + 2) >> 0] = i8;
   i1 = i1 + 3 | 0;
   i3 = i3 + 2 | 0;
  } while (i3 >>> 0 < i2 >>> 0);
 }
 if (i4) {
  i9 = HEAP16[gb + 9244 + ((HEAPU8[i5 + (i7 + -1) >> 0] | 0) << 1) >> 1] | 0;
  HEAP8[i6 + i1 >> 0] = (i9 & 65535) >>> 4;
  HEAP8[i6 + (i1 + 1) >> 0] = (i9 & 65535) << 4;
  i1 = i1 + 2 | 0;
 }
 if ((i1 | 0) == (_fec_get_enc_msg_length(6, i7) | 0)) return; else ___assert_fail(gb + 13478 | 0, gb + 13541 | 0, 226, gb + 13570 | 0);
}

function _scramble_data(i5, i4) {
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0;
 i1 = i4 & -4;
 if (!i1) i2 = 0; else {
  i2 = i4 & -4;
  i3 = 0;
  do {
   i6 = i5 + i3 | 0;
   HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 180;
   i6 = i5 + (i3 | 1) | 0;
   HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 106;
   i6 = i5 + (i3 | 2) | 0;
   HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 139;
   i6 = i5 + (i3 | 3) | 0;
   HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 197;
   i3 = i3 + 4 | 0;
  } while (i3 >>> 0 < i1 >>> 0);
 }
 if (i2 >>> 0 < i4 >>> 0) {
  i6 = i5 + i2 | 0;
  HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 180;
 }
 i1 = i2 | 1;
 if (i1 >>> 0 < i4 >>> 0) {
  i6 = i5 + i1 | 0;
  HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 106;
 }
 i1 = i2 | 2;
 if (i1 >>> 0 < i4 >>> 0) {
  i6 = i5 + i1 | 0;
  HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 139;
 }
 i1 = i2 | 3;
 if (i1 >>> 0 >= i4 >>> 0) return;
 i6 = i5 + i1 | 0;
 HEAP8[i6 >> 0] = (HEAPU8[i6 >> 0] | 0) ^ 197;
 return;
}

function _liquid_firdes_fsech_freqresponse(i2, i3, d1, i11) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 i11 = i11 | 0;
 var d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 d6 = 1.0 - d1;
 d8 = +(i2 >>> 0);
 d9 = d6 * .5 / d8;
 d10 = .5 / d8;
 d7 = d1 + 1.0;
 d8 = d7 * .5 / d8;
 d4 = 1.316957950592041 / (d10 * d1);
 d5 = +((Math_imul(i2 << 1, i3) | 0 | 1) >>> 0);
 d6 = d10 * d6;
 d7 = d10 * d7;
 i2 = (Math_imul(i3, i2) | 0) << 1 | 1;
 i3 = 0;
 do {
  d1 = +(i3 >>> 0) / d5;
  d1 = +Math_abs(+(d1 > .5 ? d1 + -1.0 : d1));
  do if (!(d1 < d9)) {
   if (!(d1 > d9 & d1 < d8)) {
    HEAPF32[i11 + (i3 << 2) >> 2] = 0.0;
    break;
   }
   if (d1 < d10) {
    HEAPF32[i11 + (i3 << 2) >> 2] = 1.0 / +_coshf(d4 * (d1 - d6));
    break;
   } else {
    HEAPF32[i11 + (i3 << 2) >> 2] = 1.0 - 1.0 / +_coshf(d4 * (d7 - d1));
    break;
   }
  } else HEAPF32[i11 + (i3 << 2) >> 2] = 1.0; while (0);
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i2 | 0));
 return;
}

function _jsonp_strtod(i4, i3) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i6 + 20 | 0;
 i7 = i6 + 16 | 0;
 i2 = i6 + 12 | 0;
 i5 = i6;
 i8 = i6 + 8 | 0;
 HEAP32[i7 >> 2] = i4;
 HEAP32[i2 >> 2] = i3;
 _to_locale(HEAP32[i7 >> 2] | 0);
 HEAP32[(___errno_location() | 0) >> 2] = 0;
 HEAPF64[i5 >> 3] = +_strtod(HEAP32[HEAP32[i7 >> 2] >> 2] | 0, i8);
 if ((HEAP32[i8 >> 2] | 0) != ((HEAP32[HEAP32[i7 >> 2] >> 2] | 0) + (HEAP32[(HEAP32[i7 >> 2] | 0) + 4 >> 2] | 0) | 0)) ___assert_fail(gb + 41358 | 0, gb + 41402 | 0, 71, gb + 41412 | 0);
 if ((+HEAPF64[i5 >> 3] == inf ? 1 : +HEAPF64[i5 >> 3] == -inf) ? (HEAP32[(___errno_location() | 0) >> 2] | 0) == 34 : 0) {
  HEAP32[i1 >> 2] = -1;
  i8 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i6;
  return i8 | 0;
 }
 HEAPF64[HEAP32[i2 >> 2] >> 3] = +HEAPF64[i5 >> 3];
 HEAP32[i1 >> 2] = 0;
 i8 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i6;
 return i8 | 0;
}

function _liquid_firdes_fexp_freqresponse(i2, i3, d1, i11) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 i11 = i11 | 0;
 var d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 d6 = 1.0 - d1;
 d8 = +(i2 >>> 0);
 d9 = d6 * .5 / d8;
 d10 = .5 / d8;
 d7 = d1 + 1.0;
 d8 = d7 * .5 / d8;
 d4 = .6931471824645996 / (d10 * d1);
 d5 = +((Math_imul(i2 << 1, i3) | 0 | 1) >>> 0);
 d6 = d10 * d6;
 d7 = d10 * d7;
 i2 = (Math_imul(i3, i2) | 0) << 1 | 1;
 i3 = 0;
 do {
  d1 = +(i3 >>> 0) / d5;
  d1 = +Math_abs(+(d1 > .5 ? d1 + -1.0 : d1));
  do if (!(d1 < d9)) {
   if (!(d1 > d9 & d1 < d8)) {
    HEAPF32[i11 + (i3 << 2) >> 2] = 0.0;
    break;
   }
   if (d1 < d10) {
    HEAPF32[i11 + (i3 << 2) >> 2] = +Math_exp(+(d4 * (d6 - d1)));
    break;
   } else {
    HEAPF32[i11 + (i3 << 2) >> 2] = 1.0 - +Math_exp(+(d4 * (d1 - d7)));
    break;
   }
  } else HEAPF32[i11 + (i3 << 2) >> 2] = 1.0; while (0);
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i2 | 0));
 return;
}

function _json_real(d4) {
 d4 = +d4;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 12 | 0;
 i2 = i5;
 i3 = i5 + 8 | 0;
 HEAPF64[i2 >> 3] = d4;
 i6 = ___DOUBLE_BITS(+HEAPF64[i2 >> 3]) | 0;
 i7 = (getTempRet0() | 0) & 2147483647;
 if (!(i7 >>> 0 > 2146435072 | (i7 | 0) == 2146435072 & i6 >>> 0 > 0) ? (i7 = ___DOUBLE_BITS(+HEAPF64[i2 >> 3]) | 0, !((i7 | 0) == 0 & ((getTempRet0() | 0) & 2147483647 | 0) == 2146435072)) : 0) {
  HEAP32[i3 >> 2] = _jsonp_malloc(16) | 0;
  if (HEAP32[i3 >> 2] | 0) {
   _json_init(HEAP32[i3 >> 2] | 0, 4);
   HEAPF64[(HEAP32[i3 >> 2] | 0) + 8 >> 3] = +HEAPF64[i2 >> 3];
   HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
   i7 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i5;
   return i7 | 0;
  } else {
   HEAP32[i1 >> 2] = 0;
   i7 = HEAP32[i1 >> 2] | 0;
   STACKTOP = i5;
   return i7 | 0;
  }
 }
 HEAP32[i1 >> 2] = 0;
 i7 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i5;
 return i7 | 0;
}

function _qdetector_cccf_execute(i5, i4) {
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i6 + 16 | 0;
 i2 = i6 + 8 | 0;
 i3 = i6;
 switch (HEAP32[i5 + 88 >> 2] | 0) {
 case 0:
  {
   i3 = HEAP32[i4 + 4 >> 2] | 0;
   HEAP32[i2 >> 2] = HEAP32[i4 >> 2];
   HEAP32[i2 + 4 >> 2] = i3;
   HEAP32[i1 >> 2] = HEAP32[i2 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
   _qdetector_cccf_execute_seek(i5, i1);
   break;
  }
 case 1:
  {
   i2 = HEAP32[i4 + 4 >> 2] | 0;
   HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
   HEAP32[i3 + 4 >> 2] = i2;
   HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   _qdetector_cccf_execute_align(i5, i1);
   break;
  }
 default:
  {}
 }
 i1 = i5 + 92 | 0;
 if (!(HEAP32[i1 >> 2] | 0)) {
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 HEAP32[i1 >> 2] = 0;
 i5 = HEAP32[i5 + 28 >> 2] | 0;
 STACKTOP = i6;
 return i5 | 0;
}

function _nco_crcf_create(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5;
 i3 = _malloc(1060) | 0;
 HEAP32[i3 >> 2] = i1;
 i1 = i3 + 12 | 0;
 i2 = 0;
 do {
  HEAPF32[i1 + (i2 << 2) >> 2] = +Math_sin(+(+(i2 >>> 0) * 6.283185307179586 * .00390625));
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 256);
 HEAPF32[i3 + 1052 >> 2] = .10000000149011612;
 HEAPF32[i3 + 1056 >> 2] = .3162277638912201;
 i1 = HEAP32[i3 >> 2] | 0;
 switch (i1 | 0) {
 case 0:
  {
   HEAP32[i3 + 1048 >> 2] = fb + 6;
   break;
  }
 case 1:
  {
   HEAP32[i3 + 1048 >> 2] = fb + 7;
   break;
  }
 default:
  {
   i2 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i4 >> 2] = i1;
   _fprintf(i2, gb + 38354 | 0, i4) | 0;
   _exit(1);
  }
 }
 HEAPF32[i3 + 4 >> 2] = 0.0;
 HEAPF32[i3 + 8 >> 2] = 0.0;
 HEAP32[i3 + 1036 >> 2] = 0;
 HEAPF32[i3 + 1040 >> 2] = 0.0;
 HEAPF32[i3 + 1044 >> 2] = 1.0;
 STACKTOP = i5;
 return i3 | 0;
}

function _estimate_req_filter_As(d1, i2) {
 d1 = +d1;
 i2 = i2 | 0;
 var i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i9 = i10 + 8 | 0;
 i3 = i10;
 d5 = d1 * 14.260000228881836;
 d4 = +(i2 >>> 0);
 if (d1 > .5 | d1 <= 0.0) {
  i2 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i3 >> 3] = d1;
  _fprintf(i2, gb + 21517 | 0, i3) | 0;
  _exit(1);
 } else {
  d6 = .009999999776482582;
  d7 = 200.0;
  i8 = 0;
 }
 while (1) {
  d1 = (d7 + d6) * .5;
  if (d1 <= 0.0) {
   i2 = 4;
   break;
  }
  i2 = (d1 + -7.949999809265137) / d5 < d4;
  i8 = i8 + 1 | 0;
  if (i8 >>> 0 >= 20) {
   i2 = 6;
   break;
  } else {
   d6 = i2 ? d1 : d6;
   d7 = i2 ? d7 : d1;
  }
 }
 if ((i2 | 0) == 4) {
  i10 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i9 >> 3] = d1;
  _fprintf(i10, gb + 21454 | 0, i9) | 0;
  _exit(1);
 } else if ((i2 | 0) == 6) {
  STACKTOP = i10;
  return +d1;
 }
 return +(0.0);
}

function _json_delete(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (HEAP32[i1 >> 2] | 0 ? (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) == 0 : 0) {
  _json_delete_object(HEAP32[i1 >> 2] | 0);
  STACKTOP = i3;
  return;
 }
 if (HEAP32[i1 >> 2] | 0 ? (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) == 1 : 0) {
  _json_delete_array(HEAP32[i1 >> 2] | 0);
  STACKTOP = i3;
  return;
 }
 if (HEAP32[i1 >> 2] | 0 ? (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) == 2 : 0) {
  _json_delete_string(HEAP32[i1 >> 2] | 0);
  STACKTOP = i3;
  return;
 }
 if (HEAP32[i1 >> 2] | 0 ? (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) == 3 : 0) {
  _json_delete_integer(HEAP32[i1 >> 2] | 0);
  STACKTOP = i3;
  return;
 }
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i3;
  return;
 }
 if ((HEAP32[HEAP32[i1 >> 2] >> 2] | 0) != 4) {
  STACKTOP = i3;
  return;
 }
 _json_delete_real(HEAP32[i1 >> 2] | 0);
 STACKTOP = i3;
 return;
}

function _decoder_on_decode(i1, i2, i7, i8, i3, i4, i5) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i6 = 0;
 if (!i2) {
  i8 = 1;
  return i8 | 0;
 }
 if (!i5) {
  i8 = 0;
  return i8 | 0;
 }
 if (!i3) {
  i8 = i5 + 108 | 0;
  HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + 1;
  i8 = 1;
  return i8 | 0;
 }
 i6 = i5 + 72 | 0;
 i4 = i5 + 76 | 0;
 i5 = i5 + 68 | 0;
 while (1) {
  i2 = HEAP32[i6 >> 2] | 0;
  i1 = HEAP32[i4 >> 2] | 0;
  if ((i2 - i1 | 0) >>> 0 >= i8 >>> 0) {
   i3 = 9;
   break;
  }
  i2 = i2 << 1;
  i1 = _realloc(HEAP32[i5 >> 2] | 0, i2) | 0;
  if (i1 | 0) {
   i3 = 8;
   break;
  }
 }
 if ((i3 | 0) == 8) {
  HEAP32[i5 >> 2] = i1;
  HEAP32[i6 >> 2] = i2;
  i8 = 1;
  return i8 | 0;
 } else if ((i3 | 0) == 9) {
  _memmove((HEAP32[i5 >> 2] | 0) + i1 | 0, i7 | 0, i8 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i8;
  i8 = 0;
  return i8 | 0;
 }
 return 0;
}

function _gmskframesync_destroy(i1) {
 i1 = i1 | 0;
 if (HEAP32[i1 + 236 >> 2] | 0) {
  _windowcf_destroy(HEAP32[i1 + 240 >> 2] | 0);
  _windowf_destroy(HEAP32[i1 + 244 >> 2] | 0);
  _windowf_destroy(HEAP32[i1 + 248 >> 2] | 0);
  _windowf_destroy(HEAP32[i1 + 252 >> 2] | 0);
 }
 _iirfilt_crcf_destroy(HEAP32[i1 >> 2] | 0);
 _firpfb_rrrf_destroy(HEAP32[i1 + 76 >> 2] | 0);
 _firpfb_rrrf_destroy(HEAP32[i1 + 80 >> 2] | 0);
 _nco_crcf_destroy(HEAP32[i1 + 128 >> 2] | 0);
 _detector_cccf_destroy(HEAP32[i1 + 108 >> 2] | 0);
 _windowcf_destroy(HEAP32[i1 + 124 >> 2] | 0);
 _free(HEAP32[i1 + 136 >> 2] | 0);
 _free(HEAP32[i1 + 140 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 168 >> 2] | 0);
 _free(HEAP32[i1 + 156 >> 2] | 0);
 _free(HEAP32[i1 + 160 >> 2] | 0);
 _free(HEAP32[i1 + 164 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 208 >> 2] | 0);
 _free(HEAP32[i1 + 200 >> 2] | 0);
 _free(HEAP32[i1 + 204 >> 2] | 0);
 _free(i1);
 return;
}

function _erff(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, d4 = 0.0;
 i3 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0) >>> 31;
 d4 = +Math_abs(+d1);
 i2 = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0);
 do if (i2 >>> 0 <= 2139095039) if (i2 >>> 0 < 1062731776) if (i2 >>> 0 < 830472192) {
  d1 = (d1 * 8.0 + d1 * 1.0270333290100098) * .125;
  break;
 } else {
  d4 = d1 * d1;
  d1 = (d4 * (d4 * (d4 * (-.005770270247012377 - d4 * 2.3763017452438362e-05) + -.028481749817728996) + -.32504209876060486) + .12837916612625122) / (d4 * (d4 * (d4 * (d4 * (1.324947370449081e-04 - d4 * 3.9602282413397916e-06) + 5.0813062116503716e-03) + .06502225250005722) + .3979172110557556) + 1.0) * d1 + d1;
  break;
 } else {
  if (i2 >>> 0 < 1086324736) d1 = 1.0 - +_erfc2_142(i2, d1); else d1 = 1.0;
  d1 = i3 | 0 ? -d1 : d1;
  break;
 } else d1 = 1.0 / d1 + +(1 - (i3 << 1) | 0); while (0);
 return +d1;
}

function _fec_hamming128_decode(i1, i7, i6, i5) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0;
 i4 = i7 & 1;
 i3 = i7 - i4 | 0;
 if ((i4 | 0) == (i7 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i9 = HEAPU8[i6 + (i1 + 1) >> 0] | 0;
   i8 = i9 << 8 & 3840 | (HEAPU8[i6 + (i1 + 2) >> 0] | 0);
   HEAP8[i5 + i2 >> 0] = _fec_hamming128_decode_symbol(i9 >>> 4 | (HEAPU8[i6 + i1 >> 0] | 0) << 4) | 0;
   HEAP8[i5 + (i2 | 1) >> 0] = _fec_hamming128_decode_symbol(i8) | 0;
   i1 = i1 + 3 | 0;
   i2 = i2 + 2 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i4) {
  HEAP8[i5 + i2 >> 0] = _fec_hamming128_decode_symbol((HEAPU8[i6 + (i1 + 1) >> 0] | 0) >>> 4 | (HEAPU8[i6 + i1 >> 0] | 0) << 4) | 0;
  i1 = i1 + 2 | 0;
 }
 if ((i1 | 0) == (_fec_get_enc_msg_length(6, i7) | 0)) return; else ___assert_fail(gb + 13478 | 0, gb + 13541 | 0, 280, gb + 13592 | 0);
}

function _gmskmod_create(i2, i3, d1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 var i4 = 0, i5 = 0;
 if (i2 >>> 0 < 2) {
  _fwrite(gb + 30360 | 0, 59, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i3) {
  _fwrite(gb + 30420 | 0, 57, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d1 <= 0.0 | d1 >= 1.0) {
  _fwrite(gb + 30478 | 0, 65, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  i4 = _malloc(32) | 0;
  HEAP32[i4 >> 2] = i2;
  HEAP32[i4 + 4 >> 2] = i3;
  HEAPF32[i4 + 8 >> 2] = d1;
  HEAPF32[i4 + 28 >> 2] = 1.0 / +(i2 >>> 0);
  i5 = Math_imul(i2 << 1, i3) | 0 | 1;
  HEAP32[i4 + 12 >> 2] = i5;
  i5 = _malloc(i5 << 2) | 0;
  HEAP32[i4 + 16 >> 2] = i5;
  _liquid_firdes_gmsktx(i2, i3, d1, 0.0, i5);
  i3 = _firinterp_rrrf_create_prototype(11, i2, i3, d1, 0.0) | 0;
  HEAP32[i4 + 20 >> 2] = i3;
  HEAPF32[i4 + 24 >> 2] = 0.0;
  _firinterp_rrrf_reset(i3);
  return i4 | 0;
 }
 return 0;
}

function _firdecim_crcf_create(i3, i5, i6) {
 i3 = i3 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i7 + 8 | 0;
 i1 = i7;
 if (!i6) {
  i4 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i1 >> 2] = gb + 19656;
  _fprintf(i4, gb + 19661 | 0, i1) | 0;
  _exit(1);
 }
 if (!i3) {
  i4 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 19656;
  _fprintf(i4, gb + 19728 | 0, i2) | 0;
  _exit(1);
 }
 i4 = _malloc(20) | 0;
 HEAP32[i4 + 4 >> 2] = i6;
 HEAP32[i4 + 8 >> 2] = i3;
 i1 = _malloc(i6 << 2) | 0;
 HEAP32[i4 >> 2] = i1;
 i2 = i6 + -1 | 0;
 i3 = 0;
 do {
  HEAP32[i1 + (i3 << 2) >> 2] = HEAP32[i5 + (i2 - i3 << 2) >> 2];
  i3 = i3 + 1 | 0;
 } while (i3 >>> 0 < i6 >>> 0);
 i5 = _windowcf_create(i6) | 0;
 HEAP32[i4 + 12 >> 2] = i5;
 HEAP32[i4 + 16 >> 2] = _dotprod_crcf_create(i1, i6) | 0;
 _windowcf_clear(i5);
 STACKTOP = i7;
 return i4 | 0;
}

function _ofdmframesync_reset(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, d4 = 0.0;
 _nco_crcf_reset(HEAP32[i2 + 108 >> 2] | 0);
 _msequence_reset(HEAP32[i2 + 112 >> 2] | 0);
 i1 = i2 + 136 | 0;
 i3 = i2 + 116 | 0;
 HEAP32[i3 >> 2] = 0;
 HEAP32[i3 + 4 >> 2] = 0;
 HEAP32[i3 + 8 >> 2] = 0;
 HEAP32[i3 + 12 >> 2] = 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 i1 = HEAP32[i2 >> 2] | 0;
 if (i1 >>> 0 > 44) {
  HEAPF32[i2 + 152 >> 2] = .3499999940395355;
  d4 = .30000001192092896;
  i3 = i2 + 156 | 0;
  HEAPF32[i3 >> 2] = d4;
  i3 = i2 + 104 | 0;
  HEAP32[i3 >> 2] = 0;
  return;
 } else {
  HEAPF32[i2 + 152 >> 2] = +((44 - i1 | 0) >>> 0) * .009999999776482582 + .3499999940395355;
  d4 = +((44 - i1 | 0) >>> 0) * .009999999776482582 + .30000001192092896;
  i3 = i2 + 156 | 0;
  HEAPF32[i3 >> 2] = d4;
  i3 = i2 + 104 | 0;
  HEAP32[i3 >> 2] = 0;
  return;
 }
}

function ___strchrnul(i1, i4) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 var i2 = 0, i3 = 0, i5 = 0;
 i3 = i4 & 255;
 L1 : do if (!i3) i1 = i1 + (_strlen(i1) | 0) | 0; else {
  if (i1 & 3) {
   i2 = i4 & 255;
   do {
    i5 = HEAP8[i1 >> 0] | 0;
    if (i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 == i2 << 24 >> 24) break L1;
    i1 = i1 + 1 | 0;
   } while ((i1 & 3 | 0) != 0);
  }
  i3 = Math_imul(i3, 16843009) | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  L10 : do if (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009)) do {
   i5 = i2 ^ i3;
   if ((i5 & -2139062144 ^ -2139062144) & i5 + -16843009 | 0) break L10;
   i1 = i1 + 4 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
  } while (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009 | 0)); while (0);
  i2 = i4 & 255;
  while (1) {
   i5 = HEAP8[i1 >> 0] | 0;
   if (i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 == i2 << 24 >> 24) break; else i1 = i1 + 1 | 0;
  }
 } while (0);
 return i1 | 0;
}

function _firdecim_crcf_execute(i1, i8, i9) {
 i1 = i1 | 0;
 i8 = i8 | 0;
 i9 = i9 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i3 = i11 + 16 | 0;
 i10 = i11 + 8 | 0;
 i4 = i11;
 i5 = i1 + 8 | 0;
 if (!(HEAP32[i5 >> 2] | 0)) {
  STACKTOP = i11;
  return;
 }
 i6 = i1 + 12 | 0;
 i7 = i4 + 4 | 0;
 i1 = i1 + 16 | 0;
 i2 = 0;
 do {
  i12 = HEAP32[i6 >> 2] | 0;
  i13 = HEAP32[i8 + (i2 << 3) + 4 >> 2] | 0;
  HEAP32[i4 >> 2] = HEAP32[i8 + (i2 << 3) >> 2];
  HEAP32[i7 >> 2] = i13;
  HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
  HEAP32[i3 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
  _windowcf_push(i12, i3);
  if (!i2) {
   _windowcf_read(HEAP32[i6 >> 2] | 0, i10);
   _dotprod_crcf_execute(HEAP32[i1 >> 2] | 0, HEAP32[i10 >> 2] | 0, i9);
  }
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
 STACKTOP = i11;
 return;
}

function _fec_hamming128_decode_symbol(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 if (i2 >>> 0 > 4095) {
  _fwrite(gb + 13422 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i1 = i2 >>> 8;
 i1 = (HEAPU8[(i1 & 6) + (gb + 38755) >> 0] | 0) + (HEAPU8[(i2 & 102) + (gb + 38755) >> 0] | 0) << 1 & 2 | (HEAPU8[(i1 & 10) + (gb + 38755) >> 0] | 0) + (HEAPU8[(i2 & 170) + (gb + 38755) >> 0] | 0) & 1 | (HEAPU8[(i1 & 1) + (gb + 38755) >> 0] | 0) + (HEAPU8[(i2 & 225) + (gb + 38755) >> 0] | 0) << 2 & 4 | (HEAPU8[gb + 38755 >> 0] | 0) + (HEAPU8[(i2 & 31) + (gb + 38755) >> 0] | 0) << 3 & 8;
 if ((i1 + -1 | 0) >>> 0 > 11) {
  i1 = i2 & 15;
  i3 = i2 >>> 1;
  i3 = i3 & 112;
  i1 = i3 | i1;
  i2 = i2 >>> 2;
  i2 = i2 & 128;
  i2 = i1 | i2;
  return i2 | 0;
 }
 i3 = 1 << 12 - i1 ^ i2;
 i2 = i3 & 15;
 i1 = i3 >>> 1;
 i1 = i1 & 112;
 i2 = i1 | i2;
 i3 = i3 >>> 2;
 i3 = i3 & 128;
 i3 = i2 | i3;
 return i3 | 0;
}

function _jsonp_error_set_source(i3, i6) {
 i3 = i3 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i7 + 12 | 0;
 i2 = i7 + 8 | 0;
 i5 = i7 + 4 | 0;
 i4 = i7;
 HEAP32[i1 >> 2] = i3;
 HEAP32[i2 >> 2] = i6;
 if (!((HEAP32[i1 >> 2] | 0) != 0 & (HEAP32[i2 >> 2] | 0) != 0)) {
  STACKTOP = i7;
  return;
 }
 HEAP32[i5 >> 2] = _strlen(HEAP32[i2 >> 2] | 0) | 0;
 if ((HEAP32[i5 >> 2] | 0) >>> 0 < 80) {
  _strncpy((HEAP32[i1 >> 2] | 0) + 12 | 0, HEAP32[i2 >> 2] | 0, (HEAP32[i5 >> 2] | 0) + 1 | 0) | 0;
  STACKTOP = i7;
  return;
 } else {
  HEAP32[i4 >> 2] = (HEAP32[i5 >> 2] | 0) - 80 + 4;
  _strncpy((HEAP32[i1 >> 2] | 0) + 12 | 0, gb + 41425 | 0, 3) | 0;
  _strncpy((HEAP32[i1 >> 2] | 0) + 12 + 3 | 0, (HEAP32[i2 >> 2] | 0) + (HEAP32[i4 >> 2] | 0) | 0, (HEAP32[i5 >> 2] | 0) - (HEAP32[i4 >> 2] | 0) + 1 | 0) | 0;
  STACKTOP = i7;
  return;
 }
}

function _ilogb(d2) {
 d2 = +d2;
 var i1 = 0, i3 = 0, i4 = 0;
 HEAPF64[tempDoublePtr >> 3] = d2;
 i1 = HEAP32[tempDoublePtr >> 2] | 0;
 i3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i4 = _bitshift64Lshr(i1 | 0, i3 | 0, 52) | 0;
 getTempRet0() | 0;
 i4 = i4 & 2047;
 switch (i4 | 0) {
 case 0:
  {
   i1 = _bitshift64Shl(i1 | 0, i3 | 0, 12) | 0;
   i3 = getTempRet0() | 0;
   if (!((i1 | 0) == 0 & (i3 | 0) == 0)) if ((i3 | 0) > -1 | (i3 | 0) == -1 & i1 >>> 0 > 4294967295) {
    i4 = i1;
    i1 = -1023;
    do {
     i1 = i1 + -1 | 0;
     i4 = _bitshift64Shl(i4 | 0, i3 | 0, 1) | 0;
     i3 = getTempRet0() | 0;
    } while ((i3 | 0) > -1 | (i3 | 0) == -1 & i4 >>> 0 > 4294967295);
   } else i1 = -1023; else i1 = -2147483648;
   break;
  }
 case 2047:
  {
   i1 = (i1 | 0) != 0 | (i3 & 1048575 | 0) != 0 ? -2147483648 : 2147483647;
   break;
  }
 default:
  i1 = i4 + -1023 | 0;
 }
 return i1 | 0;
}

function _quiet_encoder_clamp_frame_len(i6, i1) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d7 = 0.0, i8 = 0;
 HEAP8[i6 + 92 >> 0] = 1;
 d7 = +HEAPF32[i6 + 148 >> 2];
 i1 = ~~(+Math_ceil(+(+(i1 >>> 0) / d7)) + +Math_ceil(+d7)) >>> 0;
 i1 = i1 - (_modulator_flush_sample_len(HEAP32[i6 + 104 >> 2] | 0) | 0) | 0;
 if (HEAP32[i6 + 152 >> 2] | 0) i1 = i1 - (HEAP32[i6 + 44 >> 2] | 0) | 0;
 i5 = i6 + 80 | 0;
 i4 = (_quiet_encoder_sample_len(i6, HEAP32[i5 >> 2] | 0) | 0) >>> 0 > i1 >>> 0;
 i3 = HEAP32[i5 >> 2] | 0;
 if (!i4) {
  i6 = i3;
  return i6 | 0;
 }
 i2 = i3 >>> 1;
 if (i3 >>> 0 > 1) {
  i4 = 0;
  do {
   i8 = (_quiet_encoder_sample_len(i6, i2) | 0) >>> 0 > i1 >>> 0;
   i3 = i8 ? i2 : i3;
   i4 = i8 ? i4 : i2;
   i8 = i3 - i4 | 0;
   i2 = (i8 >>> 1) + i4 | 0;
  } while (i8 >>> 0 > 1);
  i1 = i2;
 } else i1 = i2;
 HEAP32[i5 >> 2] = i1;
 i8 = i1;
 return i8 | 0;
}

function _gmskmod_modulate(i4, i1, i5) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i6 = 0, d7 = 0.0, d8 = 0.0;
 i6 = STACKTOP;
 d7 = +HEAPF32[i4 + 28 >> 2];
 i3 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[i4 >> 2] << 2) | 0) + 15 & -16) | 0;
 _firinterp_rrrf_execute(HEAP32[i4 + 20 >> 2] | 0, (i1 | 0) == 0 ? -d7 : d7, i3);
 if (!(HEAP32[i4 >> 2] | 0)) {
  STACKTOP = i6;
  return;
 }
 i1 = i4 + 24 | 0;
 i2 = 0;
 do {
  d8 = +HEAPF32[i3 + (i2 << 2) >> 2] + +HEAPF32[i1 >> 2];
  d7 = d8;
  d8 = d7 > 3.141592653589793 ? d7 + -6.283185307179586 : d8;
  d7 = d8;
  d8 = d7 < -3.141592653589793 ? d7 + 6.283185307179586 : d8;
  HEAPF32[i1 >> 2] = d8;
  d7 = +Math_sin(+d8);
  HEAPF32[i5 + (i2 << 3) >> 2] = +Math_cos(+d8) + d7 * 0.0;
  HEAPF32[i5 + (i2 << 3) + 4 >> 2] = d7;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < (HEAP32[i4 >> 2] | 0) >>> 0);
 STACKTOP = i6;
 return;
}

function _liquid_unpack_bytes(i4, i5, i6, i2, i7) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 i2 = i2 | 0;
 i7 = i7 | 0;
 var i1 = 0, i3 = 0, i8 = 0, i9 = 0;
 i1 = i5 << 3;
 if (i1 >>> 0 > i2 >>> 0) {
  _fwrite(gb + 39428 | 0, 40, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(-1);
 }
 if (!i5) {
  i6 = 0;
  HEAP32[i7 >> 2] = i6;
  return;
 } else {
  i2 = 0;
  i3 = 0;
 }
 while (1) {
  i9 = HEAP8[i4 + i2 >> 0] | 0;
  i8 = i9 & 255;
  HEAP8[i6 + i3 >> 0] = (i9 & 255) >>> 7;
  HEAP8[i6 + (i3 | 1) >> 0] = i8 >>> 6 & 1;
  HEAP8[i6 + (i3 | 2) >> 0] = i8 >>> 5 & 1;
  HEAP8[i6 + (i3 | 3) >> 0] = i8 >>> 4 & 1;
  HEAP8[i6 + (i3 | 4) >> 0] = i8 >>> 3 & 1;
  HEAP8[i6 + (i3 | 5) >> 0] = i8 >>> 2 & 1;
  HEAP8[i6 + (i3 | 6) >> 0] = i8 >>> 1 & 1;
  HEAP8[i6 + (i3 | 7) >> 0] = i8 & 1;
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i5 | 0)) break; else i3 = i3 + 8 | 0;
 }
 HEAP32[i7 >> 2] = i1;
 return;
}

function _flexframegen_setprops(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0;
 if (HEAP32[i2 + 112 >> 2] | 0) {
  _fwrite(gb + 24808 | 0, 81, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  i2 = -1;
  return i2 | 0;
 }
 if (!i1) {
  _flexframegen_setprops(i2, gb + 548 | 0) | 0;
  return 0;
 }
 if (((HEAP32[i1 >> 2] | 0) + -1 | 0) >>> 0 > 5) {
  _fwrite(gb + 24890 | 0, 63, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 4 >> 2] | 0)) {
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 24954 | 0, 63, 1, i3) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 8 >> 2] | 0)) {
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 24954 | 0, 63, 1, i3) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 12 >> 2] | 0)) {
  _fwrite(gb + 25018 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 _memmove(i2 + 32 | 0, i1 | 0, 16) | 0;
 _flexframegen_reconfigure(i2);
 i3 = 0;
 return i3 | 0;
}

function _liquid_unpack_array(i8, i7, i2, i1, i9) {
 i8 = i8 | 0;
 i7 = i7 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i9 = i9 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i10 = 0;
 if (i7 << 3 >>> 0 <= i2 >>> 0) {
  _fwrite(gb + 39327 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i3 = i2 >>> 3;
 if (!(i3 >>> 0 < i7 >>> 0 & (i1 | 0) != 0)) {
  i8 = i1;
  i7 = 0;
  i8 = i7 << i8;
  HEAP32[i9 >> 2] = i8;
  return;
 }
 i6 = i1;
 i2 = i2 - (i3 << 3) | 0;
 i1 = 0;
 while (1) {
  i4 = 8 - i2 | 0;
  i10 = i6 >>> 0 < i4 >>> 0 ? i6 : i4;
  i1 = 255 >>> (8 - i10 | 0) & 255 & (HEAPU8[i8 + i3 >> 0] | 0) >>> (i4 - i10 | 0) | i1 << i10;
  i4 = i10 + i2 | 0;
  i5 = i4 >>> 0 > 7;
  i3 = (i5 & 1) + i3 | 0;
  i2 = i6 - i10 | 0;
  if (!(i3 >>> 0 < i7 >>> 0 & (i6 | 0) != (i10 | 0))) break; else {
   i6 = i2;
   i2 = i5 ? i4 & 7 : i4;
  }
 }
 i10 = i1 << i2;
 HEAP32[i9 >> 2] = i10;
 return;
}

function _json_array() {
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4 + 4 | 0;
 i3 = i4;
 HEAP32[i3 >> 2] = _jsonp_malloc(24) | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  HEAP32[i1 >> 2] = 0;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 }
 _json_init(HEAP32[i3 >> 2] | 0, 1);
 HEAP32[(HEAP32[i3 >> 2] | 0) + 12 >> 2] = 0;
 HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] = 8;
 i2 = _jsonp_malloc(HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] << 2) | 0;
 HEAP32[(HEAP32[i3 >> 2] | 0) + 16 >> 2] = i2;
 i2 = HEAP32[i3 >> 2] | 0;
 if (HEAP32[(HEAP32[i3 >> 2] | 0) + 16 >> 2] | 0) {
  HEAP32[i2 + 20 >> 2] = 0;
  HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 } else {
  _jsonp_free(i2);
  HEAP32[i1 >> 2] = 0;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 }
 return 0;
}

function _modem_get_demodulator_phase_error(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, d7 = 0.0, i8 = 0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i11 = i8 + 24 | 0;
 i10 = i8 + 16 | 0;
 i12 = i8 + 8 | 0;
 i5 = i8;
 d6 = +HEAPF32[i1 + 84 >> 2];
 d7 = +HEAPF32[i1 + 88 >> 2];
 i13 = HEAP32[i1 + 96 >> 2] | 0;
 HEAP32[i12 >> 2] = HEAP32[i1 + 92 >> 2];
 HEAP32[i12 + 4 >> 2] = i13;
 HEAP32[i11 >> 2] = HEAP32[i12 >> 2];
 HEAP32[i11 + 4 >> 2] = HEAP32[i12 + 4 >> 2];
 _conjf(i10, i11);
 d2 = +HEAPF32[i10 >> 2];
 d3 = +HEAPF32[i10 + 4 >> 2];
 d9 = d6 * d2 - d7 * d3;
 d4 = d7 * d2 + d6 * d3;
 if (!((d9 != d9 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0))) {
  d9 = d4;
  STACKTOP = i8;
  return +d9;
 }
 ___mulsc3(i5, d6, d7, d2, d3);
 d9 = +HEAPF32[i5 + 4 >> 2];
 STACKTOP = i8;
 return +d9;
}

function _fec_rep5_decode_soft(i1, i13, i15, i14) {
 i1 = i1 | 0;
 i13 = i13 | 0;
 i15 = i15 | 0;
 i14 = i14 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 if (!i13) return;
 i1 = i13 << 1;
 i4 = i13 * 3 | 0;
 i5 = i13 << 2;
 i11 = 0;
 do {
  i6 = i14 + i11 | 0;
  HEAP8[i6 >> 0] = 0;
  i8 = i11 << 3;
  i9 = i11 + i13 << 3;
  i10 = i11 + i1 << 3;
  i2 = i11 + i4 << 3;
  i3 = i11 + i5 << 3;
  i7 = 0;
  i12 = 0;
  do {
   i7 = i7 & 255 | (((HEAPU8[i15 + (i12 + i9) >> 0] | 0) + (HEAPU8[i15 + (i12 + i8) >> 0] | 0) + (HEAPU8[i15 + (i12 + i10) >> 0] | 0) + (HEAPU8[i15 + (i12 + i2) >> 0] | 0) + (HEAPU8[i15 + (i12 + i3) >> 0] | 0) | 0) >>> 0 > 639 ? 1 << 7 - i12 : 0);
   HEAP8[i6 >> 0] = i7;
   i12 = i12 + 1 | 0;
  } while ((i12 | 0) != 8);
  i11 = i11 + 1 | 0;
 } while ((i11 | 0) != (i13 | 0));
 return;
}

function _wcrtomb(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 do if (i1) {
  if (i3 >>> 0 < 128) {
   HEAP8[i1 >> 0] = i3;
   i1 = 1;
   break;
  }
  if (i3 >>> 0 < 2048) {
   HEAP8[i1 >> 0] = i3 >>> 6 | 192;
   HEAP8[i1 + 1 >> 0] = i3 & 63 | 128;
   i1 = 2;
   break;
  }
  if (i3 >>> 0 < 55296 | (i3 & -8192 | 0) == 57344) {
   HEAP8[i1 >> 0] = i3 >>> 12 | 224;
   HEAP8[i1 + 1 >> 0] = i3 >>> 6 & 63 | 128;
   HEAP8[i1 + 2 >> 0] = i3 & 63 | 128;
   i1 = 3;
   break;
  }
  if ((i3 + -65536 | 0) >>> 0 < 1048576) {
   HEAP8[i1 >> 0] = i3 >>> 18 | 240;
   HEAP8[i1 + 1 >> 0] = i3 >>> 12 & 63 | 128;
   HEAP8[i1 + 2 >> 0] = i3 >>> 6 & 63 | 128;
   HEAP8[i1 + 3 >> 0] = i3 & 63 | 128;
   i1 = 4;
   break;
  } else {
   HEAP32[(___errno_location() | 0) >> 2] = 84;
   i1 = -1;
   break;
  }
 } else i1 = 1; while (0);
 return i1 | 0;
}

function _liquid_pack_array(i5, i6, i2, i1, i7) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i3 = 0, i4 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 if (i6 << 3 >>> 0 <= i2 >>> 0) {
  _fwrite(gb + 39267 | 0, 59, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i3 = i2 >>> 3;
 if (!(i3 >>> 0 < i6 >>> 0 & (i1 | 0) != 0)) return;
 i2 = i2 - (i3 << 3) | 0;
 i4 = i3;
 while (1) {
  i8 = 8 - i2 | 0;
  i8 = i1 >>> 0 < i8 >>> 0 ? i1 : i8;
  i10 = 8 - i8 | 0;
  i9 = i1;
  i1 = i1 - i8 | 0;
  i11 = 255 >>> i10 & 255;
  i10 = i10 - i2 | 0;
  i3 = i5 + i4 | 0;
  HEAP8[i3 >> 0] = (HEAPU8[i3 >> 0] | 0) & (i11 << i10 ^ 255) | (i11 & i7 >>> i1) << i10;
  i2 = i8 + i2 | 0;
  i3 = i2 >>> 0 > 7;
  i4 = (i3 & 1) + i4 | 0;
  if (!(i4 >>> 0 < i6 >>> 0 & (i9 | 0) != (i8 | 0))) break; else i2 = i3 ? i2 & 7 : i2;
 }
 return;
}

function _modem_init_map(i7) {
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i4 = i7 + 76 | 0;
 i1 = HEAP32[i4 >> 2] | 0;
 if (!i1) {
  _fwrite(gb + 30602 | 0, 65, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i5 = i7 + 8 | 0;
 i3 = HEAP32[i5 >> 2] | 0;
 if ((i3 + -1 | 0) >>> 0 > 65535) {
  _fwrite(gb + 30668 | 0, 60, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i6 = i7 + 236 | 0;
 i2 = HEAP32[i6 >> 2] | 0;
 if (!i2) {
  _fwrite(gb + 30729 | 0, 70, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i3) return;
 mftCall_viii(i2 | 0, i7 | 0, 0, i1 | 0);
 if ((HEAP32[i5 >> 2] | 0) >>> 0 > 1) i1 = 1; else return;
 do {
  mftCall_viii(HEAP32[i6 >> 2] | 0, i7 | 0, i1 | 0, (HEAP32[i4 >> 2] | 0) + (i1 << 3) | 0);
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
 return;
}

function _seed_from_urandom(i5) {
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i7 + 16 | 0;
 i2 = i7 + 12 | 0;
 i3 = i7 + 20 | 0;
 i4 = i7 + 8 | 0;
 i6 = i7 + 4 | 0;
 HEAP32[i2 >> 2] = i5;
 HEAP32[i6 >> 2] = _open(gb + 41429 | 0, 0, i7) | 0;
 if ((HEAP32[i6 >> 2] | 0) == -1) {
  HEAP32[i1 >> 2] = 1;
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 HEAP32[i4 >> 2] = (_read(HEAP32[i6 >> 2] | 0, i3, 4) | 0) == 4 & 1;
 _close(HEAP32[i6 >> 2] | 0) | 0;
 if (HEAP32[i4 >> 2] | 0) {
  i6 = _buf_to_uint32(i3) | 0;
  HEAP32[HEAP32[i2 >> 2] >> 2] = i6;
  HEAP32[i1 >> 2] = 0;
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 } else {
  HEAP32[i1 >> 2] = 1;
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 return 0;
}

function _poly_fit_lagrange_barycentric(i5, i8, i9) {
 i5 = i5 | 0;
 i8 = i8 | 0;
 i9 = i9 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, i6 = 0, i7 = 0;
 i7 = (i8 | 0) == 0;
 if (i7) return; else i6 = 0;
 do {
  i4 = i9 + (i6 << 3) | 0;
  HEAPF64[i4 >> 3] = 1.0;
  i1 = i5 + (i6 << 3) | 0;
  d2 = 1.0;
  i3 = 0;
  do {
   if ((i6 | 0) != (i3 | 0)) {
    d2 = d2 * (+HEAPF64[i1 >> 3] - +HEAPF64[i5 + (i3 << 3) >> 3]);
    HEAPF64[i4 >> 3] = d2;
   }
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i8 | 0));
  HEAPF64[i4 >> 3] = 1.0 / d2;
  i6 = i6 + 1 | 0;
 } while ((i6 | 0) != (i8 | 0));
 d2 = +HEAPF64[i9 >> 3];
 if (i7) return;
 HEAPF64[i9 >> 3] = d2 / d2;
 if ((i8 | 0) == 1) return; else i1 = 1;
 do {
  HEAPF64[i9 + (i1 << 3) >> 3] = +HEAPF64[i9 + (i1 << 3) >> 3] / d2;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i8 | 0));
 return;
}

function _nco_crcf_mix_down(i2, i1, i10) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i10 = i10 | 0;
 var d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, d9 = 0.0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i11;
 mftCall_vi(HEAP32[i2 + 1048 >> 2] | 0, i2 | 0);
 d9 = +HEAPF32[i1 >> 2];
 d7 = +HEAPF32[i1 + 4 >> 2];
 d4 = +HEAPF32[i2 + 1040 >> 2];
 d3 = +HEAPF32[i2 + 1044 >> 2] - d4 * 0.0;
 d4 = -d4;
 d5 = d9 * d3 - d7 * d4;
 d6 = d9 * d4 + d7 * d3;
 if (!((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0))) {
  d7 = d5;
  d9 = d6;
  i8 = i10 + 4 | 0;
  HEAPF32[i10 >> 2] = d7;
  HEAPF32[i8 >> 2] = d9;
  STACKTOP = i11;
  return;
 }
 ___mulsc3(i8, d9, d7, d3, d4);
 d7 = +HEAPF32[i8 >> 2];
 d9 = +HEAPF32[i8 + 4 >> 2];
 i8 = i10 + 4 | 0;
 HEAPF32[i10 >> 2] = d7;
 HEAPF32[i8 >> 2] = d9;
 STACKTOP = i11;
 return;
}

function _liquid_factor(i6, i4, i7) {
 i6 = i6 | 0;
 i4 = i4 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i8 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i9;
 i3 = i6;
 i1 = 0;
 do {
  if (i3 >>> 0 < 2) {
   i2 = 0;
   break;
  } else i2 = 2;
  do {
   if (!((i3 >>> 0) % (i2 >>> 0) | 0)) {
    i5 = 4;
    break;
   }
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 <= i3 >>> 0);
  if ((i5 | 0) == 4) {
   i5 = 0;
   HEAP32[i4 + (i1 << 2) >> 2] = i2;
   i3 = (i3 >>> 0) / (i2 >>> 0) | 0;
   i1 = i1 + 1 | 0;
  }
  i2 = i3 >>> 0 > 1;
 } while (i2 & i1 >>> 0 < 40);
 if (i2 & (i1 | 0) == 40) {
  i9 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i8 >> 2] = i6;
  HEAP32[i8 + 4 >> 2] = 40;
  _fprintf(i9, gb + 40488 | 0, i8) | 0;
  _exit(1);
 } else {
  HEAP32[i7 >> 2] = i1;
  STACKTOP = i9;
  return;
 }
}

function _nco_crcf_mix_up(i2, i1, i10) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i10 = i10 | 0;
 var d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, d9 = 0.0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i11;
 mftCall_vi(HEAP32[i2 + 1048 >> 2] | 0, i2 | 0);
 d9 = +HEAPF32[i1 >> 2];
 d6 = +HEAPF32[i1 + 4 >> 2];
 d7 = +HEAPF32[i2 + 1040 >> 2];
 d3 = +HEAPF32[i2 + 1044 >> 2] + d7 * 0.0;
 d4 = d9 * d3 - d6 * d7;
 d5 = d9 * d7 + d6 * d3;
 if (!((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0))) {
  d7 = d4;
  d9 = d5;
  i8 = i10 + 4 | 0;
  HEAPF32[i10 >> 2] = d7;
  HEAPF32[i8 >> 2] = d9;
  STACKTOP = i11;
  return;
 }
 ___mulsc3(i8, d9, d6, d3, d7);
 d7 = +HEAPF32[i8 >> 2];
 d9 = +HEAPF32[i8 + 4 >> 2];
 i8 = i10 + 4 | 0;
 HEAPF32[i10 >> 2] = d7;
 HEAPF32[i8 >> 2] = d9;
 STACKTOP = i11;
 return;
}

function _lex_init(i7, i6, i5, i4) {
 i7 = i7 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i8 = 0, i9 = 0, i10 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i8 + 16 | 0;
 i2 = i8 + 12 | 0;
 i10 = i8 + 8 | 0;
 i3 = i8 + 4 | 0;
 i9 = i8;
 HEAP32[i2 >> 2] = i7;
 HEAP32[i10 >> 2] = i6;
 HEAP32[i3 >> 2] = i5;
 HEAP32[i9 >> 2] = i4;
 _stream_init(HEAP32[i2 >> 2] | 0, HEAP32[i10 >> 2] | 0, HEAP32[i9 >> 2] | 0);
 if (_strbuffer_init((HEAP32[i2 >> 2] | 0) + 40 | 0) | 0) {
  HEAP32[i1 >> 2] = -1;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i8;
  return i10 | 0;
 } else {
  HEAP32[(HEAP32[i2 >> 2] | 0) + 52 >> 2] = HEAP32[i3 >> 2];
  HEAP32[(HEAP32[i2 >> 2] | 0) + 56 >> 2] = -1;
  HEAP32[i1 >> 2] = 0;
  i10 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i8;
  return i10 | 0;
 }
 return 0;
}

function ___remdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i5 | 0;
 i7 = i2 >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i6 = ((i2 | 0) < 0 ? -1 : 0) >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i10 = i4 >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i9 = ((i4 | 0) < 0 ? -1 : 0) >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i1 = _i64Subtract(i7 ^ i1 | 0, i6 ^ i2 | 0, i7 | 0, i6 | 0) | 0;
 i2 = getTempRet0() | 0;
 ___udivmoddi4(i1, i2, _i64Subtract(i10 ^ i3 | 0, i9 ^ i4 | 0, i10 | 0, i9 | 0) | 0, getTempRet0() | 0, i8) | 0;
 i4 = _i64Subtract(HEAP32[i8 >> 2] ^ i7 | 0, HEAP32[i8 + 4 >> 2] ^ i6 | 0, i7 | 0, i6 | 0) | 0;
 i3 = getTempRet0() | 0;
 STACKTOP = i5;
 return (setTempRet0(i3 | 0), i4) | 0;
}

function _fflush(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 do if (i2) {
  if ((HEAP32[i2 + 76 >> 2] | 0) <= -1) {
   i1 = ___fflush_unlocked(i2) | 0;
   break;
  }
  i3 = (___lockfile(i2) | 0) == 0;
  i1 = ___fflush_unlocked(i2) | 0;
  if (!i3) ___unlockfile(i2);
 } else {
  if (!(HEAP32[gb + 9040 >> 2] | 0)) i1 = 0; else i1 = _fflush(HEAP32[gb + 9040 >> 2] | 0) | 0;
  ___lock(gb + 44304 + 28 | 0);
  i2 = HEAP32[gb + 44304 + 24 >> 2] | 0;
  if (i2) do {
   if ((HEAP32[i2 + 76 >> 2] | 0) > -1) i3 = ___lockfile(i2) | 0; else i3 = 0;
   if ((HEAP32[i2 + 20 >> 2] | 0) >>> 0 > (HEAP32[i2 + 28 >> 2] | 0) >>> 0) i1 = ___fflush_unlocked(i2) | 0 | i1;
   if (i3 | 0) ___unlockfile(i2);
   i2 = HEAP32[i2 + 56 >> 2] | 0;
  } while ((i2 | 0) != 0);
  ___unlock(gb + 44304 + 28 | 0);
 } while (0);
 return i1 | 0;
}

function _json_object() {
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4 + 4 | 0;
 i3 = i4;
 HEAP32[i3 >> 2] = _jsonp_malloc(36) | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  HEAP32[i1 >> 2] = 0;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 }
 if (!(HEAP32[gb + 44300 >> 2] | 0)) _json_object_seed(0);
 _json_init(HEAP32[i3 >> 2] | 0, 0);
 i5 = (_hashtable_init((HEAP32[i3 >> 2] | 0) + 8 | 0) | 0) != 0;
 i2 = HEAP32[i3 >> 2] | 0;
 if (i5) {
  _jsonp_free(i2);
  HEAP32[i1 >> 2] = 0;
  i5 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i5 | 0;
 } else {
  HEAP32[i2 + 28 >> 2] = 0;
  HEAP32[(HEAP32[i3 >> 2] | 0) + 32 >> 2] = 0;
  HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
  i5 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i5 | 0;
 }
 return 0;
}

function _flexframesync_destroy(i1) {
 i1 = i1 | 0;
 if (HEAP32[i1 + 208 >> 2] | 0) _windowcf_destroy(HEAP32[i1 + 216 >> 2] | 0);
 _free(HEAP32[i1 + 116 >> 2] | 0);
 _free(HEAP32[i1 + 120 >> 2] | 0);
 _free(HEAP32[i1 + 124 >> 2] | 0);
 _free(HEAP32[i1 + 136 >> 2] | 0);
 _free(HEAP32[i1 + 156 >> 2] | 0);
 _free(HEAP32[i1 + 168 >> 2] | 0);
 _free(HEAP32[i1 + 180 >> 2] | 0);
 _qpilotsync_destroy(HEAP32[i1 + 132 >> 2] | 0);
 _qpacketmodem_destroy(HEAP32[i1 + 144 >> 2] | 0);
 _modem_destroy(HEAP32[i1 + 164 >> 2] | 0);
 _qpacketmodem_destroy(HEAP32[i1 + 176 >> 2] | 0);
 _qdetector_cccf_destroy(HEAP32[i1 + 72 >> 2] | 0);
 _firpfb_crcf_destroy(HEAP32[i1 + 100 >> 2] | 0);
 _nco_crcf_destroy(HEAP32[i1 + 92 >> 2] | 0);
 _nco_crcf_destroy(HEAP32[i1 + 96 >> 2] | 0);
 _free(i1);
 return;
}

function _iirfilt_crcf_reset(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0;
 if ((HEAP32[i1 + 24 >> 2] | 0) == 1) {
  i5 = i1 + 32 | 0;
  if (!(HEAP32[i5 >> 2] | 0)) return;
  i1 = i1 + 28 | 0;
  i2 = 0;
  do {
   i3 = (HEAP32[(HEAP32[i1 >> 2] | 0) + (i2 << 2) >> 2] | 0) + 24 | 0;
   i4 = i3 + 72 | 0;
   do {
    HEAP32[i3 >> 2] = 0;
    i3 = i3 + 4 | 0;
   } while ((i3 | 0) < (i4 | 0));
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
  return;
 } else {
  i3 = i1 + 12 | 0;
  if (!(HEAP32[i3 >> 2] | 0)) return;
  i1 = i1 + 8 | 0;
  i2 = 0;
  do {
   i5 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 + (i2 << 3) >> 2] = 0.0;
   HEAPF32[i5 + (i2 << 3) + 4 >> 2] = 0.0;
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
  return;
 }
}

function _matrixf_trans(i7, i2, i1) {
 i7 = i7 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i4 = i8 + 32 | 0;
 i5 = i8 + 16 | 0;
 i6 = i8;
 _matrixf_hermitian(i7, i2, i1);
 i1 = Math_imul(i1, i2) | 0;
 if (!i1) {
  STACKTOP = i8;
  return;
 }
 i2 = i6 + 8 | 0;
 i3 = 0;
 do {
  i9 = i7 + (i3 << 2) | 0;
  HEAPF64[i6 >> 3] = +HEAPF32[i9 >> 2];
  HEAPF64[i2 >> 3] = 0.0;
  HEAP32[i4 >> 2] = HEAP32[i6 >> 2];
  HEAP32[i4 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
  HEAP32[i4 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
  HEAP32[i4 + 12 >> 2] = HEAP32[i6 + 12 >> 2];
  _conj(i5, i4);
  HEAPF32[i9 >> 2] = +HEAPF64[i5 >> 3];
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i1 | 0));
 STACKTOP = i8;
 return;
}

function ___ldexp_cexpf(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0;
 d8 = +HEAPF32[i3 + 4 >> 2];
 d7 = +Math_exp(+(+HEAPF32[i3 >> 2] + -162.88958740234375));
 i3 = (HEAPF32[tempDoublePtr >> 2] = d7, HEAP32[tempDoublePtr >> 2] | 0);
 d7 = (HEAP32[tempDoublePtr >> 2] = i3 & 8388607 | 2130706432, +HEAPF32[tempDoublePtr >> 2]);
 i2 = i2 + -19 + (i3 >>> 23) | 0;
 i3 = (i2 | 0) / 2 | 0;
 d6 = (HEAP32[tempDoublePtr >> 2] = (i3 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
 d5 = (HEAP32[tempDoublePtr >> 2] = (i2 - i3 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
 d4 = +Math_sin(+d8) * d7 * d6 * d5;
 HEAPF32[i1 >> 2] = +Math_cos(+d8) * d7 * d6 * d5;
 HEAPF32[i1 + 4 >> 2] = d4;
 return;
}

function _firpfb_crcf_execute(i3, i2, i4) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 var i1 = 0, i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i7;
 i5 = i7 + 8 | 0;
 i1 = HEAP32[i3 + 12 >> 2] | 0;
 if (i1 >>> 0 > i2 >>> 0) {
  _windowcf_read(HEAP32[i3 + 16 >> 2] | 0, i5);
  _dotprod_crcf_execute(HEAP32[(HEAP32[i3 + 20 >> 2] | 0) + (i2 << 2) >> 2] | 0, HEAP32[i5 >> 2] | 0, i4);
  d9 = +HEAPF32[i3 + 24 >> 2];
  i6 = i4 + 4 | 0;
  d8 = d9 * +HEAPF32[i6 >> 2];
  HEAPF32[i4 >> 2] = d9 * +HEAPF32[i4 >> 2];
  HEAPF32[i6 >> 2] = d8;
  STACKTOP = i7;
  return;
 } else {
  i7 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = i2;
  HEAP32[i6 + 4 >> 2] = i1;
  _fprintf(i7, gb + 20859 | 0, i6) | 0;
  _exit(1);
 }
}

function ___overflow(i8, i6) {
 i8 = i8 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i9;
 i5 = i6 & 255;
 HEAP8[i7 >> 0] = i5;
 i2 = i8 + 16 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (!i3) if (!(___towrite(i8) | 0)) {
  i3 = HEAP32[i2 >> 2] | 0;
  i4 = 4;
 } else i1 = -1; else i4 = 4;
 do if ((i4 | 0) == 4) {
  i2 = i8 + 20 | 0;
  i4 = HEAP32[i2 >> 2] | 0;
  if (i4 >>> 0 < i3 >>> 0 ? (i1 = i6 & 255, (i1 | 0) != (HEAP8[i8 + 75 >> 0] | 0)) : 0) {
   HEAP32[i2 >> 2] = i4 + 1;
   HEAP8[i4 >> 0] = i5;
   break;
  }
  if ((mftCall_iiii(HEAP32[i8 + 36 >> 2] | 0, i8 | 0, i7 | 0, 1) | 0) == 1) i1 = HEAPU8[i7 >> 0] | 0; else i1 = -1;
 } while (0);
 STACKTOP = i9;
 return i1 | 0;
}

function _liquid_csqrtf(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i3 + 8 | 0;
 i9 = i3;
 i7 = HEAP32[i1 >> 2] | 0;
 i1 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i9 >> 2] = i7;
 HEAP32[i9 + 4 >> 2] = i1;
 HEAP32[i8 >> 2] = HEAP32[i9 >> 2];
 HEAP32[i8 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
 d5 = +_cabsf(i8);
 d4 = (HEAP32[tempDoublePtr >> 2] = i7, +HEAPF32[tempDoublePtr >> 2]);
 d6 = +Math_sqrt(+((d5 + d4) * .5));
 d4 = +Math_sqrt(+((d5 - d4) * .5));
 i1 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]) > 0.0;
 d5 = d4 * 0.0;
 HEAPF32[i2 >> 2] = d6 + (i1 ? d5 : -d5);
 HEAPF32[i2 + 4 >> 2] = i1 ? d4 : -d4;
 STACKTOP = i3;
 return;
}

function _strbuffer_pop(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 5 | 0;
 i2 = i5;
 i3 = i5 + 4 | 0;
 HEAP32[i2 >> 2] = i4;
 if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] | 0) >>> 0 > 0) {
  i6 = (HEAP32[i2 >> 2] | 0) + 4 | 0;
  i4 = (HEAP32[i6 >> 2] | 0) + -1 | 0;
  HEAP32[i6 >> 2] = i4;
  HEAP8[i3 >> 0] = HEAP8[(HEAP32[HEAP32[i2 >> 2] >> 2] | 0) + i4 >> 0] | 0;
  HEAP8[(HEAP32[HEAP32[i2 >> 2] >> 2] | 0) + (HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] | 0) >> 0] = 0;
  HEAP8[i1 >> 0] = HEAP8[i3 >> 0] | 0;
  i4 = HEAP8[i1 >> 0] | 0;
  STACKTOP = i5;
  return i4 | 0;
 } else {
  HEAP8[i1 >> 0] = 0;
  i6 = HEAP8[i1 >> 0] | 0;
  STACKTOP = i5;
  return i6 | 0;
 }
 return 0;
}

function _demodulator_create(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0;
 if (!i3) {
  i3 = 0;
  return i3 | 0;
 }
 i1 = _malloc(24) | 0;
 HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i1 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
 HEAP32[i1 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
 HEAP32[i1 + 12 >> 2] = HEAP32[i3 + 12 >> 2];
 i2 = _nco_crcf_create(0) | 0;
 HEAP32[i1 + 16 >> 2] = i2;
 _nco_crcf_set_phase(i2, 0.0);
 _nco_crcf_set_frequency(i2, +HEAPF32[i3 + 12 >> 2]);
 i2 = HEAP32[i3 >> 2] | 0;
 if (i2 >>> 0 > 1) {
  HEAP32[i1 + 20 >> 2] = _firdecim_crcf_create_kaiser(i2, HEAP32[i3 + 4 >> 2] | 0, 60.0) | 0;
  i3 = i1;
  return i3 | 0;
 } else {
  HEAP32[i1 >> 2] = 1;
  HEAP32[i1 + 4 >> 2] = 0;
  HEAP32[i1 + 20 >> 2] = 0;
  i3 = i1;
  return i3 | 0;
 }
 return 0;
}

function _ofdmframegen_write_S0b(i6, i7) {
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0, i9 = 0, i10 = 0;
 i1 = HEAP32[i6 >> 2] | 0;
 i5 = i6 + 4 | 0;
 i2 = HEAP32[i5 >> 2] | 0;
 i4 = i6 + 64 | 0;
 if ((i2 | 0) != (0 - i1 | 0)) {
  i3 = 0;
  do {
   i9 = ((i1 + i3 - i2 | 0) >>> 0) % (i1 >>> 0) | 0;
   i10 = HEAP32[i4 >> 2] | 0;
   i8 = HEAP32[i10 + (i9 << 3) + 4 >> 2] | 0;
   HEAP32[i7 + (i3 << 3) >> 2] = HEAP32[i10 + (i9 << 3) >> 2];
   HEAP32[i7 + (i3 << 3) + 4 >> 2] = i8;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i6 >> 2] | 0;
   i2 = HEAP32[i5 >> 2] | 0;
  } while (i3 >>> 0 < (i2 + i1 | 0) >>> 0);
 }
 _memmove(HEAP32[i6 + 20 >> 2] | 0, HEAP32[i4 >> 2] | 0, HEAP32[i6 + 12 >> 2] << 3 | 0) | 0;
 return;
}

function _ofdmflexframegen_setprops(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0;
 while (1) if (!i1) i1 = gb + 564 | 0; else break;
 if (((HEAP32[i1 >> 2] | 0) + -1 | 0) >>> 0 > 5) {
  _fwrite(gb + 27962 | 0, 67, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 4 >> 2] | 0)) {
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 28030 | 0, 67, 1, i3) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 8 >> 2] | 0)) {
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  _fwrite(gb + 28030 | 0, 67, 1, i3) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 12 >> 2] | 0)) {
  _fwrite(gb + 28098 | 0, 74, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  _memmove(i2 + 140 | 0, i1 | 0, 16) | 0;
  _ofdmflexframegen_reconfigure(i2);
  return;
 }
}

function _json_object_seed(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i5 + 12 | 0;
 i3 = i5 + 8 | 0;
 i1 = i5 + 4 | 0;
 i2 = i5;
 HEAP32[i6 >> 2] = i4;
 HEAP32[i3 >> 2] = HEAP32[i6 >> 2];
 if (HEAP32[gb + 44300 >> 2] | 0) {
  STACKTOP = i5;
  return;
 }
 i6 = HEAP8[gb + 44848 >> 0] | 0;
 HEAP8[gb + 44848 >> 0] = 1;
 if (i6 << 24 >> 24 != 0 | 0) {
  do {
   _sched_yield() | 0;
   HEAP32[i2 >> 2] = HEAP32[gb + 44300 >> 2];
  } while (!(HEAP32[i2 >> 2] | 0));
  STACKTOP = i5;
  return;
 }
 if (!(HEAP32[i3 >> 2] | 0)) HEAP32[i3 >> 2] = _generate_seed() | 0;
 HEAP32[i1 >> 2] = HEAP32[i3 >> 2];
 HEAP32[gb + 44300 >> 2] = HEAP32[i1 >> 2];
 STACKTOP = i5;
 return;
}

function _pad(i6, i2, i5, i4, i1) {
 i6 = i6 | 0;
 i2 = i2 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i3 = 0, i7 = 0, i8 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 i7 = i8;
 do if ((i5 | 0) > (i4 | 0) & (i1 & 73728 | 0) == 0) {
  i1 = i5 - i4 | 0;
  _memset(i7 | 0, i2 | 0, (i1 >>> 0 > 256 ? 256 : i1) | 0) | 0;
  i2 = HEAP32[i6 >> 2] | 0;
  i3 = (i2 & 32 | 0) == 0;
  if (i1 >>> 0 > 255) {
   i4 = i5 - i4 | 0;
   do {
    if (i3) {
     ___fwritex(i7, 256, i6) | 0;
     i2 = HEAP32[i6 >> 2] | 0;
    }
    i1 = i1 + -256 | 0;
    i3 = (i2 & 32 | 0) == 0;
   } while (i1 >>> 0 > 255);
   if (i3) i1 = i4 & 255; else break;
  } else if (!i3) break;
  ___fwritex(i7, i1, i6) | 0;
 } while (0);
 STACKTOP = i8;
 return;
}

function _fft_create_plan(i3, i4, i5, i1, i2) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 switch (_liquid_fft_estimate_method(i3) | 0) {
 case 1:
  {
   i5 = _fft_create_plan_radix2(i3, i4, i5, i1, i2) | 0;
   return i5 | 0;
  }
 case 2:
  {
   i5 = _fft_create_plan_mixed_radix(i3, i4, i5, i1, i2) | 0;
   return i5 | 0;
  }
 case 3:
  {
   i5 = _fft_create_plan_rader(i3, i4, i5, i1, i2) | 0;
   return i5 | 0;
  }
 case 4:
  {
   i5 = _fft_create_plan_rader2(i3, i4, i5, i1, i2) | 0;
   return i5 | 0;
  }
 case 5:
  {
   i5 = _fft_create_plan_dft(i3, i4, i5, i1, i2) | 0;
   return i5 | 0;
  }
 default:
  {
   _fwrite(gb + 39822 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 return 0;
}

function _ofdmframe_init_default_sctype(i7, i8) {
 i7 = i7 | 0;
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 if (i7 >>> 0 < 6) _fwrite(gb + 34840 | 0, 66, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
 i1 = (i7 >>> 0) / 10 | 0;
 i4 = i7 >>> 0 > 34 ? 8 : 4;
 i6 = i4 >>> 1;
 if (i7 | 0) _memset(i8 | 0, 0, i7 | 0) | 0;
 i5 = (i7 >>> 1) - (i1 >>> 0 < 2 ? 2 : i1) | 0;
 i1 = i5 >>> 0 > 1;
 if (!i1) return;
 i2 = i4 + -1 | 0;
 i3 = 1;
 do {
  HEAP8[i8 + i3 >> 0] = (i3 + i6 & i2 | 0) == 0 ? 1 : 2;
  i3 = i3 + 1 | 0;
 } while (i3 >>> 0 < i5 >>> 0);
 if (!i1) return;
 i1 = i4 + -1 | 0;
 i2 = 1;
 do {
  HEAP8[i8 + (i7 - i2) >> 0] = (i2 + i6 & i1 | 0) == 0 ? 1 : 2;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < i5 >>> 0);
 return;
}

function _fec_rs_create(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = i2;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(i2);
 HEAP32[i1 + 136 >> 2] = fb + 26;
 HEAP32[i1 + 140 >> 2] = fb + 27;
 HEAP32[i1 + 144 >> 2] = 0;
 if ((i2 | 0) == 27) {
  SIMD_Int32x4_store(HEAPU8, i1 + 64 | 0, SIMD_Int32x4(8, 285, 1, 1));
  HEAP32[i1 + 80 >> 2] = 32;
  HEAP32[i1 + 88 >> 2] = 255;
  HEAP32[i1 + 92 >> 2] = 223;
  HEAP32[i1 + 8 >> 2] = 0;
  HEAP32[i1 + 96 >> 2] = 0;
  HEAP32[i1 + 120 >> 2] = _malloc(255) | 0;
  HEAP32[i1 + 124 >> 2] = _malloc(1020) | 0;
  HEAP32[i1 + 128 >> 2] = _malloc(1020) | 0;
  return i1 | 0;
 } else {
  _fwrite(gb + 18207 | 0, 37, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 return 0;
}

function _liquid_getopt_str2crc(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3;
 if (_strcmp(i1, HEAP32[gb + 0 >> 2] | 0) | 0) if (_strcmp(i1, HEAP32[gb + 0 + 8 >> 2] | 0) | 0) if (_strcmp(i1, HEAP32[gb + 0 + 16 >> 2] | 0) | 0) if (_strcmp(i1, HEAP32[gb + 0 + 24 >> 2] | 0) | 0) if (_strcmp(i1, HEAP32[gb + 0 + 32 >> 2] | 0) | 0) if (_strcmp(i1, HEAP32[gb + 0 + 40 >> 2] | 0) | 0) if (!(_strcmp(i1, HEAP32[gb + 0 + 48 >> 2] | 0) | 0)) i1 = 6; else {
  i4 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = i1;
  _fprintf(i4, gb + 10605 | 0, i2) | 0;
  i1 = 0;
 } else i1 = 5; else i1 = 4; else i1 = 3; else i1 = 2; else i1 = 1; else i1 = 0;
 STACKTOP = i3;
 return i1 | 0;
}

function _scalbn(d1, i3) {
 d1 = +d1;
 i3 = i3 | 0;
 var i2 = 0;
 if ((i3 | 0) > 1023) {
  d1 = d1 * 8988465674311579538646525.0e283;
  i2 = i3 + -1023 | 0;
  if ((i2 | 0) > 1023) {
   i2 = i3 + -2046 | 0;
   i2 = (i2 | 0) > 1023 ? 1023 : i2;
   d1 = d1 * 8988465674311579538646525.0e283;
  }
 } else if ((i3 | 0) < -1022) {
  d1 = d1 * 2.2250738585072014e-308;
  i2 = i3 + 1022 | 0;
  if ((i2 | 0) < -1022) {
   i2 = i3 + 2044 | 0;
   i2 = (i2 | 0) < -1022 ? -1022 : i2;
   d1 = d1 * 2.2250738585072014e-308;
  }
 } else i2 = i3;
 i2 = _bitshift64Shl(i2 + 1023 | 0, 0, 52) | 0;
 i3 = getTempRet0() | 0;
 HEAP32[tempDoublePtr >> 2] = i2;
 HEAP32[tempDoublePtr + 4 >> 2] = i3;
 return +(d1 * +HEAPF64[tempDoublePtr >> 3]);
}

function _json_integer(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i6 + 12 | 0;
 i4 = i6;
 i5 = i6 + 8 | 0;
 i7 = i4;
 HEAP32[i7 >> 2] = i1;
 HEAP32[i7 + 4 >> 2] = i2;
 HEAP32[i5 >> 2] = _jsonp_malloc(16) | 0;
 if (HEAP32[i5 >> 2] | 0) {
  _json_init(HEAP32[i5 >> 2] | 0, 3);
  i2 = i4;
  i4 = HEAP32[i2 + 4 >> 2] | 0;
  i7 = (HEAP32[i5 >> 2] | 0) + 8 | 0;
  HEAP32[i7 >> 2] = HEAP32[i2 >> 2];
  HEAP32[i7 + 4 >> 2] = i4;
  HEAP32[i3 >> 2] = HEAP32[i5 >> 2];
  i7 = HEAP32[i3 >> 2] | 0;
  STACKTOP = i6;
  return i7 | 0;
 } else {
  HEAP32[i3 >> 2] = 0;
  i7 = HEAP32[i3 >> 2] | 0;
  STACKTOP = i6;
  return i7 | 0;
 }
 return 0;
}

function _insert_to_bucket(i5, i4, i6) {
 i5 = i5 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i7 + 8 | 0;
 i2 = i7 + 4 | 0;
 i3 = i7;
 HEAP32[i1 >> 2] = i5;
 HEAP32[i2 >> 2] = i4;
 HEAP32[i3 >> 2] = i6;
 if (_bucket_is_empty(HEAP32[i1 >> 2] | 0, HEAP32[i2 >> 2] | 0) | 0) {
  _list_insert((HEAP32[i1 >> 2] | 0) + 12 | 0, HEAP32[i3 >> 2] | 0);
  i6 = HEAP32[i3 >> 2] | 0;
  HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] = i6;
  HEAP32[HEAP32[i2 >> 2] >> 2] = i6;
  STACKTOP = i7;
  return;
 } else {
  _list_insert(HEAP32[HEAP32[i2 >> 2] >> 2] | 0, HEAP32[i3 >> 2] | 0);
  HEAP32[HEAP32[i2 >> 2] >> 2] = HEAP32[i3 >> 2];
  STACKTOP = i7;
  return;
 }
}

function _json_number_value(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, d5 = 0.0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4;
 i2 = i4 + 8 | 0;
 HEAP32[i2 >> 2] = i3;
 if (HEAP32[i2 >> 2] | 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 3 : 0) {
  i3 = _json_integer_value(HEAP32[i2 >> 2] | 0) | 0;
  HEAPF64[i1 >> 3] = +(i3 >>> 0) + 4294967296.0 * +(getTempRet0() | 0);
  d5 = +HEAPF64[i1 >> 3];
  STACKTOP = i4;
  return +d5;
 }
 if (HEAP32[i2 >> 2] | 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 4 : 0) {
  HEAPF64[i1 >> 3] = +_json_real_value(HEAP32[i2 >> 2] | 0);
  d5 = +HEAPF64[i1 >> 3];
  STACKTOP = i4;
  return +d5;
 }
 HEAPF64[i1 >> 3] = 0.0;
 d5 = +HEAPF64[i1 >> 3];
 STACKTOP = i4;
 return +d5;
}

function _jsonp_strndup(i6, i4) {
 i6 = i6 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i7 + 12 | 0;
 i2 = i7 + 8 | 0;
 i3 = i7 + 4 | 0;
 i5 = i7;
 HEAP32[i2 >> 2] = i6;
 HEAP32[i3 >> 2] = i4;
 HEAP32[i5 >> 2] = _jsonp_malloc((HEAP32[i3 >> 2] | 0) + 1 | 0) | 0;
 if (HEAP32[i5 >> 2] | 0) {
  _memcpy(HEAP32[i5 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
  HEAP8[(HEAP32[i5 >> 2] | 0) + (HEAP32[i3 >> 2] | 0) >> 0] = 0;
  HEAP32[i1 >> 2] = HEAP32[i5 >> 2];
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 } else {
  HEAP32[i1 >> 2] = 0;
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 return 0;
}

function _frexp(d1, i5) {
 d1 = +d1;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i2 = HEAP32[tempDoublePtr >> 2] | 0;
 i3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i4 = _bitshift64Lshr(i2 | 0, i3 | 0, 52) | 0;
 getTempRet0() | 0;
 i4 = i4 & 2047;
 switch (i4 | 0) {
 case 0:
  {
   if (d1 != 0.0) {
    d1 = +_frexp(d1 * 18446744073709551616.0, i5);
    i2 = (HEAP32[i5 >> 2] | 0) + -64 | 0;
   } else i2 = 0;
   HEAP32[i5 >> 2] = i2;
   break;
  }
 case 2047:
  break;
 default:
  {
   HEAP32[i5 >> 2] = i4 + -1022;
   HEAP32[tempDoublePtr >> 2] = i2;
   HEAP32[tempDoublePtr + 4 >> 2] = i3 & -2146435073 | 1071644672;
   d1 = +HEAPF64[tempDoublePtr >> 3];
  }
 }
 return +d1;
}

function _liquid_firdes_rkaiser_internal_isi(i4, i5, d1, d2, d6, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 d6 = +d6;
 i3 = i3 | 0;
 var i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i9 + 4 | 0;
 i8 = i9;
 if (!(d6 < 0.0)) {
  if (d6 > 1.0) _fwrite(gb + 24366 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
 } else _fwrite(gb + 24310 | 0, 55, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
 i10 = Math_imul(i4 << 1, i5) | 0 | 1;
 d11 = +(i4 >>> 0);
 _liquid_firdes_kaiser(i10, ((1.0 - d6) * d1 + 1.0) * .5 / d11, +_estimate_req_filter_As(d1 * d6 / d11, i10), d2, i3);
 _liquid_filter_isi(i3, i4, i5, i8, i7);
 STACKTOP = i9;
 return +(+HEAPF32[i8 >> 2]);
}

function _liquid_sumsqcf(i5, i2) {
 i5 = i5 | 0;
 i2 = i2 | 0;
 var d1 = 0.0, i3 = 0, i4 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0;
 i4 = i2 << 1;
 i2 = i4 & -4;
 if (!i2) {
  i2 = 0;
  d1 = 0.0;
 } else {
  i3 = 0;
  d1 = 0.0;
  do {
   d9 = +HEAPF32[i5 + (i3 << 2) >> 2];
   d8 = +HEAPF32[i5 + ((i3 | 1) << 2) >> 2];
   d7 = +HEAPF32[i5 + ((i3 | 2) << 2) >> 2];
   d6 = +HEAPF32[i5 + ((i3 | 3) << 2) >> 2];
   d1 = d1 + d9 * d9 + d8 * d8 + d7 * d7 + d6 * d6;
   i3 = i3 + 4 | 0;
  } while (i3 >>> 0 < i2 >>> 0);
 }
 if (i2 >>> 0 >= i4 >>> 0) {
  d9 = d1;
  return +d9;
 }
 do {
  d9 = +HEAPF32[i5 + (i2 << 2) >> 2];
  d1 = d1 + d9 * d9;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i4 | 0));
 return +d1;
}

function _windowcf_create(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3;
 if (!i1) {
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 39574;
  _fprintf(i3, gb + 39577 | 0, i2) | 0;
  _exit(1);
 } else {
  i2 = _malloc(28) | 0;
  HEAP32[i2 + 4 >> 2] = i1;
  i4 = _liquid_msb_index(i1) | 0;
  HEAP32[i2 + 8 >> 2] = i4;
  i4 = 1 << i4;
  HEAP32[i2 + 12 >> 2] = i4;
  i4 = i4 + -1 | 0;
  HEAP32[i2 + 16 >> 2] = i4;
  i1 = i4 + i1 | 0;
  HEAP32[i2 + 20 >> 2] = i1;
  i1 = i1 << 3;
  i4 = _malloc(i1) | 0;
  HEAP32[i2 >> 2] = i4;
  HEAP32[i2 + 24 >> 2] = 0;
  _memset(i4 | 0, 0, i1 | 0) | 0;
  STACKTOP = i3;
  return i2 | 0;
 }
 return 0;
}

function _fec_rep5_decode(i1, i5, i7, i6) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 if (!i5) return;
 i1 = i5 << 1;
 i2 = i5 * 3 | 0;
 i3 = i5 << 2;
 i4 = 0;
 do {
  i11 = HEAP8[i7 + i4 >> 0] | 0;
  i12 = HEAP8[i7 + (i4 + i5) >> 0] | 0;
  i9 = HEAP8[i7 + (i4 + i1) >> 0] | 0;
  i10 = HEAP8[i7 + (i4 + i2) >> 0] | 0;
  i8 = HEAP8[i7 + (i4 + i3) >> 0] | 0;
  i14 = i9 & i11;
  i13 = i9 & i12;
  HEAP8[i6 + i4 >> 0] = (i13 | i14) & i10 | i8 & i14 | i10 & i11 & i8 | i8 & i13 | i10 & i12 & i8 | i10 & i9 & i8 | i12 & i11 & (i10 | i9 | i8);
  i4 = i4 + 1 | 0;
 } while ((i4 | 0) != (i5 | 0));
 return;
}

function _windowf_create(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3;
 if (!i1) {
  i3 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i2 >> 2] = gb + 39572;
  _fprintf(i3, gb + 39577 | 0, i2) | 0;
  _exit(1);
 } else {
  i2 = _malloc(28) | 0;
  HEAP32[i2 + 4 >> 2] = i1;
  i4 = _liquid_msb_index(i1) | 0;
  HEAP32[i2 + 8 >> 2] = i4;
  i4 = 1 << i4;
  HEAP32[i2 + 12 >> 2] = i4;
  i4 = i4 + -1 | 0;
  HEAP32[i2 + 16 >> 2] = i4;
  i1 = i4 + i1 | 0;
  HEAP32[i2 + 20 >> 2] = i1;
  i1 = i1 << 2;
  i4 = _malloc(i1) | 0;
  HEAP32[i2 >> 2] = i4;
  HEAP32[i2 + 24 >> 2] = 0;
  _memset(i4 | 0, 0, i1 | 0) | 0;
  STACKTOP = i3;
  return i2 | 0;
 }
 return 0;
}

function _qpacketmodem_encode(i5, i1, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i4 = i4 | 0;
 var i2 = 0, i3 = 0, i6 = 0;
 i3 = i5 + 20 | 0;
 i2 = HEAP32[i3 >> 2] | 0;
 i6 = i5 + 16 | 0;
 _packetizer_encode(HEAP32[i5 + 4 >> 2] | 0, i1, HEAP32[i6 >> 2] | 0);
 i1 = i5 + 32 | 0;
 _memset(HEAP32[i3 >> 2] | 0, 0, HEAP32[i1 >> 2] << 2 | 0) | 0;
 _liquid_unpack_array_block(HEAP32[i6 >> 2] | 0, HEAP32[i5 + 24 >> 2] | 0, HEAP32[i5 + 8 >> 2] | 0, HEAP32[i1 >> 2] | 0, i2);
 if (!(HEAP32[i1 >> 2] | 0)) return;
 i2 = 0;
 do {
  _modem_modulate(HEAP32[i5 >> 2] | 0, HEAP32[(HEAP32[i3 >> 2] | 0) + (i2 << 2) >> 2] | 0, i4 + (i2 << 3) | 0);
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 return;
}

function _gmskframegen_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 if (HEAP32[i4 + 88 >> 2] | 0) {
  _fwrite(gb + 26567 | 0, 87, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  return;
 }
 HEAP32[i4 + 36 >> 2] = i1;
 i2 = i1 + 5 | 0;
 i3 = i4 + 44 | 0;
 HEAP32[i3 >> 2] = _realloc(HEAP32[i3 >> 2] | 0, i2) | 0;
 i3 = i4 + 52 | 0;
 i1 = HEAP32[i3 >> 2] | 0;
 if (i1 | 0) _packetizer_destroy(i1);
 i1 = _packetizer_create(i2, 6, 6, 1) | 0;
 HEAP32[i3 >> 2] = i1;
 i1 = _packetizer_get_enc_msg_len(i1) | 0;
 i3 = i4 + 40 | 0;
 HEAP32[i3 >> 2] = i1;
 i2 = i4 + 48 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i1) | 0;
 HEAP32[i4 + 20 >> 2] = HEAP32[i3 >> 2] << 3;
 return;
}

function _fec_hamming74_decode(i1, i7, i9, i8) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i6 + 4 | 0;
 i5 = i6;
 i1 = _fec_block_get_enc_msg_len(i7, 4, 7) | 0;
 if (!i7) {
  STACKTOP = i6;
  return;
 } else {
  i2 = 0;
  i3 = 0;
 }
 while (1) {
  _liquid_unpack_array(i9, i1, i3, 7, i4);
  _liquid_unpack_array(i9, i1, i3 + 7 | 0, 7, i5);
  HEAP8[i8 + i2 >> 0] = HEAPU8[(HEAP32[i5 >> 2] | 0) + (gb + 12914) >> 0] | 0 | (HEAPU8[(HEAP32[i4 >> 2] | 0) + (gb + 12914) >> 0] | 0) << 4;
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i7 | 0)) break; else i3 = i3 + 14 | 0;
 }
 STACKTOP = i6;
 return;
}

function _string_get(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 8 | 0;
 i6 = i5 + 4 | 0;
 i2 = i5 + 12 | 0;
 i4 = i5;
 HEAP32[i6 >> 2] = i3;
 HEAP32[i4 >> 2] = HEAP32[i6 >> 2];
 HEAP8[i2 >> 0] = HEAP8[(HEAP32[HEAP32[i4 >> 2] >> 2] | 0) + (HEAP32[(HEAP32[i4 >> 2] | 0) + 4 >> 2] | 0) >> 0] | 0;
 if (!(HEAP8[i2 >> 0] | 0)) {
  HEAP32[i1 >> 2] = -1;
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i5;
  return i6 | 0;
 } else {
  i6 = (HEAP32[i4 >> 2] | 0) + 4 | 0;
  HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + 1;
  HEAP32[i1 >> 2] = HEAPU8[i2 >> 0];
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i5;
  return i6 | 0;
 }
 return 0;
}

function ___divdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = i2 >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i9 = ((i2 | 0) < 0 ? -1 : 0) >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i6 = i4 >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i5 = ((i4 | 0) < 0 ? -1 : 0) >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i8 = _i64Subtract(i10 ^ i1 | 0, i9 ^ i2 | 0, i10 | 0, i9 | 0) | 0;
 i7 = getTempRet0() | 0;
 i1 = i6 ^ i10;
 i2 = i5 ^ i9;
 return _i64Subtract((___udivmoddi4(i8, i7, _i64Subtract(i6 ^ i3 | 0, i5 ^ i4 | 0, i6 | 0, i5 | 0) | 0, getTempRet0() | 0, 0) | 0) ^ i1 | 0, (getTempRet0() | 0) ^ i2 | 0, i1 | 0, i2 | 0) | 0;
}

function _liquid_firdes_rkaiser(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 var i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if (i4 >>> 0 < 2) {
  _fwrite(gb + 23775 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!i5) {
  _fwrite(gb + 23829 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d1 <= 0.0 | d1 >= 1.0) {
  _fwrite(gb + 23883 | 0, 54, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d2 < -1.0 | d2 > 1.0) {
  _fwrite(gb + 23938 | 0, 53, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  _liquid_firdes_rkaiser_quadratic(i4, i5, d1, d2, i3, i6);
  STACKTOP = i6;
  return;
 }
}

function _fft_execute_dft(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, d7 = 0.0, i8 = 0, i9 = 0;
 i3 = HEAP32[i1 >> 2] | 0;
 if (!i3) return;
 i4 = i1 + 44 | 0;
 i5 = i1 + 4 | 0;
 i1 = i1 + 8 | 0;
 i2 = 0;
 do {
  _dotprod_cccf_execute(HEAP32[(HEAP32[i4 >> 2] | 0) + (i2 << 2) >> 2] | 0, (HEAP32[i5 >> 2] | 0) + 8 | 0, (HEAP32[i1 >> 2] | 0) + (i2 << 3) | 0);
  i9 = HEAP32[i5 >> 2] | 0;
  i6 = HEAP32[i1 >> 2] | 0;
  i8 = i6 + (i2 << 3) | 0;
  i6 = i6 + (i2 << 3) + 4 | 0;
  d7 = +HEAPF32[i9 + 4 >> 2] + +HEAPF32[i6 >> 2];
  HEAPF32[i8 >> 2] = +HEAPF32[i9 >> 2] + +HEAPF32[i8 >> 2];
  HEAPF32[i6 >> 2] = d7;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i3 | 0));
 return;
}

function _stream_init(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4 + 8 | 0;
 i7 = i4 + 4 | 0;
 i6 = i4;
 HEAP32[i5 >> 2] = i3;
 HEAP32[i7 >> 2] = i2;
 HEAP32[i6 >> 2] = i1;
 HEAP32[HEAP32[i5 >> 2] >> 2] = HEAP32[i7 >> 2];
 HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] = HEAP32[i6 >> 2];
 HEAP8[(HEAP32[i5 >> 2] | 0) + 8 >> 0] = 0;
 HEAP32[(HEAP32[i5 >> 2] | 0) + 16 >> 2] = 0;
 HEAP32[(HEAP32[i5 >> 2] | 0) + 20 >> 2] = 0;
 HEAP32[(HEAP32[i5 >> 2] | 0) + 24 >> 2] = 1;
 HEAP32[(HEAP32[i5 >> 2] | 0) + 28 >> 2] = 0;
 HEAP32[(HEAP32[i5 >> 2] | 0) + 36 >> 2] = 0;
 STACKTOP = i4;
 return;
}

function _gmskframesync_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 HEAP32[i4 + 144 >> 2] = i1;
 i1 = i1 + 5 | 0;
 i2 = i4 + 164 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i1) | 0;
 i2 = i4 + 168 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _packetizer_destroy(i3);
 i1 = _packetizer_create(i1, 6, 6, 1) | 0;
 HEAP32[i2 >> 2] = i1;
 i1 = _packetizer_get_enc_msg_len(i1) | 0;
 i3 = i4 + 148 | 0;
 HEAP32[i3 >> 2] = i1;
 i2 = i4 + 160 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i1) | 0;
 i3 = HEAP32[i3 >> 2] << 3;
 HEAP32[i4 + 152 >> 2] = i3;
 i4 = i4 + 156 | 0;
 HEAP32[i4 >> 2] = _realloc(HEAP32[i4 >> 2] | 0, i3) | 0;
 return;
}

function _lex_steal_string(i3, i4) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i6 + 8 | 0;
 i2 = i6 + 4 | 0;
 i5 = i6;
 HEAP32[i1 >> 2] = i3;
 HEAP32[i2 >> 2] = i4;
 HEAP32[i5 >> 2] = 0;
 if ((HEAP32[(HEAP32[i1 >> 2] | 0) + 56 >> 2] | 0) != 256) {
  i5 = HEAP32[i5 >> 2] | 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 HEAP32[i5 >> 2] = HEAP32[(HEAP32[i1 >> 2] | 0) + 64 >> 2];
 HEAP32[HEAP32[i2 >> 2] >> 2] = HEAP32[(HEAP32[i1 >> 2] | 0) + 64 + 4 >> 2];
 HEAP32[(HEAP32[i1 >> 2] | 0) + 64 >> 2] = 0;
 HEAP32[(HEAP32[i1 >> 2] | 0) + 64 + 4 >> 2] = 0;
 i5 = HEAP32[i5 >> 2] | 0;
 STACKTOP = i6;
 return i5 | 0;
}

function _qpacketmodem_create() {
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i2;
 i1 = _malloc(36) | 0;
 HEAP32[i1 >> 2] = _modem_create(48) | 0;
 HEAP32[i1 + 8 >> 2] = 2;
 HEAP32[i1 + 12 >> 2] = 1;
 i3 = _packetizer_create(1, 1, 1, 1) | 0;
 HEAP32[i1 + 4 >> 2] = i3;
 i3 = _packetizer_get_enc_msg_len(i3) | 0;
 HEAP32[i1 + 24 >> 2] = i3;
 i5 = i3 << 3;
 HEAP32[i1 + 28 >> 2] = i5;
 _div(i4, i5, 2);
 HEAP32[i1 + 16 >> 2] = _malloc(((HEAP32[i4 + 4 >> 2] | 0) != 0 & 1) + (HEAP32[i4 >> 2] | 0) << 1) | 0;
 HEAP32[i1 + 32 >> 2] = i3 << 1;
 HEAP32[i1 + 20 >> 2] = _malloc(i3 << 3) | 0;
 STACKTOP = i2;
 return i1 | 0;
}

function _modulator_flush(i5, i6) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0;
 i7 = STACKTOP;
 if (!i5) {
  i6 = 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 i1 = HEAP32[i5 + 4 >> 2] | 0;
 if (!i1) {
  i6 = 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 i1 = i1 << 1;
 i2 = _llvm_stacksave() | 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 3) | 0) + 15 & -16) | 0;
 if (i1 | 0) {
  i4 = 0;
  do {
   HEAPF32[i3 + (i4 << 3) >> 2] = 0.0;
   HEAPF32[i3 + (i4 << 3) + 4 >> 2] = 0.0;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i1 | 0));
 }
 i6 = _modulator_emit(i5, i3, i1, i6) | 0;
 _llvm_stackrestore(i2 | 0);
 STACKTOP = i7;
 return i6 | 0;
}

function _poly_val_lagrange_barycentric(i7, i9, i6, d8, i5) {
 i7 = i7 | 0;
 i9 = i9 | 0;
 i6 = i6 | 0;
 d8 = +d8;
 i5 = i5 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d10 = 0.0;
 L1 : do if (!i5) {
  d3 = 0.0;
  d2 = 0.0;
 } else {
  i1 = 0;
  d3 = 0.0;
  d2 = 0.0;
  while (1) {
   d4 = d8 - +HEAPF64[i7 + (i1 << 3) >> 3];
   if (+Math_abs(+d4) < 9.999999974752427e-07) break;
   d10 = +HEAPF64[i6 + (i1 << 3) >> 3];
   d3 = d3 + d10 * +HEAPF64[i9 + (i1 << 3) >> 3] / d4;
   d2 = d2 + d10 / d4;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= i5 >>> 0) break L1;
  }
  d10 = +HEAPF64[i9 + (i1 << 3) >> 3];
  return +d10;
 } while (0);
 d10 = d3 / d2;
 return +d10;
}

function _fopen(i1, i3) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i2 = 0, i4 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i4 = i5 + 16 | 0;
 i2 = i5;
 if (_memchr(gb + 44143 | 0, HEAP8[i3 >> 0] | 0, 4) | 0) {
  i6 = ___fmodeflags(i3) | 0 | 32768;
  HEAP32[i2 >> 2] = i1;
  HEAP32[i2 + 4 >> 2] = i6;
  HEAP32[i2 + 8 >> 2] = 438;
  i2 = ___syscall_ret(___syscall5(5, i2 | 0) | 0) | 0;
  if ((i2 | 0) >= 0) {
   i1 = ___fdopen(i2, i3) | 0;
   if (!i1) {
    HEAP32[i4 >> 2] = i2;
    ___syscall6(6, i4 | 0) | 0;
    i1 = 0;
   }
  } else i1 = 0;
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  i1 = 0;
 }
 STACKTOP = i5;
 return i1 | 0;
}

function _strtox_519(i8, i7, i3, i1, i2) {
 i8 = i8 | 0;
 i7 = i7 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i6 = i9;
 HEAP32[i6 >> 2] = 0;
 i4 = i6 + 4 | 0;
 HEAP32[i4 >> 2] = i8;
 HEAP32[i6 + 44 >> 2] = i8;
 i5 = i6 + 8 | 0;
 HEAP32[i5 >> 2] = (i8 | 0) < 0 ? -1 : i8 + 2147483647 | 0;
 HEAP32[i6 + 76 >> 2] = -1;
 ___shlim(i6, 0);
 i1 = ___intscan(i6, i3, 1, i1, i2) | 0;
 i2 = getTempRet0() | 0;
 if (i7 | 0) HEAP32[i7 >> 2] = i8 + ((HEAP32[i4 >> 2] | 0) + (HEAP32[i6 + 108 >> 2] | 0) - (HEAP32[i5 >> 2] | 0));
 setTempRet0(i2 | 0);
 STACKTOP = i9;
 return i1 | 0;
}

function _jsonp_error_set(i2, i3, i1, i5, i4, i6) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 var i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i13 = i7 + 32 | 0;
 i12 = i7 + 28 | 0;
 i11 = i7 + 24 | 0;
 i10 = i7 + 20 | 0;
 i9 = i7 + 16 | 0;
 i8 = i7;
 HEAP32[i13 >> 2] = i2;
 HEAP32[i12 >> 2] = i3;
 HEAP32[i11 >> 2] = i1;
 HEAP32[i10 >> 2] = i5;
 HEAP32[i9 >> 2] = i4;
 HEAP32[i8 >> 2] = i6;
 _jsonp_error_vset(HEAP32[i13 >> 2] | 0, HEAP32[i12 >> 2] | 0, HEAP32[i11 >> 2] | 0, HEAP32[i10 >> 2] | 0, HEAP32[i9 >> 2] | 0, i8);
 STACKTOP = i7;
 return;
}

function _firpfb_rrrf_execute(i3, i2, i4) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 var i1 = 0, i5 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i7;
 i5 = i7 + 8 | 0;
 i1 = HEAP32[i3 + 12 >> 2] | 0;
 if (i1 >>> 0 > i2 >>> 0) {
  _windowf_read(HEAP32[i3 + 16 >> 2] | 0, i5);
  _dotprod_rrrf_execute(HEAP32[(HEAP32[i3 + 20 >> 2] | 0) + (i2 << 2) >> 2] | 0, HEAP32[i5 >> 2] | 0, i4);
  HEAPF32[i4 >> 2] = +HEAPF32[i3 + 24 >> 2] * +HEAPF32[i4 >> 2];
  STACKTOP = i7;
  return;
 } else {
  i7 = HEAP32[gb + 8808 >> 2] | 0;
  HEAP32[i6 >> 2] = i2;
  HEAP32[i6 + 4 >> 2] = i1;
  _fprintf(i7, gb + 20859 | 0, i6) | 0;
  _exit(1);
 }
}

function _crc24_generate_key(i3, i4) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i5 = 0;
 i2 = _liquid_reverse_uint24(6122955) | 0;
 if (!i4) {
  i5 = 0;
  return i5 | 0;
 } else {
  i5 = 0;
  i1 = -1;
 }
 do {
  i1 = (HEAPU8[i3 + i5 >> 0] | 0) ^ i1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i4 | 0));
 i5 = i1 & 16777215 ^ 16777215;
 return i5 | 0;
}

function _strbuffer_init(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4 + 4 | 0;
 i2 = i4;
 HEAP32[i2 >> 2] = i3;
 HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2] = 16;
 HEAP32[(HEAP32[i2 >> 2] | 0) + 4 >> 2] = 0;
 i3 = _jsonp_malloc(HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2] | 0) | 0;
 HEAP32[HEAP32[i2 >> 2] >> 2] = i3;
 if (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) {
  HEAP8[HEAP32[HEAP32[i2 >> 2] >> 2] >> 0] = 0;
  HEAP32[i1 >> 2] = 0;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 } else {
  HEAP32[i1 >> 2] = -1;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 }
 return 0;
}

function _matrixf_hermitian(i3, i5, i4) {
 i3 = i3 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i6 = 0, i7 = 0, i8 = 0;
 i8 = STACKTOP;
 i7 = Math_imul(i4, i5) | 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i7 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i1 | 0, i3 | 0, i7 << 2 | 0) | 0;
 if ((i5 | 0) == 0 | (i4 | 0) == 0) {
  STACKTOP = i8;
  return;
 } else i7 = 0;
 do {
  i2 = Math_imul(i7, i4) | 0;
  i6 = 0;
  do {
   HEAP32[i3 + ((Math_imul(i6, i5) | 0) + i7 << 2) >> 2] = HEAP32[i1 + (i6 + i2 << 2) >> 2];
   i6 = i6 + 1 | 0;
  } while ((i6 | 0) != (i4 | 0));
  i7 = i7 + 1 | 0;
 } while ((i7 | 0) != (i5 | 0));
 STACKTOP = i8;
 return;
}

function _json_object_get(i4, i5) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i7 + 12 | 0;
 i2 = i7 + 8 | 0;
 i3 = i7 + 4 | 0;
 i6 = i7;
 HEAP32[i2 >> 2] = i4;
 HEAP32[i3 >> 2] = i5;
 if ((HEAP32[i3 >> 2] | 0) != 0 & (HEAP32[i2 >> 2] | 0) != 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 0 : 0) {
  HEAP32[i6 >> 2] = HEAP32[i2 >> 2];
  HEAP32[i1 >> 2] = _hashtable_get((HEAP32[i6 >> 2] | 0) + 8 | 0, HEAP32[i3 >> 2] | 0) | 0;
  i6 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 HEAP32[i1 >> 2] = 0;
 i6 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i7;
 return i6 | 0;
}

function _ofdm_subcarriers_create(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0;
 i2 = HEAP32[i4 >> 2] | 0;
 i5 = _malloc(i2) | 0;
 _ofdmframe_init_default_sctype(i2, i5);
 i2 = (HEAP32[i4 >> 2] | 0) >>> 1;
 i1 = i2;
 while (1) if (!(HEAP8[i5 + i1 >> 0] | 0)) i1 = i1 + -1 | 0; else break;
 while (1) {
  i3 = i5 + i2 | 0;
  if (!(HEAP8[i3 >> 0] | 0)) i2 = i2 + 1 | 0; else break;
 }
 i2 = HEAP32[i4 + 16 >> 2] | 0;
 if (i2 | 0) {
  i2 = i2 >>> 0 > 1 ? i2 : 1;
  _memset(i5 + (i1 + 1 - i2) | 0, 0, i2 | 0) | 0;
 }
 i1 = HEAP32[i4 + 12 >> 2] | 0;
 if (!i1) return i5 | 0;
 _memset(i3 | 0, 0, (i1 >>> 0 > 1 ? i1 : 1) | 0) | 0;
 return i5 | 0;
}

function _strtox(i7, i6, i1) {
 i7 = i7 | 0;
 i6 = i6 | 0;
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i8 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i5 = i8;
 i3 = i5;
 i4 = i3 + 112 | 0;
 do {
  HEAP32[i3 >> 2] = 0;
  i3 = i3 + 4 | 0;
 } while ((i3 | 0) < (i4 | 0));
 i3 = i5 + 4 | 0;
 HEAP32[i3 >> 2] = i7;
 i4 = i5 + 8 | 0;
 HEAP32[i4 >> 2] = -1;
 HEAP32[i5 + 44 >> 2] = i7;
 HEAP32[i5 + 76 >> 2] = -1;
 ___shlim(i5, 0);
 d2 = +___floatscan(i5, i1, 1);
 i1 = (HEAP32[i3 >> 2] | 0) - (HEAP32[i4 >> 2] | 0) + (HEAP32[i5 + 108 >> 2] | 0) | 0;
 if (i6 | 0) HEAP32[i6 >> 2] = i1 | 0 ? i7 + i1 | 0 : i7;
 STACKTOP = i8;
 return +d2;
}

function ___fflush_unlocked(i7) {
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i1 = i7 + 20 | 0;
 i5 = i7 + 28 | 0;
 if ((HEAP32[i1 >> 2] | 0) >>> 0 > (HEAP32[i5 >> 2] | 0) >>> 0 ? (mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, 0, 0) | 0, (HEAP32[i1 >> 2] | 0) == 0) : 0) i1 = -1; else {
  i6 = i7 + 4 | 0;
  i2 = HEAP32[i6 >> 2] | 0;
  i3 = i7 + 8 | 0;
  i4 = HEAP32[i3 >> 2] | 0;
  if (i2 >>> 0 < i4 >>> 0) mftCall_iiii(HEAP32[i7 + 40 >> 2] | 0, i7 | 0, i2 - i4 | 0, 1) | 0;
  HEAP32[i7 + 16 >> 2] = 0;
  HEAP32[i5 >> 2] = 0;
  HEAP32[i1 >> 2] = 0;
  HEAP32[i3 >> 2] = 0;
  HEAP32[i6 >> 2] = 0;
  i1 = 0;
 }
 return i1 | 0;
}

function _jsonp_error_init(i2, i3) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 4 | 0;
 i4 = i5;
 HEAP32[i1 >> 2] = i2;
 HEAP32[i4 >> 2] = i3;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i5;
  return;
 }
 HEAP8[(HEAP32[i1 >> 2] | 0) + 92 >> 0] = 0;
 HEAP32[HEAP32[i1 >> 2] >> 2] = -1;
 HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] = -1;
 HEAP32[(HEAP32[i1 >> 2] | 0) + 8 >> 2] = 0;
 i1 = HEAP32[i1 >> 2] | 0;
 if (HEAP32[i4 >> 2] | 0) {
  _jsonp_error_set_source(i1, HEAP32[i4 >> 2] | 0);
  STACKTOP = i5;
  return;
 } else {
  HEAP8[i1 + 12 >> 0] = 0;
  STACKTOP = i5;
  return;
 }
}

function _quiet_decoder_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 if (!i2) return;
 switch (HEAP32[i2 + 52 >> 2] | 0) {
 case 0:
  {
   _ofdmflexframesync_destroy(HEAP32[i2 + 60 >> 2] | 0);
   break;
  }
 case 1:
  {
   _flexframesync_destroy(HEAP32[i2 + 60 >> 2] | 0);
   break;
  }
 case 2:
  {
   _gmskframesync_destroy(HEAP32[i2 + 60 >> 2] | 0);
   break;
  }
 default:
  {}
 }
 i1 = HEAP32[i2 + 96 >> 2] | 0;
 if (i1 | 0) _resamp_rrrf_destroy(i1);
 i1 = HEAP32[i2 + 100 >> 2] | 0;
 if (i1 | 0) _free(i1);
 _demodulator_destroy(HEAP32[i2 + 64 >> 2] | 0);
 _free(HEAP32[i2 + 80 >> 2] | 0);
 _free(HEAP32[i2 + 68 >> 2] | 0);
 _free(i2);
 return;
}

function _msequence_create(i6, i1, i2) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 if ((i6 + -2 | 0) >>> 0 > 13) {
  _fwrite(gb + 38456 | 0, 42, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i5 = _malloc(24) | 0;
 HEAP32[i5 >> 2] = i6;
 HEAP32[i5 + 4 >> 2] = i1 >>> 1;
 i4 = i5 + 8 | 0;
 HEAP32[i4 >> 2] = 0;
 if (!i6) i1 = 0; else {
  i1 = 0;
  i3 = 0;
  while (1) {
   i1 = i1 << 1 | i2 & 1;
   i3 = i3 + 1 | 0;
   if (i3 >>> 0 >= i6 >>> 0) break; else i2 = i2 >>> 1;
  }
  HEAP32[i4 >> 2] = i1;
 }
 HEAP32[i5 + 12 >> 2] = (1 << i6) + -1;
 HEAP32[i5 + 16 >> 2] = i1;
 HEAP32[i5 + 20 >> 2] = 0;
 return i5 | 0;
}

function _fec_rep3_decode_soft(i1, i9, i11, i10) {
 i1 = i1 | 0;
 i9 = i9 | 0;
 i11 = i11 | 0;
 i10 = i10 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 if (!i9) return;
 i1 = i9 << 1;
 i7 = 0;
 do {
  i2 = i10 + i7 | 0;
  HEAP8[i2 >> 0] = 0;
  i4 = i7 << 3;
  i5 = i7 + i9 << 3;
  i6 = i7 + i1 << 3;
  i3 = 0;
  i8 = 0;
  do {
   i3 = i3 & 255 | (((HEAPU8[i11 + (i8 + i5) >> 0] | 0) + (HEAPU8[i11 + (i8 + i4) >> 0] | 0) + (HEAPU8[i11 + (i8 + i6) >> 0] | 0) | 0) >>> 0 > 383 ? 1 << 7 - i8 : 0);
   HEAP8[i2 >> 0] = i3;
   i8 = i8 + 1 | 0;
  } while ((i8 | 0) != 8);
  i7 = i7 + 1 | 0;
 } while ((i7 | 0) != (i9 | 0));
 return;
}

function _crc16_generate_key(i3, i4) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i5 = 0;
 i2 = _liquid_reverse_uint16(32773) | 0;
 if (!i4) {
  i5 = 0;
  return i5 | 0;
 } else {
  i5 = 0;
  i1 = -1;
 }
 do {
  i1 = (HEAPU8[i3 + i5 >> 0] | 0) ^ i1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i1 = i2 & 0 - (i1 & 1) ^ i1 >>> 1;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i4 | 0));
 i5 = i1 & 65535 ^ 65535;
 return i5 | 0;
}

function _hashtable_do_clear(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i6 + 12 | 0;
 i3 = i6 + 8 | 0;
 i4 = i6 + 4 | 0;
 i5 = i6;
 HEAP32[i1 >> 2] = i2;
 HEAP32[i3 >> 2] = HEAP32[(HEAP32[i1 >> 2] | 0) + 12 + 4 >> 2];
 while (1) {
  if ((HEAP32[i3 >> 2] | 0) == ((HEAP32[i1 >> 2] | 0) + 12 | 0)) break;
  HEAP32[i4 >> 2] = HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2];
  HEAP32[i5 >> 2] = HEAP32[i3 >> 2];
  _json_decref_1945(HEAP32[(HEAP32[i5 >> 2] | 0) + 12 >> 2] | 0);
  _jsonp_free(HEAP32[i5 >> 2] | 0);
  HEAP32[i3 >> 2] = HEAP32[i4 >> 2];
 }
 STACKTOP = i6;
 return;
}

function _windowcf_push(i2, i5) {
 i2 = i2 | 0;
 i5 = i5 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i6 = 0;
 i3 = i2 + 24 | 0;
 i1 = HEAP32[i2 + 16 >> 2] & (HEAP32[i3 >> 2] | 0) + 1;
 HEAP32[i3 >> 2] = i1;
 if (!i1) {
  i4 = HEAP32[i2 >> 2] | 0;
  i1 = i2 + 4 | 0;
  _memmove(i4 | 0, i4 + (HEAP32[i2 + 12 >> 2] << 3) | 0, (HEAP32[i1 >> 2] << 3) + -8 | 0) | 0;
  i4 = i2;
  i2 = i1;
  i1 = HEAP32[i3 >> 2] | 0;
 } else {
  i4 = i2;
  i2 = i2 + 4 | 0;
 }
 i6 = HEAP32[i5 + 4 >> 2] | 0;
 i3 = i1 + -1 + (HEAP32[i2 >> 2] | 0) | 0;
 i4 = HEAP32[i4 >> 2] | 0;
 HEAP32[i4 + (i3 << 3) >> 2] = HEAP32[i5 >> 2];
 HEAP32[i4 + (i3 << 3) + 4 >> 2] = i6;
 return;
}

function _fmt_u(i2, i3, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0;
 if (i3 >>> 0 > 0 | (i3 | 0) == 0 & i2 >>> 0 > 4294967295) while (1) {
  i4 = ___uremdi3(i2 | 0, i3 | 0, 10, 0) | 0;
  getTempRet0() | 0;
  i1 = i1 + -1 | 0;
  HEAP8[i1 >> 0] = i4 | 48;
  i4 = ___udivdi3(i2 | 0, i3 | 0, 10, 0) | 0;
  i5 = i3;
  i3 = getTempRet0() | 0;
  if (!(i5 >>> 0 > 9 | (i5 | 0) == 9 & i2 >>> 0 > 4294967295)) {
   i2 = i4;
   break;
  } else i2 = i4;
 }
 if (i2) while (1) {
  i1 = i1 + -1 | 0;
  HEAP8[i1 >> 0] = (i2 >>> 0) % 10 | 0 | 48;
  if (i2 >>> 0 < 10) break; else i2 = (i2 >>> 0) / 10 | 0;
 }
 return i1 | 0;
}

function _memcpy(i1, i4, i2) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i3 = 0;
 if ((i2 | 0) >= 4096) return _emscripten_memcpy_big(i1 | 0, i4 | 0, i2 | 0) | 0;
 i3 = i1 | 0;
 if ((i1 & 3) == (i4 & 3)) {
  while (i1 & 3) {
   if (!i2) return i3 | 0;
   HEAP8[i1 >> 0] = HEAP8[i4 >> 0] | 0;
   i1 = i1 + 1 | 0;
   i4 = i4 + 1 | 0;
   i2 = i2 - 1 | 0;
  }
  while ((i2 | 0) >= 4) {
   HEAP32[i1 >> 2] = HEAP32[i4 >> 2];
   i1 = i1 + 4 | 0;
   i4 = i4 + 4 | 0;
   i2 = i2 - 4 | 0;
  }
 }
 while ((i2 | 0) > 0) {
  HEAP8[i1 >> 0] = HEAP8[i4 >> 0] | 0;
  i1 = i1 + 1 | 0;
  i4 = i4 + 1 | 0;
  i2 = i2 - 1 | 0;
 }
 return i3 | 0;
}

function _ofdmframesync_debug_enable(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i1 = i2 + 172 | 0;
 if (HEAP32[i1 >> 2] | 0) return;
 HEAP32[i2 + 176 >> 2] = _windowcf_create(2048) | 0;
 HEAP32[i2 + 180 >> 2] = _windowf_create(2048) | 0;
 HEAP32[i2 + 184 >> 2] = _windowcf_create(2048) | 0;
 HEAP32[i2 + 188 >> 2] = _malloc(HEAP32[i2 >> 2] << 3) | 0;
 i3 = HEAP32[i2 + 20 >> 2] << 2;
 HEAP32[i2 + 192 >> 2] = _malloc(i3) | 0;
 HEAP32[i2 + 196 >> 2] = _malloc(i3) | 0;
 HEAP32[i2 + 208 >> 2] = _windowf_create(2048) | 0;
 HEAP32[i2 + 212 >> 2] = _windowf_create(2048) | 0;
 HEAP32[i2 + 168 >> 2] = 1;
 HEAP32[i1 >> 2] = 1;
 return;
}

function _fclose(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0;
 i3 = (HEAP32[i4 >> 2] & 1 | 0) != 0;
 if (!i3) {
  ___lock(gb + 44304 + 28 | 0);
  i2 = HEAP32[i4 + 52 >> 2] | 0;
  i1 = i4 + 56 | 0;
  if (i2 | 0) HEAP32[i2 + 56 >> 2] = HEAP32[i1 >> 2];
  i1 = HEAP32[i1 >> 2] | 0;
  if (i1 | 0) HEAP32[i1 + 52 >> 2] = i2;
  if ((HEAP32[gb + 44304 + 24 >> 2] | 0) == (i4 | 0)) HEAP32[gb + 44304 + 24 >> 2] = i1;
  ___unlock(gb + 44304 + 28 | 0);
 }
 i1 = _fflush(i4) | 0;
 i1 = mftCall_ii(HEAP32[i4 + 12 >> 2] | 0, i4 | 0) | 0 | i1;
 i2 = HEAP32[i4 + 92 >> 2] | 0;
 if (i2 | 0) _free(i2);
 if (!i3) _free(i4);
 return i1 | 0;
}

function _realloc(i3, i2) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i1 = 0, i4 = 0;
 if (!i3) {
  i3 = _malloc(i2) | 0;
  return i3 | 0;
 }
 if (i2 >>> 0 > 4294967231) {
  HEAP32[(___errno_location() | 0) >> 2] = 12;
  i3 = 0;
  return i3 | 0;
 }
 i1 = _try_realloc_chunk(i3 + -8 | 0, i2 >>> 0 < 11 ? 16 : i2 + 11 & -8) | 0;
 if (i1 | 0) {
  i3 = i1 + 8 | 0;
  return i3 | 0;
 }
 i1 = _malloc(i2) | 0;
 if (!i1) {
  i3 = 0;
  return i3 | 0;
 }
 i4 = HEAP32[i3 + -4 >> 2] | 0;
 i4 = (i4 & -8) - ((i4 & 3 | 0) == 0 ? 8 : 4) | 0;
 _memcpy(i1 | 0, i3 | 0, (i4 >>> 0 < i2 >>> 0 ? i4 : i2) | 0) | 0;
 _free(i3);
 i3 = i1;
 return i3 | 0;
}

function _detector_cccf_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 _windowcf_destroy(HEAP32[i3 + 16 >> 2] | 0);
 i1 = i3 + 24 | 0;
 i2 = i3 + 20 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i4 = 0;
  do {
   _dotprod_cccf_destroy(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 << 2) >> 2] | 0);
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i2 >> 2] | 0);
 _free(HEAP32[i3 + 36 >> 2] | 0);
 _free(HEAP32[i3 + 40 >> 2] | 0);
 _free(HEAP32[i3 + 44 >> 2] | 0);
 _free(HEAP32[i3 + 48 >> 2] | 0);
 _wdelayf_destroy(HEAP32[i3 + 60 >> 2] | 0);
 _free(HEAP32[i3 >> 2] | 0);
 _free(i3);
 return;
}

function _fec_hamming74_decode_soft(i1, i4, i6, i5) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i7 = 0;
 i3 = _fec_block_get_enc_msg_len(i4, 4, 7) | 0;
 if (!i4) i1 = 0; else {
  i1 = 0;
  i2 = 0;
  while (1) {
   i7 = _fecsoft_hamming74_decode(i6 + i2 | 0) | 0;
   HEAP8[i5 + i1 >> 0] = (i7 & 255) << 4 | (_fecsoft_hamming74_decode(i6 + (i2 + 7) | 0) | 0) & 255;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i4 | 0)) break; else i2 = i2 + 14 | 0;
  }
  i1 = i4 * 14 | 0;
 }
 if ((i1 | 0) == (i3 << 3 | 0)) return; else ___assert_fail(gb + 13614 | 0, gb + 13042 | 0, 193, gb + 13070 | 0);
}

function _scalbnf(d1, i3) {
 d1 = +d1;
 i3 = i3 | 0;
 var i2 = 0;
 if ((i3 | 0) > 127) {
  d1 = d1 * 1701411834604692317316873.0e14;
  i2 = i3 + -127 | 0;
  if ((i2 | 0) > 127) {
   i2 = i3 + -254 | 0;
   i2 = (i2 | 0) > 127 ? 127 : i2;
   d1 = d1 * 1701411834604692317316873.0e14;
  }
 } else if ((i3 | 0) < -126) {
  d1 = d1 * 1.1754943508222875e-38;
  i2 = i3 + 126 | 0;
  if ((i2 | 0) < -126) {
   i2 = i3 + 252 | 0;
   i2 = (i2 | 0) < -126 ? -126 : i2;
   d1 = d1 * 1.1754943508222875e-38;
  }
 } else i2 = i3;
 return +(d1 * (HEAP32[tempDoublePtr >> 2] = (i2 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]));
}

function _fec_hamming84_decode_soft(i1, i4, i6, i5) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i7 = 0;
 i3 = _fec_block_get_enc_msg_len(i4, 4, 8) | 0;
 if (!i4) i1 = 0; else {
  i1 = 0;
  i2 = 0;
  while (1) {
   i7 = _fecsoft_hamming84_decode(i6 + i2 | 0) | 0;
   HEAP8[i5 + i1 >> 0] = (i7 & 255) << 4 | (_fecsoft_hamming84_decode(i6 + (i2 | 8) | 0) | 0) & 255;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i4 | 0)) break; else i2 = i2 + 16 | 0;
  }
  i1 = i4 << 4;
 }
 if ((i1 | 0) == (i3 << 3 | 0)) return; else ___assert_fail(gb + 13614 | 0, gb + 13368 | 0, 181, gb + 13396 | 0);
}

function _lex_unget_unsave(i5, i3) {
 i5 = i5 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i6 + 4 | 0;
 i2 = i6;
 i4 = i6 + 8 | 0;
 HEAP32[i1 >> 2] = i5;
 HEAP32[i2 >> 2] = i3;
 if (!((HEAP32[i2 >> 2] | 0) != -1 & (HEAP32[i2 >> 2] | 0) != -2)) {
  STACKTOP = i6;
  return;
 }
 _stream_unget(HEAP32[i1 >> 2] | 0, HEAP32[i2 >> 2] | 0);
 HEAP8[i4 >> 0] = _strbuffer_pop((HEAP32[i1 >> 2] | 0) + 40 | 0) | 0;
 if ((HEAP32[i2 >> 2] | 0) != (HEAP8[i4 >> 0] | 0)) ___assert_fail(gb + 40763 | 0, gb + 40619 | 0, 272, gb + 40770 | 0);
 STACKTOP = i6;
 return;
}

function ___toread(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0;
 i1 = i3 + 74 | 0;
 i2 = HEAP8[i1 >> 0] | 0;
 HEAP8[i1 >> 0] = i2 + 255 | i2;
 i1 = i3 + 20 | 0;
 i2 = i3 + 44 | 0;
 if ((HEAP32[i1 >> 2] | 0) >>> 0 > (HEAP32[i2 >> 2] | 0) >>> 0) mftCall_iiii(HEAP32[i3 + 36 >> 2] | 0, i3 | 0, 0, 0) | 0;
 HEAP32[i3 + 16 >> 2] = 0;
 HEAP32[i3 + 28 >> 2] = 0;
 HEAP32[i1 >> 2] = 0;
 i1 = HEAP32[i3 >> 2] | 0;
 if (i1 & 20) if (!(i1 & 4)) i1 = -1; else {
  HEAP32[i3 >> 2] = i1 | 32;
  i1 = -1;
 } else {
  i1 = HEAP32[i2 >> 2] | 0;
  HEAP32[i3 + 8 >> 2] = i1;
  HEAP32[i3 + 4 >> 2] = i1;
  i1 = 0;
 }
 return i1 | 0;
}

function _kaiser(i4, i1, d2, d3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 d2 = +d2;
 d3 = +d3;
 if (i4 >>> 0 > i1 >>> 0) {
  _fwrite(gb + 29936 | 0, 60, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d2 < 0.0) {
  _fwrite(gb + 29997 | 0, 60, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d3 < -.5 | d3 > .5) {
  _fwrite(gb + 30058 | 0, 64, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  d3 = (+(i4 >>> 0) - +((i1 + -1 | 0) >>> 0) * .5 + d3) * 2.0 / +(i1 >>> 0);
  d3 = +_liquid_besseli0f(+Math_sqrt(+(1.0 - d3 * d3)) * d2);
  return +(d3 / +_liquid_besseli0f(d2));
 }
 return +(0.0);
}

function _fmaxf(d1, d3) {
 d1 = +d1;
 d3 = +d3;
 var i2 = 0, d4 = 0.0;
 i2 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 d4 = +Math_abs(+d1);
 do if ((HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0) >>> 0 <= 2139095040) {
  d4 = +Math_abs(+d3);
  if ((HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0) >>> 0 <= 2139095040) if (((HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0) ^ i2 | 0) < 0) {
   d1 = (i2 | 0) < 0 ? d3 : d1;
   break;
  } else {
   d1 = d1 < d3 ? d3 : d1;
   break;
  }
 } else d1 = d3; while (0);
 return +d1;
}

function _lex_save_cached(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 while (1) {
  if (!(HEAP8[(HEAP32[i1 >> 2] | 0) + 8 + (HEAP32[(HEAP32[i1 >> 2] | 0) + 16 >> 2] | 0) >> 0] | 0)) break;
  _lex_save(HEAP32[i1 >> 2] | 0, HEAP8[(HEAP32[i1 >> 2] | 0) + 8 + (HEAP32[(HEAP32[i1 >> 2] | 0) + 16 >> 2] | 0) >> 0] | 0);
  i2 = (HEAP32[i1 >> 2] | 0) + 16 | 0;
  HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + 1;
  i2 = (HEAP32[i1 >> 2] | 0) + 36 | 0;
  HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + 1;
 }
 STACKTOP = i3;
 return;
}

function _quiet_encoder_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 if (!i2) return;
 switch (HEAP32[i2 + 60 >> 2] | 0) {
 case 0:
  {
   _ofdmflexframegen_destroy(HEAP32[i2 + 96 >> 2] | 0);
   break;
  }
 case 1:
  {
   _flexframegen_destroy(HEAP32[i2 + 96 >> 2] | 0);
   break;
  }
 case 2:
  {
   _gmskframegen_destroy(HEAP32[i2 + 96 >> 2] | 0);
   break;
  }
 default:
  {}
 }
 i1 = HEAP32[i2 + 152 >> 2] | 0;
 if (i1 | 0) _resamp_rrrf_destroy(i1);
 _modulator_destroy(HEAP32[i2 + 104 >> 2] | 0);
 _free(HEAP32[i2 + 108 >> 2] | 0);
 _free(HEAP32[i2 + 116 >> 2] | 0);
 _free(i2);
 return;
}

function _array_copy(i2, i3, i5, i4, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i11 = i6 + 16 | 0;
 i10 = i6 + 12 | 0;
 i9 = i6 + 8 | 0;
 i8 = i6 + 4 | 0;
 i7 = i6;
 HEAP32[i11 >> 2] = i2;
 HEAP32[i10 >> 2] = i3;
 HEAP32[i9 >> 2] = i5;
 HEAP32[i8 >> 2] = i4;
 HEAP32[i7 >> 2] = i1;
 _memcpy((HEAP32[i11 >> 2] | 0) + (HEAP32[i10 >> 2] << 2) | 0, (HEAP32[i9 >> 2] | 0) + (HEAP32[i8 >> 2] << 2) | 0, HEAP32[i7 >> 2] << 2 | 0) | 0;
 STACKTOP = i6;
 return;
}

function _json_integer_value(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4;
 i2 = i4 + 8 | 0;
 HEAP32[i2 >> 2] = i3;
 if (HEAP32[i2 >> 2] | 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 3 : 0) {
  i5 = (HEAP32[i2 >> 2] | 0) + 8 | 0;
  i2 = HEAP32[i5 + 4 >> 2] | 0;
  i3 = i1;
  HEAP32[i3 >> 2] = HEAP32[i5 >> 2];
  HEAP32[i3 + 4 >> 2] = i2;
 } else {
  i5 = i1;
  HEAP32[i5 >> 2] = 0;
  HEAP32[i5 + 4 >> 2] = 0;
 }
 i3 = i1;
 i5 = HEAP32[i3 >> 2] | 0;
 setTempRet0(HEAP32[i3 + 4 >> 2] | 0);
 STACKTOP = i4;
 return i5 | 0;
}

function _json_delete_array(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4 + 4 | 0;
 i3 = i4;
 HEAP32[i1 >> 2] = i2;
 HEAP32[i3 >> 2] = 0;
 while (1) {
  if ((HEAP32[i3 >> 2] | 0) >>> 0 >= (HEAP32[(HEAP32[i1 >> 2] | 0) + 12 >> 2] | 0) >>> 0) break;
  _json_decref_1902(HEAP32[(HEAP32[(HEAP32[i1 >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[i3 >> 2] << 2) >> 2] | 0);
  HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + 1;
 }
 _jsonp_free(HEAP32[(HEAP32[i1 >> 2] | 0) + 16 >> 2] | 0);
 _jsonp_free(HEAP32[i1 >> 2] | 0);
 STACKTOP = i4;
 return;
}

function _strlen(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i4 = i1;
 L1 : do if (!(i4 & 3)) i3 = 4; else {
  i2 = i1;
  i1 = i4;
  while (1) {
   if (!(HEAP8[i2 >> 0] | 0)) break L1;
   i2 = i2 + 1 | 0;
   i1 = i2;
   if (!(i1 & 3)) {
    i1 = i2;
    i3 = 4;
    break;
   }
  }
 } while (0);
 if ((i3 | 0) == 4) {
  while (1) {
   i2 = HEAP32[i1 >> 2] | 0;
   if (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009)) i1 = i1 + 4 | 0; else break;
  }
  if ((i2 & 255) << 24 >> 24) do i1 = i1 + 1 | 0; while ((HEAP8[i1 >> 0] | 0) != 0);
 }
 return i1 - i4 | 0;
}

function _demodulator_flush(i6, i7) {
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0;
 i8 = STACKTOP;
 if (!i6) {
  i7 = 0;
  STACKTOP = i8;
  return i7 | 0;
 }
 i1 = HEAP32[i6 >> 2] | 0;
 i2 = HEAP32[i6 + 4 >> 2] | 0;
 i3 = Math_imul(i2 << 1, i1) | 0;
 i4 = _llvm_stacksave() | 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i3 << 2) | 0) + 15 & -16) | 0;
 if (i3 | 0) _memset(i5 | 0, 0, (Math_imul(i2, i1) | 0) << 3 | 0) | 0;
 i7 = _demodulator_recv(i6, i5, i3, i7) | 0;
 _llvm_stackrestore(i4 | 0);
 STACKTOP = i8;
 return i7 | 0;
}

function _fec_hamming74_encode(i1, i4, i5, i6) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i7 = 0, i8 = 0;
 i1 = _fec_block_get_enc_msg_len(i4, 4, 7) | 0;
 if (!i4) return; else {
  i2 = 0;
  i3 = 0;
 }
 while (1) {
  i8 = HEAP8[i5 + i2 >> 0] | 0;
  i7 = HEAPU8[(i8 & 15) + (gb + 12898) >> 0] | 0;
  _liquid_pack_array(i6, i1, i3, 7, HEAPU8[((i8 & 255) >>> 4 & 255) + (gb + 12898) >> 0] | 0);
  _liquid_pack_array(i6, i1, i3 + 7 | 0, 7, i7);
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i4 | 0)) break; else i3 = i3 + 14 | 0;
 }
 return;
}

function _strerror(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = 0;
 while (1) {
  if ((HEAPU8[gb + 42198 + i2 >> 0] | 0) == (i1 | 0)) {
   i3 = 2;
   break;
  }
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == 87) {
   i2 = 87;
   i1 = gb + 42286 | 0;
   i3 = 5;
   break;
  }
 }
 if ((i3 | 0) == 2) if (!i2) i1 = gb + 42286 | 0; else {
  i1 = gb + 42286 | 0;
  i3 = 5;
 }
 if ((i3 | 0) == 5) while (1) {
  i3 = i1;
  while (1) {
   i1 = i3 + 1 | 0;
   if (!(HEAP8[i3 >> 0] | 0)) break; else i3 = i1;
  }
  i2 = i2 + -1 | 0;
  if (!i2) break; else i3 = 5;
 }
 return i1 | 0;
}

function _flexframegen_reconfigure(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i3 = i1 + 92 | 0;
 _qpacketmodem_configure(HEAP32[i3 >> 2] | 0, HEAP32[i1 + 88 >> 2] | 0, HEAP32[i1 + 32 >> 2] | 0, HEAP32[i1 + 36 >> 2] | 0, HEAP32[i1 + 40 >> 2] | 0, HEAP32[i1 + 44 >> 2] | 0) | 0;
 i3 = _qpacketmodem_get_frame_len(HEAP32[i3 >> 2] | 0) | 0;
 HEAP32[i1 + 96 >> 2] = i3;
 i2 = i1 + 100 | 0;
 i1 = _realloc(HEAP32[i2 >> 2] | 0, i3 << 3) | 0;
 HEAP32[i2 >> 2] = i1;
 if (!i1) {
  _fwrite(gb + 25089 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else return;
}

function _crc_get_length(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i4;
 switch (i2 | 0) {
 case 1:
 case 0:
  {
   i1 = 0;
   break;
  }
 case 2:
  {
   i1 = 1;
   break;
  }
 case 3:
  {
   i1 = 1;
   break;
  }
 case 4:
  {
   i1 = 2;
   break;
  }
 case 5:
  {
   i1 = 3;
   break;
  }
 case 6:
  {
   i1 = 4;
   break;
  }
 default:
  {
   i5 = HEAP32[gb + 8808 >> 2] | 0;
   HEAP32[i3 >> 2] = i2;
   _fprintf(i5, gb + 10676 | 0, i3) | 0;
   _exit(1);
  }
 }
 STACKTOP = i4;
 return i1 | 0;
}

function _lex_get_save(i4, i3) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 8 | 0;
 i6 = i5 + 4 | 0;
 i2 = i5;
 HEAP32[i1 >> 2] = i4;
 HEAP32[i6 >> 2] = i3;
 HEAP32[i2 >> 2] = _stream_get(HEAP32[i1 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0;
 if (!((HEAP32[i2 >> 2] | 0) != -1 & (HEAP32[i2 >> 2] | 0) != -2)) {
  i6 = HEAP32[i2 >> 2] | 0;
  STACKTOP = i5;
  return i6 | 0;
 }
 _lex_save(HEAP32[i1 >> 2] | 0, HEAP32[i2 >> 2] | 0);
 i6 = HEAP32[i2 >> 2] | 0;
 STACKTOP = i5;
 return i6 | 0;
}

function _puts(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0;
 i4 = HEAP32[gb + 8924 >> 2] | 0;
 if ((HEAP32[i4 + 76 >> 2] | 0) > -1) i5 = ___lockfile(i4) | 0; else i5 = 0;
 do if ((_fputs(i3, i4) | 0) < 0) i1 = 1; else {
  if ((HEAP8[i4 + 75 >> 0] | 0) != 10 ? (i1 = i4 + 20 | 0, i2 = HEAP32[i1 >> 2] | 0, i2 >>> 0 < (HEAP32[i4 + 16 >> 2] | 0) >>> 0) : 0) {
   HEAP32[i1 >> 2] = i2 + 1;
   HEAP8[i2 >> 0] = 10;
   i1 = 0;
   break;
  }
  i1 = (___overflow(i4, 10) | 0) < 0;
 } while (0);
 if (i5 | 0) ___unlockfile(i4);
 return i1 << 31 >> 31 | 0;
}

function _fec_hamming128_decode_soft(i1, i5, i7, i6) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = i5 & 1;
 i4 = ((i5 * 3 | 0) >>> 1) + i3 | 0;
 if (!i5) i1 = 0; else {
  i1 = 0;
  i2 = 0;
  while (1) {
   HEAP8[i6 + i1 >> 0] = _fecsoft_hamming128_decode_n3(i7 + i2 | 0) | 0;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i5 | 0)) break; else i2 = i2 + 12 | 0;
  }
  i1 = i5 * 12 | 0;
 }
 if ((i1 + (i3 << 2) | 0) == (i4 << 3 | 0)) return; else ___assert_fail(gb + 13614 | 0, gb + 13541 | 0, 326, gb + 13633 | 0);
}

function _ofdmflexframesync_destroy(i1) {
 i1 = i1 | 0;
 _ofdmframesync_destroy(HEAP32[i1 + 184 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 40 >> 2] | 0);
 _modem_destroy(HEAP32[i1 + 36 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 100 >> 2] | 0);
 _modem_destroy(HEAP32[i1 + 104 >> 2] | 0);
 _free(HEAP32[i1 + 12 >> 2] | 0);
 _free(HEAP32[i1 + 108 >> 2] | 0);
 _free(HEAP32[i1 + 112 >> 2] | 0);
 _free(HEAP32[i1 + 128 >> 2] | 0);
 _free(HEAP32[i1 + 44 >> 2] | 0);
 _free(HEAP32[i1 + 48 >> 2] | 0);
 _free(HEAP32[i1 + 52 >> 2] | 0);
 _free(i1);
 return;
}

function _msequence_create_default(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 if ((i1 + -2 | 0) >>> 0 > 13) {
  _fwrite(gb + 38456 | 0, 42, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  i2 = _malloc(24) | 0;
  i1 = gb + 6936 + (i1 * 24 | 0) | 0;
  HEAP32[i2 >> 2] = HEAP32[i1 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i1 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i1 + 8 >> 2];
  HEAP32[i2 + 12 >> 2] = HEAP32[i1 + 12 >> 2];
  HEAP32[i2 + 16 >> 2] = HEAP32[i1 + 16 >> 2];
  HEAP32[i2 + 20 >> 2] = HEAP32[i1 + 20 >> 2];
  return i2 | 0;
 }
 return 0;
}

function _memset(i2, i6, i1) {
 i2 = i2 | 0;
 i6 = i6 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i7 = 0;
 i3 = i2 + i1 | 0;
 if ((i1 | 0) >= 20) {
  i6 = i6 & 255;
  i5 = i2 & 3;
  i7 = i6 | i6 << 8 | i6 << 16 | i6 << 24;
  i4 = i3 & ~3;
  if (i5) {
   i5 = i2 + 4 - i5 | 0;
   while ((i2 | 0) < (i5 | 0)) {
    HEAP8[i2 >> 0] = i6;
    i2 = i2 + 1 | 0;
   }
  }
  while ((i2 | 0) < (i4 | 0)) {
   HEAP32[i2 >> 2] = i7;
   i2 = i2 + 4 | 0;
  }
 }
 while ((i2 | 0) < (i3 | 0)) {
  HEAP8[i2 >> 0] = i6;
  i2 = i2 + 1 | 0;
 }
 return i2 - i1 | 0;
}

function _ofdmflexframegen_destroy(i1) {
 i1 = i1 | 0;
 _ofdmframegen_destroy(HEAP32[i1 + 40 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 56 >> 2] | 0);
 _modem_destroy(HEAP32[i1 + 52 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 88 >> 2] | 0);
 _modem_destroy(HEAP32[i1 + 96 >> 2] | 0);
 _free(HEAP32[i1 + 100 >> 2] | 0);
 _free(HEAP32[i1 + 104 >> 2] | 0);
 _free(HEAP32[i1 + 36 >> 2] | 0);
 _free(HEAP32[i1 + 12 >> 2] | 0);
 _free(HEAP32[i1 + 60 >> 2] | 0);
 _free(HEAP32[i1 + 64 >> 2] | 0);
 _free(HEAP32[i1 + 68 >> 2] | 0);
 _free(i1);
 return;
}

function _msequence_generate_symbol(i1, i8) {
 i1 = i1 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0;
 if (!i8) {
  i8 = 0;
  return i8 | 0;
 }
 i5 = i1 + 16 | 0;
 i6 = i1 + 4 | 0;
 i7 = i1 + 20 | 0;
 i2 = i1 + 12 | 0;
 i3 = HEAP32[i5 >> 2] | 0;
 i4 = 0;
 i1 = 0;
 do {
  i9 = _liquid_bdotprod(i3, HEAP32[i6 >> 2] | 0) | 0;
  HEAP32[i7 >> 2] = i9;
  i3 = (HEAP32[i5 >> 2] << 1 | i9) & HEAP32[i2 >> 2];
  HEAP32[i5 >> 2] = i3;
  i1 = i9 | i1 << 1;
  i4 = i4 + 1 | 0;
 } while ((i4 | 0) != (i8 | 0));
 return i1 | 0;
}

function _to_locale(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 8 | 0;
 i2 = i5 + 4 | 0;
 i3 = i5;
 HEAP32[i1 >> 2] = i4;
 HEAP32[i2 >> 2] = HEAP32[(_localeconv() | 0) >> 2];
 if ((HEAP8[HEAP32[i2 >> 2] >> 0] | 0) == 46) {
  STACKTOP = i5;
  return;
 }
 HEAP32[i3 >> 2] = _strchr(HEAP32[HEAP32[i1 >> 2] >> 2] | 0, 46) | 0;
 if (!(HEAP32[i3 >> 2] | 0)) {
  STACKTOP = i5;
  return;
 }
 HEAP8[HEAP32[i3 >> 2] >> 0] = HEAP8[HEAP32[i2 >> 2] >> 0] | 0;
 STACKTOP = i5;
 return;
}

function _dotprod_crcf_execute(i2, i6, i7) {
 i2 = i2 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 var d1 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, d8 = 0.0;
 i5 = HEAP32[i2 >> 2] | 0;
 i2 = HEAP32[i2 + 4 >> 2] | 0;
 if (!i2) {
  d3 = 0.0;
  d1 = 0.0;
 } else {
  i4 = 0;
  d3 = 0.0;
  d1 = 0.0;
  do {
   d8 = +HEAPF32[i5 + (i4 << 2) >> 2];
   d3 = d3 + d8 * +HEAPF32[i6 + (i4 << 3) >> 2];
   d1 = d1 + d8 * +HEAPF32[i6 + (i4 << 3) + 4 >> 2];
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i2 | 0));
 }
 HEAPF32[i7 >> 2] = d3;
 HEAPF32[i7 + 4 >> 2] = d1;
 return;
}

function _fft_execute_dft_2(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0;
 i3 = i1 + 4 | 0;
 i5 = HEAP32[i3 >> 2] | 0;
 d2 = +HEAPF32[i5 + 4 >> 2] + +HEAPF32[i5 + 12 >> 2];
 i1 = i1 + 8 | 0;
 i4 = HEAP32[i1 >> 2] | 0;
 HEAPF32[i4 >> 2] = +HEAPF32[i5 >> 2] + +HEAPF32[i5 + 8 >> 2];
 HEAPF32[i4 + 4 >> 2] = d2;
 i3 = HEAP32[i3 >> 2] | 0;
 d2 = +HEAPF32[i3 + 4 >> 2] - +HEAPF32[i3 + 12 >> 2];
 i1 = HEAP32[i1 >> 2] | 0;
 HEAPF32[i1 + 8 >> 2] = +HEAPF32[i3 >> 2] - +HEAPF32[i3 + 8 >> 2];
 HEAPF32[i1 + 12 >> 2] = d2;
 return;
}

function _modem_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 76 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 + 244 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 >> 2] | 0;
 switch (i1 | 0) {
 case 50:
  {
   _free(HEAP32[i2 + 100 >> 2] | 0);
   _free(i2);
   return;
  }
 case 51:
  {
   _free(HEAP32[i2 + 100 >> 2] | 0);
   _free(i2);
   return;
  }
 default:
  {
   if (!(_liquid_modem_is_apsk(i1) | 0)) {
    _free(i2);
    return;
   }
   _free(HEAP32[i2 + 232 >> 2] | 0);
   _free(i2);
   return;
  }
 }
}

function _sinhf(d1) {
 d1 = +d1;
 var d2 = 0.0, d3 = 0.0, i4 = 0;
 d3 = ((HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0) | 0) < 0 ? -.5 : .5;
 d2 = +Math_abs(+d1);
 i4 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
 do if (i4 >>> 0 < 1118925335) {
  d2 = +_expm1f(d2);
  if (i4 >>> 0 >= 1065353216) {
   d1 = d3 * (d2 + d2 / (d2 + 1.0));
   break;
  }
  if (i4 >>> 0 >= 964689920) d1 = d3 * (d2 * 2.0 - d2 * d2 / (d2 + 1.0));
 } else d1 = d3 * 2.0 * +___expo2f(d2); while (0);
 return +d1;
}

function _packetizer_recreate(i6, i5, i2, i3, i4) {
 i6 = i6 | 0;
 i5 = i5 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0;
 if (!i6) {
  i6 = _packetizer_create(i5, i2, i3, i4) | 0;
  return i6 | 0;
 }
 if ((((HEAP32[i6 >> 2] | 0) == (i5 | 0) ? (HEAP32[i6 + 8 >> 2] | 0) == (i2 | 0) : 0) ? (i1 = HEAP32[i6 + 16 >> 2] | 0, (HEAP32[i1 + 8 >> 2] | 0) == (i3 | 0)) : 0) ? (HEAP32[i1 + 28 >> 2] | 0) == (i4 | 0) : 0) return i6 | 0;
 _packetizer_destroy(i6);
 i6 = _packetizer_create(i5, i2, i3, i4) | 0;
 return i6 | 0;
}

function _windowf_push(i2, d5) {
 i2 = i2 | 0;
 d5 = +d5;
 var i1 = 0, i3 = 0, i4 = 0;
 i3 = i2 + 24 | 0;
 i1 = HEAP32[i2 + 16 >> 2] & (HEAP32[i3 >> 2] | 0) + 1;
 HEAP32[i3 >> 2] = i1;
 if (!i1) {
  i4 = HEAP32[i2 >> 2] | 0;
  i1 = i2 + 4 | 0;
  _memmove(i4 | 0, i4 + (HEAP32[i2 + 12 >> 2] << 2) | 0, (HEAP32[i1 >> 2] << 2) + -4 | 0) | 0;
  i4 = i2;
  i2 = i1;
  i1 = HEAP32[i3 >> 2] | 0;
 } else {
  i4 = i2;
  i2 = i2 + 4 | 0;
 }
 HEAPF32[(HEAP32[i4 >> 2] | 0) + (i1 + -1 + (HEAP32[i2 >> 2] | 0) << 2) >> 2] = d5;
 return;
}

function _ilogbf(d2) {
 d2 = +d2;
 var i1 = 0, i3 = 0;
 i1 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
 i3 = i1 >>> 23 & 255;
 switch (i3 | 0) {
 case 0:
  {
   i3 = i1 << 9;
   if (i3) if ((i3 | 0) > -1) {
    i1 = -127;
    do {
     i1 = i1 + -1 | 0;
     i3 = i3 << 1;
    } while ((i3 | 0) > -1);
   } else i1 = -127; else i1 = -2147483648;
   break;
  }
 case 255:
  {
   i1 = i1 & 8388607 | 0 ? -2147483648 : 2147483647;
   break;
  }
 default:
  i1 = i3 + -127 | 0;
 }
 return i1 | 0;
}

function _packetizer_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 i1 = i3 + 20 | 0;
 i2 = i3 + 16 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i4 = 0;
  do {
   _fec_destroy(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 * 20 | 0) + 12 >> 2] | 0);
   _interleaver_destroy(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 * 20 | 0) + 16 >> 2] | 0);
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i2 >> 2] | 0);
 _free(HEAP32[i3 + 28 >> 2] | 0);
 _free(HEAP32[i3 + 32 >> 2] | 0);
 _free(i3);
 return;
}

function _csinf(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, d4 = 0.0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i3 + 16 | 0;
 i5 = i3 + 8 | 0;
 i7 = i3;
 i8 = HEAP32[i2 >> 2] | 0;
 HEAPF32[i7 >> 2] = -+HEAPF32[i2 + 4 >> 2];
 HEAP32[i7 + 4 >> 2] = i8;
 HEAP32[i6 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i6 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 _csinhf(i5, i6);
 d4 = -+HEAPF32[i5 >> 2];
 HEAP32[i1 >> 2] = HEAP32[i5 + 4 >> 2];
 HEAPF32[i1 + 4 >> 2] = d4;
 STACKTOP = i3;
 return;
}

function _modem_modulate(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0;
 if ((HEAP32[i1 + 8 >> 2] | 0) >>> 0 <= i2 >>> 0) {
  _fwrite(gb + 30864 | 0, 65, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (!(HEAP32[i1 + 80 >> 2] | 0)) {
  mftCall_viii(HEAP32[i1 + 236 >> 2] | 0, i1 | 0, i2 | 0, i3 | 0);
  return;
 } else {
  i4 = HEAP32[i1 + 76 >> 2] | 0;
  i1 = HEAP32[i4 + (i2 << 3) + 4 >> 2] | 0;
  HEAP32[i3 >> 2] = HEAP32[i4 + (i2 << 3) >> 2];
  HEAP32[i3 + 4 >> 2] = i1;
  return;
 }
}

function _iirfilt_crcf_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 _free(HEAP32[i3 >> 2] | 0);
 _free(HEAP32[i3 + 4 >> 2] | 0);
 if ((HEAP32[i3 + 24 >> 2] | 0) != 1) {
  _free(HEAP32[i3 + 8 >> 2] | 0);
  _free(i3);
  return;
 }
 i1 = i3 + 32 | 0;
 i2 = i3 + 28 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i4 = 0;
  do {
   _free(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 << 2) >> 2] | 0);
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i2 >> 2] | 0);
 _free(i3);
 return;
}

function _json_decref_1945(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i3;
  return;
 }
 if ((HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] | 0) == -1) {
  STACKTOP = i3;
  return;
 }
 i4 = (HEAP32[i1 >> 2] | 0) + 4 | 0;
 i2 = (HEAP32[i4 >> 2] | 0) + -1 | 0;
 HEAP32[i4 >> 2] = i2;
 if (i2 | 0) {
  STACKTOP = i3;
  return;
 }
 _json_delete(HEAP32[i1 >> 2] | 0);
 STACKTOP = i3;
 return;
}

function _json_decref_1902(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i3;
  return;
 }
 if ((HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] | 0) == -1) {
  STACKTOP = i3;
  return;
 }
 i4 = (HEAP32[i1 >> 2] | 0) + 4 | 0;
 i2 = (HEAP32[i4 >> 2] | 0) + -1 | 0;
 HEAP32[i4 >> 2] = i2;
 if (i2 | 0) {
  STACKTOP = i3;
  return;
 }
 _json_delete(HEAP32[i1 >> 2] | 0);
 STACKTOP = i3;
 return;
}

function _ccosf(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i3 + 16 | 0;
 i4 = i3 + 8 | 0;
 i6 = i3;
 i7 = HEAP32[i2 >> 2] | 0;
 HEAPF32[i6 >> 2] = -+HEAPF32[i2 + 4 >> 2];
 HEAP32[i6 + 4 >> 2] = i7;
 HEAP32[i5 >> 2] = HEAP32[i6 >> 2];
 HEAP32[i5 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
 _ccoshf(i4, i5);
 i2 = HEAP32[i4 + 4 >> 2] | 0;
 HEAP32[i1 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i1 + 4 >> 2] = i2;
 STACKTOP = i3;
 return;
}

function _buf_to_uint32(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i5 + 8 | 0;
 i3 = i5 + 4 | 0;
 i4 = i5;
 HEAP32[i2 >> 2] = i1;
 HEAP32[i4 >> 2] = 0;
 HEAP32[i3 >> 2] = 0;
 while (1) {
  i1 = HEAP32[i4 >> 2] | 0;
  if ((HEAP32[i3 >> 2] | 0) >>> 0 >= 4) break;
  HEAP32[i4 >> 2] = i1 << 8 | (HEAPU8[(HEAP32[i2 >> 2] | 0) + (HEAP32[i3 >> 2] | 0) >> 0] | 0);
  HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + 1;
 }
 STACKTOP = i5;
 return i1 | 0;
}

function _json_decref(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i3;
  return;
 }
 if ((HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] | 0) == -1) {
  STACKTOP = i3;
  return;
 }
 i4 = (HEAP32[i1 >> 2] | 0) + 4 | 0;
 i2 = (HEAP32[i4 >> 2] | 0) + -1 | 0;
 HEAP32[i4 >> 2] = i2;
 if (i2 | 0) {
  STACKTOP = i3;
  return;
 }
 _json_delete(HEAP32[i1 >> 2] | 0);
 STACKTOP = i3;
 return;
}

function ___stdio_seek(i1, i2, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 var i3 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i5;
 i3 = i5 + 20 | 0;
 HEAP32[i6 >> 2] = HEAP32[i1 + 60 >> 2];
 HEAP32[i6 + 4 >> 2] = 0;
 HEAP32[i6 + 8 >> 2] = i2;
 HEAP32[i6 + 12 >> 2] = i3;
 HEAP32[i6 + 16 >> 2] = i4;
 if ((___syscall_ret(___syscall140(140, i6 | 0) | 0) | 0) < 0) {
  HEAP32[i3 >> 2] = -1;
  i1 = -1;
 } else i1 = HEAP32[i3 >> 2] | 0;
 STACKTOP = i5;
 return i1 | 0;
}

function _firinterp_crcf_destroy(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0;
 i1 = HEAP32[i4 + 16 >> 2] | 0;
 i2 = i1 + 12 | 0;
 i3 = i1 + 20 | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i5 = 0;
  do {
   _dotprod_crcf_destroy(HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0);
   i5 = i5 + 1 | 0;
  } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i3 >> 2] | 0);
 _windowcf_destroy(HEAP32[i1 + 16 >> 2] | 0);
 _free(i1);
 _free(HEAP32[i4 >> 2] | 0);
 _free(i4);
 return;
}

function _liquid_getopt_str2mod(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i5;
 i1 = 0;
 do {
  if (!(_strcmp(i2, HEAP32[gb + 580 + (i1 << 4) >> 2] | 0) | 0)) {
   i4 = 5;
   break;
  }
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < 60);
 if ((i4 | 0) == 5) {
  STACKTOP = i5;
  return i1 | 0;
 }
 i4 = HEAP32[gb + 8808 >> 2] | 0;
 HEAP32[i3 >> 2] = i2;
 _fprintf(i4, gb + 34121 | 0, i3) | 0;
 i4 = 0;
 STACKTOP = i5;
 return i4 | 0;
}

function _firinterp_rrrf_destroy(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0;
 i1 = HEAP32[i4 + 16 >> 2] | 0;
 i2 = i1 + 12 | 0;
 i3 = i1 + 20 | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i5 = 0;
  do {
   _dotprod_rrrf_destroy(HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0);
   i5 = i5 + 1 | 0;
  } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i3 >> 2] | 0);
 _windowf_destroy(HEAP32[i1 + 16 >> 2] | 0);
 _free(i1);
 _free(HEAP32[i4 >> 2] | 0);
 _free(i4);
 return;
}

function _liquid_getopt_str2fec(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i5;
 i1 = 0;
 do {
  if (!(_strcmp(i2, HEAP32[gb + 56 + (i1 << 3) >> 2] | 0) | 0)) {
   i4 = 5;
   break;
  }
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < 28);
 if ((i4 | 0) == 5) {
  STACKTOP = i5;
  return i1 | 0;
 }
 i4 = HEAP32[gb + 8808 >> 2] | 0;
 HEAP32[i3 >> 2] = i2;
 _fprintf(i4, gb + 11761 | 0, i3) | 0;
 i4 = 0;
 STACKTOP = i5;
 return i4 | 0;
}

function _modem_modulate_dpsk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var d4 = 0.0, d5 = 0.0;
 d5 = +((_gray_decode(i2) | 0) << 1 >>> 0);
 i2 = i1 + 104 | 0;
 d5 = +HEAPF32[i2 >> 2] + +HEAPF32[i1 + 108 >> 2] * d5;
 d5 = d5 - (d5 > 6.283185307179586 ? 6.283185307179586 : 0.0);
 HEAPF32[i2 >> 2] = d5;
 d4 = +Math_sin(+d5);
 d5 = +Math_cos(+d5) + d4 * 0.0;
 HEAPF32[i3 >> 2] = d5;
 HEAPF32[i3 + 4 >> 2] = d4;
 HEAPF32[i1 + 84 >> 2] = d5;
 HEAPF32[i1 + 88 >> 2] = d4;
 return;
}

function _bucket_is_empty(i3, i2) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i1 = 0, i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4 + 4 | 0;
 i1 = i4;
 HEAP32[i5 >> 2] = i3;
 HEAP32[i1 >> 2] = i2;
 if ((HEAP32[HEAP32[i1 >> 2] >> 2] | 0) != ((HEAP32[i5 >> 2] | 0) + 12 | 0)) {
  i5 = 0;
  i5 = i5 & 1;
  STACKTOP = i4;
  return i5 | 0;
 }
 i5 = (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) == (HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] | 0);
 i5 = i5 & 1;
 STACKTOP = i4;
 return i5 | 0;
}

function _fec_block_get_enc_msg_len(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 if (!i3) {
  _fwrite(gb + 11967 | 0, 61, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (i2 >>> 0 < i3 >>> 0) {
  _fwrite(gb + 12029 | 0, 76, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  i1 = i1 << 3;
  i3 = Math_imul((((i1 >>> 0) % (i3 >>> 0) | 0 | 0) != 0 & 1) + ((i1 >>> 0) / (i3 >>> 0) | 0) | 0, i2) | 0;
  return ((i3 & 7 | 0) != 0 & 1) + (i3 >>> 3) | 0;
 }
 return 0;
}

function _generate_seed() {
 var i1 = 0, i2 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3 + 4 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = 0;
 if ((HEAP32[i1 >> 2] | 0) == 0 ? (_seed_from_urandom(i2) | 0) == 0 : 0) HEAP32[i1 >> 2] = 1;
 if (!(HEAP32[i1 >> 2] | 0)) _seed_from_timestamp_and_pid(i2) | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i2 = HEAP32[i2 >> 2] | 0;
  STACKTOP = i3;
  return i2 | 0;
 }
 HEAP32[i2 >> 2] = 1;
 i2 = HEAP32[i2 >> 2] | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function _open(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i4;
 i6 = i4 + 16 | 0;
 HEAP32[i6 >> 2] = i3;
 i7 = (HEAP32[i6 >> 2] | 0) + (4 - 1) & ~(4 - 1);
 i3 = HEAP32[i7 >> 2] | 0;
 HEAP32[i6 >> 2] = i7 + 4;
 HEAP32[i5 >> 2] = i1;
 HEAP32[i5 + 4 >> 2] = i2 | 32768;
 HEAP32[i5 + 8 >> 2] = i3;
 i3 = ___syscall_ret(___syscall5(5, i5 | 0) | 0) | 0;
 STACKTOP = i4;
 return i3 | 0;
}

function _modem_demodulate(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4 + 8 | 0;
 i7 = i4;
 i6 = HEAP32[i1 + 240 >> 2] | 0;
 i8 = HEAP32[i3 + 4 >> 2] | 0;
 HEAP32[i7 >> 2] = HEAP32[i3 >> 2];
 HEAP32[i7 + 4 >> 2] = i8;
 HEAP32[i5 >> 2] = HEAP32[i7 >> 2];
 HEAP32[i5 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
 mftCall_viii(i6 | 0, i1 | 0, i5 | 0, i2 | 0);
 STACKTOP = i4;
 return;
}

function _modem_demodulate_qpsk(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, d5 = 0.0, i6 = 0;
 d5 = +HEAPF32[i3 >> 2];
 i6 = !(d5 > 0.0);
 d4 = +HEAPF32[i3 + 4 >> 2];
 i3 = d4 > 0.0;
 HEAP32[i2 >> 2] = (i3 ? 0 : 2) | i6 & 1;
 HEAPF32[i1 + 92 >> 2] = (i6 ? -.7071067811865476 : .7071067811865476) + (i3 ? 0.0 : -0.0);
 HEAPF32[i1 + 96 >> 2] = i3 ? .7071067690849304 : -.7071067690849304;
 HEAPF32[i1 + 84 >> 2] = d5;
 HEAPF32[i1 + 88 >> 2] = d4;
 return;
}

function _ofdmflexframesync_internal_callback(i2, i3, i1, i4) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 i4 = i4 | 0;
 i3 = i4 + 188 | 0;
 HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + 1;
 switch (HEAP32[i4 + 192 >> 2] | 0) {
 case 0:
  {
   _ofdmflexframesync_rxheader(i4, i2);
   return 0;
  }
 case 1:
  {
   _ofdmflexframesync_rxpayload(i4, i2);
   return 0;
  }
 default:
  {
   _fwrite(gb + 29017 | 0, 81, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(1);
  }
 }
 return 0;
}

function _list_insert(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3 + 4 | 0;
 i5 = i3;
 HEAP32[i4 >> 2] = i1;
 HEAP32[i5 >> 2] = i2;
 HEAP32[(HEAP32[i5 >> 2] | 0) + 4 >> 2] = HEAP32[i4 >> 2];
 HEAP32[HEAP32[i5 >> 2] >> 2] = HEAP32[HEAP32[i4 >> 2] >> 2];
 HEAP32[(HEAP32[HEAP32[i4 >> 2] >> 2] | 0) + 4 >> 2] = HEAP32[i5 >> 2];
 HEAP32[HEAP32[i4 >> 2] >> 2] = HEAP32[i5 >> 2];
 STACKTOP = i3;
 return;
}

function _gmskframesync_debug_enable(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = i2 + 236 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i2 = i2 + 232 | 0;
  HEAP32[i2 >> 2] = 1;
  HEAP32[i1 >> 2] = 1;
  return;
 }
 HEAP32[i2 + 240 >> 2] = _windowcf_create(2e3) | 0;
 HEAP32[i2 + 244 >> 2] = _windowf_create(2e3) | 0;
 HEAP32[i2 + 248 >> 2] = _windowf_create(2e3) | 0;
 HEAP32[i2 + 252 >> 2] = _windowf_create(2e3) | 0;
 i2 = i2 + 232 | 0;
 HEAP32[i2 >> 2] = 1;
 HEAP32[i1 >> 2] = 1;
 return;
}

function _firdespm_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 + 88 >> 2] | 0);
 _free(HEAP32[i1 + 64 >> 2] | 0);
 _free(HEAP32[i1 + 68 >> 2] | 0);
 _free(HEAP32[i1 + 72 >> 2] | 0);
 _free(HEAP32[i1 + 48 >> 2] | 0);
 _free(HEAP32[i1 + 52 >> 2] | 0);
 _free(HEAP32[i1 + 56 >> 2] | 0);
 _free(HEAP32[i1 + 60 >> 2] | 0);
 _free(HEAP32[i1 + 32 >> 2] | 0);
 _free(HEAP32[i1 + 36 >> 2] | 0);
 _free(HEAP32[i1 + 40 >> 2] | 0);
 _free(HEAP32[i1 + 44 >> 2] | 0);
 _free(i1);
 return;
}

function _detector_cccf_reset(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 _windowcf_clear(HEAP32[i1 + 16 >> 2] | 0);
 _wdelayf_clear(HEAP32[i1 + 60 >> 2] | 0);
 HEAP32[i1 + 76 >> 2] = HEAP32[i1 + 4 >> 2];
 HEAP32[i1 + 72 >> 2] = 0;
 HEAP32[i1 + 52 >> 2] = 0;
 HEAP32[i1 + 56 >> 2] = 0;
 HEAPF32[i1 + 64 >> 2] = 0.0;
 i2 = i1 + 24 | 0;
 _memset(HEAP32[i1 + 44 >> 2] | 0, 0, HEAP32[i2 >> 2] << 2 | 0) | 0;
 _memset(HEAP32[i1 + 48 >> 2] | 0, 0, HEAP32[i2 >> 2] << 2 | 0) | 0;
 return;
}

function _ofdmframegen_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 + 8 >> 2] | 0);
 _free(HEAP32[i1 + 52 >> 2] | 0);
 _free(HEAP32[i1 + 56 >> 2] | 0);
 _fft_destroy_plan(HEAP32[i1 + 48 >> 2] | 0);
 _free(HEAP32[i1 + 16 >> 2] | 0);
 _free(HEAP32[i1 + 20 >> 2] | 0);
 _free(HEAP32[i1 + 60 >> 2] | 0);
 _free(HEAP32[i1 + 64 >> 2] | 0);
 _free(HEAP32[i1 + 68 >> 2] | 0);
 _free(HEAP32[i1 + 72 >> 2] | 0);
 _msequence_destroy(HEAP32[i1 + 76 >> 2] | 0);
 _free(i1);
 return;
}

function _quiet_encoder_profile_str(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 i4 = _json_loads(i1, 0, i5) | 0;
 if (i4) {
  i1 = _encoder_profile(i4, i2) | 0;
  i2 = i4 + 4 | 0;
  i3 = HEAP32[i2 >> 2] | 0;
  if ((i3 | 0) != -1 ? (i3 = i3 + -1 | 0, HEAP32[i2 >> 2] = i3, (i3 | 0) == 0) : 0) _json_delete(i4);
 } else {
  _puts(gb + 10444 | 0) | 0;
  i1 = 0;
 }
 STACKTOP = i5;
 return i1 | 0;
}

function _quiet_decoder_profile_str(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 i4 = _json_loads(i1, 0, i5) | 0;
 if (i4) {
  i1 = _decoder_profile(i4, i2) | 0;
  i2 = i4 + 4 | 0;
  i3 = HEAP32[i2 >> 2] | 0;
  if ((i3 | 0) != -1 ? (i3 = i3 + -1 | 0, HEAP32[i2 >> 2] = i3, (i3 | 0) == 0) : 0) _json_delete(i4);
 } else {
  _puts(gb + 10444 | 0) | 0;
  i1 = 0;
 }
 STACKTOP = i5;
 return i1 | 0;
}

function ___towrite(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i1 = i2 + 74 | 0;
 i3 = HEAP8[i1 >> 0] | 0;
 HEAP8[i1 >> 0] = i3 + 255 | i3;
 i1 = HEAP32[i2 >> 2] | 0;
 if (!(i1 & 8)) {
  HEAP32[i2 + 8 >> 2] = 0;
  HEAP32[i2 + 4 >> 2] = 0;
  i1 = HEAP32[i2 + 44 >> 2] | 0;
  HEAP32[i2 + 28 >> 2] = i1;
  HEAP32[i2 + 20 >> 2] = i1;
  HEAP32[i2 + 16 >> 2] = i1 + (HEAP32[i2 + 48 >> 2] | 0);
  i1 = 0;
 } else {
  HEAP32[i2 >> 2] = i1 | 32;
  i1 = -1;
 }
 return i1 | 0;
}

function _resamp_rrrf_destroy(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0;
 i1 = HEAP32[i4 + 48 >> 2] | 0;
 i2 = i1 + 12 | 0;
 i3 = i1 + 20 | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i5 = 0;
  do {
   _dotprod_rrrf_destroy(HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0);
   i5 = i5 + 1 | 0;
  } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i3 >> 2] | 0);
 _windowf_destroy(HEAP32[i1 + 16 >> 2] | 0);
 _free(i1);
 _free(i4);
 return;
}

function _json_object_set_nocheck(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i4 + 8 | 0;
 i6 = i4 + 4 | 0;
 i5 = i4;
 HEAP32[i7 >> 2] = i2;
 HEAP32[i6 >> 2] = i1;
 HEAP32[i5 >> 2] = i3;
 i2 = HEAP32[i7 >> 2] | 0;
 i3 = HEAP32[i6 >> 2] | 0;
 i3 = _json_object_set_new_nocheck(i2, i3, _json_incref(HEAP32[i5 >> 2] | 0) | 0) | 0;
 STACKTOP = i4;
 return i3 | 0;
}

function ___stdout_write(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i4 = i5;
 HEAP32[i2 + 36 >> 2] = fb + 1;
 if ((HEAP32[i2 >> 2] & 64 | 0) == 0 ? (HEAP32[i4 >> 2] = HEAP32[i2 + 60 >> 2], HEAP32[i4 + 4 >> 2] = 21505, HEAP32[i4 + 8 >> 2] = i5 + 12, ___syscall54(54, i4 | 0) | 0) : 0) HEAP8[i2 + 75 >> 0] = -1;
 i4 = ___stdio_write(i2, i1, i3) | 0;
 STACKTOP = i5;
 return i4 | 0;
}

function copyTempDouble(i1) {
 i1 = i1 | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[i1 >> 0];
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[i1 + 1 >> 0];
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[i1 + 2 >> 0];
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[i1 + 3 >> 0];
 HEAP8[tempDoublePtr + 4 >> 0] = HEAP8[i1 + 4 >> 0];
 HEAP8[tempDoublePtr + 5 >> 0] = HEAP8[i1 + 5 >> 0];
 HEAP8[tempDoublePtr + 6 >> 0] = HEAP8[i1 + 6 >> 0];
 HEAP8[tempDoublePtr + 7 >> 0] = HEAP8[i1 + 7 >> 0];
}

function _fec_hamming84_encode(i1, i3, i4, i5) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i2 = 0, i6 = 0;
 if (!i3) return; else {
  i1 = 0;
  i2 = 0;
 }
 while (1) {
  i6 = HEAP8[i4 + i1 >> 0] | 0;
  HEAP8[i5 + i2 >> 0] = HEAP8[((i6 & 255) >>> 4 & 255) + (gb + 13096) >> 0] | 0;
  HEAP8[i5 + (i2 | 1) >> 0] = HEAP8[(i6 & 15) + (gb + 13096) >> 0] | 0;
  i1 = i1 + 1 | 0;
  if ((i1 | 0) == (i3 | 0)) break; else i2 = i2 + 2 | 0;
 }
 return;
}

function _json_real_value(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, d5 = 0.0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4;
 i2 = i4 + 8 | 0;
 HEAP32[i2 >> 2] = i3;
 if (HEAP32[i2 >> 2] | 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 4 : 0) {
  HEAPF64[i1 >> 3] = +HEAPF64[(HEAP32[i2 >> 2] | 0) + 8 >> 3];
  d5 = +HEAPF64[i1 >> 3];
  STACKTOP = i4;
  return +d5;
 }
 HEAPF64[i1 >> 3] = 0.0;
 d5 = +HEAPF64[i1 >> 3];
 STACKTOP = i4;
 return +d5;
}

function _quiet_decoder_readbuf(i2, i3, i4) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0;
 if (!i2) {
  i4 = 0;
  return i4 | 0;
 }
 i1 = i2 + 76 | 0;
 if ((HEAP32[i1 >> 2] | 0) >>> 0 < i4 >>> 0) {
  i4 = 0;
  return i4 | 0;
 }
 i2 = i2 + 68 | 0;
 _memmove(i3 | 0, HEAP32[i2 >> 2] | 0, i4 | 0) | 0;
 i3 = (HEAP32[i1 >> 2] | 0) - i4 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = HEAP32[i2 >> 2] | 0;
 _memmove(i2 | 0, i2 + i4 | 0, i3 | 0) | 0;
 return i4 | 0;
}

function _modem_modulate_qam(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0;
 i7 = HEAP32[i1 + 104 >> 2] | 0;
 i5 = _gray_decode(i2 >>> i7) | 0;
 i2 = _gray_decode((1 << i7) + -1 & i2) | 0;
 d6 = +HEAPF32[i1 + 116 >> 2];
 d4 = d6 * +((i2 << 1 | 1) - (HEAP32[i1 + 112 >> 2] | 0) | 0);
 HEAPF32[i3 >> 2] = d6 * +((i5 << 1 | 1) - (HEAP32[i1 + 108 >> 2] | 0) | 0) + d4 * 0.0;
 HEAPF32[i3 + 4 >> 2] = d4;
 return;
}

function _json_string_value(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4 + 4 | 0;
 i2 = i4;
 HEAP32[i2 >> 2] = i3;
 if (HEAP32[i2 >> 2] | 0 ? (HEAP32[HEAP32[i2 >> 2] >> 2] | 0) == 2 : 0) {
  HEAP32[i1 >> 2] = HEAP32[(HEAP32[i2 >> 2] | 0) + 8 >> 2];
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 }
 HEAP32[i1 >> 2] = 0;
 i3 = HEAP32[i1 >> 2] | 0;
 STACKTOP = i4;
 return i3 | 0;
}

function _jsonp_malloc(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i4 + 4 | 0;
 i2 = i4;
 HEAP32[i2 >> 2] = i3;
 if (HEAP32[i2 >> 2] | 0) {
  HEAP32[i1 >> 2] = mftCall_ii(HEAP32[gb + 8776 >> 2] | 0, HEAP32[i2 >> 2] | 0) | 0;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 } else {
  HEAP32[i1 >> 2] = 0;
  i3 = HEAP32[i1 >> 2] | 0;
  STACKTOP = i4;
  return i3 | 0;
 }
 return 0;
}

function _modem_get_demodulator_evm(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3 + 8 | 0;
 i5 = i3;
 d2 = +HEAPF32[i1 + 96 >> 2] - +HEAPF32[i1 + 88 >> 2];
 HEAPF32[i5 >> 2] = +HEAPF32[i1 + 92 >> 2] - +HEAPF32[i1 + 84 >> 2];
 HEAPF32[i5 + 4 >> 2] = d2;
 HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i4 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 d2 = +_cabsf(i4);
 STACKTOP = i3;
 return +d2;
}

function _nco_crcf_pll_step(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 var i3 = 0;
 i3 = i2 + 8 | 0;
 HEAPF32[i3 >> 2] = +HEAPF32[i3 >> 2] + +HEAPF32[i2 + 1052 >> 2] * d1;
 i3 = i2 + 4 | 0;
 d1 = +HEAPF32[i3 >> 2] + +HEAPF32[i2 + 1056 >> 2] * d1;
 HEAPF32[i3 >> 2] = d1;
 if (d1 > 3.141592653589793) {
  HEAPF32[i3 >> 2] = d1 + -6.283185307179586;
  return;
 }
 if (!(d1 < -3.141592653589793)) return;
 HEAPF32[i3 >> 2] = d1 + 6.283185307179586;
 return;
}

function _coshf(d1) {
 d1 = +d1;
 var i2 = 0;
 d1 = +Math_abs(+d1);
 i2 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 do if (i2 >>> 0 < 1060205079) if (i2 >>> 0 < 964689920) d1 = 1.0; else {
  d1 = +_expm1f(d1);
  d1 = d1 * d1 / ((d1 + 1.0) * 2.0) + 1.0;
 } else if (i2 >>> 0 < 1118925335) {
  d1 = +Math_exp(+d1);
  d1 = (d1 + 1.0 / d1) * .5;
  break;
 } else {
  d1 = +___expo2f(d1);
  break;
 } while (0);
 return +d1;
}

function _flexframegen_destroy(i1) {
 i1 = i1 | 0;
 _firinterp_crcf_destroy(HEAP32[i1 + 12 >> 2] | 0);
 _qpacketmodem_destroy(HEAP32[i1 + 64 >> 2] | 0);
 _qpilotgen_destroy(HEAP32[i1 + 76 >> 2] | 0);
 _qpacketmodem_destroy(HEAP32[i1 + 92 >> 2] | 0);
 _free(HEAP32[i1 + 48 >> 2] | 0);
 _free(HEAP32[i1 + 52 >> 2] | 0);
 _free(HEAP32[i1 + 72 >> 2] | 0);
 _free(HEAP32[i1 + 84 >> 2] | 0);
 _free(HEAP32[i1 + 100 >> 2] | 0);
 _free(i1);
 return;
}

function ___fmodeflags(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = (_strchr(i1, 43) | 0) == 0;
 i2 = HEAP8[i1 >> 0] | 0;
 i3 = i3 ? i2 << 24 >> 24 != 114 & 1 : 2;
 i4 = (_strchr(i1, 120) | 0) == 0;
 i3 = i4 ? i3 : i3 | 128;
 i1 = (_strchr(i1, 101) | 0) == 0;
 i1 = i1 ? i3 : i3 | 524288;
 i1 = i2 << 24 >> 24 == 114 ? i1 : i1 | 64;
 i1 = i2 << 24 >> 24 == 119 ? i1 | 512 : i1;
 return (i2 << 24 >> 24 == 97 ? i1 | 1024 : i1) | 0;
}

function _strcmp(i4, i2) {
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = HEAP8[i4 >> 0] | 0;
 i1 = HEAP8[i2 >> 0] | 0;
 if (i3 << 24 >> 24 == 0 ? 1 : i3 << 24 >> 24 != i1 << 24 >> 24) i2 = i3; else {
  do {
   i4 = i4 + 1 | 0;
   i2 = i2 + 1 | 0;
   i3 = HEAP8[i4 >> 0] | 0;
   i1 = HEAP8[i2 >> 0] | 0;
  } while (!(i3 << 24 >> 24 == 0 ? 1 : i3 << 24 >> 24 != i1 << 24 >> 24));
  i2 = i3;
 }
 return (i2 & 255) - (i1 & 255) | 0;
}

function _dotprod_rrrf_execute(i2, i5, i6) {
 i2 = i2 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var d1 = 0.0, i3 = 0, i4 = 0;
 i4 = HEAP32[i2 >> 2] | 0;
 i2 = HEAP32[i2 + 4 >> 2] | 0;
 if (!i2) {
  d1 = 0.0;
  HEAPF32[i6 >> 2] = d1;
  return;
 } else {
  i3 = 0;
  d1 = 0.0;
 }
 do {
  d1 = d1 + +HEAPF32[i4 + (i3 << 2) >> 2] * +HEAPF32[i5 + (i3 << 2) >> 2];
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i2 | 0));
 HEAPF32[i6 >> 2] = d1;
 return;
}

function _firpfb_crcf_push(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3 + 8 | 0;
 i5 = i3;
 i1 = HEAP32[i1 + 16 >> 2] | 0;
 i6 = HEAP32[i2 + 4 >> 2] | 0;
 HEAP32[i5 >> 2] = HEAP32[i2 >> 2];
 HEAP32[i5 + 4 >> 2] = i6;
 HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
 HEAP32[i4 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
 _windowcf_push(i1, i4);
 STACKTOP = i3;
 return;
}

function _interleaver_create(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0;
 i4 = _malloc(16) | 0;
 HEAP32[i4 >> 2] = i3;
 HEAP32[i4 + 12 >> 2] = 4;
 i2 = (~~+Math_floor(+(+Math_sqrt(+(+(i3 >>> 0))))) >>> 0) + 1 | 0;
 HEAP32[i4 + 4 >> 2] = i2;
 i5 = i4 + 8 | 0;
 i1 = (i3 >>> 0) / (i2 >>> 0) | 0;
 while (1) if ((Math_imul(i2, i1) | 0) >>> 0 > i3 >>> 0) break; else i1 = i1 + 1 | 0;
 HEAP32[i5 >> 2] = i1;
 return i4 | 0;
}

function mftCall_iiiiiiii(i8, i1, i2, i3, i4, i5, i6, i7) {
 i8 = i8 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 if ((i8 | 0) >= (fb | 0) & (i8 | 0) < (fb + 1 | 0)) return FUNCTION_TABLE_iiiiiiii[i8 - fb & 1](i1 | 0, i2 | 0, i3 | 0, i4 | 0, i5 | 0, i6 | 0, i7 | 0) | 0;
 return ftCall_iiiiiiii(i8 | 0, i1 | 0, i2 | 0, i3 | 0, i4 | 0, i5 | 0, i6 | 0, i7 | 0) | 0;
}

function _firpfb_crcf_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 i1 = i3 + 12 | 0;
 i2 = i3 + 20 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i4 = 0;
  do {
   _dotprod_crcf_destroy(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 << 2) >> 2] | 0);
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i2 >> 2] | 0);
 _windowcf_destroy(HEAP32[i3 + 16 >> 2] | 0);
 _free(i3);
 return;
}

function _firpfb_rrrf_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 i1 = i3 + 12 | 0;
 i2 = i3 + 20 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i4 = 0;
  do {
   _dotprod_rrrf_destroy(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 << 2) >> 2] | 0);
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i2 >> 2] | 0);
 _windowf_destroy(HEAP32[i3 + 16 >> 2] | 0);
 _free(i3);
 return;
}

function ___muldsi3(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = i1 & 65535;
 i5 = i2 & 65535;
 i3 = Math_imul(i5, i6) | 0;
 i4 = i1 >>> 16;
 i1 = (i3 >>> 16) + (Math_imul(i5, i4) | 0) | 0;
 i5 = i2 >>> 16;
 i2 = Math_imul(i5, i6) | 0;
 return (setTempRet0((i1 >>> 16) + (Math_imul(i5, i4) | 0) + (((i1 & 65535) + i2 | 0) >>> 16) | 0), i1 + i2 << 16 | i3 & 65535 | 0) | 0;
}

function _modem_modulate_arb(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0;
 if ((HEAP32[i1 + 8 >> 2] | 0) >>> 0 > i2 >>> 0) {
  i4 = HEAP32[i1 + 76 >> 2] | 0;
  i1 = HEAP32[i4 + (i2 << 3) + 4 >> 2] | 0;
  HEAP32[i3 >> 2] = HEAP32[i4 + (i2 << 3) >> 2];
  HEAP32[i3 + 4 >> 2] = i1;
  return;
 } else {
  _fwrite(gb + 31527 | 0, 52, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
}

function _seed_from_timestamp_and_pid(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i2 + 8 | 0;
 i3 = i2;
 HEAP32[i4 >> 2] = i1;
 _gettimeofday(i3 | 0, 0) | 0;
 HEAP32[HEAP32[i4 >> 2] >> 2] = HEAP32[i3 >> 2] ^ HEAP32[i3 + 4 >> 2];
 i3 = _getpid() | 0;
 i1 = HEAP32[i4 >> 2] | 0;
 HEAP32[i1 >> 2] = HEAP32[i1 >> 2] ^ i3;
 STACKTOP = i2;
 return 0;
}

function _ofdmframegen_reset(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 _msequence_reset(HEAP32[i1 + 76 >> 2] | 0);
 i3 = i1 + 12 | 0;
 if (!(HEAP32[i3 >> 2] | 0)) return;
 i1 = i1 + 20 | 0;
 i2 = 0;
 do {
  i4 = HEAP32[i1 >> 2] | 0;
  HEAPF32[i4 + (i2 << 3) >> 2] = 0.0;
  HEAPF32[i4 + (i2 << 3) + 4 >> 2] = 0.0;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
 return;
}

function _fwrite(i2, i5, i1, i3) {
 i2 = i2 | 0;
 i5 = i5 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i6 = 0;
 i4 = Math_imul(i1, i5) | 0;
 if ((HEAP32[i3 + 76 >> 2] | 0) > -1) {
  i6 = (___lockfile(i3) | 0) == 0;
  i2 = ___fwritex(i2, i4, i3) | 0;
  if (!i6) ___unlockfile(i3);
 } else i2 = ___fwritex(i2, i4, i3) | 0;
 if ((i2 | 0) != (i4 | 0)) i1 = (i2 >>> 0) / (i5 >>> 0) | 0;
 return i1 | 0;
}

function _rand() {
 var i1 = 0, i2 = 0, i3 = 0;
 i2 = gb + 44152 | 0;
 i2 = ___muldi3(HEAP32[i2 >> 2] | 0, HEAP32[i2 + 4 >> 2] | 0, 1284865837, 1481765933) | 0;
 i2 = _i64Add(i2 | 0, getTempRet0() | 0, 1, 0) | 0;
 i1 = getTempRet0() | 0;
 i3 = gb + 44152 | 0;
 HEAP32[i3 >> 2] = i2;
 HEAP32[i3 + 4 >> 2] = i1;
 i1 = _bitshift64Lshr(i2 | 0, i1 | 0, 33) | 0;
 getTempRet0() | 0;
 return i1 | 0;
}

function _fec_hamming84_decode(i1, i2, i4, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i5 = 0;
 if (!i2) return; else i1 = 0;
 do {
  i5 = i1 << 1;
  HEAP8[i3 + i1 >> 0] = (HEAPU8[(HEAPU8[i4 + i5 >> 0] | 0) + (gb + 13112) >> 0] | 0) << 4 | (HEAPU8[(HEAPU8[i4 + (i5 | 1) >> 0] | 0) + (gb + 13112) >> 0] | 0);
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i2 | 0));
 return;
}

function _copysign(d1, d2) {
 d1 = +d1;
 d2 = +d2;
 var i3 = 0;
 HEAPF64[tempDoublePtr >> 3] = d2;
 i3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 d2 = +Math_abs(+d1);
 HEAPF64[tempDoublePtr >> 3] = d2;
 i3 = i3 & -2147483648 | HEAP32[tempDoublePtr + 4 >> 2];
 HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
 HEAP32[tempDoublePtr + 4 >> 2] = i3;
 return +(+HEAPF64[tempDoublePtr >> 3]);
}

function _gmskframegen_getframelen(i1) {
 i1 = i1 | 0;
 if (!(HEAP32[i1 + 88 >> 2] | 0)) {
  _fwrite(gb + 26655 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  i1 = 0;
  return i1 | 0;
 } else {
  i1 = Math_imul((HEAP32[i1 + 20 >> 2] | 0) + (HEAP32[i1 + 16 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] | 0) + (HEAP32[i1 + 8 >> 2] << 1) | 0, HEAP32[i1 + 4 >> 2] | 0) | 0;
  return i1 | 0;
 }
 return 0;
}

function _crc_validate_message(i4, i2, i3, i1) {
 i4 = i4 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 switch (i4 | 0) {
 case 0:
  {
   _fwrite(gb + 10864 | 0, 71, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
   _exit(-1);
   break;
  }
 case 1:
  {
   i4 = 1;
   return i4 | 0;
  }
 default:
  {
   i4 = (_crc_generate_key(i4, i2, i3) | 0) == (i1 | 0) & 1;
   return i4 | 0;
  }
 }
 return 0;
}

function _strbuffer_close(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (HEAP32[HEAP32[i1 >> 2] >> 2] | 0) _jsonp_free(HEAP32[HEAP32[i1 >> 2] >> 2] | 0);
 HEAP32[(HEAP32[i1 >> 2] | 0) + 8 >> 2] = 0;
 HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] = 0;
 HEAP32[HEAP32[i1 >> 2] >> 2] = 0;
 STACKTOP = i3;
 return;
}

function _fec_rep3_decode(i1, i3, i5, i4) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i2 = 0, i6 = 0, i7 = 0;
 if (!i3) return;
 i1 = i3 << 1;
 i2 = 0;
 do {
  i6 = HEAP8[i5 + (i2 + i3) >> 0] | 0;
  i7 = HEAP8[i5 + (i2 + i1) >> 0] | 0;
  HEAP8[i4 + i2 >> 0] = (i7 | i6) & HEAP8[i5 + i2 >> 0] | i7 & i6;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i3 | 0));
 return;
}

function _memmove(i1, i4, i2) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i3 = 0;
 if ((i4 | 0) < (i1 | 0) & (i1 | 0) < (i4 + i2 | 0)) {
  i3 = i1;
  i4 = i4 + i2 | 0;
  i1 = i1 + i2 | 0;
  while ((i2 | 0) > 0) {
   i1 = i1 - 1 | 0;
   i4 = i4 - 1 | 0;
   i2 = i2 - 1 | 0;
   HEAP8[i1 >> 0] = HEAP8[i4 >> 0] | 0;
  }
  i1 = i3;
 } else _memcpy(i1, i4, i2) | 0;
 return i1 | 0;
}

function _qdetector_cccf_set_threshold(i1, d2) {
 i1 = i1 | 0;
 d2 = +d2;
 var i3 = 0, i4 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i4;
 if (d2 <= 0.0 | d2 > 2.0) {
  i1 = HEAP32[gb + 8808 >> 2] | 0;
  HEAPF64[i3 >> 3] = d2;
  _fprintf(i1, gb + 29163 | 0, i3) | 0;
  STACKTOP = i4;
  return;
 } else {
  HEAPF32[i1 + 48 >> 2] = d2;
  STACKTOP = i4;
  return;
 }
}

function _modem_demodulate_ook(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, i5 = 0;
 d4 = +HEAPF32[i3 >> 2];
 i5 = !(d4 > .7071067811865476);
 HEAP32[i2 >> 2] = i5 & 1;
 HEAPF32[i1 + 92 >> 2] = i5 ? 0.0 : 1.4142135381698608;
 HEAPF32[i1 + 96 >> 2] = 0.0;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 HEAPF32[i1 + 84 >> 2] = d4;
 HEAP32[i1 + 88 >> 2] = i3;
 return;
}

function _liquid_msb_index(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = i2 >>> 24;
 if (!i1) {
  i1 = i2 >>> 16 & 255;
  if (!i1) {
   i1 = i2 >>> 8 & 255;
   if (!i1) {
    i1 = i2 & 255;
    if (!i1) {
     i2 = 0;
     return i2 | 0;
    } else i2 = 8;
   } else i2 = 16;
  } else i2 = 24;
 } else i2 = 32;
 i2 = i2 - (HEAP32[gb + 7320 + (i1 << 2) >> 2] | 0) | 0;
 return i2 | 0;
}

function _llvm_cttz_i32(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP8[cttz_i8 + (i2 & 255) >> 0] | 0;
 if ((i1 | 0) < 8) return i1 | 0;
 i1 = HEAP8[cttz_i8 + (i2 >> 8 & 255) >> 0] | 0;
 if ((i1 | 0) < 8) return i1 + 8 | 0;
 i1 = HEAP8[cttz_i8 + (i2 >> 16 & 255) >> 0] | 0;
 if ((i1 | 0) < 8) return i1 + 16 | 0;
 return (HEAP8[cttz_i8 + (i2 >>> 24) >> 0] | 0) + 24 | 0;
}

function _qdetector_cccf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 + 4 >> 2] | 0);
 _free(HEAP32[i1 + 8 >> 2] | 0);
 _free(HEAP32[i1 + 16 >> 2] | 0);
 _free(HEAP32[i1 + 20 >> 2] | 0);
 _free(HEAP32[i1 + 24 >> 2] | 0);
 _free(HEAP32[i1 + 28 >> 2] | 0);
 _fft_destroy_plan(HEAP32[i1 + 36 >> 2] | 0);
 _fft_destroy_plan(HEAP32[i1 + 40 >> 2] | 0);
 _free(i1);
 return;
}

function _liquid_lngammaf(d1) {
 d1 = +d1;
 if (d1 < 0.0) {
  _fwrite(gb + 30123 | 0, 47, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 if (d1 < 10.0) return +(+_liquid_lngammaf(d1 + 1.0) - +Math_log(+d1)); else return +((1.8378770351409912 - +Math_log(+d1)) * .5 + (+Math_log(+(1.0 / (d1 * 12.0 - .10000000149011612 / d1) + d1)) + -1.0) * d1);
 return 0.0;
}

function _flexframegen_getframelen(i1) {
 i1 = i1 | 0;
 if (!(HEAP32[i1 + 112 >> 2] | 0)) {
  _fwrite(gb + 25161 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  i1 = 0;
  return i1 | 0;
 } else {
  i1 = Math_imul((HEAP32[i1 + 80 >> 2] | 0) + 64 + (HEAP32[i1 + 96 >> 2] | 0) + (HEAP32[i1 + 4 >> 2] << 1) | 0, HEAP32[i1 >> 2] | 0) | 0;
  return i1 | 0;
 }
 return 0;
}

function _calloc(i3, i1) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i2 = 0;
 if (i3) {
  i2 = Math_imul(i1, i3) | 0;
  if ((i1 | i3) >>> 0 > 65535) i2 = ((i2 >>> 0) / (i3 >>> 0) | 0 | 0) == (i1 | 0) ? i2 : -1;
 } else i2 = 0;
 i1 = _malloc(i2) | 0;
 if (!i1) return i1 | 0;
 if (!(HEAP32[i1 + -4 >> 2] & 3)) return i1 | 0;
 _memset(i1 | 0, 0, i2 | 0) | 0;
 return i1 | 0;
}

function _json_incref(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (HEAP32[i1 >> 2] | 0 ? (HEAP32[(HEAP32[i1 >> 2] | 0) + 4 >> 2] | 0) != -1 : 0) {
  i2 = (HEAP32[i1 >> 2] | 0) + 4 | 0;
  HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + 1;
 }
 STACKTOP = i3;
 return HEAP32[i1 >> 2] | 0;
}

function _gmskframegen_destroy(i1) {
 i1 = i1 | 0;
 _gmskmod_destroy(HEAP32[i1 >> 2] | 0);
 _msequence_destroy(HEAP32[i1 + 32 >> 2] | 0);
 _free(HEAP32[i1 + 44 >> 2] | 0);
 _free(HEAP32[i1 + 48 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 52 >> 2] | 0);
 _free(HEAP32[i1 + 80 >> 2] | 0);
 _packetizer_destroy(HEAP32[i1 + 56 >> 2] | 0);
 _free(i1);
 return;
}

function _iirfilt_crcf_create_dc_blocker(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3 + 8 | 0;
 i2 = i3;
 HEAPF32[i4 >> 2] = 1.0;
 HEAPF32[i4 + 4 >> 2] = -1.0;
 HEAPF32[i2 >> 2] = 1.0;
 HEAPF32[i2 + 4 >> 2] = d1 + -1.0;
 i2 = _iirfilt_crcf_create(i4, 2, i2, 2) | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function _json_array_append(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i3 + 4 | 0;
 i4 = i3;
 HEAP32[i5 >> 2] = i1;
 HEAP32[i4 >> 2] = i2;
 i2 = HEAP32[i5 >> 2] | 0;
 i2 = _json_array_append_new(i2, _json_incref(HEAP32[i4 >> 2] | 0) | 0) | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function _modem_demodulate_bpsk(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, i5 = 0;
 d4 = +HEAPF32[i3 >> 2];
 i5 = !(d4 > 0.0);
 HEAP32[i2 >> 2] = i5 & 1;
 HEAPF32[i1 + 92 >> 2] = i5 ? -1.0 : 1.0;
 HEAPF32[i1 + 96 >> 2] = 0.0;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 HEAPF32[i1 + 84 >> 2] = d4;
 HEAP32[i1 + 88 >> 2] = i3;
 return;
}

function ___uflow(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 if ((HEAP32[i2 + 8 >> 2] | 0) == 0 ? (___toread(i2) | 0) != 0 : 0) i1 = -1; else if ((mftCall_iiii(HEAP32[i2 + 32 >> 2] | 0, i2 | 0, i1 | 0, 1) | 0) == 1) i1 = HEAPU8[i1 >> 0] | 0; else i1 = -1;
 STACKTOP = i3;
 return i1 | 0;
}

function _fec_rep5_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 _memcpy(i3 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + i1 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 << 1) | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 * 3 | 0) | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 << 2) | 0, i2 | 0, i1 | 0) | 0;
 return;
}

function _nco_crcf_step(i2) {
 i2 = i2 | 0;
 var d1 = 0.0, i3 = 0;
 i3 = i2 + 4 | 0;
 d1 = +HEAPF32[i2 + 8 >> 2] + +HEAPF32[i3 >> 2];
 HEAPF32[i3 >> 2] = d1;
 if (d1 > 3.141592653589793) {
  HEAPF32[i3 >> 2] = d1 + -6.283185307179586;
  return;
 }
 if (!(d1 < -3.141592653589793)) return;
 HEAPF32[i3 >> 2] = d1 + 6.283185307179586;
 return;
}

function _polyf_val(i3, i2, d4) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 d4 = +d4;
 var d1 = 0.0, i5 = 0, d6 = 0.0;
 if (!i2) {
  d6 = 0.0;
  return +d6;
 } else {
  i5 = 0;
  d6 = 1.0;
  d1 = 0.0;
 }
 while (1) {
  d1 = d1 + d6 * +HEAPF32[i3 + (i5 << 2) >> 2];
  i5 = i5 + 1 | 0;
  if ((i5 | 0) == (i2 | 0)) break; else d6 = d6 * d4;
 }
 return +d1;
}
function ___shlim(i3, i4) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i5 = 0;
 HEAP32[i3 + 104 >> 2] = i4;
 i1 = HEAP32[i3 + 8 >> 2] | 0;
 i2 = HEAP32[i3 + 4 >> 2] | 0;
 i5 = i1 - i2 | 0;
 HEAP32[i3 + 108 >> 2] = i5;
 if ((i4 | 0) != 0 & (i5 | 0) > (i4 | 0)) HEAP32[i3 + 100 >> 2] = i2 + i4; else HEAP32[i3 + 100 >> 2] = i1;
 return;
}

function _nco_crcf_compute_sincos_nco(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = ~~(+HEAPF32[i1 + 4 >> 2] * 40.7436637878418 + 512.0 + .5) >>> 0;
 i3 = i2 & 255;
 HEAP32[i1 + 1036 >> 2] = i3;
 HEAP32[i1 + 1040 >> 2] = HEAP32[i1 + 12 + (i3 << 2) >> 2];
 HEAP32[i1 + 1044 >> 2] = HEAP32[i1 + 12 + ((i2 + 64 & 255) << 2) >> 2];
 return;
}

function _logb(d1) {
 d1 = +d1;
 var i2 = 0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i2 = HEAP32[tempDoublePtr + 4 >> 2] & 2146435072;
 do if (i2 >>> 0 < 2146435072 | (i2 | 0) == 2146435072 & 0 < 0) if (d1 == 0.0) {
  d1 = -1.0 / (d1 * d1);
  break;
 } else {
  d1 = +(_ilogb(d1) | 0);
  break;
 } else d1 = d1 * d1; while (0);
 return +d1;
}

function _liquid_besseli0f(d1) {
 d1 = +d1;
 var d2 = 0.0, i3 = 0, d4 = 0.0;
 if (d1 == 0.0) {
  d2 = 1.0;
  return +d2;
 }
 d2 = +Math_log(+(d1 * .5));
 i3 = 0;
 d1 = 0.0;
 do {
  d4 = +(i3 >>> 0);
  d1 = d1 + +Math_exp(+((d4 * d2 - +_liquid_lngammaf(d4 + 1.0)) * 2.0));
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 32);
 return +d1;
}

function _lex_free_string(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 _jsonp_free(HEAP32[(HEAP32[i3 >> 2] | 0) + 64 >> 2] | 0);
 HEAP32[(HEAP32[i3 >> 2] | 0) + 64 >> 2] = 0;
 HEAP32[(HEAP32[i3 >> 2] | 0) + 64 + 4 >> 2] = 0;
 STACKTOP = i2;
 return;
}

function _jsonp_stringn_nocheck_own(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i3 + 4 | 0;
 i4 = i3;
 HEAP32[i5 >> 2] = i2;
 HEAP32[i4 >> 2] = i1;
 i2 = _string_create(HEAP32[i5 >> 2] | 0, HEAP32[i4 >> 2] | 0, 1) | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function _json_init(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3 + 4 | 0;
 i5 = i3;
 HEAP32[i4 >> 2] = i1;
 HEAP32[i5 >> 2] = i2;
 HEAP32[HEAP32[i4 >> 2] >> 2] = HEAP32[i5 >> 2];
 HEAP32[(HEAP32[i4 >> 2] | 0) + 4 >> 2] = 1;
 STACKTOP = i3;
 return;
}

function _sn_write(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0;
 i4 = i1 + 20 | 0;
 i5 = HEAP32[i4 >> 2] | 0;
 i1 = (HEAP32[i1 + 16 >> 2] | 0) - i5 | 0;
 i1 = i1 >>> 0 > i2 >>> 0 ? i2 : i1;
 _memcpy(i5 | 0, i3 | 0, i1 | 0) | 0;
 HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 return i2 | 0;
}

function _liquid_nextpow2(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 if (!i1) {
  _fwrite(gb + 29877 | 0, 58, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 }
 i1 = i1 + -1 | 0;
 if (!i1) {
  i2 = 0;
  return i2 | 0;
 } else i2 = 0;
 do {
  i1 = i1 >>> 1;
  i2 = i2 + 1 | 0;
 } while ((i1 | 0) != 0);
 i1 = i2;
 return i1 | 0;
}

function _copysignf(d1, d2) {
 d1 = +d1;
 d2 = +d2;
 var i3 = 0;
 i3 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
 d2 = +Math_abs(+d1);
 return +(HEAP32[tempDoublePtr >> 2] = i3 & -2147483648 | (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0), +HEAPF32[tempDoublePtr >> 2]);
}

function _lex_save(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i3 + 4 | 0;
 i4 = i3;
 HEAP32[i5 >> 2] = i2;
 HEAP32[i4 >> 2] = i1;
 _strbuffer_append_byte((HEAP32[i5 >> 2] | 0) + 40 | 0, HEAP32[i4 >> 2] & 255) | 0;
 STACKTOP = i3;
 return;
}

function _lex_close(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if ((HEAP32[(HEAP32[i1 >> 2] | 0) + 56 >> 2] | 0) == 256) _lex_free_string(HEAP32[i1 >> 2] | 0);
 _strbuffer_close((HEAP32[i1 >> 2] | 0) + 40 | 0);
 STACKTOP = i3;
 return;
}

function _strbuffer_append_byte(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i3;
 i4 = i3 + 4 | 0;
 HEAP32[i5 >> 2] = i2;
 HEAP8[i4 >> 0] = i1;
 i2 = _strbuffer_append_bytes(HEAP32[i5 >> 2] | 0, i4, 1) | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function mftCall_iiiii(i5, i1, i2, i3, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 if ((i5 | 0) >= (fb | 0) & (i5 | 0) < (fb + 7 | 0)) return FUNCTION_TABLE_iiiii[i5 - fb & 7](i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
 return ftCall_iiiii(i5 | 0, i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _read(i3, i1, i2) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4;
 HEAP32[i5 >> 2] = i3;
 HEAP32[i5 + 4 >> 2] = i1;
 HEAP32[i5 + 8 >> 2] = i2;
 i3 = ___syscall_ret(___syscall3(3, i5 | 0) | 0) | 0;
 STACKTOP = i4;
 return i3 | 0;
}

function _liquid_is_prime(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 L1 : do if (i1 >>> 0 > 3) {
  i2 = 2;
  while (1) {
   if (!((i1 >>> 0) % (i2 >>> 0) | 0)) {
    i1 = 0;
    break L1;
   }
   i2 = i2 + 1 | 0;
   if (i2 >>> 0 >= i1 >>> 0) {
    i1 = 1;
    break;
   }
  }
 } else i1 = 1; while (0);
 return i1 | 0;
}

function mftCall_viiii(i5, i1, i2, i3, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 if ((i5 | 0) >= (fb | 0) & (i5 | 0) < (fb + 63 | 0)) {
  FUNCTION_TABLE_viiii[i5 - fb & 63](i1 | 0, i2 | 0, i3 | 0, i4 | 0);
  return;
 }
 ftCall_viiii(i5 | 0, i1 | 0, i2 | 0, i3 | 0, i4 | 0);
}

function ___DOUBLE_BITS(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3 + 8 | 0;
 i4 = i3;
 HEAPF64[i2 >> 3] = d1;
 HEAPF64[i4 >> 3] = +HEAPF64[i2 >> 3];
 i2 = HEAP32[i4 >> 2] | 0;
 setTempRet0(HEAP32[i4 + 4 >> 2] | 0);
 STACKTOP = i3;
 return i2 | 0;
}

function _fec_conv_init_v29(i1) {
 i1 = i1 | 0;
 HEAP32[i1 + 28 >> 2] = 2;
 HEAP32[i1 + 32 >> 2] = 9;
 HEAP32[i1 + 24 >> 2] = gb + 288;
 HEAP32[i1 + 44 >> 2] = fb + 4;
 HEAP32[i1 + 48 >> 2] = fb + 2;
 HEAP32[i1 + 52 >> 2] = fb + 6;
 HEAP32[i1 + 56 >> 2] = fb + 2;
 HEAP32[i1 + 60 >> 2] = fb + 3;
 return;
}

function _fec_conv_init_v27(i1) {
 i1 = i1 | 0;
 HEAP32[i1 + 28 >> 2] = 2;
 HEAP32[i1 + 32 >> 2] = 7;
 HEAP32[i1 + 24 >> 2] = gb + 280;
 HEAP32[i1 + 44 >> 2] = fb + 3;
 HEAP32[i1 + 48 >> 2] = fb + 1;
 HEAP32[i1 + 52 >> 2] = fb + 5;
 HEAP32[i1 + 56 >> 2] = fb + 1;
 HEAP32[i1 + 60 >> 2] = fb + 2;
 return;
}

function ___uremdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i6 | 0;
 ___udivmoddi4(i1, i2, i3, i4, i5) | 0;
 STACKTOP = i6;
 return (setTempRet0(HEAP32[i5 + 4 >> 2] | 0), HEAP32[i5 >> 2] | 0) | 0;
}

function _liquid_modpow(i2, i3, i4) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i5 = 0;
 if (!i3) {
  i5 = 1;
  return i5 | 0;
 } else {
  i1 = 1;
  i5 = 0;
 }
 do {
  i1 = ((Math_imul(i1, i2) | 0) >>> 0) % (i4 >>> 0) | 0;
  i5 = i5 + 1 | 0;
 } while ((i5 | 0) != (i3 | 0));
 return i1 | 0;
}

function _lex_get(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i3 + 4 | 0;
 i4 = i3;
 HEAP32[i5 >> 2] = i2;
 HEAP32[i4 >> 2] = i1;
 i2 = _stream_get(HEAP32[i5 >> 2] | 0, HEAP32[i4 >> 2] | 0) | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function _fft_reverse_index(i1, i4) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 var i2 = 0, i3 = 0;
 if (!i4) {
  i4 = 0;
  return i4 | 0;
 } else {
  i2 = i1;
  i1 = 0;
  i3 = 0;
 }
 while (1) {
  i1 = i1 << 1 | i2 & 1;
  i3 = i3 + 1 | 0;
  if ((i3 | 0) == (i4 | 0)) break; else i2 = i2 >>> 1;
 }
 return i1 | 0;
}

function _ofdmflexframegen_reset(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = i1 + 116 | 0;
 HEAP32[i2 >> 2] = 0;
 HEAP32[i2 + 4 >> 2] = 0;
 HEAP32[i2 + 8 >> 2] = 0;
 HEAP32[i2 + 12 >> 2] = 0;
 HEAP32[i2 + 16 >> 2] = 0;
 HEAP32[i2 + 20 >> 2] = 0;
 _ofdmframegen_reset(HEAP32[i1 + 40 >> 2] | 0);
 return;
}

function ___muldi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0;
 i5 = i1;
 i6 = i3;
 i3 = ___muldsi3(i5, i6) | 0;
 i1 = getTempRet0() | 0;
 return (setTempRet0((Math_imul(i2, i6) | 0) + (Math_imul(i4, i5) | 0) + i1 | i1 & 0 | 0), i3 | 0 | 0) | 0;
}

function _modem_modulate_psk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var d4 = 0.0, d5 = 0.0;
 d5 = +((_gray_decode(i2) | 0) << 1 >>> 0);
 d5 = +HEAPF32[i1 + 104 >> 2] * d5;
 d4 = +Math_sin(+d5);
 HEAPF32[i3 >> 2] = +Math_cos(+d5) + d4 * 0.0;
 HEAPF32[i3 + 4 >> 2] = d4;
 return;
}

function _liquid_bdotprod(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i2 = i2 & i1;
 return (HEAPU8[(i2 >>> 8 & 255) + (gb + 38755) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 38755) >> 0] | 0) + (HEAPU8[(i2 >>> 16 & 255) + (gb + 38755) >> 0] | 0) + (HEAPU8[(i2 >>> 24) + (gb + 38755) >> 0] | 0) & 1 | 0;
}

function _modulator_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 if (!i2) return;
 _nco_crcf_destroy(HEAP32[i2 + 24 >> 2] | 0);
 i1 = HEAP32[i2 + 28 >> 2] | 0;
 if (i1 | 0) _firinterp_crcf_destroy(i1);
 i1 = HEAP32[i2 + 32 >> 2] | 0;
 if (i1 | 0) _iirfilt_crcf_destroy(i1);
 _free(i2);
 return;
}

function _lex_unget(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i3 + 4 | 0;
 i4 = i3;
 HEAP32[i5 >> 2] = i2;
 HEAP32[i4 >> 2] = i1;
 _stream_unget(HEAP32[i5 >> 2] | 0, HEAP32[i4 >> 2] | 0);
 STACKTOP = i3;
 return;
}

function _nco_crcf_set_phase(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 i2 = i2 + 4 | 0;
 HEAPF32[i2 >> 2] = d1;
 if (d1 > 3.141592653589793) {
  HEAPF32[i2 >> 2] = d1 + -6.283185307179586;
  return;
 }
 if (!(d1 < -3.141592653589793)) return;
 HEAPF32[i2 >> 2] = d1 + 6.283185307179586;
 return;
}

function _jsonp_free(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i3;
 HEAP32[i1 >> 2] = i2;
 if (!(HEAP32[i1 >> 2] | 0)) {
  STACKTOP = i3;
  return;
 }
 mftCall_vi(HEAP32[gb + 8780 >> 2] | 0, HEAP32[i1 >> 2] | 0);
 STACKTOP = i3;
 return;
}

function _sincf(d2) {
 d2 = +d2;
 var d1 = 0.0;
 d1 = d2 * 3.141592653589793;
 if (+Math_abs(+d2) < .009999999776482582) {
  d2 = +Math_cos(+(d1 * .5)) * +Math_cos(+(d1 * .25)) * +Math_cos(+(d1 * .125));
  return +d2;
 } else {
  d2 = +Math_sin(+d1) / d1;
  return +d2;
 }
 return 0.0;
}

function _logbf(d1) {
 d1 = +d1;
 do if (((HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0) & 2139095040) >>> 0 < 2139095040) if (d1 == 0.0) {
  d1 = -1.0 / (d1 * d1);
  break;
 } else {
  d1 = +(_ilogbf(d1) | 0);
  break;
 } else d1 = d1 * d1; while (0);
 return +d1;
}

function _firdespm_run(i5, i6, i1, i3, i7, i8, i2, i4) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 i8 = _firdespm_create(i5, i6, i1, i3, i7, i8, i2) | 0;
 _firdespm_execute(i8, i4);
 _firdespm_destroy(i8);
 return;
}

function _modem_modulate_qpsk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = (i2 & 2 | 0) != 0;
 HEAPF32[i3 >> 2] = (i2 & 1 | 0 ? -.7071067811865476 : .7071067811865476) + (i1 ? -0.0 : 0.0);
 HEAPF32[i3 + 4 >> 2] = i1 ? -.7071067690849304 : .7071067690849304;
 return;
}

function _liquid_reverse_uint32(i1) {
 i1 = i1 | 0;
 return (HEAPU8[(i1 >>> 8 & 255) + (gb + 39011) >> 0] | 0) << 16 | (HEAPU8[(i1 & 255) + (gb + 39011) >> 0] | 0) << 24 | (HEAPU8[(i1 >>> 16 & 255) + (gb + 39011) >> 0] | 0) << 8 | (HEAPU8[(i1 >>> 24) + (gb + 39011) >> 0] | 0) | 0;
}

function mftCall_iiii(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 if ((i4 | 0) >= (fb | 0) & (i4 | 0) < (fb + 15 | 0)) return FUNCTION_TABLE_iiii[i4 - fb & 15](i1 | 0, i2 | 0, i3 | 0) | 0;
 return ftCall_iiii(i4 | 0, i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _msequence_advance(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i3 = i1 + 16 | 0;
 i2 = _liquid_bdotprod(HEAP32[i3 >> 2] | 0, HEAP32[i1 + 4 >> 2] | 0) | 0;
 HEAP32[i1 + 20 >> 2] = i2;
 HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] << 1 | i2) & HEAP32[i1 + 12 >> 2];
 return i2 | 0;
}

function _list_init(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] = HEAP32[i3 >> 2];
 HEAP32[HEAP32[i3 >> 2] >> 2] = HEAP32[i3 >> 2];
 STACKTOP = i2;
 return;
}

function _hashtable_close(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 _hashtable_do_clear(HEAP32[i3 >> 2] | 0);
 _jsonp_free(HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] | 0);
 STACKTOP = i2;
 return;
}

function mftCall_viii(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 if ((i4 | 0) >= (fb | 0) & (i4 | 0) < (fb + 31 | 0)) {
  FUNCTION_TABLE_viii[i4 - fb & 31](i1 | 0, i2 | 0, i3 | 0);
  return;
 }
 ftCall_viii(i4 | 0, i1 | 0, i2 | 0, i3 | 0);
}

function _wdelayf_push(i1, d2) {
 i1 = i1 | 0;
 d2 = +d2;
 var i3 = 0, i4 = 0;
 i3 = i1 + 8 | 0;
 i4 = HEAP32[i3 >> 2] | 0;
 HEAPF32[(HEAP32[i1 >> 2] | 0) + (i4 << 2) >> 2] = d2;
 HEAP32[i3 >> 2] = ((i4 + 1 | 0) >>> 0) % ((HEAP32[i1 + 4 >> 2] | 0) >>> 0) | 0;
 return;
}

function _json_delete_string(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 _jsonp_free(HEAP32[(HEAP32[i3 >> 2] | 0) + 8 >> 2] | 0);
 _jsonp_free(HEAP32[i3 >> 2] | 0);
 STACKTOP = i2;
 return;
}

function _nco_crcf_pll_set_bandwidth(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 if (d1 < 0.0) {
  _fwrite(gb + 38396 | 0, 59, 1, HEAP32[gb + 8808 >> 2] | 0) | 0;
  _exit(1);
 } else {
  HEAPF32[i2 + 1052 >> 2] = d1;
  HEAPF32[i2 + 1056 >> 2] = +Math_sqrt(+d1);
  return;
 }
}

function _strbuffer_clear(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 HEAP32[(HEAP32[i3 >> 2] | 0) + 4 >> 2] = 0;
 HEAP8[HEAP32[HEAP32[i3 >> 2] >> 2] >> 0] = 0;
 STACKTOP = i2;
 return;
}

function _snprintf(i3, i2, i1, i4) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i5;
 HEAP32[i6 >> 2] = i4;
 i4 = _vsnprintf(i3, i2, i1, i6) | 0;
 STACKTOP = i5;
 return i4 | 0;
}

function _fec_conv_punctured_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 20 >> 2] | 0;
 if (i1 | 0) mftCall_vi(HEAP32[i2 + 60 >> 2] | 0, i1 | 0);
 i1 = HEAP32[i2 + 16 >> 2] | 0;
 if (!i1) {
  _free(i2);
  return;
 }
 _free(i1);
 _free(i2);
 return;
}

function _json_delete_object(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 _hashtable_close((HEAP32[i3 >> 2] | 0) + 8 | 0);
 _jsonp_free(HEAP32[i3 >> 2] | 0);
 STACKTOP = i2;
 return;
}

function _fec_hamming128_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 6;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(6);
 HEAP32[i1 + 136 >> 2] = fb + 15;
 HEAP32[i1 + 140 >> 2] = fb + 16;
 HEAP32[i1 + 144 >> 2] = fb + 17;
 return i1 | 0;
}

function _bitshift64Ashr(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i1 | 0) < 32) {
  setTempRet0(i2 >> i1 | 0);
  return i3 >>> i1 | (i2 & (1 << i1) - 1) << 32 - i1;
 }
 setTempRet0(((i2 | 0) < 0 ? -1 : 0) | 0);
 return i2 >> i1 - 32 | 0;
}

function _fec_hamming84_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 5;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(5);
 HEAP32[i1 + 136 >> 2] = fb + 12;
 HEAP32[i1 + 140 >> 2] = fb + 13;
 HEAP32[i1 + 144 >> 2] = fb + 14;
 return i1 | 0;
}

function _fec_hamming74_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 4;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(4);
 HEAP32[i1 + 136 >> 2] = fb + 9;
 HEAP32[i1 + 140 >> 2] = fb + 10;
 HEAP32[i1 + 144 >> 2] = fb + 11;
 return i1 | 0;
}

function _close(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 i1 = ___syscall6(6, i3 | 0) | 0;
 i1 = ___syscall_ret((i1 | 0) == -4 ? -115 : i1) | 0;
 STACKTOP = i2;
 return i1 | 0;
}

function _fec_secded7264_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 10;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(10);
 HEAP32[i1 + 136 >> 2] = fb + 32;
 HEAP32[i1 + 140 >> 2] = fb + 33;
 HEAP32[i1 + 144 >> 2] = 0;
 return i1 | 0;
}

function _fec_conv_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 20 >> 2] | 0;
 if (i1 | 0) mftCall_vi(HEAP32[i2 + 60 >> 2] | 0, i1 | 0);
 i1 = HEAP32[i2 + 16 >> 2] | 0;
 if (!i1) {
  _free(i2);
  return;
 }
 _free(i1);
 _free(i2);
 return;
}

function _fec_secded3932_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 9;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(9);
 HEAP32[i1 + 136 >> 2] = fb + 30;
 HEAP32[i1 + 140 >> 2] = fb + 31;
 HEAP32[i1 + 144 >> 2] = 0;
 return i1 | 0;
}

function _fec_secded2216_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 8;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(8);
 HEAP32[i1 + 136 >> 2] = fb + 28;
 HEAP32[i1 + 140 >> 2] = fb + 29;
 HEAP32[i1 + 144 >> 2] = 0;
 return i1 | 0;
}

function _fec_rep5_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 3;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(3);
 HEAP32[i1 + 136 >> 2] = fb + 23;
 HEAP32[i1 + 140 >> 2] = fb + 24;
 HEAP32[i1 + 144 >> 2] = fb + 25;
 return i1 | 0;
}

function _fec_rep3_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 2;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(2);
 HEAP32[i1 + 136 >> 2] = fb + 20;
 HEAP32[i1 + 140 >> 2] = fb + 21;
 HEAP32[i1 + 144 >> 2] = fb + 22;
 return i1 | 0;
}

function _dotprod_rrrf_create(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0;
 i3 = _malloc(8) | 0;
 HEAP32[i3 + 4 >> 2] = i2;
 i2 = i2 << 2;
 i4 = _malloc(i2) | 0;
 HEAP32[i3 >> 2] = i4;
 _memcpy(i4 | 0, i1 | 0, i2 | 0) | 0;
 return i3 | 0;
}

function _dotprod_crcf_create(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0;
 i3 = _malloc(8) | 0;
 HEAP32[i3 + 4 >> 2] = i2;
 i2 = i2 << 2;
 i4 = _malloc(i2) | 0;
 HEAP32[i3 >> 2] = i4;
 _memcpy(i4 | 0, i1 | 0, i2 | 0) | 0;
 return i3 | 0;
}

function _dotprod_cccf_create(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0;
 i3 = _malloc(8) | 0;
 HEAP32[i3 + 4 >> 2] = i2;
 i2 = i2 << 3;
 i4 = _malloc(i2) | 0;
 HEAP32[i3 >> 2] = i4;
 _memcpy(i4 | 0, i1 | 0, i2 | 0) | 0;
 return i3 | 0;
}

function _wdelayf_create(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = _malloc(12) | 0;
 HEAP32[i2 + 4 >> 2] = i1;
 i1 = i1 << 2;
 i3 = _malloc(i1) | 0;
 HEAP32[i2 >> 2] = i3;
 HEAP32[i2 + 8 >> 2] = 0;
 _memset(i3 | 0, 0, i1 | 0) | 0;
 return i2 | 0;
}

function _fec_rs_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 96 >> 2] | 0;
 if (i1 | 0) _free_rs_char(i1 | 0);
 _free(HEAP32[i2 + 120 >> 2] | 0);
 _free(HEAP32[i2 + 124 >> 2] | 0);
 _free(HEAP32[i2 + 128 >> 2] | 0);
 _free(i2);
 return;
}

function ___FLOAT_BITS(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3 + 4 | 0;
 i2 = i3;
 HEAPF32[i4 >> 2] = d1;
 HEAPF32[i2 >> 2] = +HEAPF32[i4 >> 2];
 STACKTOP = i3;
 return HEAP32[i2 >> 2] | 0;
}

function _fec_golay2412_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 7;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(7);
 HEAP32[i1 + 136 >> 2] = fb + 7;
 HEAP32[i1 + 140 >> 2] = fb + 8;
 HEAP32[i1 + 144 >> 2] = 0;
 return i1 | 0;
}

function _gmskframegen_reset(i1) {
 i1 = i1 | 0;
 _gmskmod_reset(HEAP32[i1 >> 2] | 0);
 HEAP32[i1 + 84 >> 2] = 0;
 _msequence_reset(HEAP32[i1 + 32 >> 2] | 0);
 HEAP32[i1 + 88 >> 2] = 0;
 HEAP32[i1 + 92 >> 2] = 0;
 HEAP32[i1 + 96 >> 2] = 0;
 return;
}

function ___stdio_close(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = HEAP32[i1 + 60 >> 2];
 i1 = ___syscall_ret(___syscall6(6, i3 | 0) | 0) | 0;
 STACKTOP = i2;
 return i1 | 0;
}

function copyTempFloat(i1) {
 i1 = i1 | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[i1 >> 0];
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[i1 + 1 >> 0];
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[i1 + 2 >> 0];
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[i1 + 3 >> 0];
}

function _modem_modulate_ask(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i2 = (_gray_decode(i2) | 0) << 1;
 HEAPF32[i3 >> 2] = +HEAPF32[i1 + 100 >> 2] * +(1 - (HEAP32[i1 + 8 >> 2] | 0) + i2 | 0);
 HEAPF32[i3 + 4 >> 2] = 0.0;
 return;
}

function _fec_pass_create(i1) {
 i1 = i1 | 0;
 i1 = _malloc(148) | 0;
 HEAP32[i1 >> 2] = 1;
 HEAPF32[i1 + 4 >> 2] = +_fec_get_rate(1);
 HEAP32[i1 + 136 >> 2] = fb + 18;
 HEAP32[i1 + 140 >> 2] = fb + 19;
 HEAP32[i1 + 144 >> 2] = 0;
 return i1 | 0;
}

function _printf(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3;
 HEAP32[i4 >> 2] = i2;
 i2 = _vfprintf(HEAP32[gb + 8924 >> 2] | 0, i1, i4) | 0;
 STACKTOP = i3;
 return i2 | 0;
}

function _bitshift64Shl(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i1 | 0) < 32) {
  setTempRet0(i2 << i1 | (i3 & (1 << i1) - 1 << 32 - i1) >>> 32 - i1 | 0);
  return i3 << i1;
 }
 setTempRet0(i3 << i1 - 32 | 0);
 return 0;
}

function _gray_decode(i1) {
 i1 = i1 | 0;
 return i1 >>> 1 ^ i1 ^ i1 >>> 2 ^ i1 >>> 3 ^ i1 >>> 4 ^ i1 >>> 5 ^ i1 >>> 6 ^ i1 >>> 7 ^ i1 >>> 8 ^ i1 >>> 9 ^ i1 >>> 10 ^ i1 >>> 11 ^ i1 >>> 12 ^ i1 >>> 13 ^ i1 >>> 14 ^ i1 >>> 15 ^ i1 >>> 16 | 0;
}

function _sprintf(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4;
 HEAP32[i5 >> 2] = i3;
 i3 = _vsprintf(i2, i1, i5) | 0;
 STACKTOP = i4;
 return i3 | 0;
}

function _fprintf(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4;
 HEAP32[i5 >> 2] = i3;
 i3 = _vfprintf(i1, i2, i5) | 0;
 STACKTOP = i4;
 return i3 | 0;
}

function _fec_rep3_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 _memcpy(i3 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + i1 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 << 1) | 0, i2 | 0, i1 | 0) | 0;
 return;
}

function mftCall_iii(i3, i1, i2) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 if ((i3 | 0) >= (fb | 0) & (i3 | 0) < (fb + 7 | 0)) return FUNCTION_TABLE_iii[i3 - fb & 7](i1 | 0, i2 | 0) | 0;
 return ftCall_iii(i3 | 0, i1 | 0, i2 | 0) | 0;
}

function _fft_run(i3, i4, i5, i1, i2) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i5 = _fft_create_plan(i3, i4, i5, i1, i2) | 0;
 mftCall_vi(HEAP32[i5 + 28 >> 2] | 0, i5 | 0);
 _fft_destroy_plan(i5);
 return;
}

function _flexframesync_debug_enable(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = i2 + 208 | 0;
 if (HEAP32[i1 >> 2] | 0) return;
 HEAP32[i2 + 216 >> 2] = _windowcf_create(2e3) | 0;
 HEAP32[i2 + 204 >> 2] = 1;
 HEAP32[i1 >> 2] = 1;
 return;
}

function _bitshift64Lshr(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i1 | 0) < 32) {
  setTempRet0(i2 >>> i1 | 0);
  return i3 >>> i1 | (i2 & (1 << i1) - 1) << 32 - i1;
 }
 setTempRet0(0);
 return i2 >>> i1 - 32 | 0;
}

function _liquid_reverse_uint24(i1) {
 i1 = i1 | 0;
 return (HEAPU8[(i1 >>> 8 & 255) + (gb + 39011) >> 0] | 0) << 8 | (HEAPU8[(i1 & 255) + (gb + 39011) >> 0] | 0) << 16 | (HEAPU8[(i1 >>> 16 & 255) + (gb + 39011) >> 0] | 0) | 0;
}

function _qpacketmodem_destroy(i1) {
 i1 = i1 | 0;
 _packetizer_destroy(HEAP32[i1 + 4 >> 2] | 0);
 _modem_destroy(HEAP32[i1 >> 2] | 0);
 _free(HEAP32[i1 + 16 >> 2] | 0);
 _free(HEAP32[i1 + 20 >> 2] | 0);
 _free(i1);
 return;
}

function _demodulator_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 if (!i2) return;
 _nco_crcf_destroy(HEAP32[i2 + 16 >> 2] | 0);
 i1 = HEAP32[i2 + 20 >> 2] | 0;
 if (i1 | 0) _firdecim_crcf_destroy(i1);
 _free(i2);
 return;
}

function _qpilotsync_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 + 16 >> 2] | 0);
 _free(HEAP32[i1 + 24 >> 2] | 0);
 _free(HEAP32[i1 + 28 >> 2] | 0);
 _fft_destroy_plan(HEAP32[i1 + 32 >> 2] | 0);
 _free(i1);
 return;
}

function _modulator_reset(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 28 >> 2] | 0;
 if (i1 | 0) _firinterp_crcf_reset(i1);
 i1 = HEAP32[i2 + 32 >> 2] | 0;
 if (!i1) return;
 _iirfilt_crcf_reset(i1);
 return;
}

function _json_delete_integer(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 _jsonp_free(HEAP32[i3 >> 2] | 0);
 STACKTOP = i2;
 return;
}

function _json_delete_real(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i1;
 _jsonp_free(HEAP32[i3 >> 2] | 0);
 STACKTOP = i2;
 return;
}

function _flexframegen_reset(i1) {
 i1 = i1 | 0;
 i1 = i1 + 104 | 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 HEAP32[i1 + 16 >> 2] = 0;
 return;
}

function _strbuffer_value(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3;
 HEAP32[i2 >> 2] = i1;
 STACKTOP = i3;
 return HEAP32[HEAP32[i2 >> 2] >> 2] | 0;
}

function _nco_crcf_reset(i1) {
 i1 = i1 | 0;
 HEAPF32[i1 + 4 >> 2] = 0.0;
 HEAPF32[i1 + 8 >> 2] = 0.0;
 HEAP32[i1 + 1036 >> 2] = 0;
 HEAPF32[i1 + 1040 >> 2] = 0.0;
 HEAPF32[i1 + 1044 >> 2] = 1.0;
 return;
}

function _modem_recreate(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if ((HEAP32[i1 >> 2] | 0) == (i2 | 0)) {
  i2 = i1;
  return i2 | 0;
 }
 _modem_destroy(i1);
 i2 = _modem_create(i2) | 0;
 return i2 | 0;
}

function mftCall_ii(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i2 | 0) >= (fb | 0) & (i2 | 0) < (fb + 7 | 0)) return FUNCTION_TABLE_ii[i2 - fb & 7](i1 | 0) | 0;
 return ftCall_ii(i2 | 0, i1 | 0) | 0;
}

function _i64Subtract(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i4 = i2 - i4 - (i3 >>> 0 > i1 >>> 0 | 0) >>> 0;
 return (setTempRet0(i4 | 0), i1 - i3 >>> 0 | 0) | 0;
}

function _constrained_write(i3, i4, i2, i1) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i4 = i1 >>> 0 < i4 >>> 0 ? i1 : i4;
 _memmove(i2 | 0, i3 | 0, i4 << 2 | 0) | 0;
 return i4 | 0;
}

function mftCall_vi(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i2 | 0) >= (fb | 0) & (i2 | 0) < (fb + 31 | 0)) {
  FUNCTION_TABLE_vi[i2 - fb & 31](i1 | 0);
  return;
 }
 ftCall_vi(i2 | 0, i1 | 0);
}

function _firdecim_crcf_destroy(i1) {
 i1 = i1 | 0;
 _windowcf_destroy(HEAP32[i1 + 12 >> 2] | 0);
 _dotprod_crcf_destroy(HEAP32[i1 + 16 >> 2] | 0);
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function _nco_crcf_compute_sincos_vco(i1) {
 i1 = i1 | 0;
 var d2 = 0.0;
 d2 = +HEAPF32[i1 + 4 >> 2];
 HEAPF32[i1 + 1040 >> 2] = +Math_sin(+d2);
 HEAPF32[i1 + 1044 >> 2] = +Math_cos(+d2);
 return;
}

function _i64Add(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i3 = i1 + i3 >>> 0;
 return (setTempRet0(i2 + i4 + (i3 >>> 0 < i1 >>> 0 | 0) >>> 0 | 0), i3 | 0) | 0;
}

function _modulator_flush_sample_len(i1) {
 i1 = i1 | 0;
 if (!i1) {
  i1 = 0;
  return i1 | 0;
 }
 i1 = Math_imul(HEAP32[i1 >> 2] << 1, HEAP32[i1 + 4 >> 2] | 0) | 0;
 return i1 | 0;
}

function _liquid_firdes_rfarcsech(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 _liquid_firdes_fnyquist(6, 1, i4, i5, d1, 0.0, i3);
 return;
}

function _modulator_symbol_len(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if (!i1) {
  i2 = 0;
  return i2 | 0;
 }
 i2 = (i2 >>> 0) / ((HEAP32[i1 >> 2] | 0) >>> 0) | 0;
 return i2 | 0;
}

function _liquid_firdes_farcsech(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 _liquid_firdes_fnyquist(6, 0, i4, i5, d1, 0.0, i3);
 return;
}

function _chainback_viterbi615__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi615(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _liquid_firdes_rfsech(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 _liquid_firdes_fnyquist(5, 1, i4, i5, d1, 0.0, i3);
 return;
}

function _framedatastats_reset(i1) {
 i1 = i1 | 0;
 if (!i1) return;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 return;
}

function _fec_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 mftCall_viiii(HEAP32[i4 + 136 >> 2] | 0, i4 | 0, i1 | 0, i2 | 0, i3 | 0);
 return;
}

function _fec_decode(i4, i1, i3, i2) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 mftCall_viiii(HEAP32[i4 + 140 >> 2] | 0, i4 | 0, i1 | 0, i3 | 0, i2 | 0);
 return;
}

function _chainback_viterbi39__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi39(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _chainback_viterbi29__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi29(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _chainback_viterbi27__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi27(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _modem_modulate_ook(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 HEAPF32[i3 >> 2] = i2 | 0 ? 0.0 : 1.4142135381698608;
 HEAPF32[i3 + 4 >> 2] = 0.0;
 return;
}

function _liquid_firdes_rfexp(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 _liquid_firdes_fnyquist(4, 1, i4, i5, d1, 0.0, i3);
 return;
}

function _liquid_firdes_fsech(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 _liquid_firdes_fnyquist(5, 0, i4, i5, d1, 0.0, i3);
 return;
}

function _liquid_firdes_fexp(i4, i5, d1, d2, i3) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 d1 = +d1;
 d2 = +d2;
 i3 = i3 | 0;
 _liquid_firdes_fnyquist(4, 0, i4, i5, d1, 0.0, i3);
 return;
}

function _strtoll(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = _strtox_519(i3, i2, i1, 0, -2147483648) | 0;
 setTempRet0(getTempRet0() | 0);
 return i3 | 0;
}

function _conj(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var d3 = 0.0;
 d3 = -+HEAPF64[i2 + 8 >> 3];
 HEAPF64[i1 >> 3] = +HEAPF64[i2 >> 3];
 HEAPF64[i1 + 8 >> 3] = d3;
 return;
}

function _modulator_sample_len(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if (!i1) {
  i2 = 0;
  return i2 | 0;
 }
 i2 = Math_imul(HEAP32[i1 >> 2] | 0, i2) | 0;
 return i2 | 0;
}

function ___errno_location() {
 var i1 = 0;
 if (!(HEAP32[gb + 44304 >> 2] | 0)) i1 = gb + 44348 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
 return i1 | 0;
}

function _conjf(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var d3 = 0.0;
 d3 = -+HEAPF32[i2 + 4 >> 2];
 HEAP32[i1 >> 2] = HEAP32[i2 >> 2];
 HEAPF32[i1 + 4 >> 2] = d3;
 return;
}

function _div(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 HEAP32[i1 >> 2] = (i3 | 0) / (i2 | 0) | 0;
 HEAP32[i1 + 4 >> 2] = (i3 | 0) % (i2 | 0) | 0;
 return;
}

function _liquid_reverse_uint16(i1) {
 i1 = i1 | 0;
 return (HEAPU8[(i1 & 255) + (gb + 39011) >> 0] | 0) << 8 | (HEAPU8[(i1 >>> 8 & 255) + (gb + 39011) >> 0] | 0) | 0;
}

function _modem_modulate_bpsk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 HEAPF32[i3 >> 2] = i2 | 0 ? -1.0 : 1.0;
 HEAPF32[i3 + 4 >> 2] = 0.0;
 return;
}

function _iirfilt_crcf_create_lowpass(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 return _iirfilt_crcf_create_prototype(0, 0, 0, i2, d1, 0.0, .10000000149011612, 60.0) | 0;
}

function b0(i1, i2, i3, i4, i5, i6, i7) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 abort(0);
 return 0;
}

function _ofdmflexframesync_execute(i2, i3, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 _ofdmframesync_execute(HEAP32[i2 + 184 >> 2] | 0, i3, i1);
 return;
}

function _strchr(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i2 = ___strchrnul(i2, i1) | 0;
 return ((HEAP8[i2 >> 0] | 0) == (i1 & 255) << 24 >> 24 ? i2 : 0) | 0;
}

function _update_viterbi615_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi615_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _hamming(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 return +(.53836 - +Math_cos(+(+(i2 >>> 0) * 6.283185307179586 / +((i1 + -1 | 0) >>> 0))) * .46164);
}

function _getpid() {
 var i1 = 0, i2 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = ___syscall20(20, i2 | 0) | 0;
 STACKTOP = i2;
 return i1 | 0;
}

function _update_viterbi39_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi39_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _update_viterbi29_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi29_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _update_viterbi27_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi27_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function ___syscall_ret(i1) {
 i1 = i1 | 0;
 if (i1 >>> 0 > 4294963200) {
  HEAP32[(___errno_location() | 0) >> 2] = 0 - i1;
  i1 = -1;
 }
 return i1 | 0;
}

function _wdelayf_read(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 HEAP32[i2 >> 2] = HEAP32[(HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 8 >> 2] << 2) >> 2];
 return;
}

function _gmskmod_destroy(i1) {
 i1 = i1 | 0;
 _firinterp_rrrf_destroy(HEAP32[i1 + 20 >> 2] | 0);
 _free(HEAP32[i1 + 16 >> 2] | 0);
 _free(i1);
 return;
}

function ___expo2f(d1) {
 d1 = +d1;
 return +(+Math_exp(+(d1 + -162.88958740234375)) * 1661534994731144841129758.0e11 * 1661534994731144841129758.0e11);
}

function _windowcf_clear(i1) {
 i1 = i1 | 0;
 HEAP32[i1 + 24 >> 2] = 0;
 _memset(HEAP32[i1 >> 2] | 0, 0, HEAP32[i1 + 20 >> 2] << 3 | 0) | 0;
 return;
}

function _windowf_clear(i1) {
 i1 = i1 | 0;
 HEAP32[i1 + 24 >> 2] = 0;
 _memset(HEAP32[i1 >> 2] | 0, 0, HEAP32[i1 + 20 >> 2] << 2 | 0) | 0;
 return;
}

function _demodulator_flush_symbol_len(i1) {
 i1 = i1 | 0;
 if (!i1) {
  i1 = 0;
  return i1 | 0;
 }
 i1 = HEAP32[i1 + 4 >> 2] << 1;
 return i1 | 0;
}
function stackAlloc(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + i1 | 0;
 STACKTOP = STACKTOP + 15 & -16;
 return i2 | 0;
}

function _fec_pass_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 _memmove(i3 | 0, i2 | 0, i1 | 0) | 0;
 return;
}

function _fec_pass_decode(i4, i1, i3, i2) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 _memmove(i2 | 0, i3 | 0, i1 | 0) | 0;
 return;
}

function _wdelayf_clear(i1) {
 i1 = i1 | 0;
 HEAP32[i1 + 8 >> 2] = 0;
 _memset(HEAP32[i1 >> 2] | 0, 0, HEAP32[i1 + 4 >> 2] << 2 | 0) | 0;
 return;
}

function _ofdmflexframesync_debug_print(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 _ofdmframesync_debug_print(HEAP32[i2 + 184 >> 2] | 0, i1);
 return;
}

function _modem_gen_rand_sym(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = _rand() | 0;
 return (i2 >>> 0) % ((HEAP32[i1 + 8 >> 2] | 0) >>> 0) | 0 | 0;
}

function _windowcf_read(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 HEAP32[i2 >> 2] = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 3);
 return;
}

function _windowf_read(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 HEAP32[i2 >> 2] = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 2);
 return;
}

function _nco_crcf_adjust_frequency(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 i2 = i2 + 8 | 0;
 HEAPF32[i2 >> 2] = +HEAPF32[i2 >> 2] + d1;
 return;
}

function ___udivdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return ___udivmoddi4(i1, i2, i3, i4, 0) | 0;
}

function _gmskmod_reset(i1) {
 i1 = i1 | 0;
 HEAPF32[i1 + 24 >> 2] = 0.0;
 _firinterp_rrrf_reset(HEAP32[i1 + 20 >> 2] | 0);
 return;
}

function _ofdmflexframegen_getframelen(i1) {
 i1 = i1 | 0;
 return (HEAP32[i1 + 44 >> 2] | 0) + 3 + (HEAP32[i1 + 48 >> 2] | 0) | 0;
}

function _firinterp_crcf_reset(i1) {
 i1 = i1 | 0;
 _windowcf_clear(HEAP32[(HEAP32[i1 + 16 >> 2] | 0) + 16 >> 2] | 0);
 return;
}

function _ofdmflexframesync_debug_enable(i1) {
 i1 = i1 | 0;
 _ofdmframesync_debug_enable(HEAP32[i1 + 184 >> 2] | 0);
 return;
}

function _firinterp_rrrf_reset(i1) {
 i1 = i1 | 0;
 _windowf_clear(HEAP32[(HEAP32[i1 + 16 >> 2] | 0) + 16 >> 2] | 0);
 return;
}

function _wctomb(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if (!i1) i1 = 0; else i1 = _wcrtomb(i1, i2, 0) | 0;
 return i1 | 0;
}

function _vsprintf(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 return _vsnprintf(i3, 2147483647, i2, i1) | 0;
}

function _strncpy(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 ___stpncpy(i1, i3, i2) | 0;
 return i1 | 0;
}

function _init_viterbi615__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi615(i1 | 0, i2 | 0) | 0;
}

function _init_viterbi39__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi39(i1 | 0, i2 | 0) | 0;
}

function _init_viterbi29__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi29(i1 | 0, i2 | 0) | 0;
}

function _init_viterbi27__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi27(i1 | 0, i2 | 0) | 0;
}

function _firpfb_rrrf_push(i1, d2) {
 i1 = i1 | 0;
 d2 = +d2;
 _windowf_push(HEAP32[i1 + 16 >> 2] | 0, d2);
 return;
}

function _ofdmframesync_get_cfo(i1) {
 i1 = i1 | 0;
 return +(+_nco_crcf_get_frequency(HEAP32[i1 + 108 >> 2] | 0));
}

function setThrew(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if (!__THREW__) {
  __THREW__ = i1;
  threwValue = i2;
 }
}

function _fputs(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 return (_fwrite(i2, _strlen(i2) | 0, 1, i1) | 0) + -1 | 0;
}

function _qpacketmodem_get_fec1(i1) {
 i1 = i1 | 0;
 return _packetizer_get_fec1(HEAP32[i1 + 4 >> 2] | 0) | 0;
}

function _qpacketmodem_get_fec0(i1) {
 i1 = i1 | 0;
 return _packetizer_get_fec0(HEAP32[i1 + 4 >> 2] | 0) | 0;
}

function _framesyncstats_init_default(i1) {
 i1 = i1 | 0;
 _memmove(i1 | 0, gb + 44260 | 0, 40) | 0;
 return;
}

function _qpacketmodem_get_modscheme(i1) {
 i1 = i1 | 0;
 return _modem_get_scheme(HEAP32[i1 >> 2] | 0) | 0;
}

function _qpacketmodem_get_crc(i1) {
 i1 = i1 | 0;
 return _packetizer_get_crc(HEAP32[i1 + 4 >> 2] | 0) | 0;
}

function b5(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 abort(5);
 return 0;
}

function _packetizer_get_fec1(i1) {
 i1 = i1 | 0;
 return HEAP32[(HEAP32[i1 + 16 >> 2] | 0) + 28 >> 2] | 0;
}

function _cargf(i1) {
 i1 = i1 | 0;
 return +(+Math_atan2(+(+HEAPF32[i1 + 4 >> 2]), +(+HEAPF32[i1 >> 2])));
}

function _packetizer_get_fec0(i1) {
 i1 = i1 | 0;
 return HEAP32[(HEAP32[i1 + 16 >> 2] | 0) + 8 >> 2] | 0;
}

function _interleaver_set_depth(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 HEAP32[i2 + 12 >> 2] = i1;
 return;
}

function _ofdmframesync_get_rssi(i1) {
 i1 = i1 | 0;
 return +(+_log10(+HEAPF32[i1 + 80 >> 2]) * -10.0);
}

function _nco_crcf_set_frequency(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 HEAPF32[i2 + 8 >> 2] = d1;
 return;
}

function _firpfb_crcf_set_scale(i1, d2) {
 i1 = i1 | 0;
 d2 = +d2;
 HEAPF32[i1 + 24 >> 2] = d2;
 return;
}

function _cleanup_387(i1) {
 i1 = i1 | 0;
 if (!(HEAP32[i1 + 68 >> 2] | 0)) ___unlockfile(i1);
 return;
}

function _cleanup_382(i1) {
 i1 = i1 | 0;
 if (!(HEAP32[i1 + 68 >> 2] | 0)) ___unlockfile(i1);
 return;
}

function _qpilotgen_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 + 16 >> 2] | 0);
 _free(i1);
 return;
}

function _firpfb_crcf_reset(i1) {
 i1 = i1 | 0;
 _windowcf_clear(HEAP32[i1 + 16 >> 2] | 0);
 return;
}

function _dotprod_rrrf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function _dotprod_crcf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function _dotprod_cccf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function establishStackSpace(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 STACKTOP = i1;
 STACK_MAX = i2;
}

function _msequence_reset(i1) {
 i1 = i1 | 0;
 HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
 return;
}

function _firpfb_rrrf_reset(i1) {
 i1 = i1 | 0;
 _windowf_clear(HEAP32[i1 + 16 >> 2] | 0);
 return;
}

function _cabsf(i1) {
 i1 = i1 | 0;
 return +(+_hypotf(+HEAPF32[i1 >> 2], +HEAPF32[i1 + 4 >> 2]));
}

function _unscramble_data(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 _scramble_data(i2, i1);
 return;
}

function _roundf(d1) {
 d1 = +d1;
 return d1 >= 0.0 ? +Math_floor(d1 + .5) : +Math_ceil(d1 - .5);
}

function _isspace(i1) {
 i1 = i1 | 0;
 return ((i1 | 0) == 32 | (i1 + -9 | 0) >>> 0 < 5) & 1 | 0;
}

function _fft_execute(i1) {
 i1 = i1 | 0;
 mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
 return;
}

function b7(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 abort(7);
}

function _windowcf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function _create_viterbi615__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi615(i1 | 0) | 0;
}

function _windowf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function _wdelayf_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 >> 2] | 0);
 _free(i1);
 return;
}

function _ofdmflexframegen_is_assembled(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 124 >> 2] | 0;
}

function _create_viterbi39__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi39(i1 | 0) | 0;
}

function _create_viterbi29__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi29(i1 | 0) | 0;
}

function _create_viterbi27__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi27(i1 | 0) | 0;
}

function _quiet_decoder_checksum_fails(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 108 >> 2] | 0;
}

function _liquid_Qf(d1) {
 d1 = +d1;
 return +((1.0 - +_erff(d1 * .7071067811865476)) * .5);
}

function _qpacketmodem_get_frame_len(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 32 >> 2] | 0;
}

function _qdetector_cccf_get_buf_len(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 32 >> 2] | 0;
}

function _flexframegen_is_assembled(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 112 >> 2] | 0;
}

function b1(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 abort(1);
 return 0;
}

function _qdetector_cccf_get_gamma(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 76 >> 2]);
}

function _packetizer_get_enc_msg_len(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 4 >> 2] | 0;
}

function _gmskframegen_is_assembled(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 88 >> 2] | 0;
}

function _qpilotsync_get_frame_len(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 12 >> 2] | 0;
}

function _qdetector_cccf_get_dphi(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 80 >> 2]);
}

function _liquid_modem_is_apsk(i1) {
 i1 = i1 | 0;
 return (i1 + -40 | 0) >>> 0 < 7 | 0;
}

function _qpilotgen_get_frame_len(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 12 >> 2] | 0;
}

function _qdetector_cccf_get_tau(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 72 >> 2]);
}

function _qdetector_cccf_get_phi(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 84 >> 2]);
}

function _liquid_modem_is_dpsk(i1) {
 i1 = i1 | 0;
 return (i1 + -9 | 0) >>> 0 < 8 | 0;
}

function _strtod(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 return +(+_strtox(i2, i1, 1));
}

function _nco_crcf_get_frequency(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 8 >> 2]);
}

function _delete_viterbi615__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi615(i1 | 0);
}

function _qpilotsync_get_dphi(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 36 >> 2]);
}

function _qpilotsync_get_phi(i1) {
 i1 = i1 | 0;
 return +(+HEAPF32[i1 + 40 >> 2]);
}

function _delete_viterbi39__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi39(i1 | 0);
}

function _delete_viterbi29__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi29(i1 | 0);
}

function _delete_viterbi27__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi27(i1 | 0);
}

function _copysignl(d1, d2) {
 d1 = +d1;
 d2 = +d2;
 return +(+_copysign(d1, d2));
}

function _scalbnl(d2, i1) {
 d2 = +d2;
 i1 = i1 | 0;
 return +(+_scalbn(d2, i1));
}

function _packetizer_get_crc(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 8 >> 2] | 0;
}

function _frexpl(d2, i1) {
 d2 = +d2;
 i1 = i1 | 0;
 return +(+_frexp(d2, i1));
}

function b4(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 abort(4);
}

function _modem_get_bps(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 4 >> 2] | 0;
}

function _modem_get_scheme(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 >> 2] | 0;
}

function _fmodl(d1, d2) {
 d1 = +d1;
 d2 = +d2;
 return +(+_fmod(d1, d2));
}

function _fec_secded7264_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_secded3932_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_secded2216_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_hamming128_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_hamming84_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_hamming74_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_golay2412_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function b6(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 abort(6);
 return 0;
}

function _interleaver_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _msequence_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _gray_encode(i1) {
 i1 = i1 | 0;
 return i1 >>> 1 ^ i1 | 0;
}

function _nco_crcf_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_rep5_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_rep3_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _fec_pass_destroy(i1) {
 i1 = i1 | 0;
 _free(i1);
 return;
}

function _qdetector_cccf_reset(i1) {
 i1 = i1 | 0;
 return;
}

function stackRestore(i1) {
 i1 = i1 | 0;
 STACKTOP = i1;
}

function b3(i1) {
 i1 = i1 | 0;
 abort(3);
 return 0;
}

function ___unlockfile(i1) {
 i1 = i1 | 0;
 return;
}

function ___lockfile(i1) {
 i1 = i1 | 0;
 return 0;
}

function _localeconv() {
 return gb + 9188 | 0;
}

function _json_false() {
 return gb + 8792 | 0;
}

function _json_true() {
 return gb + 8784 | 0;
}

function _json_null() {
 return gb + 8800 | 0;
}

function stackSave() {
 return STACKTOP | 0;
}

function b2(i1) {
 i1 = i1 | 0;
 abort(2);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_iiiiiiii = [b0,_decoder_on_decode];
var FUNCTION_TABLE_iiii = [b1,___stdio_write,___stdio_seek,___stdout_write,_sn_write,_update_viterbi27_blk__wrapper,_update_viterbi29_blk__wrapper,_update_viterbi39_blk__wrapper,_update_viterbi615_blk__wrapper,___stdio_read,b1,b1,b1,b1,b1,b1];
var FUNCTION_TABLE_vi = [b2,_free,_delete_viterbi27__wrapper,_delete_viterbi29__wrapper,_delete_viterbi39__wrapper,_delete_viterbi615__wrapper,_nco_crcf_compute_sincos_nco,_nco_crcf_compute_sincos_vco,_fft_execute_radix2,_fft_execute_mixed_radix,_fft_execute_rader,_fft_execute_rader2,_fft_execute_dft_2,_fft_execute_dft_3,_fft_execute_dft_4,_fft_execute_dft_5,_fft_execute_dft_6,_fft_execute_dft_7,_fft_execute_dft_8,_fft_execute_dft_16,_fft_execute_dft,_cleanup_387,_cleanup_382,b2,b2,b2,b2,b2,b2
,b2,b2,b2];
var FUNCTION_TABLE_ii = [b3,_malloc,___stdio_close,_create_viterbi27__wrapper,_create_viterbi29__wrapper,_create_viterbi39__wrapper,_create_viterbi615__wrapper,_string_get];
var FUNCTION_TABLE_viii = [b4,_modem_modulate_dpsk,_modem_demodulate_dpsk,_modem_modulate_ask,_modem_demodulate_ask,_modem_modulate_bpsk,_modem_demodulate_bpsk,_modem_modulate_qpsk,_modem_demodulate_qpsk,_modem_modulate_ook,_modem_demodulate_ook,_modem_modulate_sqam32,_modem_demodulate_sqam32,_modem_modulate_sqam128,_modem_demodulate_sqam128,_modem_modulate_arb,_modem_demodulate_arb,_modem_modulate_psk,_modem_demodulate_psk,_modem_modulate_qam,_modem_demodulate_qam,_modem_modulate_apsk,_modem_demodulate_apsk,b4,b4,b4,b4,b4,b4
,b4,b4,b4];
var FUNCTION_TABLE_iiiii = [b5,_chainback_viterbi27__wrapper,_chainback_viterbi29__wrapper,_chainback_viterbi39__wrapper,_chainback_viterbi615__wrapper,_ofdmflexframesync_internal_callback,b5,b5];
var FUNCTION_TABLE_iii = [b6,_init_viterbi27__wrapper,_init_viterbi29__wrapper,_init_viterbi39__wrapper,_init_viterbi615__wrapper,b6,b6,b6];
var FUNCTION_TABLE_viiii = [b7,_fec_conv_encode,_fec_conv_decode_hard,_fec_conv_decode_soft,_fec_conv_punctured_encode,_fec_conv_punctured_decode_hard,_fec_conv_punctured_decode_soft,_fec_golay2412_encode,_fec_golay2412_decode,_fec_hamming74_encode,_fec_hamming74_decode,_fec_hamming74_decode_soft,_fec_hamming84_encode,_fec_hamming84_decode,_fec_hamming84_decode_soft,_fec_hamming128_encode,_fec_hamming128_decode,_fec_hamming128_decode_soft,_fec_pass_encode,_fec_pass_decode,_fec_rep3_encode,_fec_rep3_decode,_fec_rep3_decode_soft,_fec_rep5_encode,_fec_rep5_decode,_fec_rep5_decode_soft,_fec_rs_encode,_fec_rs_decode,_fec_secded2216_encode
,_fec_secded2216_decode,_fec_secded3932_encode,_fec_secded3932_decode,_fec_secded7264_encode,_fec_secded7264_decode,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7];

  return { _fec_hamming84_decode_soft: _fec_hamming84_decode_soft, _fec_hamming84_destroy: _fec_hamming84_destroy, _nco_crcf_set_frequency: _nco_crcf_set_frequency, _crc_generate_key: _crc_generate_key, _memchr: _memchr, _flexframegen_write_samples: _flexframegen_write_samples, _strbuffer_append_byte: _strbuffer_append_byte, _ellip_acdf: _ellip_acdf, _liquid_cacosf: _liquid_cacosf, _fec_secded7264_encode: _fec_secded7264_encode, _fft_create_plan_rader: _fft_create_plan_rader, _fec_get_enc_msg_length: _fec_get_enc_msg_length, _jsonp_stringn_nocheck_own: _jsonp_stringn_nocheck_own, _fec_hamming84_encode: _fec_hamming84_encode, _ilogb: _ilogb, _firpfb_rrrf_create_drnyquist: _firpfb_rrrf_create_drnyquist, _wdelayf_read: _wdelayf_read, _nco_crcf_mix_down: _nco_crcf_mix_down, _decoder_profile: _decoder_profile, _ofdmframegen_write_S0b: _ofdmframegen_write_S0b, _ofdmframegen_write_S0a: _ofdmframegen_write_S0a, _iirfilt_crcf_reset: _iirfilt_crcf_reset, _fec_block_get_enc_msg_len: _fec_block_get_enc_msg_len, _vsprintf: _vsprintf, _modem_modulate_psk: _modem_modulate_psk, _puts: _puts, _liquid_firdes_prototype: _liquid_firdes_prototype, _liquid_reverse_uint24: _liquid_reverse_uint24, _liquid_firdes_fnyquist: _liquid_firdes_fnyquist, _dotprod_cccf_execute: _dotprod_cccf_execute, _wctomb: _wctomb, _qdetector_cccf_get_phi: _qdetector_cccf_get_phi, _gmskframesync_update_symsync: _gmskframesync_update_symsync, _flexframegen_reconfigure: _flexframegen_reconfigure, stackSave: stackSave, _iirfilt_crcf_destroy: _iirfilt_crcf_destroy, _jsonp_free: _jsonp_free, _modulator_symbol_len: _modulator_symbol_len, _pad: _pad, _modem_modulate_qam: _modem_modulate_qam, _iirfilt_crcf_create_dc_blocker: _iirfilt_crcf_create_dc_blocker, _ofdmframe_validate_sctype: _ofdmframe_validate_sctype, _nco_crcf_compute_sincos_nco: _nco_crcf_compute_sincos_nco, _json_array_append: _json_array_append, _qdetector_cccf_execute_seek: _qdetector_cccf_execute_seek, _ccosf: _ccosf, _ellip_cdf: _ellip_cdf, _nco_crcf_reset: _nco_crcf_reset, _quiet_decoder_checksum_fails: _quiet_decoder_checksum_fails, _ofdmflexframesync_execute: _ofdmflexframesync_execute, _resamp_rrrf_destroy: _resamp_rrrf_destroy, _fec_secded7264_compute_syndrome: _fec_secded7264_compute_syndrome, _firinterp_crcf_execute: _firinterp_crcf_execute, _fft_execute_rader2: _fft_execute_rader2, _modem_modulate_ask: _modem_modulate_ask, setThrew: setThrew, _liquid_firdes_fexp_freqresponse: _liquid_firdes_fexp_freqresponse, _fec_rs_setlength: _fec_rs_setlength, _liquid_firdes_rfsech: _liquid_firdes_rfsech, _qdetector_cccf_get_buf_len: _qdetector_cccf_get_buf_len, ___towrite: ___towrite, _ofdmflexframegen_create: _ofdmflexframegen_create, _firinterp_crcf_create_kaiser: _firinterp_crcf_create_kaiser, _liquid_nextpow2: _liquid_nextpow2, _json_object_set_new_nocheck: _json_object_set_new_nocheck, _liquid_firdes_fsech_freqresponse: _liquid_firdes_fsech_freqresponse, _modem_demodulate_dpsk: _modem_demodulate_dpsk, _packetizer_destroy: _packetizer_destroy, _qpilotsync_get_dphi: _qpilotsync_get_dphi, _packetizer_recreate: _packetizer_recreate, _packetizer_get_enc_msg_len: _packetizer_get_enc_msg_len, ___strchrnul: ___strchrnul, _flexframegen_getframelen: _flexframegen_getframelen, _modem_demodulate_apsk: _modem_demodulate_apsk, _windowcf_create: _windowcf_create, _flexframesync_execute_rxpreamble: _flexframesync_execute_rxpreamble, _ofdmflexframegen_destroy: _ofdmflexframegen_destroy, _fft_create_plan: _fft_create_plan, _encoder_profile: _encoder_profile, _localeconv: _localeconv, _matrixf_trans: _matrixf_trans, _firinterp_crcf_create: _firinterp_crcf_create, _modem_demodulate: _modem_demodulate, _flexframegen_generate_symbol: _flexframegen_generate_symbol, _fec_rep5_destroy: _fec_rep5_destroy, _modem_recreate: _modem_recreate, _flexframegen_create: _flexframegen_create, _json_delete_object: _json_delete_object, _json_false: _json_false, _liquid_csqrtf: _liquid_csqrtf, _json_object_get: _json_object_get, _liquid_msb_index: _liquid_msb_index, _crc_validate_message: _crc_validate_message, _hashtable_do_clear: _hashtable_do_clear, _liquid_cplxpair_cleanup: _liquid_cplxpair_cleanup, _conjf: _conjf, _fft_execute_dft_7: _fft_execute_dft_7, _nco_crcf_destroy: _nco_crcf_destroy, _gmskframegen_destroy: _gmskframegen_destroy, _gmskframegen_getframelen: _gmskframegen_getframelen, _fec_rep3_decode: _fec_rep3_decode, _iirdes_dzpk2sosf: _iirdes_dzpk2sosf, _list_insert: _list_insert, _fec_golay2412_decode: _fec_golay2412_decode, _quiet_decoder_recv: _quiet_decoder_recv, _gmskframegen_create: _gmskframegen_create, _strtoll: _strtoll, _fec_secded7264_decode: _fec_secded7264_decode, ___uflow: ___uflow, _fec_secded2216_decode: _fec_secded2216_decode, _liquid_Qf: _liquid_Qf, _demodulator_recv: _demodulator_recv, _matrixf_hermitian: _matrixf_hermitian, _stream_get: _stream_get, _json_number_value: _json_number_value, _fec_hamming128_decode_symbol: _fec_hamming128_decode_symbol, _modem_demodulate_arb: _modem_demodulate_arb, ___stdio_seek: ___stdio_seek, _conj: _conj, _scramble_data: _scramble_data, _msequence_reset: _msequence_reset, _quiet_encoder_profile_str: _quiet_encoder_profile_str, _pop_arg: _pop_arg, _json_array_append_new: _json_array_append_new, _buf_to_uint32: _buf_to_uint32, _lex_close: _lex_close, _malloc: _malloc, _generate_seed: _generate_seed, _firinterp_crcf_reset: _firinterp_crcf_reset, _fopen: _fopen, _msequence_destroy: _msequence_destroy, ___mulsc3: ___mulsc3, _ofdmflexframesync_debug_print: _ofdmflexframesync_debug_print, _dotprod_cccf_create: _dotprod_cccf_create, _ofdmframesync_reset: _ofdmframesync_reset, _fft_create_plan_rader2: _fft_create_plan_rader2, _ofdmframesync_estimate_gain_S1: _ofdmframesync_estimate_gain_S1, _ofdmframesync_estimate_gain_S0: _ofdmframesync_estimate_gain_S0, _unscramble_data: _unscramble_data, _liquid_reverse_uint16: _liquid_reverse_uint16, _sinhf: _sinhf, _fec_secded7264_compute_parity: _fec_secded7264_compute_parity, _json_decref_1945: _json_decref_1945, _gmskmod_modulate: _gmskmod_modulate, _gmskframesync_execute_rxpreamble: _gmskframesync_execute_rxpreamble, _ofdmframesync_rxsymbol: _ofdmframesync_rxsymbol, _fec_conv_init_v29: _fec_conv_init_v29, _fec_secded3932_estimate_ehat: _fec_secded3932_estimate_ehat, _erfc2_142: _erfc2_142, _fec_conv_punctured_create: _fec_conv_punctured_create, _modem_demodulate_sqam128: _modem_demodulate_sqam128, _fec_pass_create: _fec_pass_create, _dispose_chunk: _dispose_chunk, _interleaver_decode: _interleaver_decode, _strtox_519: _strtox_519, ___lockfile: ___lockfile, _log10: _log10, _fec_conv_decode_hard: _fec_conv_decode_hard, _detector_cccf_destroy: _detector_cccf_destroy, _cexpf: _cexpf, _modem_get_demodulator_evm: _modem_get_demodulator_evm, _modem_demodulate_sqam32: _modem_demodulate_sqam32, _json_array: _json_array, _firdespm_init_grid: _firdespm_init_grid, _modem_gen_rand_sym: _modem_gen_rand_sym, _liquid_filter_isi: _liquid_filter_isi, _demodulator_flush: _demodulator_flush, stackRestore: stackRestore, _gmskmod_destroy: _gmskmod_destroy, _firpfb_crcf_execute: _firpfb_crcf_execute, _liquid_firdes_fsech: _liquid_firdes_fsech, _crc_get_length: _crc_get_length, _qpacketmodem_destroy: _qpacketmodem_destroy, _qdetector_cccf_create: _qdetector_cccf_create, _lex_scan_string: _lex_scan_string, _ofdmflexframesync_rxheader: _ofdmflexframesync_rxheader, _fpoly_bessel_roots_orchard_recursion: _fpoly_bessel_roots_orchard_recursion, _wcrtomb: _wcrtomb, _modulator_create: _modulator_create, ___stdio_close: ___stdio_close, _fft_create_plan_mixed_radix: _fft_create_plan_mixed_radix, _butter_azpkf: _butter_azpkf, _hashlittle: _hashlittle, _ofdmframegen_writesymbol: _ofdmframegen_writesymbol, _modem_modulate_dpsk: _modem_modulate_dpsk, _modem_modulate_sqam128: _modem_modulate_sqam128, _ofdmframesync_execute_S1: _ofdmframesync_execute_S1, ___muldc3: ___muldc3, _modem_modulate_ook: _modem_modulate_ook, _liquid_firdes_gmsktx: _liquid_firdes_gmsktx, _quiet_decoder_destroy: _quiet_decoder_destroy, _hashtable_set: _hashtable_set, _cleanup_382: _cleanup_382, _qdetector_cccf_execute: _qdetector_cccf_execute, _cleanup_387: _cleanup_387, _firdespm_destroy: _firdespm_destroy, _fec_pass_destroy: _fec_pass_destroy, ___divdc3: ___divdc3, _json_integer: _json_integer, _liquid_getopt_str2mod: _liquid_getopt_str2mod, _ofdmframe_init_default_sctype: _ofdmframe_init_default_sctype, _nco_crcf_adjust_frequency: _nco_crcf_adjust_frequency, _liquid_firdes_rkaiser_quadratic: _liquid_firdes_rkaiser_quadratic, _ofdmflexframesync_decode_header: _ofdmflexframesync_decode_header, _windowf_create: _windowf_create, _flexframesync_execute_rxheader: _flexframesync_execute_rxheader, _ofdmframesync_get_rssi: _ofdmframesync_get_rssi, _quiet_decoder_readbuf: _quiet_decoder_readbuf, _interleaver_encode: _interleaver_encode, _nco_crcf_set_phase: _nco_crcf_set_phase, _ofdmframesync_destroy: _ofdmframesync_destroy, _gmskframegen_write_samples: _gmskframegen_write_samples, _ofdmframegen_destroy: _ofdmframegen_destroy, _lex_save: _lex_save, ___fmodeflags: ___fmodeflags, _rand: _rand, _json_init: _json_init, _free: _free, _scalbn: _scalbn, _qpacketmodem_get_frame_len: _qpacketmodem_get_frame_len, _liquid_firdes_gmskrx: _liquid_firdes_gmskrx, _flexframesync_execute_seekpn: _flexframesync_execute_seekpn, _gmskframesync_destroy: _gmskframesync_destroy, _quiet_decoder_flush: _quiet_decoder_flush, _dotprod_rrrf_destroy: _dotprod_rrrf_destroy, _modem_get_scheme: _modem_get_scheme, _dotprod_cccf_destroy: _dotprod_cccf_destroy, _error_set: _error_set, _flexframesync_debug_print: _flexframesync_debug_print, _liquid_firdes_kaiser: _liquid_firdes_kaiser, _ofdmflexframesync_create: _ofdmflexframesync_create, _demodulator_flush_symbol_len: _demodulator_flush_symbol_len, _fecsoft_hamming74_decode: _fecsoft_hamming74_decode, _cheby1_azpkf: _cheby1_azpkf, _fft_execute_dft_16: _fft_execute_dft_16, _qdetector_cccf_reset: _qdetector_cccf_reset, _csinhf: _csinhf, ___unlockfile: ___unlockfile, _interleaver_set_depth: _interleaver_set_depth, _nco_crcf_mix_up: _nco_crcf_mix_up, _firdespm_run: _firdespm_run, _nco_crcf_get_frequency: _nco_crcf_get_frequency, _firpfb_rrrf_execute: _firpfb_rrrf_execute, _firinterp_rrrf_reset: _firinterp_rrrf_reset, _getpid: _getpid, _cabsf: _cabsf, _div: _div, _modulator_flush: _modulator_flush, _quiet_encoder_clamp_frame_len: _quiet_encoder_clamp_frame_len, _firdecim_crcf_create: _firdecim_crcf_create, _ofdmflexframegen_writesymbol: _ofdmflexframegen_writesymbol, _ofdmframesync_estimate_eqgain_poly: _ofdmframesync_estimate_eqgain_poly, _utf8_check_first: _utf8_check_first, _json_object: _json_object, _flexframesync_create: _flexframesync_create, _strbuffer_init: _strbuffer_init, _modem_demodulate_ook: _modem_demodulate_ook, _logb: _logb, _windowf_push: _windowf_push, _fwrite: _fwrite, _fec_rs_encode: _fec_rs_encode, _modem_get_bps: _modem_get_bps, _fec_secded7264_create: _fec_secded7264_create, _roundf: _roundf, _qpacketmodem_decode: _qpacketmodem_decode, _fec_secded7264_decode_symbol: _fec_secded7264_decode_symbol, _qpacketmodem_get_fec1: _qpacketmodem_get_fec1, _fpoly_bessel_roots_orchard: _fpoly_bessel_roots_orchard, _fec_hamming74_decode: _fec_hamming74_decode, _qdetector_cccf_destroy: _qdetector_cccf_destroy, _bilinear_zpkf: _bilinear_zpkf, _memset: _memset, _modem_demodulate_qpsk: _modem_demodulate_qpsk, _to_locale: _to_locale, _windowf_destroy: _windowf_destroy, _fec_hamming128_destroy: _fec_hamming128_destroy, _interleaver_create: _interleaver_create, _vfprintf: _vfprintf, _liquid_unpack_bytes: _liquid_unpack_bytes, _iirdes_dzpk_lp2bp: _iirdes_dzpk_lp2bp, _modem_demodulate_ask: _modem_demodulate_ask, _firinterp_crcf_destroy: _firinterp_crcf_destroy, _fec_hamming128_create: _fec_hamming128_create, _qpacketmodem_get_fec0: _qpacketmodem_get_fec0, _liquid_sumsqcf: _liquid_sumsqcf, _gmskmod_reset: _gmskmod_reset, _poly_val_lagrange_barycentric: _poly_val_lagrange_barycentric, _snprintf: _snprintf, _parse_object: _parse_object, _matrixf_gjelim: _matrixf_gjelim, _cargf: _cargf, _lex_scan: _lex_scan, _json_delete_integer: _json_delete_integer, _json_decref_1902: _json_decref_1902, _firdecim_crcf_create_kaiser: _firdecim_crcf_create_kaiser, _msequence_create: _msequence_create, _modem_modulate_arb: _modem_modulate_arb, _fec_rep5_decode: _fec_rep5_decode, _detector_cccf_create: _detector_cccf_create, _modem_create_qam: _modem_create_qam, _modem_demodulate_qam: _modem_demodulate_qam, _ellip_snf: _ellip_snf, _modem_modulate: _modem_modulate, _fec_hamming74_encode: _fec_hamming74_encode, _modem_demodulate_bpsk: _modem_demodulate_bpsk, _string_create: _string_create, _fec_rep5_encode: _fec_rep5_encode, _frexpl: _frexpl, _windowcf_destroy: _windowcf_destroy, _flexframegen_reset: _flexframegen_reset, _modem_create_psk: _modem_create_psk, _fec_secded7264_destroy: _fec_secded7264_destroy, _hashtable_get: _hashtable_get, _isspace: _isspace, _cheby2_azpkf: _cheby2_azpkf, _liquid_firdes_farcsech_freqresponse: _liquid_firdes_farcsech_freqresponse, _fec_rep3_decode_soft: _fec_rep3_decode_soft, _gmskframesync_execute_rxheader: _gmskframesync_execute_rxheader, _dotprod_rrrf_execute: _dotprod_rrrf_execute, _i64Subtract: _i64Subtract, _packetizer_get_fec1: _packetizer_get_fec1, _packetizer_get_fec0: _packetizer_get_fec0, _fec_pass_encode: _fec_pass_encode, _msequence_advance: _msequence_advance, _firpfb_rrrf_create: _firpfb_rrrf_create, _qpilotgen_destroy: _qpilotgen_destroy, _fecsoft_hamming128_decode_n3: _fecsoft_hamming128_decode_n3, _dotprod_crcf_execute: _dotprod_crcf_execute, _ofdmframegen_reset: _ofdmframegen_reset, _open: _open, _fflush: _fflush, _firinterp_rrrf_execute: _firinterp_rrrf_execute, _qdetector_cccf_create_linear: _qdetector_cccf_create_linear, ___FLOAT_BITS: ___FLOAT_BITS, _fft_execute_mixed_radix: _fft_execute_mixed_radix, _dotprod_crcf_destroy: _dotprod_crcf_destroy, _ofdmframesync_create: _ofdmframesync_create, _detector_cccf_correlate: _detector_cccf_correlate, _firdespm_iext_search: _firdespm_iext_search, ___expo2f: ___expo2f, _scalbnl: _scalbnl, _expm1f: _expm1f, _coshf: _coshf, _firpfb_crcf_push: _firpfb_crcf_push, _calloc: _calloc, _fec_conv_punctured_destroy: _fec_conv_punctured_destroy, _scalbnf: _scalbnf, _gmskframegen_write_preamble: _gmskframegen_write_preamble, _flexframesync_set_header_len: _flexframesync_set_header_len, _qpacketmodem_create: _qpacketmodem_create, _utf8_check_full: _utf8_check_full, _flexframesync_execute: _flexframesync_execute, _resamp_rrrf_create: _resamp_rrrf_create, _flexframesync_execute_rxpayload: _flexframesync_execute_rxpayload, _json_delete_string: _json_delete_string, ___errno_location: ___errno_location, _fec_hamming84_decode: _fec_hamming84_decode, _strcmp: _strcmp, _fec_secded2216_encode: _fec_secded2216_encode, _ofdmframesync_execute_rxsymbols: _ofdmframesync_execute_rxsymbols, _copysign: _copysign, _csqrtf: _csqrtf, _printf_core: _printf_core, _memmove: _memmove, _liquid_lngammaf: _liquid_lngammaf, _qdetector_cccf_get_dphi: _qdetector_cccf_get_dphi, _lex_save_cached: _lex_save_cached, _ofdmflexframesync_rxpayload: _ofdmflexframesync_rxpayload, _hamming: _hamming, _quiet_encoder_set_payload: _quiet_encoder_set_payload, _ofdmflexframegen_set_header_len: _ofdmflexframegen_set_header_len, _strlen: _strlen, _ofdmflexframesync_destroy: _ofdmflexframesync_destroy, _json_decref: _json_decref, _polycf_expandroots: _polycf_expandroots, _strbuffer_pop: _strbuffer_pop, _fec_conv_encode: _fec_conv_encode, _flexframegen_setprops: _flexframegen_setprops, _fec_hamming74_destroy: _fec_hamming74_destroy, _firdespm_execute: _firdespm_execute, _strncpy: _strncpy, _resamp_rrrf_execute_output_block: _resamp_rrrf_execute_output_block, _json_integer_value: _json_integer_value, _hashtable_init: _hashtable_init, ___stpncpy: ___stpncpy, ___stdio_write: ___stdio_write, _liquid_modem_is_apsk: _liquid_modem_is_apsk, _gmskframegen_write_tail: _gmskframegen_write_tail, _ofdmflexframegen_assemble: _ofdmflexframegen_assemble, _json_null: _json_null, _msequence_generate_symbol: _msequence_generate_symbol, _modem_modulate_apsk: _modem_modulate_apsk, _packetizer_create: _packetizer_create, _ofdmframegen_create: _ofdmframegen_create, _liquid_firdes_rcos: _liquid_firdes_rcos, _flexframegen_destroy: _flexframegen_destroy, _liquid_firdes_farcsech: _liquid_firdes_farcsech, _fec_conv_init_v27: _fec_conv_init_v27, ___DOUBLE_BITS: ___DOUBLE_BITS, _fec_rep3_destroy: _fec_rep3_destroy, _gmskframesync_set_header_len: _gmskframesync_set_header_len, _windowf_read: _windowf_read, _fmt_u: _fmt_u, _jsonp_error_vset: _jsonp_error_vset, _iirfilt_crcf_create: _iirfilt_crcf_create, _quiet_encoder_create: _quiet_encoder_create, _polyf_fit: _polyf_fit, _matrixf_inv: _matrixf_inv, _qpilotgen_get_frame_len: _qpilotgen_get_frame_len, _qpilotsync_get_phi: _qpilotsync_get_phi, ___shgetc: ___shgetc, _qpilotsync_destroy: _qpilotsync_destroy, _ofdmflexframegen_setprops: _ofdmflexframegen_setprops, _gmskframesync_execute: _gmskframesync_execute, _firpfb_crcf_set_scale: _firpfb_crcf_set_scale, _firpfb_rrrf_destroy: _firpfb_rrrf_destroy, _fft_execute_dft_5: _fft_execute_dft_5, _fft_execute_dft_4: _fft_execute_dft_4, _json_real: _json_real, _fft_execute_dft_6: _fft_execute_dft_6, _liquid_modem_is_dpsk: _liquid_modem_is_dpsk, _fft_execute_dft_3: _fft_execute_dft_3, _fft_execute_dft_2: _fft_execute_dft_2, _strbuffer_clear: _strbuffer_clear, _fft_execute_dft_8: _fft_execute_dft_8, _fmodl: _fmodl, _fec_hamming128_decode_soft: _fec_hamming128_decode_soft, _packetizer_get_crc: _packetizer_get_crc, _liquid_firdes_rrcos: _liquid_firdes_rrcos, _liquid_firdes_fexp: _liquid_firdes_fexp, _crc24_generate_key: _crc24_generate_key, _ellipkf: _ellipkf, _lex_scan_number: _lex_scan_number, _iirfilt_crcf_execute: _iirfilt_crcf_execute, _fft_create_plan_dft: _fft_create_plan_dft, _modulator_reset: _modulator_reset, _fec_secded2216_estimate_ehat: _fec_secded2216_estimate_ehat, _lex_free_string: _lex_free_string, _fec_golay2412_destroy: _fec_golay2412_destroy, _flexframesync_destroy: _flexframesync_destroy, _modem_get_demodulator_phase_error: _modem_get_demodulator_phase_error, _firinterp_rrrf_create_prototype: _firinterp_rrrf_create_prototype, _fec_secded3932_decode: _fec_secded3932_decode, _framesyncstats_init_default: _framesyncstats_init_default, _ofdmframesync_execute: _ofdmframesync_execute, _modem_arb_init: _modem_arb_init, _fec_secded3932_create: _fec_secded3932_create, _flexframegen_assemble: _flexframegen_assemble, _jsonp_error_set_source: _jsonp_error_set_source, _matrixf_mul: _matrixf_mul, _ofdmflexframegen_is_assembled: _ofdmflexframegen_is_assembled, _fecsoft_hamming84_decode: _fecsoft_hamming84_decode, _strchr: _strchr, _dotprod_rrrf_create: _dotprod_rrrf_create, _liquid_bdotprod: _liquid_bdotprod, _qpilotsync_execute: _qpilotsync_execute, _fec_secded3932_destroy: _fec_secded3932_destroy, _fft_execute: _fft_execute, _parse_json: _parse_json, _gmskframegen_assemble: _gmskframegen_assemble, _bessel_azpkf: _bessel_azpkf, _firdecim_crcf_destroy: _firdecim_crcf_destroy, _detector_cccf_reset: _detector_cccf_reset, _vsnprintf: _vsnprintf, _firinterp_crcf_create_prototype: _firinterp_crcf_create_prototype, _firpfb_rrrf_create_rnyquist: _firpfb_rrrf_create_rnyquist, _liquid_firdes_rfarcsech: _liquid_firdes_rfarcsech, _fec_conv_punctured_encode: _fec_conv_punctured_encode, _rkaiser_approximate_rho: _rkaiser_approximate_rho, _poly_fit_lagrange_barycentric: _poly_fit_lagrange_barycentric, _fprintf: _fprintf, _sprintf: _sprintf, _gray_decode: _gray_decode, _detector_cccf_update_sumsq: _detector_cccf_update_sumsq, _strbuffer_close: _strbuffer_close, _ofdmframesync_execute_S0b: _ofdmframesync_execute_S0b, _liquid_fft_estimate_method: _liquid_fft_estimate_method, _firinterp_rrrf_create: _firinterp_rrrf_create, _qpilotsync_create: _qpilotsync_create, _copysignf: _copysignf, _jsonp_error_set: _jsonp_error_set, _modulator_emit: _modulator_emit, _nco_crcf_compute_sincos_vco: _nco_crcf_compute_sincos_vco, _ellip_azpkf: _ellip_azpkf, _liquid_pack_bytes: _liquid_pack_bytes, _polyf_val: _polyf_val, _demodulator_create: _demodulator_create, _logbf: _logbf, _estimate_req_filter_As: _estimate_req_filter_As, _fec_get_rate: _fec_get_rate, _fclose: _fclose, _parse_value: _parse_value, _ofdmflexframesync_debug_enable: _ofdmflexframesync_debug_enable, _liquid_getopt_str2crc: _liquid_getopt_str2crc, _liquid_factor: _liquid_factor, _insert_to_bucket: _insert_to_bucket, _liquid_firdes_rfexp: _liquid_firdes_rfexp, _ofdm_subcarriers_create: _ofdm_subcarriers_create, _lex_unget: _lex_unget, _fft_execute_radix2: _fft_execute_radix2, _liquid_is_prime: _liquid_is_prime, _firpfb_crcf_reset: _firpfb_crcf_reset, ___intscan: ___intscan, _decode_unicode_escape: _decode_unicode_escape, _gmskframesync_debug_print: _gmskframesync_debug_print, _ofdmflexframegen_reset: _ofdmflexframegen_reset, _json_true: _json_true, _sincf: _sincf, _modem_destroy: _modem_destroy, _flexframegen_is_assembled: _flexframegen_is_assembled, _modem_init_map: _modem_init_map, _wdelayf_destroy: _wdelayf_destroy, _modulator_destroy: _modulator_destroy, _qpacketmodem_encode: _qpacketmodem_encode, _fft_reverse_index: _fft_reverse_index, ___stdio_read: ___stdio_read, _liquid_primitive_root_prime: _liquid_primitive_root_prime, _csinf: _csinf, _iirfilt_crcf_create_sos: _iirfilt_crcf_create_sos, _fec_secded2216_destroy: _fec_secded2216_destroy, _modulator_sample_len: _modulator_sample_len, _fec_conv_decode_soft: _fec_conv_decode_soft, _bitshift64Shl: _bitshift64Shl, _fec_conv_punctured_decode_soft: _fec_conv_punctured_decode_soft, _i64Add: _i64Add, _interleaver_destroy: _interleaver_destroy, _fmax: _fmax, _framedatastats_reset: _framedatastats_reset, _wdelayf_push: _wdelayf_push, _wdelayf_create: _wdelayf_create, _hypot: _hypot, _seed_from_timestamp_and_pid: _seed_from_timestamp_and_pid, _modulator_flush_sample_len: _modulator_flush_sample_len, ___shlim: ___shlim, _fec_rs_create: _fec_rs_create, _hypotf: _hypotf, _copysignl: _copysignl, _fec_hamming84_create: _fec_hamming84_create, _fec_conv_punctured_decode_hard: _fec_conv_punctured_decode_hard, _fec_rep3_encode: _fec_rep3_encode, _ccoshf: _ccoshf, _firdespm_create: _firdespm_create, _frexp: _frexp, _gmskframegen_set_header_len: _gmskframegen_set_header_len, _hashtable_close: _hashtable_close, _quiet_decoder_profile_str: _quiet_decoder_profile_str, _liquid_reverse_uint32: _liquid_reverse_uint32, _firdespm_compute_interp: _firdespm_compute_interp, _hashtable_find_pair: _hashtable_find_pair, _jsonp_strndup: _jsonp_strndup, ___syscall_ret: ___syscall_ret, _liquid_vectorcf_mulscalar: _liquid_vectorcf_mulscalar, _fec_rs_destroy: _fec_rs_destroy, _bitshift64Lshr: _bitshift64Lshr, _modem_demodulate_psk: _modem_demodulate_psk, _fec_create: _fec_create, _modem_modulate_bpsk: _modem_modulate_bpsk, _fec_hamming128_decode: _fec_hamming128_decode, _liquid_getopt_str2fec: _liquid_getopt_str2fec, _parse_array: _parse_array, ___fdopen: ___fdopen, _gmskframesync_pushpn: _gmskframesync_pushpn, _memcpy: _memcpy, _json_object_set_nocheck: _json_object_set_nocheck, _dotprod_crcf_create: _dotprod_crcf_create, _ofdmframesync_S0_metrics: _ofdmframesync_S0_metrics, _close: _close, _qpacketmodem_configure: _qpacketmodem_configure, _qpilotgen_execute: _qpilotgen_execute, _gmskframegen_is_assembled: _gmskframegen_is_assembled, ___stdout_write: ___stdout_write, _liquid_iirdes: _liquid_iirdes, _sn_write: _sn_write, _fec_decode: _fec_decode, _bitshift64Ashr: _bitshift64Ashr, _qpacketmodem_get_modscheme: _qpacketmodem_get_modscheme, _constrained_write: _constrained_write, _packetizer_decode: _packetizer_decode, _ofdmflexframegen_reconfigure: _ofdmflexframegen_reconfigure, _ofdmframesync_debug_enable: _ofdmframesync_debug_enable, _erff: _erff, _packetizer_encode: _packetizer_encode, _json_string_value: _json_string_value, _kaiser: _kaiser, runPostSets: runPostSets, _strbuffer_append_bytes: _strbuffer_append_bytes, _crc16_generate_key: _crc16_generate_key, _fec_rep5_create: _fec_rep5_create, _firdespm_compute_taps: _firdespm_compute_taps, _lex_get: _lex_get, _try_realloc_chunk: _try_realloc_chunk, _gmskframegen_reset: _gmskframegen_reset, _nco_crcf_create: _nco_crcf_create, _stream_unget: _stream_unget, _quiet_encoder_destroy: _quiet_encoder_destroy, ___divsc3: ___divsc3, _json_array_grow: _json_array_grow, _qdetector_cccf_set_threshold: _qdetector_cccf_set_threshold, _modem_modulate_qpsk: _modem_modulate_qpsk, _json_delete: _json_delete, _gmskmod_create: _gmskmod_create, _fec_secded2216_create: _fec_secded2216_create, _log10f: _log10f, _windowcf_push: _windowcf_push, _quiet_decoder_create: _quiet_decoder_create, _liquid_unpack_array: _liquid_unpack_array, _llvm_cttz_i32: _llvm_cttz_i32, _fec_secded2216_compute_parity: _fec_secded2216_compute_parity, _liquid_firdes_hM3: _liquid_firdes_hM3, _firdecim_crcf_execute: _firdecim_crcf_execute, _lex_steal_string: _lex_steal_string, _fec_hamming128_encode: _fec_hamming128_encode, _strtox: _strtox, _jsonp_strtod: _jsonp_strtod, _liquid_firdes_rkaiser: _liquid_firdes_rkaiser, _fft_execute_dft: _fft_execute_dft, _wdelayf_clear: _wdelayf_clear, _ofdmframesync_get_cfo: _ofdmframesync_get_cfo, _fft_destroy_plan: _fft_destroy_plan, _printf: _printf, _fmaxf: _fmaxf, _liquid_repack_bytes: _liquid_repack_bytes, _json_loads: _json_loads, _msequence_create_default: _msequence_create_default, _fec_golay2412_encode: _fec_golay2412_encode, _nco_crcf_pll_set_bandwidth: _nco_crcf_pll_set_bandwidth, _liquid_firdes_rkaiser_internal_isi: _liquid_firdes_rkaiser_internal_isi, _lex_init: _lex_init, _firpfb_crcf_create: _firpfb_crcf_create, establishStackSpace: establishStackSpace, _firpfb_rrrf_push: _firpfb_rrrf_push, _read: _read, _string_get: _string_get, _nco_crcf_pll_step: _nco_crcf_pll_step, _modem_create: _modem_create, _json_real_value: _json_real_value, _qdetector_cccf_get_gamma: _qdetector_cccf_get_gamma, _utf8_encode: _utf8_encode, _windowcf_read: _windowcf_read, _fec_rs_decode: _fec_rs_decode, _json_object_seed: _json_object_seed, _fec_conv_create: _fec_conv_create, _seed_from_urandom: _seed_from_urandom, _fec_rep5_decode_soft: _fec_rep5_decode_soft, _modem_demodsoft_gentab: _modem_demodsoft_gentab, _ofdmframesync_debug_print: _ofdmframesync_debug_print, _qpilotsync_get_frame_len: _qpilotsync_get_frame_len, _fmod: _fmod, _iirdes_dzpk2tff: _iirdes_dzpk2tff, _fec_hamming74_decode_soft: _fec_hamming74_decode_soft, _array_copy: _array_copy, _liquid_unpack_array_block: _liquid_unpack_array_block, _iirfilt_crcf_create_lowpass: _iirfilt_crcf_create_lowpass, _gmskframesync_decode_header: _gmskframesync_decode_header, _quiet_encoder_sample_len: _quiet_encoder_sample_len, _fec_pass_decode: _fec_pass_decode, _fec_destroy: _fec_destroy, _fec_golay2412_decode_symbol: _fec_golay2412_decode_symbol, _qpilotgen_create: _qpilotgen_create, _liquid_cplxpair: _liquid_cplxpair, ___overflow: ___overflow, _firpfb_rrrf_reset: _firpfb_rrrf_reset, _lex_get_save: _lex_get_save, _json_delete_real: _json_delete_real, _gmskframesync_debug_enable: _gmskframesync_debug_enable, _flexframesync_decode_header: _flexframesync_decode_header, _json_incref: _json_incref, _firpfb_crcf_destroy: _firpfb_crcf_destroy, _json_delete_array: _json_delete_array, _qdetector_cccf_get_tau: _qdetector_cccf_get_tau, _ofdmflexframesync_set_header_len: _ofdmflexframesync_set_header_len, _jsonp_error_init: _jsonp_error_init, _modem_modulate_sqam32: _modem_modulate_sqam32, _liquid_besseli0f: _liquid_besseli0f, ___floatscan: ___floatscan, ___fflush_unlocked: ___fflush_unlocked, _hashtable_do_rehash: _hashtable_do_rehash, ___toread: ___toread, _windowf_clear: _windowf_clear, _fec_rep3_create: _fec_rep3_create, _ilogbf: _ilogbf, _ofdmflexframesync_internal_callback: _ofdmflexframesync_internal_callback, _firinterp_rrrf_destroy: _firinterp_rrrf_destroy, _fec_golay2412_create: _fec_golay2412_create, _decoder_on_decode: _decoder_on_decode, _list_init: _list_init, _fec_hamming74_create: _fec_hamming74_create, _demodulator_destroy: _demodulator_destroy, _liquid_pack_array: _liquid_pack_array, _fft_run: _fft_run, _flexframesync_debug_enable: _flexframesync_debug_enable, _bucket_is_empty: _bucket_is_empty, ___ldexp_cexpf: ___ldexp_cexpf, _modem_create_apsk: _modem_create_apsk, _ofdmflexframegen_getframelen: _ofdmflexframegen_getframelen, _jsonp_malloc: _jsonp_malloc, _scanexp: _scanexp, _fft_create_plan_radix2: _fft_create_plan_radix2, _fec_conv_destroy: _fec_conv_destroy, _iirfilt_crcf_create_prototype: _iirfilt_crcf_create_prototype, _ofdmframe_init_S1: _ofdmframe_init_S1, _ofdmframe_init_S0: _ofdmframe_init_S0, _stream_init: _stream_init, _ofdmflexframegen_write_header: _ofdmflexframegen_write_header, _liquid_modpow: _liquid_modpow, _strerror: _strerror, _strbuffer_value: _strbuffer_value, _quiet_encoder_emit: _quiet_encoder_emit, _qdetector_cccf_execute_align: _qdetector_cccf_execute_align, stackAlloc: stackAlloc, _ofdmflexframegen_write_payload: _ofdmflexframegen_write_payload, _realloc: _realloc, _gmskframesync_execute_rxpayload: _gmskframesync_execute_rxpayload, _fputs: _fputs, _strtod: _strtod, _ofdmframesync_execute_seekplcp: _ofdmframesync_execute_seekplcp, _ofdmframegen_write_S1: _ofdmframegen_write_S1, _firpfb_crcf_create_rnyquist: _firpfb_crcf_create_rnyquist, _gray_encode: _gray_encode, _nco_crcf_step: _nco_crcf_step, _flexframegen_set_header_len: _flexframegen_set_header_len, _windowcf_clear: _windowcf_clear, _fec_secded3932_encode: _fec_secded3932_encode, _fec_encode: _fec_encode, _liquid_firdes_arkaiser: _liquid_firdes_arkaiser, _gmskframesync_create: _gmskframesync_create, _lex_unget_unsave: _lex_unget_unsave, _fft_execute_rader: _fft_execute_rader, ___fwritex: ___fwritex, _qpacketmodem_get_crc: _qpacketmodem_get_crc };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
var _fec_hamming84_decode_soft = Module["_fec_hamming84_decode_soft"] = asm["_fec_hamming84_decode_soft"];
var _fec_hamming84_destroy = Module["_fec_hamming84_destroy"] = asm["_fec_hamming84_destroy"];
var _nco_crcf_set_frequency = Module["_nco_crcf_set_frequency"] = asm["_nco_crcf_set_frequency"];
var _crc_generate_key = Module["_crc_generate_key"] = asm["_crc_generate_key"];
var _firpfb_rrrf_reset = Module["_firpfb_rrrf_reset"] = asm["_firpfb_rrrf_reset"];
var _memchr = Module["_memchr"] = asm["_memchr"];
var _flexframegen_write_samples = Module["_flexframegen_write_samples"] = asm["_flexframegen_write_samples"];
var _strbuffer_append_byte = Module["_strbuffer_append_byte"] = asm["_strbuffer_append_byte"];
var _ellip_acdf = Module["_ellip_acdf"] = asm["_ellip_acdf"];
var _liquid_cacosf = Module["_liquid_cacosf"] = asm["_liquid_cacosf"];
var _lex_save_cached = Module["_lex_save_cached"] = asm["_lex_save_cached"];
var _fec_secded7264_encode = Module["_fec_secded7264_encode"] = asm["_fec_secded7264_encode"];
var _fft_create_plan_rader = Module["_fft_create_plan_rader"] = asm["_fft_create_plan_rader"];
var _fec_get_enc_msg_length = Module["_fec_get_enc_msg_length"] = asm["_fec_get_enc_msg_length"];
var _jsonp_stringn_nocheck_own = Module["_jsonp_stringn_nocheck_own"] = asm["_jsonp_stringn_nocheck_own"];
var _fec_hamming84_encode = Module["_fec_hamming84_encode"] = asm["_fec_hamming84_encode"];
var _ilogb = Module["_ilogb"] = asm["_ilogb"];
var _firpfb_rrrf_create_drnyquist = Module["_firpfb_rrrf_create_drnyquist"] = asm["_firpfb_rrrf_create_drnyquist"];
var _wdelayf_read = Module["_wdelayf_read"] = asm["_wdelayf_read"];
var _nco_crcf_mix_down = Module["_nco_crcf_mix_down"] = asm["_nco_crcf_mix_down"];
var _decoder_profile = Module["_decoder_profile"] = asm["_decoder_profile"];
var _ofdmframegen_write_S0b = Module["_ofdmframegen_write_S0b"] = asm["_ofdmframegen_write_S0b"];
var _ofdmframegen_write_S0a = Module["_ofdmframegen_write_S0a"] = asm["_ofdmframegen_write_S0a"];
var _ofdmframesync_rxsymbol = Module["_ofdmframesync_rxsymbol"] = asm["_ofdmframesync_rxsymbol"];
var _iirfilt_crcf_reset = Module["_iirfilt_crcf_reset"] = asm["_iirfilt_crcf_reset"];
var _gmskframesync_create = Module["_gmskframesync_create"] = asm["_gmskframesync_create"];
var _fec_block_get_enc_msg_len = Module["_fec_block_get_enc_msg_len"] = asm["_fec_block_get_enc_msg_len"];
var _vsprintf = Module["_vsprintf"] = asm["_vsprintf"];
var _modem_modulate_psk = Module["_modem_modulate_psk"] = asm["_modem_modulate_psk"];
var _puts = Module["_puts"] = asm["_puts"];
var _liquid_firdes_hM3 = Module["_liquid_firdes_hM3"] = asm["_liquid_firdes_hM3"];
var _liquid_reverse_uint24 = Module["_liquid_reverse_uint24"] = asm["_liquid_reverse_uint24"];
var _liquid_firdes_fnyquist = Module["_liquid_firdes_fnyquist"] = asm["_liquid_firdes_fnyquist"];
var _dotprod_cccf_execute = Module["_dotprod_cccf_execute"] = asm["_dotprod_cccf_execute"];
var _wctomb = Module["_wctomb"] = asm["_wctomb"];
var _qdetector_cccf_get_phi = Module["_qdetector_cccf_get_phi"] = asm["_qdetector_cccf_get_phi"];
var _polycf_expandroots = Module["_polycf_expandroots"] = asm["_polycf_expandroots"];
var _flexframegen_reconfigure = Module["_flexframegen_reconfigure"] = asm["_flexframegen_reconfigure"];
var _iirfilt_crcf_destroy = Module["_iirfilt_crcf_destroy"] = asm["_iirfilt_crcf_destroy"];
var _jsonp_free = Module["_jsonp_free"] = asm["_jsonp_free"];
var _modulator_symbol_len = Module["_modulator_symbol_len"] = asm["_modulator_symbol_len"];
var _pad = Module["_pad"] = asm["_pad"];
var _modem_modulate_qam = Module["_modem_modulate_qam"] = asm["_modem_modulate_qam"];
var _buf_to_uint32 = Module["_buf_to_uint32"] = asm["_buf_to_uint32"];
var _ofdmframe_validate_sctype = Module["_ofdmframe_validate_sctype"] = asm["_ofdmframe_validate_sctype"];
var _nco_crcf_compute_sincos_nco = Module["_nco_crcf_compute_sincos_nco"] = asm["_nco_crcf_compute_sincos_nco"];
var _json_array_append = Module["_json_array_append"] = asm["_json_array_append"];
var _qdetector_cccf_execute_seek = Module["_qdetector_cccf_execute_seek"] = asm["_qdetector_cccf_execute_seek"];
var _ccosf = Module["_ccosf"] = asm["_ccosf"];
var _ellip_cdf = Module["_ellip_cdf"] = asm["_ellip_cdf"];
var _nco_crcf_reset = Module["_nco_crcf_reset"] = asm["_nco_crcf_reset"];
var _quiet_decoder_checksum_fails = Module["_quiet_decoder_checksum_fails"] = asm["_quiet_decoder_checksum_fails"];
var _ofdmflexframesync_execute = Module["_ofdmflexframesync_execute"] = asm["_ofdmflexframesync_execute"];
var _resamp_rrrf_destroy = Module["_resamp_rrrf_destroy"] = asm["_resamp_rrrf_destroy"];
var _fec_secded7264_compute_syndrome = Module["_fec_secded7264_compute_syndrome"] = asm["_fec_secded7264_compute_syndrome"];
var _firinterp_crcf_execute = Module["_firinterp_crcf_execute"] = asm["_firinterp_crcf_execute"];
var _fft_execute_rader2 = Module["_fft_execute_rader2"] = asm["_fft_execute_rader2"];
var _modem_modulate_ask = Module["_modem_modulate_ask"] = asm["_modem_modulate_ask"];
var _liquid_firdes_rkaiser = Module["_liquid_firdes_rkaiser"] = asm["_liquid_firdes_rkaiser"];
var _firpfb_crcf_reset = Module["_firpfb_crcf_reset"] = asm["_firpfb_crcf_reset"];
var _liquid_firdes_rfsech = Module["_liquid_firdes_rfsech"] = asm["_liquid_firdes_rfsech"];
var _qdetector_cccf_get_buf_len = Module["_qdetector_cccf_get_buf_len"] = asm["_qdetector_cccf_get_buf_len"];
var ___towrite = Module["___towrite"] = asm["___towrite"];
var _ofdmflexframegen_create = Module["_ofdmflexframegen_create"] = asm["_ofdmflexframegen_create"];
var _firinterp_crcf_create_kaiser = Module["_firinterp_crcf_create_kaiser"] = asm["_firinterp_crcf_create_kaiser"];
var _liquid_nextpow2 = Module["_liquid_nextpow2"] = asm["_liquid_nextpow2"];
var _json_object_set_new_nocheck = Module["_json_object_set_new_nocheck"] = asm["_json_object_set_new_nocheck"];
var _liquid_firdes_fsech_freqresponse = Module["_liquid_firdes_fsech_freqresponse"] = asm["_liquid_firdes_fsech_freqresponse"];
var _modem_demodulate_dpsk = Module["_modem_demodulate_dpsk"] = asm["_modem_demodulate_dpsk"];
var _packetizer_destroy = Module["_packetizer_destroy"] = asm["_packetizer_destroy"];
var _qpilotsync_get_dphi = Module["_qpilotsync_get_dphi"] = asm["_qpilotsync_get_dphi"];
var _packetizer_recreate = Module["_packetizer_recreate"] = asm["_packetizer_recreate"];
var _packetizer_get_enc_msg_len = Module["_packetizer_get_enc_msg_len"] = asm["_packetizer_get_enc_msg_len"];
var ___strchrnul = Module["___strchrnul"] = asm["___strchrnul"];
var _flexframegen_getframelen = Module["_flexframegen_getframelen"] = asm["_flexframegen_getframelen"];
var _modem_demodulate_apsk = Module["_modem_demodulate_apsk"] = asm["_modem_demodulate_apsk"];
var _windowcf_create = Module["_windowcf_create"] = asm["_windowcf_create"];
var _flexframesync_execute_rxpreamble = Module["_flexframesync_execute_rxpreamble"] = asm["_flexframesync_execute_rxpreamble"];
var _ofdmflexframegen_destroy = Module["_ofdmflexframegen_destroy"] = asm["_ofdmflexframegen_destroy"];
var _fft_create_plan = Module["_fft_create_plan"] = asm["_fft_create_plan"];
var _encoder_profile = Module["_encoder_profile"] = asm["_encoder_profile"];
var _localeconv = Module["_localeconv"] = asm["_localeconv"];
var _matrixf_trans = Module["_matrixf_trans"] = asm["_matrixf_trans"];
var _firinterp_crcf_create = Module["_firinterp_crcf_create"] = asm["_firinterp_crcf_create"];
var _modem_demodulate = Module["_modem_demodulate"] = asm["_modem_demodulate"];
var _flexframegen_generate_symbol = Module["_flexframegen_generate_symbol"] = asm["_flexframegen_generate_symbol"];
var _fec_rep5_destroy = Module["_fec_rep5_destroy"] = asm["_fec_rep5_destroy"];
var _modem_recreate = Module["_modem_recreate"] = asm["_modem_recreate"];
var _flexframegen_create = Module["_flexframegen_create"] = asm["_flexframegen_create"];
var _firdespm_execute = Module["_firdespm_execute"] = asm["_firdespm_execute"];
var _json_false = Module["_json_false"] = asm["_json_false"];
var _resamp_rrrf_execute_output_block = Module["_resamp_rrrf_execute_output_block"] = asm["_resamp_rrrf_execute_output_block"];
var _json_object_get = Module["_json_object_get"] = asm["_json_object_get"];
var _liquid_msb_index = Module["_liquid_msb_index"] = asm["_liquid_msb_index"];
var _crc_validate_message = Module["_crc_validate_message"] = asm["_crc_validate_message"];
var _hashtable_do_clear = Module["_hashtable_do_clear"] = asm["_hashtable_do_clear"];
var _liquid_cplxpair_cleanup = Module["_liquid_cplxpair_cleanup"] = asm["_liquid_cplxpair_cleanup"];
var _json_integer_value = Module["_json_integer_value"] = asm["_json_integer_value"];
var _nco_crcf_destroy = Module["_nco_crcf_destroy"] = asm["_nco_crcf_destroy"];
var _gmskframegen_destroy = Module["_gmskframegen_destroy"] = asm["_gmskframegen_destroy"];
var _gmskframegen_getframelen = Module["_gmskframegen_getframelen"] = asm["_gmskframegen_getframelen"];
var _fec_rep3_decode = Module["_fec_rep3_decode"] = asm["_fec_rep3_decode"];
var _iirdes_dzpk2sosf = Module["_iirdes_dzpk2sosf"] = asm["_iirdes_dzpk2sosf"];
var _list_insert = Module["_list_insert"] = asm["_list_insert"];
var _fec_golay2412_decode = Module["_fec_golay2412_decode"] = asm["_fec_golay2412_decode"];
var _ofdmframesync_estimate_gain_S1 = Module["_ofdmframesync_estimate_gain_S1"] = asm["_ofdmframesync_estimate_gain_S1"];
var _ofdmframesync_estimate_gain_S0 = Module["_ofdmframesync_estimate_gain_S0"] = asm["_ofdmframesync_estimate_gain_S0"];
var _strtoll = Module["_strtoll"] = asm["_strtoll"];
var _fec_secded7264_decode = Module["_fec_secded7264_decode"] = asm["_fec_secded7264_decode"];
var ___uflow = Module["___uflow"] = asm["___uflow"];
var _fec_secded2216_decode = Module["_fec_secded2216_decode"] = asm["_fec_secded2216_decode"];
var _liquid_Qf = Module["_liquid_Qf"] = asm["_liquid_Qf"];
var _demodulator_recv = Module["_demodulator_recv"] = asm["_demodulator_recv"];
var _matrixf_hermitian = Module["_matrixf_hermitian"] = asm["_matrixf_hermitian"];
var _stream_get = Module["_stream_get"] = asm["_stream_get"];
var _json_number_value = Module["_json_number_value"] = asm["_json_number_value"];
var _fec_hamming128_decode_symbol = Module["_fec_hamming128_decode_symbol"] = asm["_fec_hamming128_decode_symbol"];
var _modem_demodulate_arb = Module["_modem_demodulate_arb"] = asm["_modem_demodulate_arb"];
var ___stdio_seek = Module["___stdio_seek"] = asm["___stdio_seek"];
var _conj = Module["_conj"] = asm["_conj"];
var _scramble_data = Module["_scramble_data"] = asm["_scramble_data"];
var _msequence_reset = Module["_msequence_reset"] = asm["_msequence_reset"];
var _quiet_encoder_profile_str = Module["_quiet_encoder_profile_str"] = asm["_quiet_encoder_profile_str"];
var _pop_arg = Module["_pop_arg"] = asm["_pop_arg"];
var _json_array_append_new = Module["_json_array_append_new"] = asm["_json_array_append_new"];
var _iirfilt_crcf_create_dc_blocker = Module["_iirfilt_crcf_create_dc_blocker"] = asm["_iirfilt_crcf_create_dc_blocker"];
var _lex_close = Module["_lex_close"] = asm["_lex_close"];
var _firpfb_crcf_create = Module["_firpfb_crcf_create"] = asm["_firpfb_crcf_create"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _firinterp_crcf_reset = Module["_firinterp_crcf_reset"] = asm["_firinterp_crcf_reset"];
var _fopen = Module["_fopen"] = asm["_fopen"];
var _msequence_destroy = Module["_msequence_destroy"] = asm["_msequence_destroy"];
var ___mulsc3 = Module["___mulsc3"] = asm["___mulsc3"];
var _ofdmflexframesync_debug_print = Module["_ofdmflexframesync_debug_print"] = asm["_ofdmflexframesync_debug_print"];
var _dotprod_cccf_create = Module["_dotprod_cccf_create"] = asm["_dotprod_cccf_create"];
var _ofdmframesync_reset = Module["_ofdmframesync_reset"] = asm["_ofdmframesync_reset"];
var _packetizer_create = Module["_packetizer_create"] = asm["_packetizer_create"];
var _quiet_decoder_recv = Module["_quiet_decoder_recv"] = asm["_quiet_decoder_recv"];
var _gmskframegen_create = Module["_gmskframegen_create"] = asm["_gmskframegen_create"];
var _unscramble_data = Module["_unscramble_data"] = asm["_unscramble_data"];
var _liquid_reverse_uint16 = Module["_liquid_reverse_uint16"] = asm["_liquid_reverse_uint16"];
var _flexframegen_is_assembled = Module["_flexframegen_is_assembled"] = asm["_flexframegen_is_assembled"];
var _fec_secded7264_compute_parity = Module["_fec_secded7264_compute_parity"] = asm["_fec_secded7264_compute_parity"];
var _json_decref_1945 = Module["_json_decref_1945"] = asm["_json_decref_1945"];
var _gmskmod_modulate = Module["_gmskmod_modulate"] = asm["_gmskmod_modulate"];
var _gmskframesync_execute_rxpreamble = Module["_gmskframesync_execute_rxpreamble"] = asm["_gmskframesync_execute_rxpreamble"];
var _fec_conv_init_v27 = Module["_fec_conv_init_v27"] = asm["_fec_conv_init_v27"];
var _fec_conv_init_v29 = Module["_fec_conv_init_v29"] = asm["_fec_conv_init_v29"];
var _fec_secded3932_estimate_ehat = Module["_fec_secded3932_estimate_ehat"] = asm["_fec_secded3932_estimate_ehat"];
var _erfc2_142 = Module["_erfc2_142"] = asm["_erfc2_142"];
var _fec_conv_punctured_create = Module["_fec_conv_punctured_create"] = asm["_fec_conv_punctured_create"];
var _modem_demodulate_sqam128 = Module["_modem_demodulate_sqam128"] = asm["_modem_demodulate_sqam128"];
var _fec_pass_create = Module["_fec_pass_create"] = asm["_fec_pass_create"];
var _interleaver_decode = Module["_interleaver_decode"] = asm["_interleaver_decode"];
var _strtox_519 = Module["_strtox_519"] = asm["_strtox_519"];
var ___lockfile = Module["___lockfile"] = asm["___lockfile"];
var _log10 = Module["_log10"] = asm["_log10"];
var _fec_conv_decode_hard = Module["_fec_conv_decode_hard"] = asm["_fec_conv_decode_hard"];
var _fec_rs_encode = Module["_fec_rs_encode"] = asm["_fec_rs_encode"];
var _detector_cccf_destroy = Module["_detector_cccf_destroy"] = asm["_detector_cccf_destroy"];
var _cexpf = Module["_cexpf"] = asm["_cexpf"];
var _modem_get_demodulator_evm = Module["_modem_get_demodulator_evm"] = asm["_modem_get_demodulator_evm"];
var _modem_demodulate_sqam32 = Module["_modem_demodulate_sqam32"] = asm["_modem_demodulate_sqam32"];
var _modem_init_map = Module["_modem_init_map"] = asm["_modem_init_map"];
var ___DOUBLE_BITS = Module["___DOUBLE_BITS"] = asm["___DOUBLE_BITS"];
var _firdespm_init_grid = Module["_firdespm_init_grid"] = asm["_firdespm_init_grid"];
var _modem_gen_rand_sym = Module["_modem_gen_rand_sym"] = asm["_modem_gen_rand_sym"];
var _liquid_filter_isi = Module["_liquid_filter_isi"] = asm["_liquid_filter_isi"];
var _demodulator_flush = Module["_demodulator_flush"] = asm["_demodulator_flush"];
var _gmskmod_destroy = Module["_gmskmod_destroy"] = asm["_gmskmod_destroy"];
var _firpfb_crcf_execute = Module["_firpfb_crcf_execute"] = asm["_firpfb_crcf_execute"];
var _liquid_firdes_fsech = Module["_liquid_firdes_fsech"] = asm["_liquid_firdes_fsech"];
var _crc_get_length = Module["_crc_get_length"] = asm["_crc_get_length"];
var _qpacketmodem_destroy = Module["_qpacketmodem_destroy"] = asm["_qpacketmodem_destroy"];
var _qdetector_cccf_create = Module["_qdetector_cccf_create"] = asm["_qdetector_cccf_create"];
var _lex_scan_string = Module["_lex_scan_string"] = asm["_lex_scan_string"];
var _ofdmflexframesync_rxheader = Module["_ofdmflexframesync_rxheader"] = asm["_ofdmflexframesync_rxheader"];
var _fpoly_bessel_roots_orchard_recursion = Module["_fpoly_bessel_roots_orchard_recursion"] = asm["_fpoly_bessel_roots_orchard_recursion"];
var _wcrtomb = Module["_wcrtomb"] = asm["_wcrtomb"];
var _modulator_create = Module["_modulator_create"] = asm["_modulator_create"];
var _windowf_read = Module["_windowf_read"] = asm["_windowf_read"];
var _fft_create_plan_mixed_radix = Module["_fft_create_plan_mixed_radix"] = asm["_fft_create_plan_mixed_radix"];
var _butter_azpkf = Module["_butter_azpkf"] = asm["_butter_azpkf"];
var _hashlittle = Module["_hashlittle"] = asm["_hashlittle"];
var _ofdmframegen_writesymbol = Module["_ofdmframegen_writesymbol"] = asm["_ofdmframegen_writesymbol"];
var _modem_modulate_dpsk = Module["_modem_modulate_dpsk"] = asm["_modem_modulate_dpsk"];
var _modem_modulate_sqam128 = Module["_modem_modulate_sqam128"] = asm["_modem_modulate_sqam128"];
var _ofdmframesync_execute_S1 = Module["_ofdmframesync_execute_S1"] = asm["_ofdmframesync_execute_S1"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var ___muldc3 = Module["___muldc3"] = asm["___muldc3"];
var _modem_modulate_ook = Module["_modem_modulate_ook"] = asm["_modem_modulate_ook"];
var _liquid_firdes_gmsktx = Module["_liquid_firdes_gmsktx"] = asm["_liquid_firdes_gmsktx"];
var _quiet_decoder_destroy = Module["_quiet_decoder_destroy"] = asm["_quiet_decoder_destroy"];
var _hashtable_set = Module["_hashtable_set"] = asm["_hashtable_set"];
var _cleanup_382 = Module["_cleanup_382"] = asm["_cleanup_382"];
var _qdetector_cccf_execute = Module["_qdetector_cccf_execute"] = asm["_qdetector_cccf_execute"];
var _cleanup_387 = Module["_cleanup_387"] = asm["_cleanup_387"];
var _gmskframesync_set_header_len = Module["_gmskframesync_set_header_len"] = asm["_gmskframesync_set_header_len"];
var _firdespm_destroy = Module["_firdespm_destroy"] = asm["_firdespm_destroy"];
var ___divdc3 = Module["___divdc3"] = asm["___divdc3"];
var _json_integer = Module["_json_integer"] = asm["_json_integer"];
var _liquid_getopt_str2mod = Module["_liquid_getopt_str2mod"] = asm["_liquid_getopt_str2mod"];
var _ofdmframe_init_default_sctype = Module["_ofdmframe_init_default_sctype"] = asm["_ofdmframe_init_default_sctype"];
var _nco_crcf_adjust_frequency = Module["_nco_crcf_adjust_frequency"] = asm["_nco_crcf_adjust_frequency"];
var _liquid_firdes_rkaiser_quadratic = Module["_liquid_firdes_rkaiser_quadratic"] = asm["_liquid_firdes_rkaiser_quadratic"];
var _windowf_create = Module["_windowf_create"] = asm["_windowf_create"];
var _flexframesync_execute_rxheader = Module["_flexframesync_execute_rxheader"] = asm["_flexframesync_execute_rxheader"];
var _ofdmframesync_debug_print = Module["_ofdmframesync_debug_print"] = asm["_ofdmframesync_debug_print"];
var _ofdmframesync_get_rssi = Module["_ofdmframesync_get_rssi"] = asm["_ofdmframesync_get_rssi"];
var _quiet_decoder_readbuf = Module["_quiet_decoder_readbuf"] = asm["_quiet_decoder_readbuf"];
var _qdetector_cccf_destroy = Module["_qdetector_cccf_destroy"] = asm["_qdetector_cccf_destroy"];
var _nco_crcf_set_phase = Module["_nco_crcf_set_phase"] = asm["_nco_crcf_set_phase"];
var _ofdmframesync_destroy = Module["_ofdmframesync_destroy"] = asm["_ofdmframesync_destroy"];
var _fec_conv_decode_soft = Module["_fec_conv_decode_soft"] = asm["_fec_conv_decode_soft"];
var _ofdmframegen_destroy = Module["_ofdmframegen_destroy"] = asm["_ofdmframegen_destroy"];
var ___fmodeflags = Module["___fmodeflags"] = asm["___fmodeflags"];
var _rand = Module["_rand"] = asm["_rand"];
var _json_init = Module["_json_init"] = asm["_json_init"];
var _gmskframesync_debug_enable = Module["_gmskframesync_debug_enable"] = asm["_gmskframesync_debug_enable"];
var _free = Module["_free"] = asm["_free"];
var _scalbn = Module["_scalbn"] = asm["_scalbn"];
var _qpacketmodem_get_frame_len = Module["_qpacketmodem_get_frame_len"] = asm["_qpacketmodem_get_frame_len"];
var _iirdes_dzpk2tff = Module["_iirdes_dzpk2tff"] = asm["_iirdes_dzpk2tff"];
var _liquid_firdes_gmskrx = Module["_liquid_firdes_gmskrx"] = asm["_liquid_firdes_gmskrx"];
var _flexframesync_execute_seekpn = Module["_flexframesync_execute_seekpn"] = asm["_flexframesync_execute_seekpn"];
var _gmskframesync_destroy = Module["_gmskframesync_destroy"] = asm["_gmskframesync_destroy"];
var _quiet_decoder_flush = Module["_quiet_decoder_flush"] = asm["_quiet_decoder_flush"];
var _modem_get_scheme = Module["_modem_get_scheme"] = asm["_modem_get_scheme"];
var _dotprod_cccf_destroy = Module["_dotprod_cccf_destroy"] = asm["_dotprod_cccf_destroy"];
var _error_set = Module["_error_set"] = asm["_error_set"];
var _flexframesync_debug_print = Module["_flexframesync_debug_print"] = asm["_flexframesync_debug_print"];
var _fft_execute_mixed_radix = Module["_fft_execute_mixed_radix"] = asm["_fft_execute_mixed_radix"];
var _liquid_firdes_kaiser = Module["_liquid_firdes_kaiser"] = asm["_liquid_firdes_kaiser"];
var _ofdmflexframesync_create = Module["_ofdmflexframesync_create"] = asm["_ofdmflexframesync_create"];
var _demodulator_flush_symbol_len = Module["_demodulator_flush_symbol_len"] = asm["_demodulator_flush_symbol_len"];
var _fecsoft_hamming74_decode = Module["_fecsoft_hamming74_decode"] = asm["_fecsoft_hamming74_decode"];
var _cheby1_azpkf = Module["_cheby1_azpkf"] = asm["_cheby1_azpkf"];
var _fft_execute_dft_16 = Module["_fft_execute_dft_16"] = asm["_fft_execute_dft_16"];
var _qdetector_cccf_reset = Module["_qdetector_cccf_reset"] = asm["_qdetector_cccf_reset"];
var _csinhf = Module["_csinhf"] = asm["_csinhf"];
var ___unlockfile = Module["___unlockfile"] = asm["___unlockfile"];
var _interleaver_set_depth = Module["_interleaver_set_depth"] = asm["_interleaver_set_depth"];
var _firdespm_run = Module["_firdespm_run"] = asm["_firdespm_run"];
var _nco_crcf_get_frequency = Module["_nco_crcf_get_frequency"] = asm["_nco_crcf_get_frequency"];
var _fec_hamming84_create = Module["_fec_hamming84_create"] = asm["_fec_hamming84_create"];
var _firpfb_rrrf_execute = Module["_firpfb_rrrf_execute"] = asm["_firpfb_rrrf_execute"];
var _firinterp_rrrf_reset = Module["_firinterp_rrrf_reset"] = asm["_firinterp_rrrf_reset"];
var _getpid = Module["_getpid"] = asm["_getpid"];
var _fec_pass_decode = Module["_fec_pass_decode"] = asm["_fec_pass_decode"];
var _div = Module["_div"] = asm["_div"];
var _modulator_flush = Module["_modulator_flush"] = asm["_modulator_flush"];
var _quiet_encoder_clamp_frame_len = Module["_quiet_encoder_clamp_frame_len"] = asm["_quiet_encoder_clamp_frame_len"];
var _ofdmframesync_estimate_eqgain_poly = Module["_ofdmframesync_estimate_eqgain_poly"] = asm["_ofdmframesync_estimate_eqgain_poly"];
var _utf8_check_first = Module["_utf8_check_first"] = asm["_utf8_check_first"];
var _json_object = Module["_json_object"] = asm["_json_object"];
var _flexframesync_create = Module["_flexframesync_create"] = asm["_flexframesync_create"];
var _fec_destroy = Module["_fec_destroy"] = asm["_fec_destroy"];
var _modem_demodulate_ook = Module["_modem_demodulate_ook"] = asm["_modem_demodulate_ook"];
var _logb = Module["_logb"] = asm["_logb"];
var _windowf_push = Module["_windowf_push"] = asm["_windowf_push"];
var _fwrite = Module["_fwrite"] = asm["_fwrite"];
var _fec_secded7264_create = Module["_fec_secded7264_create"] = asm["_fec_secded7264_create"];
var _modem_get_bps = Module["_modem_get_bps"] = asm["_modem_get_bps"];
var _qpacketmodem_decode = Module["_qpacketmodem_decode"] = asm["_qpacketmodem_decode"];
var _fec_secded7264_decode_symbol = Module["_fec_secded7264_decode_symbol"] = asm["_fec_secded7264_decode_symbol"];
var _liquid_sumsqcf = Module["_liquid_sumsqcf"] = asm["_liquid_sumsqcf"];
var _fpoly_bessel_roots_orchard = Module["_fpoly_bessel_roots_orchard"] = asm["_fpoly_bessel_roots_orchard"];
var _interleaver_encode = Module["_interleaver_encode"] = asm["_interleaver_encode"];
var _bilinear_zpkf = Module["_bilinear_zpkf"] = asm["_bilinear_zpkf"];
var _json_delete_real = Module["_json_delete_real"] = asm["_json_delete_real"];
var _modem_demodulate_qpsk = Module["_modem_demodulate_qpsk"] = asm["_modem_demodulate_qpsk"];
var _to_locale = Module["_to_locale"] = asm["_to_locale"];
var _windowf_destroy = Module["_windowf_destroy"] = asm["_windowf_destroy"];
var _fec_hamming128_destroy = Module["_fec_hamming128_destroy"] = asm["_fec_hamming128_destroy"];
var _interleaver_create = Module["_interleaver_create"] = asm["_interleaver_create"];
var _vfprintf = Module["_vfprintf"] = asm["_vfprintf"];
var _liquid_unpack_bytes = Module["_liquid_unpack_bytes"] = asm["_liquid_unpack_bytes"];
var _ellip_snf = Module["_ellip_snf"] = asm["_ellip_snf"];
var _iirdes_dzpk_lp2bp = Module["_iirdes_dzpk_lp2bp"] = asm["_iirdes_dzpk_lp2bp"];
var _modem_demodulate_ask = Module["_modem_demodulate_ask"] = asm["_modem_demodulate_ask"];
var _firinterp_crcf_destroy = Module["_firinterp_crcf_destroy"] = asm["_firinterp_crcf_destroy"];
var _fec_hamming128_create = Module["_fec_hamming128_create"] = asm["_fec_hamming128_create"];
var _qpacketmodem_get_fec0 = Module["_qpacketmodem_get_fec0"] = asm["_qpacketmodem_get_fec0"];
var _qpacketmodem_get_fec1 = Module["_qpacketmodem_get_fec1"] = asm["_qpacketmodem_get_fec1"];
var _gmskmod_reset = Module["_gmskmod_reset"] = asm["_gmskmod_reset"];
var _poly_val_lagrange_barycentric = Module["_poly_val_lagrange_barycentric"] = asm["_poly_val_lagrange_barycentric"];
var _snprintf = Module["_snprintf"] = asm["_snprintf"];
var _parse_object = Module["_parse_object"] = asm["_parse_object"];
var _matrixf_gjelim = Module["_matrixf_gjelim"] = asm["_matrixf_gjelim"];
var _liquid_firdes_fexp = Module["_liquid_firdes_fexp"] = asm["_liquid_firdes_fexp"];
var _lex_scan = Module["_lex_scan"] = asm["_lex_scan"];
var _json_delete_integer = Module["_json_delete_integer"] = asm["_json_delete_integer"];
var _json_decref_1902 = Module["_json_decref_1902"] = asm["_json_decref_1902"];
var _firdecim_crcf_create_kaiser = Module["_firdecim_crcf_create_kaiser"] = asm["_firdecim_crcf_create_kaiser"];
var _msequence_create = Module["_msequence_create"] = asm["_msequence_create"];
var _modem_modulate_arb = Module["_modem_modulate_arb"] = asm["_modem_modulate_arb"];
var _fec_rep5_decode = Module["_fec_rep5_decode"] = asm["_fec_rep5_decode"];
var _detector_cccf_create = Module["_detector_cccf_create"] = asm["_detector_cccf_create"];
var _modem_create_qam = Module["_modem_create_qam"] = asm["_modem_create_qam"];
var _iirfilt_crcf_create_lowpass = Module["_iirfilt_crcf_create_lowpass"] = asm["_iirfilt_crcf_create_lowpass"];
var _modem_demodulate_qam = Module["_modem_demodulate_qam"] = asm["_modem_demodulate_qam"];
var _lex_save = Module["_lex_save"] = asm["_lex_save"];
var _modem_modulate = Module["_modem_modulate"] = asm["_modem_modulate"];
var _crc24_generate_key = Module["_crc24_generate_key"] = asm["_crc24_generate_key"];
var _modem_demodulate_bpsk = Module["_modem_demodulate_bpsk"] = asm["_modem_demodulate_bpsk"];
var _string_create = Module["_string_create"] = asm["_string_create"];
var _fec_rep5_encode = Module["_fec_rep5_encode"] = asm["_fec_rep5_encode"];
var _frexpl = Module["_frexpl"] = asm["_frexpl"];
var _windowcf_destroy = Module["_windowcf_destroy"] = asm["_windowcf_destroy"];
var _flexframegen_reset = Module["_flexframegen_reset"] = asm["_flexframegen_reset"];
var _modem_create_psk = Module["_modem_create_psk"] = asm["_modem_create_psk"];
var _fec_secded7264_destroy = Module["_fec_secded7264_destroy"] = asm["_fec_secded7264_destroy"];
var _liquid_besseli0f = Module["_liquid_besseli0f"] = asm["_liquid_besseli0f"];
var _isspace = Module["_isspace"] = asm["_isspace"];
var _cheby2_azpkf = Module["_cheby2_azpkf"] = asm["_cheby2_azpkf"];
var _liquid_firdes_farcsech_freqresponse = Module["_liquid_firdes_farcsech_freqresponse"] = asm["_liquid_firdes_farcsech_freqresponse"];
var _fec_rep3_decode_soft = Module["_fec_rep3_decode_soft"] = asm["_fec_rep3_decode_soft"];
var _modulator_reset = Module["_modulator_reset"] = asm["_modulator_reset"];
var _dotprod_rrrf_execute = Module["_dotprod_rrrf_execute"] = asm["_dotprod_rrrf_execute"];
var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
var _packetizer_get_fec1 = Module["_packetizer_get_fec1"] = asm["_packetizer_get_fec1"];
var _packetizer_get_fec0 = Module["_packetizer_get_fec0"] = asm["_packetizer_get_fec0"];
var _fec_pass_encode = Module["_fec_pass_encode"] = asm["_fec_pass_encode"];
var _msequence_advance = Module["_msequence_advance"] = asm["_msequence_advance"];
var _firpfb_rrrf_create = Module["_firpfb_rrrf_create"] = asm["_firpfb_rrrf_create"];
var _qpilotgen_destroy = Module["_qpilotgen_destroy"] = asm["_qpilotgen_destroy"];
var _fecsoft_hamming128_decode_n3 = Module["_fecsoft_hamming128_decode_n3"] = asm["_fecsoft_hamming128_decode_n3"];
var _dotprod_crcf_execute = Module["_dotprod_crcf_execute"] = asm["_dotprod_crcf_execute"];
var _ofdmframegen_reset = Module["_ofdmframegen_reset"] = asm["_ofdmframegen_reset"];
var _fflush = Module["_fflush"] = asm["_fflush"];
var _json_real = Module["_json_real"] = asm["_json_real"];
var _firinterp_rrrf_execute = Module["_firinterp_rrrf_execute"] = asm["_firinterp_rrrf_execute"];
var _qdetector_cccf_create_linear = Module["_qdetector_cccf_create_linear"] = asm["_qdetector_cccf_create_linear"];
var ___FLOAT_BITS = Module["___FLOAT_BITS"] = asm["___FLOAT_BITS"];
var _parse_array = Module["_parse_array"] = asm["_parse_array"];
var _dotprod_crcf_destroy = Module["_dotprod_crcf_destroy"] = asm["_dotprod_crcf_destroy"];
var _ofdmframesync_create = Module["_ofdmframesync_create"] = asm["_ofdmframesync_create"];
var _detector_cccf_correlate = Module["_detector_cccf_correlate"] = asm["_detector_cccf_correlate"];
var ___expo2f = Module["___expo2f"] = asm["___expo2f"];
var _scalbnl = Module["_scalbnl"] = asm["_scalbnl"];
var _expm1f = Module["_expm1f"] = asm["_expm1f"];
var _coshf = Module["_coshf"] = asm["_coshf"];
var _firpfb_crcf_push = Module["_firpfb_crcf_push"] = asm["_firpfb_crcf_push"];
var _fec_conv_punctured_destroy = Module["_fec_conv_punctured_destroy"] = asm["_fec_conv_punctured_destroy"];
var _scalbnf = Module["_scalbnf"] = asm["_scalbnf"];
var _gmskframegen_write_preamble = Module["_gmskframegen_write_preamble"] = asm["_gmskframegen_write_preamble"];
var _flexframesync_set_header_len = Module["_flexframesync_set_header_len"] = asm["_flexframesync_set_header_len"];
var _qpacketmodem_create = Module["_qpacketmodem_create"] = asm["_qpacketmodem_create"];
var _utf8_check_full = Module["_utf8_check_full"] = asm["_utf8_check_full"];
var _flexframesync_execute = Module["_flexframesync_execute"] = asm["_flexframesync_execute"];
var _resamp_rrrf_create = Module["_resamp_rrrf_create"] = asm["_resamp_rrrf_create"];
var _flexframesync_execute_rxpayload = Module["_flexframesync_execute_rxpayload"] = asm["_flexframesync_execute_rxpayload"];
var _json_delete_string = Module["_json_delete_string"] = asm["_json_delete_string"];
var ___errno_location = Module["___errno_location"] = asm["___errno_location"];
var _fec_hamming84_decode = Module["_fec_hamming84_decode"] = asm["_fec_hamming84_decode"];
var _strcmp = Module["_strcmp"] = asm["_strcmp"];
var _fec_secded2216_encode = Module["_fec_secded2216_encode"] = asm["_fec_secded2216_encode"];
var _ofdmframesync_execute_rxsymbols = Module["_ofdmframesync_execute_rxsymbols"] = asm["_ofdmframesync_execute_rxsymbols"];
var _copysign = Module["_copysign"] = asm["_copysign"];
var _csqrtf = Module["_csqrtf"] = asm["_csqrtf"];
var _printf_core = Module["_printf_core"] = asm["_printf_core"];
var _memmove = Module["_memmove"] = asm["_memmove"];
var _liquid_lngammaf = Module["_liquid_lngammaf"] = asm["_liquid_lngammaf"];
var _qdetector_cccf_get_dphi = Module["_qdetector_cccf_get_dphi"] = asm["_qdetector_cccf_get_dphi"];
var _gray_encode = Module["_gray_encode"] = asm["_gray_encode"];
var _ofdmflexframesync_rxpayload = Module["_ofdmflexframesync_rxpayload"] = asm["_ofdmflexframesync_rxpayload"];
var _hamming = Module["_hamming"] = asm["_hamming"];
var _quiet_encoder_set_payload = Module["_quiet_encoder_set_payload"] = asm["_quiet_encoder_set_payload"];
var _ofdmflexframegen_set_header_len = Module["_ofdmflexframegen_set_header_len"] = asm["_ofdmflexframegen_set_header_len"];
var _strlen = Module["_strlen"] = asm["_strlen"];
var _ofdmflexframesync_destroy = Module["_ofdmflexframesync_destroy"] = asm["_ofdmflexframesync_destroy"];
var _json_decref = Module["_json_decref"] = asm["_json_decref"];
var _gmskframesync_update_symsync = Module["_gmskframesync_update_symsync"] = asm["_gmskframesync_update_symsync"];
var _strbuffer_pop = Module["_strbuffer_pop"] = asm["_strbuffer_pop"];
var _modulator_flush_sample_len = Module["_modulator_flush_sample_len"] = asm["_modulator_flush_sample_len"];
var _fec_conv_encode = Module["_fec_conv_encode"] = asm["_fec_conv_encode"];
var _flexframegen_setprops = Module["_flexframegen_setprops"] = asm["_flexframegen_setprops"];
var _fec_hamming74_destroy = Module["_fec_hamming74_destroy"] = asm["_fec_hamming74_destroy"];
var _json_delete_object = Module["_json_delete_object"] = asm["_json_delete_object"];
var _strncpy = Module["_strncpy"] = asm["_strncpy"];
var _liquid_csqrtf = Module["_liquid_csqrtf"] = asm["_liquid_csqrtf"];
var _conjf = Module["_conjf"] = asm["_conjf"];
var _hashtable_init = Module["_hashtable_init"] = asm["_hashtable_init"];
var ___stpncpy = Module["___stpncpy"] = asm["___stpncpy"];
var _liquid_modem_is_apsk = Module["_liquid_modem_is_apsk"] = asm["_liquid_modem_is_apsk"];
var _gmskframegen_write_tail = Module["_gmskframegen_write_tail"] = asm["_gmskframegen_write_tail"];
var _ofdmflexframegen_assemble = Module["_ofdmflexframegen_assemble"] = asm["_ofdmflexframegen_assemble"];
var _json_null = Module["_json_null"] = asm["_json_null"];
var _msequence_generate_symbol = Module["_msequence_generate_symbol"] = asm["_msequence_generate_symbol"];
var _modem_modulate_apsk = Module["_modem_modulate_apsk"] = asm["_modem_modulate_apsk"];
var _fft_create_plan_rader2 = Module["_fft_create_plan_rader2"] = asm["_fft_create_plan_rader2"];
var _ofdmframegen_create = Module["_ofdmframegen_create"] = asm["_ofdmframegen_create"];
var _liquid_firdes_rcos = Module["_liquid_firdes_rcos"] = asm["_liquid_firdes_rcos"];
var _flexframegen_destroy = Module["_flexframegen_destroy"] = asm["_flexframegen_destroy"];
var _liquid_firdes_farcsech = Module["_liquid_firdes_farcsech"] = asm["_liquid_firdes_farcsech"];
var ___stdio_write = Module["___stdio_write"] = asm["___stdio_write"];
var _fec_rep3_destroy = Module["_fec_rep3_destroy"] = asm["_fec_rep3_destroy"];
var _nco_crcf_mix_up = Module["_nco_crcf_mix_up"] = asm["_nco_crcf_mix_up"];
var ___stdio_close = Module["___stdio_close"] = asm["___stdio_close"];
var _firdespm_compute_interp = Module["_firdespm_compute_interp"] = asm["_firdespm_compute_interp"];
var _jsonp_error_vset = Module["_jsonp_error_vset"] = asm["_jsonp_error_vset"];
var _ofdmflexframesync_internal_callback = Module["_ofdmflexframesync_internal_callback"] = asm["_ofdmflexframesync_internal_callback"];
var _quiet_encoder_create = Module["_quiet_encoder_create"] = asm["_quiet_encoder_create"];
var _polyf_fit = Module["_polyf_fit"] = asm["_polyf_fit"];
var _matrixf_inv = Module["_matrixf_inv"] = asm["_matrixf_inv"];
var _qpilotgen_get_frame_len = Module["_qpilotgen_get_frame_len"] = asm["_qpilotgen_get_frame_len"];
var _ofdmframesync_execute_seekplcp = Module["_ofdmframesync_execute_seekplcp"] = asm["_ofdmframesync_execute_seekplcp"];
var ___shgetc = Module["___shgetc"] = asm["___shgetc"];
var _qpilotsync_destroy = Module["_qpilotsync_destroy"] = asm["_qpilotsync_destroy"];
var _ofdmflexframegen_setprops = Module["_ofdmflexframegen_setprops"] = asm["_ofdmflexframegen_setprops"];
var _gmskframesync_execute = Module["_gmskframesync_execute"] = asm["_gmskframesync_execute"];
var _firpfb_crcf_set_scale = Module["_firpfb_crcf_set_scale"] = asm["_firpfb_crcf_set_scale"];
var _firpfb_rrrf_destroy = Module["_firpfb_rrrf_destroy"] = asm["_firpfb_rrrf_destroy"];
var _fft_execute_dft_5 = Module["_fft_execute_dft_5"] = asm["_fft_execute_dft_5"];
var _fft_execute_dft_4 = Module["_fft_execute_dft_4"] = asm["_fft_execute_dft_4"];
var _fft_execute_dft_7 = Module["_fft_execute_dft_7"] = asm["_fft_execute_dft_7"];
var _fft_execute_dft_6 = Module["_fft_execute_dft_6"] = asm["_fft_execute_dft_6"];
var _liquid_modem_is_dpsk = Module["_liquid_modem_is_dpsk"] = asm["_liquid_modem_is_dpsk"];
var _fft_execute_dft_3 = Module["_fft_execute_dft_3"] = asm["_fft_execute_dft_3"];
var _fft_execute_dft_2 = Module["_fft_execute_dft_2"] = asm["_fft_execute_dft_2"];
var _strbuffer_clear = Module["_strbuffer_clear"] = asm["_strbuffer_clear"];
var _ilogbf = Module["_ilogbf"] = asm["_ilogbf"];
var _fft_execute_dft_8 = Module["_fft_execute_dft_8"] = asm["_fft_execute_dft_8"];
var _liquid_vectorcf_mulscalar = Module["_liquid_vectorcf_mulscalar"] = asm["_liquid_vectorcf_mulscalar"];
var _fec_hamming128_decode_soft = Module["_fec_hamming128_decode_soft"] = asm["_fec_hamming128_decode_soft"];
var _packetizer_get_crc = Module["_packetizer_get_crc"] = asm["_packetizer_get_crc"];
var _liquid_firdes_rrcos = Module["_liquid_firdes_rrcos"] = asm["_liquid_firdes_rrcos"];
var _cargf = Module["_cargf"] = asm["_cargf"];
var _fec_hamming74_encode = Module["_fec_hamming74_encode"] = asm["_fec_hamming74_encode"];
var _ellipkf = Module["_ellipkf"] = asm["_ellipkf"];
var _lex_scan_number = Module["_lex_scan_number"] = asm["_lex_scan_number"];
var _iirfilt_crcf_execute = Module["_iirfilt_crcf_execute"] = asm["_iirfilt_crcf_execute"];
var _fft_create_plan_dft = Module["_fft_create_plan_dft"] = asm["_fft_create_plan_dft"];
var _gmskframesync_execute_rxheader = Module["_gmskframesync_execute_rxheader"] = asm["_gmskframesync_execute_rxheader"];
var _fec_secded2216_estimate_ehat = Module["_fec_secded2216_estimate_ehat"] = asm["_fec_secded2216_estimate_ehat"];
var _lex_free_string = Module["_lex_free_string"] = asm["_lex_free_string"];
var _fec_golay2412_destroy = Module["_fec_golay2412_destroy"] = asm["_fec_golay2412_destroy"];
var _flexframesync_destroy = Module["_flexframesync_destroy"] = asm["_flexframesync_destroy"];
var _modem_get_demodulator_phase_error = Module["_modem_get_demodulator_phase_error"] = asm["_modem_get_demodulator_phase_error"];
var _firinterp_rrrf_create_prototype = Module["_firinterp_rrrf_create_prototype"] = asm["_firinterp_rrrf_create_prototype"];
var _fec_secded3932_decode = Module["_fec_secded3932_decode"] = asm["_fec_secded3932_decode"];
var _framesyncstats_init_default = Module["_framesyncstats_init_default"] = asm["_framesyncstats_init_default"];
var _ofdmframesync_execute = Module["_ofdmframesync_execute"] = asm["_ofdmframesync_execute"];
var _modem_arb_init = Module["_modem_arb_init"] = asm["_modem_arb_init"];
var _fec_secded3932_create = Module["_fec_secded3932_create"] = asm["_fec_secded3932_create"];
var _flexframegen_assemble = Module["_flexframegen_assemble"] = asm["_flexframegen_assemble"];
var _jsonp_error_set_source = Module["_jsonp_error_set_source"] = asm["_jsonp_error_set_source"];
var _matrixf_mul = Module["_matrixf_mul"] = asm["_matrixf_mul"];
var _fecsoft_hamming84_decode = Module["_fecsoft_hamming84_decode"] = asm["_fecsoft_hamming84_decode"];
var _strchr = Module["_strchr"] = asm["_strchr"];
var _dotprod_rrrf_create = Module["_dotprod_rrrf_create"] = asm["_dotprod_rrrf_create"];
var _liquid_bdotprod = Module["_liquid_bdotprod"] = asm["_liquid_bdotprod"];
var _qpilotsync_execute = Module["_qpilotsync_execute"] = asm["_qpilotsync_execute"];
var _fec_secded3932_destroy = Module["_fec_secded3932_destroy"] = asm["_fec_secded3932_destroy"];
var _fft_execute = Module["_fft_execute"] = asm["_fft_execute"];
var _parse_json = Module["_parse_json"] = asm["_parse_json"];
var _gmskframegen_assemble = Module["_gmskframegen_assemble"] = asm["_gmskframegen_assemble"];
var _bessel_azpkf = Module["_bessel_azpkf"] = asm["_bessel_azpkf"];
var _firdecim_crcf_destroy = Module["_firdecim_crcf_destroy"] = asm["_firdecim_crcf_destroy"];
var _detector_cccf_reset = Module["_detector_cccf_reset"] = asm["_detector_cccf_reset"];
var _vsnprintf = Module["_vsnprintf"] = asm["_vsnprintf"];
var _firinterp_crcf_create_prototype = Module["_firinterp_crcf_create_prototype"] = asm["_firinterp_crcf_create_prototype"];
var _firpfb_rrrf_create_rnyquist = Module["_firpfb_rrrf_create_rnyquist"] = asm["_firpfb_rrrf_create_rnyquist"];
var _liquid_firdes_rfarcsech = Module["_liquid_firdes_rfarcsech"] = asm["_liquid_firdes_rfarcsech"];
var _fec_conv_punctured_encode = Module["_fec_conv_punctured_encode"] = asm["_fec_conv_punctured_encode"];
var _rkaiser_approximate_rho = Module["_rkaiser_approximate_rho"] = asm["_rkaiser_approximate_rho"];
var _poly_fit_lagrange_barycentric = Module["_poly_fit_lagrange_barycentric"] = asm["_poly_fit_lagrange_barycentric"];
var _fprintf = Module["_fprintf"] = asm["_fprintf"];
var _sprintf = Module["_sprintf"] = asm["_sprintf"];
var _gray_decode = Module["_gray_decode"] = asm["_gray_decode"];
var _detector_cccf_update_sumsq = Module["_detector_cccf_update_sumsq"] = asm["_detector_cccf_update_sumsq"];
var _strbuffer_close = Module["_strbuffer_close"] = asm["_strbuffer_close"];
var _ofdmframesync_execute_S0b = Module["_ofdmframesync_execute_S0b"] = asm["_ofdmframesync_execute_S0b"];
var _liquid_fft_estimate_method = Module["_liquid_fft_estimate_method"] = asm["_liquid_fft_estimate_method"];
var _qpilotsync_create = Module["_qpilotsync_create"] = asm["_qpilotsync_create"];
var _jsonp_error_set = Module["_jsonp_error_set"] = asm["_jsonp_error_set"];
var _modulator_emit = Module["_modulator_emit"] = asm["_modulator_emit"];
var _quiet_encoder_destroy = Module["_quiet_encoder_destroy"] = asm["_quiet_encoder_destroy"];
var _gmskframesync_pushpn = Module["_gmskframesync_pushpn"] = asm["_gmskframesync_pushpn"];
var _ellip_azpkf = Module["_ellip_azpkf"] = asm["_ellip_azpkf"];
var _liquid_pack_bytes = Module["_liquid_pack_bytes"] = asm["_liquid_pack_bytes"];
var _polyf_val = Module["_polyf_val"] = asm["_polyf_val"];
var _demodulator_create = Module["_demodulator_create"] = asm["_demodulator_create"];
var _logbf = Module["_logbf"] = asm["_logbf"];
var _estimate_req_filter_As = Module["_estimate_req_filter_As"] = asm["_estimate_req_filter_As"];
var _fec_get_rate = Module["_fec_get_rate"] = asm["_fec_get_rate"];
var _fclose = Module["_fclose"] = asm["_fclose"];
var _firinterp_rrrf_destroy = Module["_firinterp_rrrf_destroy"] = asm["_firinterp_rrrf_destroy"];
var _parse_value = Module["_parse_value"] = asm["_parse_value"];
var _ofdmflexframesync_debug_enable = Module["_ofdmflexframesync_debug_enable"] = asm["_ofdmflexframesync_debug_enable"];
var _liquid_getopt_str2crc = Module["_liquid_getopt_str2crc"] = asm["_liquid_getopt_str2crc"];
var _liquid_factor = Module["_liquid_factor"] = asm["_liquid_factor"];
var _insert_to_bucket = Module["_insert_to_bucket"] = asm["_insert_to_bucket"];
var _liquid_firdes_rfexp = Module["_liquid_firdes_rfexp"] = asm["_liquid_firdes_rfexp"];
var _ofdm_subcarriers_create = Module["_ofdm_subcarriers_create"] = asm["_ofdm_subcarriers_create"];
var _lex_unget = Module["_lex_unget"] = asm["_lex_unget"];
var _fft_execute_radix2 = Module["_fft_execute_radix2"] = asm["_fft_execute_radix2"];
var _liquid_is_prime = Module["_liquid_is_prime"] = asm["_liquid_is_prime"];
var _fec_rs_setlength = Module["_fec_rs_setlength"] = asm["_fec_rs_setlength"];
var _decode_unicode_escape = Module["_decode_unicode_escape"] = asm["_decode_unicode_escape"];
var _gmskframesync_debug_print = Module["_gmskframesync_debug_print"] = asm["_gmskframesync_debug_print"];
var _ofdmflexframegen_reset = Module["_ofdmflexframegen_reset"] = asm["_ofdmflexframegen_reset"];
var _json_true = Module["_json_true"] = asm["_json_true"];
var _qpilotgen_execute = Module["_qpilotgen_execute"] = asm["_qpilotgen_execute"];
var _modem_destroy = Module["_modem_destroy"] = asm["_modem_destroy"];
var _sinhf = Module["_sinhf"] = asm["_sinhf"];
var _json_array = Module["_json_array"] = asm["_json_array"];
var _wdelayf_destroy = Module["_wdelayf_destroy"] = asm["_wdelayf_destroy"];
var _modulator_destroy = Module["_modulator_destroy"] = asm["_modulator_destroy"];
var _qpacketmodem_encode = Module["_qpacketmodem_encode"] = asm["_qpacketmodem_encode"];
var _fft_reverse_index = Module["_fft_reverse_index"] = asm["_fft_reverse_index"];
var ___stdio_read = Module["___stdio_read"] = asm["___stdio_read"];
var _liquid_primitive_root_prime = Module["_liquid_primitive_root_prime"] = asm["_liquid_primitive_root_prime"];
var _liquid_iirdes = Module["_liquid_iirdes"] = asm["_liquid_iirdes"];
var _iirfilt_crcf_create_sos = Module["_iirfilt_crcf_create_sos"] = asm["_iirfilt_crcf_create_sos"];
var _fec_secded2216_destroy = Module["_fec_secded2216_destroy"] = asm["_fec_secded2216_destroy"];
var _modulator_sample_len = Module["_modulator_sample_len"] = asm["_modulator_sample_len"];
var _fec_hamming74_decode = Module["_fec_hamming74_decode"] = asm["_fec_hamming74_decode"];
var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
var _fec_conv_punctured_decode_soft = Module["_fec_conv_punctured_decode_soft"] = asm["_fec_conv_punctured_decode_soft"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _interleaver_destroy = Module["_interleaver_destroy"] = asm["_interleaver_destroy"];
var _fec_conv_destroy = Module["_fec_conv_destroy"] = asm["_fec_conv_destroy"];
var _framedatastats_reset = Module["_framedatastats_reset"] = asm["_framedatastats_reset"];
var _wdelayf_push = Module["_wdelayf_push"] = asm["_wdelayf_push"];
var _wdelayf_create = Module["_wdelayf_create"] = asm["_wdelayf_create"];
var _hypot = Module["_hypot"] = asm["_hypot"];
var _seed_from_timestamp_and_pid = Module["_seed_from_timestamp_and_pid"] = asm["_seed_from_timestamp_and_pid"];
var _copysignf = Module["_copysignf"] = asm["_copysignf"];
var ___shlim = Module["___shlim"] = asm["___shlim"];
var _fec_rs_create = Module["_fec_rs_create"] = asm["_fec_rs_create"];
var _hypotf = Module["_hypotf"] = asm["_hypotf"];
var _copysignl = Module["_copysignl"] = asm["_copysignl"];
var ___intscan = Module["___intscan"] = asm["___intscan"];
var _fec_conv_punctured_decode_hard = Module["_fec_conv_punctured_decode_hard"] = asm["_fec_conv_punctured_decode_hard"];
var _fec_rep3_encode = Module["_fec_rep3_encode"] = asm["_fec_rep3_encode"];
var _ccoshf = Module["_ccoshf"] = asm["_ccoshf"];
var _decoder_on_decode = Module["_decoder_on_decode"] = asm["_decoder_on_decode"];
var _firdespm_create = Module["_firdespm_create"] = asm["_firdespm_create"];
var ___toread = Module["___toread"] = asm["___toread"];
var _frexp = Module["_frexp"] = asm["_frexp"];
var _gmskframegen_set_header_len = Module["_gmskframegen_set_header_len"] = asm["_gmskframegen_set_header_len"];
var _hashtable_close = Module["_hashtable_close"] = asm["_hashtable_close"];
var _quiet_decoder_profile_str = Module["_quiet_decoder_profile_str"] = asm["_quiet_decoder_profile_str"];
var _liquid_reverse_uint32 = Module["_liquid_reverse_uint32"] = asm["_liquid_reverse_uint32"];
var _fmt_u = Module["_fmt_u"] = asm["_fmt_u"];
var _hashtable_find_pair = Module["_hashtable_find_pair"] = asm["_hashtable_find_pair"];
var _jsonp_strndup = Module["_jsonp_strndup"] = asm["_jsonp_strndup"];
var ___syscall_ret = Module["___syscall_ret"] = asm["___syscall_ret"];
var _fmodl = Module["_fmodl"] = asm["_fmodl"];
var _fec_rs_destroy = Module["_fec_rs_destroy"] = asm["_fec_rs_destroy"];
var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
var _modem_demodulate_psk = Module["_modem_demodulate_psk"] = asm["_modem_demodulate_psk"];
var _fec_create = Module["_fec_create"] = asm["_fec_create"];
var _modem_modulate_bpsk = Module["_modem_modulate_bpsk"] = asm["_modem_modulate_bpsk"];
var _fec_hamming128_decode = Module["_fec_hamming128_decode"] = asm["_fec_hamming128_decode"];
var _liquid_getopt_str2fec = Module["_liquid_getopt_str2fec"] = asm["_liquid_getopt_str2fec"];
var _firdespm_iext_search = Module["_firdespm_iext_search"] = asm["_firdespm_iext_search"];
var ___fdopen = Module["___fdopen"] = asm["___fdopen"];
var _nco_crcf_compute_sincos_vco = Module["_nco_crcf_compute_sincos_vco"] = asm["_nco_crcf_compute_sincos_vco"];
var _quiet_encoder_emit = Module["_quiet_encoder_emit"] = asm["_quiet_encoder_emit"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _json_object_set_nocheck = Module["_json_object_set_nocheck"] = asm["_json_object_set_nocheck"];
var _dotprod_crcf_create = Module["_dotprod_crcf_create"] = asm["_dotprod_crcf_create"];
var _ofdmframesync_S0_metrics = Module["_ofdmframesync_S0_metrics"] = asm["_ofdmframesync_S0_metrics"];
var _close = Module["_close"] = asm["_close"];
var _qpacketmodem_configure = Module["_qpacketmodem_configure"] = asm["_qpacketmodem_configure"];
var _sincf = Module["_sincf"] = asm["_sincf"];
var _gmskframegen_is_assembled = Module["_gmskframegen_is_assembled"] = asm["_gmskframegen_is_assembled"];
var ___stdout_write = Module["___stdout_write"] = asm["___stdout_write"];
var _csinf = Module["_csinf"] = asm["_csinf"];
var _sn_write = Module["_sn_write"] = asm["_sn_write"];
var _fec_decode = Module["_fec_decode"] = asm["_fec_decode"];
var _qpacketmodem_get_modscheme = Module["_qpacketmodem_get_modscheme"] = asm["_qpacketmodem_get_modscheme"];
var _constrained_write = Module["_constrained_write"] = asm["_constrained_write"];
var _packetizer_decode = Module["_packetizer_decode"] = asm["_packetizer_decode"];
var _ofdmflexframegen_reconfigure = Module["_ofdmflexframegen_reconfigure"] = asm["_ofdmflexframegen_reconfigure"];
var _ofdmframesync_debug_enable = Module["_ofdmframesync_debug_enable"] = asm["_ofdmframesync_debug_enable"];
var _erff = Module["_erff"] = asm["_erff"];
var _json_string_value = Module["_json_string_value"] = asm["_json_string_value"];
var _kaiser = Module["_kaiser"] = asm["_kaiser"];
var _ofdmflexframegen_writesymbol = Module["_ofdmflexframegen_writesymbol"] = asm["_ofdmflexframegen_writesymbol"];
var _crc16_generate_key = Module["_crc16_generate_key"] = asm["_crc16_generate_key"];
var _fec_rep5_create = Module["_fec_rep5_create"] = asm["_fec_rep5_create"];
var _firdespm_compute_taps = Module["_firdespm_compute_taps"] = asm["_firdespm_compute_taps"];
var _lex_get = Module["_lex_get"] = asm["_lex_get"];
var _try_realloc_chunk = Module["_try_realloc_chunk"] = asm["_try_realloc_chunk"];
var _gmskframegen_reset = Module["_gmskframegen_reset"] = asm["_gmskframegen_reset"];
var _stream_unget = Module["_stream_unget"] = asm["_stream_unget"];
var _fec_rep5_decode_soft = Module["_fec_rep5_decode_soft"] = asm["_fec_rep5_decode_soft"];
var ___divsc3 = Module["___divsc3"] = asm["___divsc3"];
var _json_array_grow = Module["_json_array_grow"] = asm["_json_array_grow"];
var _qdetector_cccf_set_threshold = Module["_qdetector_cccf_set_threshold"] = asm["_qdetector_cccf_set_threshold"];
var _modem_modulate_qpsk = Module["_modem_modulate_qpsk"] = asm["_modem_modulate_qpsk"];
var _json_delete = Module["_json_delete"] = asm["_json_delete"];
var _gmskmod_create = Module["_gmskmod_create"] = asm["_gmskmod_create"];
var _fec_secded2216_create = Module["_fec_secded2216_create"] = asm["_fec_secded2216_create"];
var _log10f = Module["_log10f"] = asm["_log10f"];
var _windowcf_push = Module["_windowcf_push"] = asm["_windowcf_push"];
var _quiet_decoder_create = Module["_quiet_decoder_create"] = asm["_quiet_decoder_create"];
var _liquid_unpack_array = Module["_liquid_unpack_array"] = asm["_liquid_unpack_array"];
var _llvm_cttz_i32 = Module["_llvm_cttz_i32"] = asm["_llvm_cttz_i32"];
var _fec_secded2216_compute_parity = Module["_fec_secded2216_compute_parity"] = asm["_fec_secded2216_compute_parity"];
var _liquid_firdes_prototype = Module["_liquid_firdes_prototype"] = asm["_liquid_firdes_prototype"];
var _firdecim_crcf_execute = Module["_firdecim_crcf_execute"] = asm["_firdecim_crcf_execute"];
var _json_object_seed = Module["_json_object_seed"] = asm["_json_object_seed"];
var _lex_steal_string = Module["_lex_steal_string"] = asm["_lex_steal_string"];
var _fec_hamming128_encode = Module["_fec_hamming128_encode"] = asm["_fec_hamming128_encode"];
var _strtox = Module["_strtox"] = asm["_strtox"];
var _jsonp_strtod = Module["_jsonp_strtod"] = asm["_jsonp_strtod"];
var _liquid_firdes_fexp_freqresponse = Module["_liquid_firdes_fexp_freqresponse"] = asm["_liquid_firdes_fexp_freqresponse"];
var _fft_execute_dft = Module["_fft_execute_dft"] = asm["_fft_execute_dft"];
var _wdelayf_clear = Module["_wdelayf_clear"] = asm["_wdelayf_clear"];
var _ofdmframesync_get_cfo = Module["_ofdmframesync_get_cfo"] = asm["_ofdmframesync_get_cfo"];
var _fft_destroy_plan = Module["_fft_destroy_plan"] = asm["_fft_destroy_plan"];
var _printf = Module["_printf"] = asm["_printf"];
var _fmaxf = Module["_fmaxf"] = asm["_fmaxf"];
var _liquid_repack_bytes = Module["_liquid_repack_bytes"] = asm["_liquid_repack_bytes"];
var _json_loads = Module["_json_loads"] = asm["_json_loads"];
var _msequence_create_default = Module["_msequence_create_default"] = asm["_msequence_create_default"];
var _fec_golay2412_encode = Module["_fec_golay2412_encode"] = asm["_fec_golay2412_encode"];
var _nco_crcf_pll_set_bandwidth = Module["_nco_crcf_pll_set_bandwidth"] = asm["_nco_crcf_pll_set_bandwidth"];
var _liquid_firdes_rkaiser_internal_isi = Module["_liquid_firdes_rkaiser_internal_isi"] = asm["_liquid_firdes_rkaiser_internal_isi"];
var _lex_init = Module["_lex_init"] = asm["_lex_init"];
var _ofdmflexframegen_is_assembled = Module["_ofdmflexframegen_is_assembled"] = asm["_ofdmflexframegen_is_assembled"];
var _generate_seed = Module["_generate_seed"] = asm["_generate_seed"];
var _firpfb_rrrf_push = Module["_firpfb_rrrf_push"] = asm["_firpfb_rrrf_push"];
var _read = Module["_read"] = asm["_read"];
var _string_get = Module["_string_get"] = asm["_string_get"];
var _nco_crcf_pll_step = Module["_nco_crcf_pll_step"] = asm["_nco_crcf_pll_step"];
var _modem_create = Module["_modem_create"] = asm["_modem_create"];
var _json_real_value = Module["_json_real_value"] = asm["_json_real_value"];
var _qdetector_cccf_get_gamma = Module["_qdetector_cccf_get_gamma"] = asm["_qdetector_cccf_get_gamma"];
var _fft_create_plan_radix2 = Module["_fft_create_plan_radix2"] = asm["_fft_create_plan_radix2"];
var _utf8_encode = Module["_utf8_encode"] = asm["_utf8_encode"];
var _windowcf_read = Module["_windowcf_read"] = asm["_windowcf_read"];
var _fec_rs_decode = Module["_fec_rs_decode"] = asm["_fec_rs_decode"];
var _roundf = Module["_roundf"] = asm["_roundf"];
var _fec_conv_create = Module["_fec_conv_create"] = asm["_fec_conv_create"];
var _seed_from_urandom = Module["_seed_from_urandom"] = asm["_seed_from_urandom"];
var _fec_pass_destroy = Module["_fec_pass_destroy"] = asm["_fec_pass_destroy"];
var _modem_demodsoft_gentab = Module["_modem_demodsoft_gentab"] = asm["_modem_demodsoft_gentab"];
var _windowf_clear = Module["_windowf_clear"] = asm["_windowf_clear"];
var _qpilotsync_get_frame_len = Module["_qpilotsync_get_frame_len"] = asm["_qpilotsync_get_frame_len"];
var _fmod = Module["_fmod"] = asm["_fmod"];
var _dotprod_rrrf_destroy = Module["_dotprod_rrrf_destroy"] = asm["_dotprod_rrrf_destroy"];
var _fec_hamming74_decode_soft = Module["_fec_hamming74_decode_soft"] = asm["_fec_hamming74_decode_soft"];
var _array_copy = Module["_array_copy"] = asm["_array_copy"];
var _liquid_unpack_array_block = Module["_liquid_unpack_array_block"] = asm["_liquid_unpack_array_block"];
var _firinterp_rrrf_create = Module["_firinterp_rrrf_create"] = asm["_firinterp_rrrf_create"];
var _gmskframesync_decode_header = Module["_gmskframesync_decode_header"] = asm["_gmskframesync_decode_header"];
var _quiet_encoder_sample_len = Module["_quiet_encoder_sample_len"] = asm["_quiet_encoder_sample_len"];
var _cabsf = Module["_cabsf"] = asm["_cabsf"];
var _strbuffer_init = Module["_strbuffer_init"] = asm["_strbuffer_init"];
var _fec_golay2412_decode_symbol = Module["_fec_golay2412_decode_symbol"] = asm["_fec_golay2412_decode_symbol"];
var _qpilotgen_create = Module["_qpilotgen_create"] = asm["_qpilotgen_create"];
var _liquid_cplxpair = Module["_liquid_cplxpair"] = asm["_liquid_cplxpair"];
var ___overflow = Module["___overflow"] = asm["___overflow"];
var _firdecim_crcf_create = Module["_firdecim_crcf_create"] = asm["_firdecim_crcf_create"];
var _lex_get_save = Module["_lex_get_save"] = asm["_lex_get_save"];
var _memset = Module["_memset"] = asm["_memset"];
var _open = Module["_open"] = asm["_open"];
var _flexframesync_decode_header = Module["_flexframesync_decode_header"] = asm["_flexframesync_decode_header"];
var _json_incref = Module["_json_incref"] = asm["_json_incref"];
var _firpfb_crcf_destroy = Module["_firpfb_crcf_destroy"] = asm["_firpfb_crcf_destroy"];
var _json_delete_array = Module["_json_delete_array"] = asm["_json_delete_array"];
var _qdetector_cccf_get_tau = Module["_qdetector_cccf_get_tau"] = asm["_qdetector_cccf_get_tau"];
var _ofdmflexframesync_set_header_len = Module["_ofdmflexframesync_set_header_len"] = asm["_ofdmflexframesync_set_header_len"];
var _jsonp_error_init = Module["_jsonp_error_init"] = asm["_jsonp_error_init"];
var _modem_modulate_sqam32 = Module["_modem_modulate_sqam32"] = asm["_modem_modulate_sqam32"];
var _hashtable_get = Module["_hashtable_get"] = asm["_hashtable_get"];
var ___floatscan = Module["___floatscan"] = asm["___floatscan"];
var ___fflush_unlocked = Module["___fflush_unlocked"] = asm["___fflush_unlocked"];
var _hashtable_do_rehash = Module["_hashtable_do_rehash"] = asm["_hashtable_do_rehash"];
var _nco_crcf_create = Module["_nco_crcf_create"] = asm["_nco_crcf_create"];
var _fec_rep3_create = Module["_fec_rep3_create"] = asm["_fec_rep3_create"];
var _ofdmflexframesync_decode_header = Module["_ofdmflexframesync_decode_header"] = asm["_ofdmflexframesync_decode_header"];
var _gmskframegen_write_samples = Module["_gmskframegen_write_samples"] = asm["_gmskframegen_write_samples"];
var _iirfilt_crcf_create = Module["_iirfilt_crcf_create"] = asm["_iirfilt_crcf_create"];
var _qpilotsync_get_phi = Module["_qpilotsync_get_phi"] = asm["_qpilotsync_get_phi"];
var _fec_golay2412_create = Module["_fec_golay2412_create"] = asm["_fec_golay2412_create"];
var _dispose_chunk = Module["_dispose_chunk"] = asm["_dispose_chunk"];
var _list_init = Module["_list_init"] = asm["_list_init"];
var _fec_hamming74_create = Module["_fec_hamming74_create"] = asm["_fec_hamming74_create"];
var _demodulator_destroy = Module["_demodulator_destroy"] = asm["_demodulator_destroy"];
var _liquid_pack_array = Module["_liquid_pack_array"] = asm["_liquid_pack_array"];
var _fft_run = Module["_fft_run"] = asm["_fft_run"];
var _flexframesync_debug_enable = Module["_flexframesync_debug_enable"] = asm["_flexframesync_debug_enable"];
var _bucket_is_empty = Module["_bucket_is_empty"] = asm["_bucket_is_empty"];
var ___ldexp_cexpf = Module["___ldexp_cexpf"] = asm["___ldexp_cexpf"];
var _modem_create_apsk = Module["_modem_create_apsk"] = asm["_modem_create_apsk"];
var _ofdmflexframegen_getframelen = Module["_ofdmflexframegen_getframelen"] = asm["_ofdmflexframegen_getframelen"];
var _jsonp_malloc = Module["_jsonp_malloc"] = asm["_jsonp_malloc"];
var _scanexp = Module["_scanexp"] = asm["_scanexp"];
var _calloc = Module["_calloc"] = asm["_calloc"];
var _fmax = Module["_fmax"] = asm["_fmax"];
var _iirfilt_crcf_create_prototype = Module["_iirfilt_crcf_create_prototype"] = asm["_iirfilt_crcf_create_prototype"];
var _ofdmframe_init_S1 = Module["_ofdmframe_init_S1"] = asm["_ofdmframe_init_S1"];
var _ofdmframe_init_S0 = Module["_ofdmframe_init_S0"] = asm["_ofdmframe_init_S0"];
var _stream_init = Module["_stream_init"] = asm["_stream_init"];
var _ofdmflexframegen_write_header = Module["_ofdmflexframegen_write_header"] = asm["_ofdmflexframegen_write_header"];
var _liquid_modpow = Module["_liquid_modpow"] = asm["_liquid_modpow"];
var _strerror = Module["_strerror"] = asm["_strerror"];
var _strbuffer_value = Module["_strbuffer_value"] = asm["_strbuffer_value"];
var _packetizer_encode = Module["_packetizer_encode"] = asm["_packetizer_encode"];
var _qdetector_cccf_execute_align = Module["_qdetector_cccf_execute_align"] = asm["_qdetector_cccf_execute_align"];
var _ofdmflexframegen_write_payload = Module["_ofdmflexframegen_write_payload"] = asm["_ofdmflexframegen_write_payload"];
var _realloc = Module["_realloc"] = asm["_realloc"];
var _gmskframesync_execute_rxpayload = Module["_gmskframesync_execute_rxpayload"] = asm["_gmskframesync_execute_rxpayload"];
var _fputs = Module["_fputs"] = asm["_fputs"];
var _strtod = Module["_strtod"] = asm["_strtod"];
var _strbuffer_append_bytes = Module["_strbuffer_append_bytes"] = asm["_strbuffer_append_bytes"];
var _ofdmframegen_write_S1 = Module["_ofdmframegen_write_S1"] = asm["_ofdmframegen_write_S1"];
var _firpfb_crcf_create_rnyquist = Module["_firpfb_crcf_create_rnyquist"] = asm["_firpfb_crcf_create_rnyquist"];
var _nco_crcf_step = Module["_nco_crcf_step"] = asm["_nco_crcf_step"];
var _flexframegen_set_header_len = Module["_flexframegen_set_header_len"] = asm["_flexframegen_set_header_len"];
var _windowcf_clear = Module["_windowcf_clear"] = asm["_windowcf_clear"];
var _fec_secded3932_encode = Module["_fec_secded3932_encode"] = asm["_fec_secded3932_encode"];
var _fec_encode = Module["_fec_encode"] = asm["_fec_encode"];
var _liquid_firdes_arkaiser = Module["_liquid_firdes_arkaiser"] = asm["_liquid_firdes_arkaiser"];
var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
var _lex_unget_unsave = Module["_lex_unget_unsave"] = asm["_lex_unget_unsave"];
var _fft_execute_rader = Module["_fft_execute_rader"] = asm["_fft_execute_rader"];
var ___fwritex = Module["___fwritex"] = asm["___fwritex"];
var _qpacketmodem_get_crc = Module["_qpacketmodem_get_crc"] = asm["_qpacketmodem_get_crc"];
function b0(p0, p1, p2, p3, p4, p5, p6) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 p6 = p6 | 0;
 abort(0);
 return 0;
}
function b1(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(1);
 return 0;
}
function _update_viterbi27_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi27_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function _update_viterbi29_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi29_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function _update_viterbi39_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi39_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function _update_viterbi615_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi615_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function b2(p0) {
 p0 = p0 | 0;
 abort(2);
}
function _delete_viterbi27__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi27(p0 | 0);
}
function _delete_viterbi29__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi29(p0 | 0);
}
function _delete_viterbi39__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi39(p0 | 0);
}
function _delete_viterbi615__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi615(p0 | 0);
}
function b3(p0) {
 p0 = p0 | 0;
 abort(3);
 return 0;
}
function _create_viterbi27__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi27(p0 | 0) | 0;
}
function _create_viterbi29__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi29(p0 | 0) | 0;
}
function _create_viterbi39__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi39(p0 | 0) | 0;
}
function _create_viterbi615__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi615(p0 | 0) | 0;
}
function b4(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(4);
}
function b5(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(5);
 return 0;
}
function _chainback_viterbi27__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi27(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function _chainback_viterbi29__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi29(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function _chainback_viterbi39__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi39(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function _chainback_viterbi615__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi615(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function b6(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(6);
 return 0;
}
function _init_viterbi27__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi27(p0 | 0, p1 | 0) | 0;
}
function _init_viterbi29__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi29(p0 | 0, p1 | 0) | 0;
}
function _init_viterbi39__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi39(p0 | 0, p1 | 0) | 0;
}
function _init_viterbi615__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi615(p0 | 0, p1 | 0) | 0;
}
function b7(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(7);
}
var FUNCTION_TABLE_iiiiiiii = [ b0, asm["_decoder_on_decode"] ];
var FUNCTION_TABLE_iiii = [ b1, asm["___stdio_write"], asm["___stdio_seek"], asm["___stdout_write"], asm["_sn_write"], _update_viterbi27_blk__wrapper, _update_viterbi29_blk__wrapper, _update_viterbi39_blk__wrapper, _update_viterbi615_blk__wrapper, asm["___stdio_read"], b1, b1, b1, b1, b1, b1 ];
var FUNCTION_TABLE_vi = [ b2, asm["_free"], _delete_viterbi27__wrapper, _delete_viterbi29__wrapper, _delete_viterbi39__wrapper, _delete_viterbi615__wrapper, asm["_nco_crcf_compute_sincos_nco"], asm["_nco_crcf_compute_sincos_vco"], asm["_fft_execute_radix2"], asm["_fft_execute_mixed_radix"], asm["_fft_execute_rader"], asm["_fft_execute_rader2"], asm["_fft_execute_dft_2"], asm["_fft_execute_dft_3"], asm["_fft_execute_dft_4"], asm["_fft_execute_dft_5"], asm["_fft_execute_dft_6"], asm["_fft_execute_dft_7"], asm["_fft_execute_dft_8"], asm["_fft_execute_dft_16"], asm["_fft_execute_dft"], asm["_cleanup_387"], asm["_cleanup_382"], b2, b2, b2, b2, b2, b2, b2, b2, b2 ];
var FUNCTION_TABLE_ii = [ b3, asm["_malloc"], asm["___stdio_close"], _create_viterbi27__wrapper, _create_viterbi29__wrapper, _create_viterbi39__wrapper, _create_viterbi615__wrapper, asm["_string_get"] ];
var FUNCTION_TABLE_viii = [ b4, asm["_modem_modulate_dpsk"], asm["_modem_demodulate_dpsk"], asm["_modem_modulate_ask"], asm["_modem_demodulate_ask"], asm["_modem_modulate_bpsk"], asm["_modem_demodulate_bpsk"], asm["_modem_modulate_qpsk"], asm["_modem_demodulate_qpsk"], asm["_modem_modulate_ook"], asm["_modem_demodulate_ook"], asm["_modem_modulate_sqam32"], asm["_modem_demodulate_sqam32"], asm["_modem_modulate_sqam128"], asm["_modem_demodulate_sqam128"], asm["_modem_modulate_arb"], asm["_modem_demodulate_arb"], asm["_modem_modulate_psk"], asm["_modem_demodulate_psk"], asm["_modem_modulate_qam"], asm["_modem_demodulate_qam"], asm["_modem_modulate_apsk"], asm["_modem_demodulate_apsk"], b4, b4, b4, b4, b4, b4, b4, b4, b4 ];
var FUNCTION_TABLE_iiiii = [ b5, _chainback_viterbi27__wrapper, _chainback_viterbi29__wrapper, _chainback_viterbi39__wrapper, _chainback_viterbi615__wrapper, asm["_ofdmflexframesync_internal_callback"], b5, b5 ];
var FUNCTION_TABLE_iii = [ b6, _init_viterbi27__wrapper, _init_viterbi29__wrapper, _init_viterbi39__wrapper, _init_viterbi615__wrapper, b6, b6, b6 ];
var FUNCTION_TABLE_viiii = [ b7, asm["_fec_conv_encode"], asm["_fec_conv_decode_hard"], asm["_fec_conv_decode_soft"], asm["_fec_conv_punctured_encode"], asm["_fec_conv_punctured_decode_hard"], asm["_fec_conv_punctured_decode_soft"], asm["_fec_golay2412_encode"], asm["_fec_golay2412_decode"], asm["_fec_hamming74_encode"], asm["_fec_hamming74_decode"], asm["_fec_hamming74_decode_soft"], asm["_fec_hamming84_encode"], asm["_fec_hamming84_decode"], asm["_fec_hamming84_decode_soft"], asm["_fec_hamming128_encode"], asm["_fec_hamming128_decode"], asm["_fec_hamming128_decode_soft"], asm["_fec_pass_encode"], asm["_fec_pass_decode"], asm["_fec_rep3_encode"], asm["_fec_rep3_decode"], asm["_fec_rep3_decode_soft"], asm["_fec_rep5_encode"], asm["_fec_rep5_decode"], asm["_fec_rep5_decode_soft"], asm["_fec_rs_encode"], asm["_fec_rs_decode"], asm["_fec_secded2216_encode"], asm["_fec_secded2216_decode"], asm["_fec_secded3932_encode"], asm["_fec_secded3932_decode"], asm["_fec_secded7264_encode"], asm["_fec_secded7264_decode"], b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7 ];
Module["dynCall_iiiiiiii"] = dynCall_iiiiiiii;
Module["dynCall_iiii"] = dynCall_iiii;
Module["dynCall_vi"] = dynCall_vi;
Module["dynCall_ii"] = dynCall_ii;
Module["dynCall_viii"] = dynCall_viii;
Module["dynCall_iiiii"] = dynCall_iiiii;
Module["dynCall_iii"] = dynCall_iii;
Module["dynCall_viiii"] = dynCall_viiii;
Module["FUNCTION_TABLE_iiiiiiii"] = FUNCTION_TABLE_iiiiiiii;
Module["FUNCTION_TABLE_iiii"] = FUNCTION_TABLE_iiii;
Module["FUNCTION_TABLE_vi"] = FUNCTION_TABLE_vi;
Module["FUNCTION_TABLE_ii"] = FUNCTION_TABLE_ii;
Module["FUNCTION_TABLE_viii"] = FUNCTION_TABLE_viii;
Module["FUNCTION_TABLE_iiiii"] = FUNCTION_TABLE_iiiii;
Module["FUNCTION_TABLE_iii"] = FUNCTION_TABLE_iii;
Module["FUNCTION_TABLE_viiii"] = FUNCTION_TABLE_viiii;
var NAMED_GLOBALS = {
 "str": 10022
};
for (var named in NAMED_GLOBALS) {
 Module["_" + named] = gb + NAMED_GLOBALS[named];
}
Module["NAMED_GLOBALS"] = NAMED_GLOBALS;
Runtime.stackAlloc = asm["stackAlloc"];
Runtime.stackSave = asm["stackSave"];
Runtime.stackRestore = asm["stackRestore"];
Runtime.establishStackSpace = asm["establishStackSpace"];
if (memoryInitializer) {
 if (typeof Module["locateFile"] === "function") {
  memoryInitializer = Module["locateFile"](memoryInitializer);
 } else if (Module["memoryInitializerPrefixURL"]) {
  memoryInitializer = Module["memoryInitializerPrefixURL"] + memoryInitializer;
 }
 if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
  var data = Module["readBinary"](memoryInitializer);
  HEAPU8.set(data, Runtime.GLOBAL_BASE);
 } else {
  addRunDependency("memory initializer");
  var applyMemoryInitializer = (function(data) {
   if (data.byteLength) data = new Uint8Array(data);
   HEAPU8.set(data, Runtime.GLOBAL_BASE);
   if (Module["memoryInitializerRequest"]) delete Module["memoryInitializerRequest"].response;
   removeRunDependency("memory initializer");
  });
  function doBrowserLoad() {
   Module["readAsync"](memoryInitializer, applyMemoryInitializer, (function() {
    throw "could not load memory initializer " + memoryInitializer;
   }));
  }
  if (Module["memoryInitializerRequest"]) {
   function useRequest() {
    var request = Module["memoryInitializerRequest"];
    if (request.status !== 200 && request.status !== 0) {
     console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
     doBrowserLoad();
     return;
    }
    applyMemoryInitializer(request.response);
   }
   if (Module["memoryInitializerRequest"].response) {
    setTimeout(useRequest, 0);
   } else {
    Module["memoryInitializerRequest"].addEventListener("load", useRequest);
   }
  } else {
   doBrowserLoad();
  }
 }
}
function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}
ExitStatus.prototype = new Error;
ExitStatus.prototype.constructor = ExitStatus;
var initialStackTop;
var preloadStartTime = null;
var calledMain = false;
dependenciesFulfilled = function runCaller() {
 if (!Module["calledRun"]) run();
 if (!Module["calledRun"]) dependenciesFulfilled = runCaller;
};
Module["callMain"] = Module.callMain = function callMain(args) {
 args = args || [];
 ensureInitRuntime();
 var argc = args.length + 1;
 function pad() {
  for (var i = 0; i < 4 - 1; i++) {
   argv.push(0);
  }
 }
 var argv = [ allocate(intArrayFromString(Module["thisProgram"]), "i8", ALLOC_NORMAL) ];
 pad();
 for (var i = 0; i < argc - 1; i = i + 1) {
  argv.push(allocate(intArrayFromString(args[i]), "i8", ALLOC_NORMAL));
  pad();
 }
 argv.push(0);
 argv = allocate(argv, "i32", ALLOC_NORMAL);
 try {
  var ret = Module["_main"](argc, argv, 0);
  exit(ret, true);
 } catch (e) {
  if (e instanceof ExitStatus) {
   return;
  } else if (e == "SimulateInfiniteLoop") {
   Module["noExitRuntime"] = true;
   return;
  } else {
   if (e && typeof e === "object" && e.stack) Module.printErr("exception thrown: " + [ e, e.stack ]);
   throw e;
  }
 } finally {
  calledMain = true;
 }
};
function run(args) {
 args = args || Module["arguments"];
 if (preloadStartTime === null) preloadStartTime = Date.now();
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) return;
 if (Module["calledRun"]) return;
 function doRun() {
  if (Module["calledRun"]) return;
  Module["calledRun"] = true;
  if (ABORT) return;
  ensureInitRuntime();
  preMain();
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  if (Module["_main"] && shouldRunNow) Module["callMain"](args);
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout((function() {
   setTimeout((function() {
    Module["setStatus"]("");
   }), 1);
   doRun();
  }), 1);
 } else {
  doRun();
 }
}
Module["run"] = Module.run = run;
function exit(status, implicit) {
 if (implicit && Module["noExitRuntime"]) {
  return;
 }
 if (Module["noExitRuntime"]) {} else {
  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;
  exitRuntime();
  if (Module["onExit"]) Module["onExit"](status);
 }
 if (ENVIRONMENT_IS_NODE) {
  process["exit"](status);
 } else if (ENVIRONMENT_IS_SHELL && typeof quit === "function") {
  quit(status);
 }
 throw new ExitStatus(status);
}
Module["exit"] = Module.exit = exit;
var abortDecorators = [];
function abort(what) {
 if (what !== undefined) {
  Module.print(what);
  Module.printErr(what);
  what = JSON.stringify(what);
 } else {
  what = "";
 }
 ABORT = true;
 EXITSTATUS = 1;
 var extra = "\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";
 var output = "abort(" + what + ") at " + stackTrace() + extra;
 if (abortDecorators) {
  abortDecorators.forEach((function(decorator) {
   output = decorator(output, what);
  }));
 }
 throw output;
}
Module["abort"] = Module.abort = abort;
if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}
var shouldRunNow = true;
if (Module["noInitialRun"]) {
 shouldRunNow = false;
}
run();




