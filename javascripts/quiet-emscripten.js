((function(global) {
 if (typeof global.SIMD === "undefined") {
  global.SIMD = {};
 }
 if (typeof module !== "undefined") {
  module.exports = global.SIMD;
 }
 var SIMD = global.SIMD;
 var _f32x4 = new Float32Array(4);
 var _f64x2 = new Float64Array(_f32x4.buffer);
 var _i32x4 = new Int32Array(_f32x4.buffer);
 var _i16x8 = new Int16Array(_f32x4.buffer);
 var _i8x16 = new Int8Array(_f32x4.buffer);
 var _ui32x4 = new Uint32Array(_f32x4.buffer);
 var _ui16x8 = new Uint16Array(_f32x4.buffer);
 var _ui8x16 = new Uint8Array(_f32x4.buffer);
 function convertValue(buffer, value) {
  buffer[0] = value;
  return buffer[0];
 }
 function convertArray(buffer, array) {
  for (var i = 0; i < array.length; i++) array[i] = convertValue(buffer, array[i]);
  return array;
 }
 function isInt32(o) {
  return (o | 0) === o;
 }
 function isTypedArray(o) {
  return o instanceof Int8Array || o instanceof Uint8Array || o instanceof Uint8ClampedArray || o instanceof Int16Array || o instanceof Uint16Array || o instanceof Int32Array || o instanceof Uint32Array || o instanceof Float32Array || o instanceof Float64Array;
 }
 function minNum(x, y) {
  return x != x ? y : y != y ? x : Math.min(x, y);
 }
 function maxNum(x, y) {
  return x != x ? y : y != y ? x : Math.max(x, y);
 }
 function clamp(a, min, max) {
  if (a < min) return min;
  if (a > max) return max;
  return a;
 }
 function simdCheckLaneIndex(index, lanes) {
  if (!isInt32(index)) throw new TypeError("Lane index must be an int32");
  if (index < 0 || index >= lanes) throw new RangeError("Lane index must be in bounds");
 }
 var lanes = [];
 function simdCreate(type) {
  return type.fn.apply(type.fn, lanes);
 }
 function simdToString(type, a) {
  a = type.fn.check(a);
  var str = "SIMD." + type.name + "(";
  str += type.fn.extractLane(a, 0);
  for (var i = 1; i < type.lanes; i++) {
   str += ", " + type.fn.extractLane(a, i);
  }
  return str + ")";
 }
 function simdToLocaleString(type, a) {
  a = type.fn.check(a);
  var str = "SIMD." + type.name + "(";
  str += type.fn.extractLane(a, 0).toLocaleString();
  for (var i = 1; i < type.lanes; i++) {
   str += ", " + type.fn.extractLane(a, i).toLocaleString();
  }
  return str + ")";
 }
 function simdSplat(type, s) {
  for (var i = 0; i < type.lanes; i++) lanes[i] = s;
  return simdCreate(type);
 }
 function simdReplaceLane(type, a, i, s) {
  a = type.fn.check(a);
  simdCheckLaneIndex(i, type.lanes);
  for (var j = 0; j < type.lanes; j++) lanes[j] = type.fn.extractLane(a, j);
  lanes[i] = s;
  return simdCreate(type);
 }
 function simdFrom(toType, fromType, a) {
  a = fromType.fn.check(a);
  for (var i = 0; i < fromType.lanes; i++) {
   var v = fromType.fn.extractLane(a, i);
   if (toType.minVal !== undefined && (v < toType.minVal || v > toType.maxVal)) {
    throw new RangeError("Can't convert value");
   }
   lanes[i] = v;
  }
  return simdCreate(toType);
 }
 function simdFromBits(toType, fromType, a) {
  a = fromType.fn.check(a);
  var newValue = new toType.fn;
  newValue.s_ = new toType.view(a.s_.buffer);
  return newValue;
 }
 function simdSelect(type, selector, a, b) {
  selector = type.boolType.fn.check(selector);
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) {
   lanes[i] = type.boolType.fn.extractLane(selector, i) ? type.fn.extractLane(a, i) : type.fn.extractLane(b, i);
  }
  return simdCreate(type);
 }
 function simdSwizzle(type, a, indices) {
  a = type.fn.check(a);
  for (var i = 0; i < indices.length; i++) {
   simdCheckLaneIndex(indices[i], type.lanes);
   lanes[i] = type.fn.extractLane(a, indices[i]);
  }
  return simdCreate(type);
 }
 function simdShuffle(type, a, b, indices) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < indices.length; i++) {
   simdCheckLaneIndex(indices[i], 2 * type.lanes);
   lanes[i] = indices[i] < type.lanes ? type.fn.extractLane(a, indices[i]) : type.fn.extractLane(b, indices[i] - type.lanes);
  }
  return simdCreate(type);
 }
 function unaryNeg(a) {
  return -a;
 }
 function unaryBitwiseNot(a) {
  return ~a;
 }
 function unaryLogicalNot(a) {
  return !a;
 }
 function simdUnaryOp(type, op, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i));
  return simdCreate(type);
 }
 function binaryAnd(a, b) {
  return a & b;
 }
 function binaryOr(a, b) {
  return a | b;
 }
 function binaryXor(a, b) {
  return a ^ b;
 }
 function binaryAdd(a, b) {
  return a + b;
 }
 function binarySub(a, b) {
  return a - b;
 }
 function binaryMul(a, b) {
  return a * b;
 }
 function binaryDiv(a, b) {
  return a / b;
 }
 var binaryImul;
 if (typeof Math.imul !== "undefined") {
  binaryImul = Math.imul;
 } else {
  binaryImul = (function(a, b) {
   var ah = a >>> 16 & 65535;
   var al = a & 65535;
   var bh = b >>> 16 & 65535;
   var bl = b & 65535;
   return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  });
 }
 function simdBinaryOp(type, op, a, b) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i), type.fn.extractLane(b, i));
  return simdCreate(type);
 }
 function binaryEqual(a, b) {
  return a == b;
 }
 function binaryNotEqual(a, b) {
  return a != b;
 }
 function binaryLess(a, b) {
  return a < b;
 }
 function binaryLessEqual(a, b) {
  return a <= b;
 }
 function binaryGreater(a, b) {
  return a > b;
 }
 function binaryGreaterEqual(a, b) {
  return a >= b;
 }
 function simdRelationalOp(type, op, a, b) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i), type.fn.extractLane(b, i));
  return simdCreate(type.boolType);
 }
 function simdAnyTrue(type, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) if (type.fn.extractLane(a, i)) return true;
  return false;
 }
 function simdAllTrue(type, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) if (!type.fn.extractLane(a, i)) return false;
  return true;
 }
 function binaryShiftLeft(a, bits) {
  return a << bits;
 }
 function binaryShiftRightArithmetic(a, bits) {
  return a >> bits;
 }
 function binaryShiftRightLogical(a, bits) {
  return a >>> bits;
 }
 function simdShiftOp(type, op, a, bits) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++) lanes[i] = op(type.fn.extractLane(a, i), bits);
  return simdCreate(type);
 }
 function simdLoad(type, tarray, index, count) {
  if (!isTypedArray(tarray)) throw new TypeError("The 1st argument must be a typed array.");
  if (!isInt32(index)) throw new TypeError("The 2nd argument must be an Int32.");
  var bpe = tarray.BYTES_PER_ELEMENT;
  var bytes = count * type.laneSize;
  if (index < 0 || index * bpe + bytes > tarray.byteLength) throw new RangeError("The value of index is invalid.");
  var newValue = type.fn();
  var dst = new Uint8Array(newValue.s_.buffer);
  var src = new Uint8Array(tarray.buffer, tarray.byteOffset + index * bpe, bytes);
  for (var i = 0; i < bytes; i++) {
   dst[i] = src[i];
  }
  for (var i = bytes; i < 16; ++i) {
   dst[i] = 0;
  }
  return newValue;
 }
 function simdStore(type, tarray, index, a, count) {
  if (!isTypedArray(tarray)) throw new TypeError("The 1st argument must be a typed array.");
  if (!isInt32(index)) throw new TypeError("The 2nd argument must be an Int32.");
  var bpe = tarray.BYTES_PER_ELEMENT;
  var bytes = count * type.laneSize;
  if (index < 0 || index * bpe + bytes > tarray.byteLength) throw new RangeError("The value of index is invalid.");
  a = type.fn.check(a);
  var src = new Uint8Array(a.s_.buffer);
  var dst = new Uint8Array(tarray.buffer, tarray.byteOffset + index * bpe, bytes);
  for (var i = 0; i < bytes; i++) {
   dst[i] = src[i];
  }
  return a;
 }
 if (typeof SIMD.Float32x4 === "undefined" || typeof SIMD.Float32x4.extractLane === "undefined") {
  SIMD.Float32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Float32x4)) {
    return new SIMD.Float32x4(s0, s1, s2, s3);
   }
   this.s_ = convertArray(_f32x4, new Float32Array([ s0, s1, s2, s3 ]));
  });
  SIMD.Float32x4.extractLane = (function(v, i) {
   v = SIMD.Float32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Float32x4.swizzle === "undefined") {
  SIMD.Float32x4.swizzle = (function(a, s0, s1, s2, s3) {
   return simdSwizzle(float32x4, a, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Float32x4.shuffle === "undefined") {
  SIMD.Float32x4.shuffle = (function(a, b, s0, s1, s2, s3) {
   return simdShuffle(float32x4, a, b, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Int32x4 === "undefined" || typeof SIMD.Int32x4.extractLane === "undefined") {
  SIMD.Int32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Int32x4)) {
    return new SIMD.Int32x4(s0, s1, s2, s3);
   }
   this.s_ = convertArray(_i32x4, new Int32Array([ s0, s1, s2, s3 ]));
  });
  SIMD.Int32x4.extractLane = (function(v, i) {
   v = SIMD.Int32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Int32x4.swizzle === "undefined") {
  SIMD.Int32x4.swizzle = (function(a, s0, s1, s2, s3) {
   return simdSwizzle(int32x4, a, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Int32x4.shuffle === "undefined") {
  SIMD.Int32x4.shuffle = (function(a, b, s0, s1, s2, s3) {
   return simdShuffle(int32x4, a, b, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Int16x8 === "undefined" || typeof SIMD.Int16x8.extractLane === "undefined") {
  SIMD.Int16x8 = (function(s0, s1, s2, s3, s4, s5, s6, s7) {
   if (!(this instanceof SIMD.Int16x8)) {
    return new SIMD.Int16x8(s0, s1, s2, s3, s4, s5, s6, s7);
   }
   this.s_ = convertArray(_i16x8, new Int16Array([ s0, s1, s2, s3, s4, s5, s6, s7 ]));
  });
  SIMD.Int16x8.extractLane = (function(v, i) {
   v = SIMD.Int16x8.check(v);
   simdCheckLaneIndex(i, 8);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Int16x8.swizzle === "undefined") {
  SIMD.Int16x8.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdSwizzle(int16x8, a, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Int16x8.shuffle === "undefined") {
  SIMD.Int16x8.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdShuffle(int16x8, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Int8x16 === "undefined" || typeof SIMD.Int8x16.extractLane === "undefined") {
  SIMD.Int8x16 = (function(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   if (!(this instanceof SIMD.Int8x16)) {
    return new SIMD.Int8x16(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15);
   }
   this.s_ = convertArray(_i8x16, new Int8Array([ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]));
  });
  SIMD.Int8x16.extractLane = (function(v, i) {
   v = SIMD.Int8x16.check(v);
   simdCheckLaneIndex(i, 16);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Int8x16.swizzle === "undefined") {
  SIMD.Int8x16.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdSwizzle(int8x16, a, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Int8x16.shuffle === "undefined") {
  SIMD.Int8x16.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdShuffle(int8x16, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Uint32x4 === "undefined" || typeof SIMD.Uint32x4.extractLane === "undefined") {
  SIMD.Uint32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Uint32x4)) {
    return new SIMD.Uint32x4(s0, s1, s2, s3);
   }
   this.s_ = convertArray(_ui32x4, new Uint32Array([ s0, s1, s2, s3 ]));
  });
  SIMD.Uint32x4.extractLane = (function(v, i) {
   v = SIMD.Uint32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Uint32x4.swizzle === "undefined") {
  SIMD.Uint32x4.swizzle = (function(a, s0, s1, s2, s3) {
   return simdSwizzle(uint32x4, a, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Uint32x4.shuffle === "undefined") {
  SIMD.Uint32x4.shuffle = (function(a, b, s0, s1, s2, s3) {
   return simdShuffle(uint32x4, a, b, [ s0, s1, s2, s3 ]);
  });
 }
 if (typeof SIMD.Uint16x8 === "undefined" || typeof SIMD.Uint16x8.extractLane === "undefined") {
  SIMD.Uint16x8 = (function(s0, s1, s2, s3, s4, s5, s6, s7) {
   if (!(this instanceof SIMD.Uint16x8)) {
    return new SIMD.Uint16x8(s0, s1, s2, s3, s4, s5, s6, s7);
   }
   this.s_ = convertArray(_ui16x8, new Uint16Array([ s0, s1, s2, s3, s4, s5, s6, s7 ]));
  });
  SIMD.Uint16x8.extractLane = (function(v, i) {
   v = SIMD.Uint16x8.check(v);
   simdCheckLaneIndex(i, 8);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Uint16x8.swizzle === "undefined") {
  SIMD.Uint16x8.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdSwizzle(uint16x8, a, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Uint16x8.shuffle === "undefined") {
  SIMD.Uint16x8.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7) {
   return simdShuffle(uint16x8, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7 ]);
  });
 }
 if (typeof SIMD.Uint8x16 === "undefined" || typeof SIMD.Uint8x16.extractLane === "undefined") {
  SIMD.Uint8x16 = (function(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   if (!(this instanceof SIMD.Uint8x16)) {
    return new SIMD.Uint8x16(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15);
   }
   this.s_ = convertArray(_ui8x16, new Uint8Array([ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]));
  });
  SIMD.Uint8x16.extractLane = (function(v, i) {
   v = SIMD.Uint8x16.check(v);
   simdCheckLaneIndex(i, 16);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Uint8x16.swizzle === "undefined") {
  SIMD.Uint8x16.swizzle = (function(a, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdSwizzle(uint8x16, a, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Uint8x16.shuffle === "undefined") {
  SIMD.Uint8x16.shuffle = (function(a, b, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   return simdShuffle(uint8x16, a, b, [ s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15 ]);
  });
 }
 if (typeof SIMD.Bool32x4 === "undefined" || typeof SIMD.Bool32x4.extractLane === "undefined") {
  SIMD.Bool32x4 = (function(s0, s1, s2, s3) {
   if (!(this instanceof SIMD.Bool32x4)) {
    return new SIMD.Bool32x4(s0, s1, s2, s3);
   }
   this.s_ = [ !!s0, !!s1, !!s2, !!s3 ];
  });
  SIMD.Bool32x4.extractLane = (function(v, i) {
   v = SIMD.Bool32x4.check(v);
   simdCheckLaneIndex(i, 4);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Bool16x8 === "undefined" || typeof SIMD.Bool16x8.extractLane === "undefined") {
  SIMD.Bool16x8 = (function(s0, s1, s2, s3, s4, s5, s6, s7) {
   if (!(this instanceof SIMD.Bool16x8)) {
    return new SIMD.Bool16x8(s0, s1, s2, s3, s4, s5, s6, s7);
   }
   this.s_ = [ !!s0, !!s1, !!s2, !!s3, !!s4, !!s5, !!s6, !!s7 ];
  });
  SIMD.Bool16x8.extractLane = (function(v, i) {
   v = SIMD.Bool16x8.check(v);
   simdCheckLaneIndex(i, 8);
   return v.s_[i];
  });
 }
 if (typeof SIMD.Bool8x16 === "undefined" || typeof SIMD.Bool8x16.extractLane === "undefined") {
  SIMD.Bool8x16 = (function(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15) {
   if (!(this instanceof SIMD.Bool8x16)) {
    return new SIMD.Bool8x16(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15);
   }
   this.s_ = [ !!s0, !!s1, !!s2, !!s3, !!s4, !!s5, !!s6, !!s7, !!s8, !!s9, !!s10, !!s11, !!s12, !!s13, !!s14, !!s15 ];
  });
  SIMD.Bool8x16.extractLane = (function(v, i) {
   v = SIMD.Bool8x16.check(v);
   simdCheckLaneIndex(i, 16);
   return v.s_[i];
  });
 }
 var float32x4 = {
  name: "Float32x4",
  fn: SIMD.Float32x4,
  lanes: 4,
  laneSize: 4,
  buffer: _f32x4,
  view: Float32Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "add", "sub", "mul", "div", "neg", "abs", "min", "max", "minNum", "maxNum", "reciprocalApproximation", "reciprocalSqrtApproximation", "sqrt", "load", "load1", "load2", "load3", "store", "store1", "store2", "store3" ]
 };
 var int32x4 = {
  name: "Int32x4",
  fn: SIMD.Int32x4,
  lanes: 4,
  laneSize: 4,
  minVal: -2147483648,
  maxVal: 2147483647,
  buffer: _i32x4,
  notFn: unaryBitwiseNot,
  view: Int32Array,
  mulFn: binaryImul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "neg", "shiftLeftByScalar", "shiftRightByScalar", "load", "load1", "load2", "load3", "store", "store1", "store2", "store3" ]
 };
 var int16x8 = {
  name: "Int16x8",
  fn: SIMD.Int16x8,
  lanes: 8,
  laneSize: 2,
  minVal: -32768,
  maxVal: 32767,
  buffer: _i16x8,
  notFn: unaryBitwiseNot,
  view: Int16Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "neg", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var int8x16 = {
  name: "Int8x16",
  fn: SIMD.Int8x16,
  lanes: 16,
  laneSize: 1,
  minVal: -128,
  maxVal: 127,
  buffer: _i8x16,
  notFn: unaryBitwiseNot,
  view: Int8Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "neg", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var uint32x4 = {
  name: "Uint32x4",
  fn: SIMD.Uint32x4,
  lanes: 4,
  laneSize: 4,
  minVal: 0,
  maxVal: 4294967295,
  unsigned: true,
  buffer: _ui32x4,
  notFn: unaryBitwiseNot,
  view: Uint32Array,
  mulFn: binaryImul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "shiftLeftByScalar", "shiftRightByScalar", "load", "load1", "load2", "load3", "store", "store1", "store2", "store3" ]
 };
 var uint16x8 = {
  name: "Uint16x8",
  fn: SIMD.Uint16x8,
  lanes: 8,
  laneSize: 2,
  unsigned: true,
  minVal: 0,
  maxVal: 65535,
  buffer: _ui16x8,
  notFn: unaryBitwiseNot,
  view: Uint16Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var uint8x16 = {
  name: "Uint8x16",
  fn: SIMD.Uint8x16,
  lanes: 16,
  laneSize: 1,
  unsigned: true,
  minVal: 0,
  maxVal: 255,
  buffer: _ui8x16,
  notFn: unaryBitwiseNot,
  view: Uint8Array,
  mulFn: binaryMul,
  fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "and", "or", "xor", "not", "add", "sub", "mul", "shiftLeftByScalar", "shiftRightByScalar", "addSaturate", "subSaturate", "load", "store" ]
 };
 var bool32x4 = {
  name: "Bool32x4",
  fn: SIMD.Bool32x4,
  lanes: 4,
  laneSize: 4,
  notFn: unaryLogicalNot,
  fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
 };
 var bool16x8 = {
  name: "Bool16x8",
  fn: SIMD.Bool16x8,
  lanes: 8,
  laneSize: 2,
  notFn: unaryLogicalNot,
  fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
 };
 var bool8x16 = {
  name: "Bool8x16",
  fn: SIMD.Bool8x16,
  lanes: 16,
  laneSize: 1,
  notFn: unaryLogicalNot,
  fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
 };
 float32x4.boolType = int32x4.boolType = uint32x4.boolType = bool32x4;
 int16x8.boolType = uint16x8.boolType = bool16x8;
 int8x16.boolType = uint8x16.boolType = bool8x16;
 float32x4.from = [ int32x4, uint32x4 ];
 int32x4.from = [ float32x4, uint32x4 ];
 int16x8.from = [ uint16x8 ];
 int8x16.from = [ uint8x16 ];
 uint32x4.from = [ float32x4, int32x4 ];
 uint16x8.from = [ int16x8 ];
 uint8x16.from = [ int8x16 ];
 float32x4.fromBits = [ int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16 ];
 int32x4.fromBits = [ float32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16 ];
 int16x8.fromBits = [ float32x4, int32x4, int8x16, uint32x4, uint16x8, uint8x16 ];
 int8x16.fromBits = [ float32x4, int32x4, int16x8, uint32x4, uint16x8, uint8x16 ];
 uint32x4.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint16x8, uint8x16 ];
 uint16x8.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint8x16 ];
 uint8x16.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8 ];
 var simdTypes = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16, bool32x4, bool16x8, bool8x16 ];
 simdPhase2 = true;
 if (typeof simdPhase2 !== "undefined") {
  if (typeof SIMD.Float64x2 === "undefined" || typeof SIMD.Float64x2.extractLane === "undefined") {
   SIMD.Float64x2 = (function(s0, s1) {
    if (!(this instanceof SIMD.Float64x2)) {
     return new SIMD.Float64x2(s0, s1);
    }
    this.s_ = convertArray(_f64x2, new Float64Array([ s0, s1 ]));
   });
   SIMD.Float64x2.extractLane = (function(v, i) {
    v = SIMD.Float64x2.check(v);
    simdCheckLaneIndex(i, 2);
    return v.s_[i];
   });
  }
  if (typeof SIMD.Float64x2.swizzle === "undefined") {
   SIMD.Float64x2.swizzle = (function(a, s0, s1) {
    return simdSwizzle(float64x2, a, [ s0, s1 ]);
   });
  }
  if (typeof SIMD.Float64x2.shuffle === "undefined") {
   SIMD.Float64x2.shuffle = (function(a, b, s0, s1) {
    return simdShuffle(float64x2, a, b, [ s0, s1 ]);
   });
  }
  if (typeof SIMD.Bool64x2 === "undefined" || typeof SIMD.Bool64x2.extractLane === "undefined") {
   SIMD.Bool64x2 = (function(s0, s1) {
    if (!(this instanceof SIMD.Bool64x2)) {
     return new SIMD.Bool64x2(s0, s1);
    }
    this.s_ = [ !!s0, !!s1 ];
   });
   SIMD.Bool64x2.extractLane = (function(v, i) {
    v = SIMD.Bool64x2.check(v);
    simdCheckLaneIndex(i, 2);
    return v.s_[i];
   });
  }
  var float64x2 = {
   name: "Float64x2",
   fn: SIMD.Float64x2,
   lanes: 2,
   laneSize: 8,
   buffer: _f64x2,
   view: Float64Array,
   mulFn: binaryMul,
   fns: [ "check", "splat", "replaceLane", "select", "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "add", "sub", "mul", "div", "neg", "abs", "min", "max", "minNum", "maxNum", "reciprocalApproximation", "reciprocalSqrtApproximation", "sqrt", "load", "store" ]
  };
  float64x2.fns.push("load1");
  float64x2.fns.push("store1");
  var bool64x2 = {
   name: "Bool64x2",
   fn: SIMD.Bool64x2,
   lanes: 2,
   laneSize: 8,
   notFn: unaryLogicalNot,
   fns: [ "check", "splat", "replaceLane", "allTrue", "anyTrue", "and", "or", "xor", "not" ]
  };
  float64x2.boolType = bool64x2;
  float32x4.fromBits.push(float64x2);
  int32x4.fromBits.push(float64x2);
  int16x8.fromBits.push(float64x2);
  int8x16.fromBits.push(float64x2);
  uint32x4.fromBits.push(float64x2);
  uint16x8.fromBits.push(float64x2);
  uint8x16.fromBits.push(float64x2);
  float64x2.fromBits = [ float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16 ];
  simdTypes.push(float64x2);
  simdTypes.push(bool64x2);
 }
 var prototypeFns = {
  valueOf: (function(type) {
   return (function() {
    throw new TypeError(type.name + " cannot be converted to a number");
   });
  }),
  toString: (function(type) {
   return (function() {
    return simdToString(type, this);
   });
  }),
  toLocaleString: (function(type) {
   return (function() {
    return simdToLocaleString(type, this);
   });
  })
 };
 var simdFns = {
  check: (function(type) {
   return (function(a) {
    if (!(a instanceof type.fn)) {
     throw new TypeError("Argument is not a " + type.name + ".");
    }
    return a;
   });
  }),
  splat: (function(type) {
   return (function(s) {
    return simdSplat(type, s);
   });
  }),
  replaceLane: (function(type) {
   return (function(a, i, s) {
    return simdReplaceLane(type, a, i, s);
   });
  }),
  allTrue: (function(type) {
   return (function(a) {
    return simdAllTrue(type, a);
   });
  }),
  anyTrue: (function(type) {
   return (function(a) {
    return simdAnyTrue(type, a);
   });
  }),
  and: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryAnd, a, b);
   });
  }),
  or: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryOr, a, b);
   });
  }),
  xor: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryXor, a, b);
   });
  }),
  not: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, type.notFn, a);
   });
  }),
  equal: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryEqual, a, b);
   });
  }),
  notEqual: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryNotEqual, a, b);
   });
  }),
  lessThan: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryLess, a, b);
   });
  }),
  lessThanOrEqual: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryLessEqual, a, b);
   });
  }),
  greaterThan: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryGreater, a, b);
   });
  }),
  greaterThanOrEqual: (function(type) {
   return (function(a, b) {
    return simdRelationalOp(type, binaryGreaterEqual, a, b);
   });
  }),
  add: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryAdd, a, b);
   });
  }),
  sub: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binarySub, a, b);
   });
  }),
  mul: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, type.mulFn, a, b);
   });
  }),
  div: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, binaryDiv, a, b);
   });
  }),
  neg: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, unaryNeg, a);
   });
  }),
  abs: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, Math.abs, a);
   });
  }),
  min: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, Math.min, a, b);
   });
  }),
  max: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, Math.max, a, b);
   });
  }),
  minNum: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, minNum, a, b);
   });
  }),
  maxNum: (function(type) {
   return (function(a, b) {
    return simdBinaryOp(type, maxNum, a, b);
   });
  }),
  load: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, type.lanes);
   });
  }),
  load1: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, 1);
   });
  }),
  load2: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, 2);
   });
  }),
  load3: (function(type) {
   return (function(tarray, index) {
    return simdLoad(type, tarray, index, 3);
   });
  }),
  store: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, type.lanes);
   });
  }),
  store1: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, 1);
   });
  }),
  store2: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, 2);
   });
  }),
  store3: (function(type) {
   return (function(tarray, index, a) {
    return simdStore(type, tarray, index, a, 3);
   });
  }),
  select: (function(type) {
   return (function(selector, a, b) {
    return simdSelect(type, selector, a, b);
   });
  }),
  reciprocalApproximation: (function(type) {
   return (function(a) {
    a = type.fn.check(a);
    return type.fn.div(type.fn.splat(1), a);
   });
  }),
  reciprocalSqrtApproximation: (function(type) {
   return (function(a) {
    a = type.fn.check(a);
    return type.fn.reciprocalApproximation(type.fn.sqrt(a));
   });
  }),
  sqrt: (function(type) {
   return (function(a) {
    return simdUnaryOp(type, Math.sqrt, a);
   });
  }),
  shiftLeftByScalar: (function(type) {
   return (function(a, bits) {
    if (bits >>> 0 >= type.laneSize * 8) return type.fn.splat(0);
    return simdShiftOp(type, binaryShiftLeft, a, bits);
   });
  }),
  shiftRightByScalar: (function(type) {
   if (type.unsigned) {
    return (function(a, bits) {
     if (bits >>> 0 >= type.laneSize * 8) return type.fn.splat(0);
     return simdShiftOp(type, binaryShiftRightLogical, a, bits);
    });
   } else {
    return (function(a, bits) {
     if (bits >>> 0 >= type.laneSize * 8) bits = type.laneSize * 8 - 1;
     return simdShiftOp(type, binaryShiftRightArithmetic, a, bits);
    });
   }
  }),
  addSaturate: (function(type) {
   function addSaturate(a, b) {
    return clamp(a + b, type.minVal, type.maxVal);
   }
   return (function(a, b) {
    return simdBinaryOp(type, addSaturate, a, b);
   });
  }),
  subSaturate: (function(type) {
   function subSaturate(a, b) {
    return clamp(a - b, type.minVal, type.maxVal);
   }
   return (function(a, b) {
    return simdBinaryOp(type, subSaturate, a, b);
   });
  })
 };
 simdTypes.forEach((function(type) {
  var simdFn = type.fn;
  var proto = simdFn.prototype;
  for (var name in prototypeFns) {
   if (!proto.hasOwnProperty(name)) proto[name] = prototypeFns[name](type);
  }
  type.fns.forEach((function(name) {
   if (typeof simdFn[name] === "undefined") simdFn[name] = simdFns[name](type);
  }));
  if (type.from) {
   type.from.forEach((function(fromType) {
    var name = "from" + fromType.name;
    var toType = type;
    if (typeof type.fn[name] === "undefined") {
     type.fn[name] = (function(a) {
      return simdFrom(toType, fromType, a);
     });
    }
   }));
  }
  if (type.fromBits) {
   type.fromBits.forEach((function(fromType) {
    var name = "from" + fromType.name + "Bits";
    var toType = type;
    if (typeof type.fn[name] === "undefined") {
     type.fn[name] = (function(a) {
      return simdFromBits(toType, fromType, a);
     });
    }
   }));
  }
 }));
}))(typeof window !== "undefined" ? window : typeof process === "object" && typeof require === "function" && typeof global === "object" ? global : typeof self === "object" ? self : this);
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.equal(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevEqual = SIMD.Float64x2.equal;
  SIMD.Float64x2.equal = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.equal to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.notEqual(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevNotEqual = SIMD.Float64x2.notEqual;
  SIMD.Float64x2.notEqual = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevNotEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.notEqual to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.greaterThan(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevGreaterThan = SIMD.Float64x2.greaterThan;
  SIMD.Float64x2.greaterThan = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevGreaterThan(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.greaterThan to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.greaterThanOrEqual(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevGreaterThanOrEqual = SIMD.Float64x2.greaterThanOrEqual;
  SIMD.Float64x2.greaterThanOrEqual = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevGreaterThanOrEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.greaterThanOrEqual to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.lessThan(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevLessThan = SIMD.Float64x2.lessThan;
  SIMD.Float64x2.lessThan = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevLessThan(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.lessThan to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
try {
 if (SIMD.Int32x4.check(SIMD.Float64x2.lessThanOrEqual(SIMD.Float64x2.splat(5), SIMD.Float64x2.splat(5)))) {
  SIMD.Float64x2.prevLessThanOrEqual = SIMD.Float64x2.lessThanOrEqual;
  SIMD.Float64x2.lessThanOrEqual = (function(a, b) {
   var int32x4 = SIMD.Float64x2.prevLessThanOrEqual(a, b);
   return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
  });
  console.error("Warning: Patching up SIMD.Float64x2.lessThanOrEqual to return a Bool64x2 instead of Int32x4!");
 }
} catch (e) {}
if (!SIMD.Int32x4.fromBool64x2Bits) {
 SIMD.Int32x4.fromBool64x2Bits = (function(bool64x2) {
  var lane0 = SIMD.Bool64x2.extractLane(bool64x2, 0) ? -1 : 0;
  var lane1 = SIMD.Bool64x2.extractLane(bool64x2, 1) ? -1 : 0;
  return SIMD.Int32x4(lane0, lane0, lane1, lane1);
 });
}
var Module;
if (!Module) Module = (typeof Module !== "undefined" ? Module : null) || {};
var moduleOverrides = {};
for (var key in Module) {
 if (Module.hasOwnProperty(key)) {
  moduleOverrides[key] = Module[key];
 }
}
var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
if (Module["ENVIRONMENT"]) {
 if (Module["ENVIRONMENT"] === "WEB") {
  ENVIRONMENT_IS_WEB = true;
 } else if (Module["ENVIRONMENT"] === "WORKER") {
  ENVIRONMENT_IS_WORKER = true;
 } else if (Module["ENVIRONMENT"] === "NODE") {
  ENVIRONMENT_IS_NODE = true;
 } else if (Module["ENVIRONMENT"] === "SHELL") {
  ENVIRONMENT_IS_SHELL = true;
 } else {
  throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");
 }
} else {
 ENVIRONMENT_IS_WEB = typeof window === "object";
 ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
 ENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
 ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
}
if (ENVIRONMENT_IS_NODE) {
 if (!Module["print"]) Module["print"] = console.log;
 if (!Module["printErr"]) Module["printErr"] = console.warn;
 var nodeFS;
 var nodePath;
 Module["read"] = function read(filename, binary) {
  if (!nodeFS) nodeFS = require("fs");
  if (!nodePath) nodePath = require("path");
  filename = nodePath["normalize"](filename);
  var ret = nodeFS["readFileSync"](filename);
  if (!ret && filename != nodePath["resolve"](filename)) {
   filename = path.join(__dirname, "..", "src", filename);
   ret = nodeFS["readFileSync"](filename);
  }
  if (ret && !binary) ret = ret.toString();
  return ret;
 };
 Module["readBinary"] = function readBinary(filename) {
  var ret = Module["read"](filename, true);
  if (!ret.buffer) {
   ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
 };
 Module["load"] = function load(f) {
  globalEval(read(f));
 };
 if (!Module["thisProgram"]) {
  if (process["argv"].length > 1) {
   Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/");
  } else {
   Module["thisProgram"] = "unknown-program";
  }
 }
 Module["arguments"] = process["argv"].slice(2);
 if (typeof module !== "undefined") {
  module["exports"] = Module;
 }
 process["on"]("uncaughtException", (function(ex) {
  if (!(ex instanceof ExitStatus)) {
   throw ex;
  }
 }));
 Module["inspect"] = (function() {
  return "[Emscripten Module object]";
 });
} else if (ENVIRONMENT_IS_SHELL) {
 if (!Module["print"]) Module["print"] = print;
 if (typeof printErr != "undefined") Module["printErr"] = printErr;
 if (typeof read != "undefined") {
  Module["read"] = read;
 } else {
  Module["read"] = function read() {
   throw "no read() available (jsc?)";
  };
 }
 Module["readBinary"] = function readBinary(f) {
  if (typeof readbuffer === "function") {
   return new Uint8Array(readbuffer(f));
  }
  var data = read(f, "binary");
  assert(typeof data === "object");
  return data;
 };
 if (typeof scriptArgs != "undefined") {
  Module["arguments"] = scriptArgs;
 } else if (typeof arguments != "undefined") {
  Module["arguments"] = arguments;
 }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 Module["read"] = function read(url) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", url, false);
  xhr.send(null);
  return xhr.responseText;
 };
 Module["readAsync"] = function readAsync(url, onload, onerror) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", url, true);
  xhr.responseType = "arraybuffer";
  xhr.onload = function xhr_onload() {
   if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
    onload(xhr.response);
   } else {
    onerror();
   }
  };
  xhr.onerror = onerror;
  xhr.send(null);
 };
 if (typeof arguments != "undefined") {
  Module["arguments"] = arguments;
 }
 if (typeof console !== "undefined") {
  if (!Module["print"]) Module["print"] = function print(x) {
   console.log(x);
  };
  if (!Module["printErr"]) Module["printErr"] = function printErr(x) {
   console.warn(x);
  };
 } else {
  var TRY_USE_DUMP = false;
  if (!Module["print"]) Module["print"] = TRY_USE_DUMP && typeof dump !== "undefined" ? (function(x) {
   dump(x);
  }) : (function(x) {});
 }
 if (ENVIRONMENT_IS_WORKER) {
  Module["load"] = importScripts;
 }
 if (typeof Module["setWindowTitle"] === "undefined") {
  Module["setWindowTitle"] = (function(title) {
   document.title = title;
  });
 }
} else {
 throw "Unknown runtime environment. Where are we?";
}
function globalEval(x) {
 eval.call(null, x);
}
if (!Module["load"] && Module["read"]) {
 Module["load"] = function load(f) {
  globalEval(Module["read"](f));
 };
}
if (!Module["print"]) {
 Module["print"] = (function() {});
}
if (!Module["printErr"]) {
 Module["printErr"] = Module["print"];
}
if (!Module["arguments"]) {
 Module["arguments"] = [];
}
if (!Module["thisProgram"]) {
 Module["thisProgram"] = "./this.program";
}
Module.print = Module["print"];
Module.printErr = Module["printErr"];
Module["preRun"] = [];
Module["postRun"] = [];
for (var key in moduleOverrides) {
 if (moduleOverrides.hasOwnProperty(key)) {
  Module[key] = moduleOverrides[key];
 }
}
moduleOverrides = undefined;
var Runtime = {
 setTempRet0: (function(x) {
  Runtime.tempRet0 = x;
 }),
 getTempRet0: (function() {
  return Runtime.tempRet0;
 }),
 stackSave: (function() {
  return STACKTOP;
 }),
 stackRestore: (function(stackTop) {
  STACKTOP = stackTop;
 }),
 getNativeTypeSize: (function(type) {
  switch (type) {
  case "i1":
  case "i8":
   return 1;
  case "i16":
   return 2;
  case "i32":
   return 4;
  case "i64":
   return 8;
  case "float":
   return 4;
  case "double":
   return 8;
  default:
   {
    if (type[type.length - 1] === "*") {
     return Runtime.QUANTUM_SIZE;
    } else if (type[0] === "i") {
     var bits = parseInt(type.substr(1));
     assert(bits % 8 === 0);
     return bits / 8;
    } else {
     return 0;
    }
   }
  }
 }),
 getNativeFieldSize: (function(type) {
  return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
 }),
 STACK_ALIGN: 16,
 prepVararg: (function(ptr, type) {
  if (type === "double" || type === "i64") {
   if (ptr & 7) {
    assert((ptr & 7) === 4);
    ptr += 4;
   }
  } else {
   assert((ptr & 3) === 0);
  }
  return ptr;
 }),
 getAlignSize: (function(type, size, vararg) {
  if (!vararg && (type == "i64" || type == "double")) return 8;
  if (!type) return Math.min(size, 8);
  return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
 }),
 dynCall: (function(sig, ptr, args) {
  if (args && args.length) {
   if (!args.splice) args = Array.prototype.slice.call(args);
   args.splice(0, 0, ptr);
   return Module["dynCall_" + sig].apply(null, args);
  } else {
   return Module["dynCall_" + sig].call(null, ptr);
  }
 }),
 getFunctionTables: (function(module) {
  if (!module) module = Module;
  var tables = {};
  for (var t in module) {
   if (/^FUNCTION_TABLE_.*/.test(t)) {
    var table = module[t];
    if (typeof table === "object") tables[t.substr("FUNCTION_TABLE_".length)] = table;
   }
  }
  return tables;
 }),
 alignFunctionTables: (function(module) {
  var tables = Runtime.getFunctionTables(module);
  var maxx = 0;
  for (var sig in tables) {
   maxx = Math.max(maxx, tables[sig].length);
  }
  assert(maxx >= 0);
  for (var sig in tables) {
   var table = tables[sig];
   while (table.length < maxx) table.push(0);
  }
  return maxx;
 }),
 registerFunctions: (function(sigs, newModule) {
  sigs.forEach((function(sig) {
   if (!Module["FUNCTION_TABLE_" + sig]) {
    Module["FUNCTION_TABLE_" + sig] = [];
   }
  }));
  var oldMaxx = Runtime.alignFunctionTables();
  var newMaxx = Runtime.alignFunctionTables(newModule);
  var maxx = oldMaxx + newMaxx;
  sigs.forEach((function(sig) {
   var newTable = newModule["FUNCTION_TABLE_" + sig];
   var oldTable = Module["FUNCTION_TABLE_" + sig];
   assert(newTable !== oldTable);
   assert(oldTable.length === oldMaxx);
   for (var i = 0; i < newTable.length; i++) {
    oldTable.push(newTable[i]);
   }
   assert(oldTable.length === maxx);
  }));
  assert(maxx === Runtime.alignFunctionTables());
 }),
 functionPointers: [],
 addFunction: (function(func) {
  Runtime.alignFunctionTables();
  var tables = Runtime.getFunctionTables();
  var ret = -1;
  for (var sig in tables) {
   var table = tables[sig];
   if (ret < 0) ret = table.length; else assert(ret === table.length);
   table.push(func);
  }
  return ret;
 }),
 removeFunction: (function(index) {
  Runtime.alignFunctionTables();
  var tables = Runtime.getFunctionTables();
  for (var sig in tables) {
   tables[sig][index] = null;
  }
 }),
 loadedDynamicLibraries: [],
 loadDynamicLibrary: (function(lib) {
  var src = Module["read"](lib);
  var libModule = eval(src)(Runtime.alignFunctionTables(), Module);
  for (var sym in libModule) {
   if (!Module.hasOwnProperty(sym)) {
    Module[sym] = libModule[sym];
   }
  }
  Runtime.loadedDynamicLibraries.push(libModule);
 }),
 warnOnce: (function(text) {
  if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
  if (!Runtime.warnOnce.shown[text]) {
   Runtime.warnOnce.shown[text] = 1;
   Module.printErr(text);
  }
 }),
 funcWrappers: {},
 getFuncWrapper: (function(func, sig) {
  assert(sig);
  if (!Runtime.funcWrappers[sig]) {
   Runtime.funcWrappers[sig] = {};
  }
  var sigCache = Runtime.funcWrappers[sig];
  if (!sigCache[func]) {
   sigCache[func] = function dynCall_wrapper() {
    return Runtime.dynCall(sig, func, arguments);
   };
  }
  return sigCache[func];
 }),
 getCompilerSetting: (function(name) {
  throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";
 }),
 stackAlloc: (function(size) {
  var ret = STACKTOP;
  STACKTOP = STACKTOP + size | 0;
  STACKTOP = STACKTOP + 15 & -16;
  return ret;
 }),
 staticAlloc: (function(size) {
  var ret = STATICTOP;
  STATICTOP = STATICTOP + size | 0;
  STATICTOP = STATICTOP + 15 & -16;
  return ret;
 }),
 dynamicAlloc: (function(size) {
  var ret = DYNAMICTOP;
  DYNAMICTOP = DYNAMICTOP + size | 0;
  DYNAMICTOP = DYNAMICTOP + 15 & -16;
  if (DYNAMICTOP >= TOTAL_MEMORY) {
   var success = enlargeMemory();
   if (!success) {
    DYNAMICTOP = ret;
    return 0;
   }
  }
  return ret;
 }),
 alignMemory: (function(size, quantum) {
  var ret = size = Math.ceil(size / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
  return ret;
 }),
 makeBigInt: (function(low, high, unsigned) {
  var ret = unsigned ? +(low >>> 0) + +(high >>> 0) * +4294967296 : +(low >>> 0) + +(high | 0) * +4294967296;
  return ret;
 }),
 tempRet0: 0,
 GLOBAL_BASE: 8,
 QUANTUM_SIZE: 4,
 __dummy__: 0
};
Runtime.GLOBAL_BASE = Runtime.alignMemory(Runtime.GLOBAL_BASE, 8);
Module["Runtime"] = Runtime;
var ABORT = false;
var EXITSTATUS = 0;
function assert(condition, text) {
 if (!condition) {
  abort("Assertion failed: " + text);
 }
}
function getCFunc(ident) {
 var func = Module["_" + ident];
 if (!func) {
  try {
   func = eval("_" + ident);
  } catch (e) {}
 }
 assert(func, "Cannot call unknown function " + ident + " (perhaps LLVM optimizations or closure removed it?)");
 return func;
}
var cwrap, ccall;
((function() {
 var JSfuncs = {
  "stackSave": (function() {
   Runtime.stackSave();
  }),
  "stackRestore": (function() {
   Runtime.stackRestore();
  }),
  "arrayToC": (function(arr) {
   var ret = Runtime.stackAlloc(arr.length);
   writeArrayToMemory(arr, ret);
   return ret;
  }),
  "stringToC": (function(str) {
   var ret = 0;
   if (str !== null && str !== undefined && str !== 0) {
    ret = Runtime.stackAlloc((str.length << 2) + 1);
    writeStringToMemory(str, ret);
   }
   return ret;
  })
 };
 var toC = {
  "string": JSfuncs["stringToC"],
  "array": JSfuncs["arrayToC"]
 };
 ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {
  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
   for (var i = 0; i < args.length; i++) {
    var converter = toC[argTypes[i]];
    if (converter) {
     if (stack === 0) stack = Runtime.stackSave();
     cArgs[i] = converter(args[i]);
    } else {
     cArgs[i] = args[i];
    }
   }
  }
  var ret = func.apply(null, cArgs);
  if (returnType === "string") ret = Pointer_stringify(ret);
  if (stack !== 0) {
   if (opts && opts.async) {
    EmterpreterAsync.asyncFinalizers.push((function() {
     Runtime.stackRestore(stack);
    }));
    return;
   }
   Runtime.stackRestore(stack);
  }
  return ret;
 };
 var sourceRegex = /^function\s*[a-zA-Z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
 function parseJSFunc(jsfunc) {
  var parsed = jsfunc.toString().match(sourceRegex).slice(1);
  return {
   arguments: parsed[0],
   body: parsed[1],
   returnValue: parsed[2]
  };
 }
 var JSsource = null;
 function ensureJSsource() {
  if (!JSsource) {
   JSsource = {};
   for (var fun in JSfuncs) {
    if (JSfuncs.hasOwnProperty(fun)) {
     JSsource[fun] = parseJSFunc(JSfuncs[fun]);
    }
   }
  }
 }
 cwrap = function cwrap(ident, returnType, argTypes) {
  argTypes = argTypes || [];
  var cfunc = getCFunc(ident);
  var numericArgs = argTypes.every((function(type) {
   return type === "number";
  }));
  var numericRet = returnType !== "string";
  if (numericRet && numericArgs) {
   return cfunc;
  }
  var argNames = argTypes.map((function(x, i) {
   return "$" + i;
  }));
  var funcstr = "(function(" + argNames.join(",") + ") {";
  var nargs = argTypes.length;
  if (!numericArgs) {
   ensureJSsource();
   funcstr += "var stack = " + JSsource["stackSave"].body + ";";
   for (var i = 0; i < nargs; i++) {
    var arg = argNames[i], type = argTypes[i];
    if (type === "number") continue;
    var convertCode = JSsource[type + "ToC"];
    funcstr += "var " + convertCode.arguments + " = " + arg + ";";
    funcstr += convertCode.body + ";";
    funcstr += arg + "=(" + convertCode.returnValue + ");";
   }
  }
  var cfuncname = parseJSFunc((function() {
   return cfunc;
  })).returnValue;
  funcstr += "var ret = " + cfuncname + "(" + argNames.join(",") + ");";
  if (!numericRet) {
   var strgfy = parseJSFunc((function() {
    return Pointer_stringify;
   })).returnValue;
   funcstr += "ret = " + strgfy + "(ret);";
  }
  if (!numericArgs) {
   ensureJSsource();
   funcstr += JSsource["stackRestore"].body.replace("()", "(stack)") + ";";
  }
  funcstr += "return ret})";
  return eval(funcstr);
 };
}))();
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;
function setValue(ptr, value, type, noSafe) {
 type = type || "i8";
 if (type.charAt(type.length - 1) === "*") type = "i32";
 switch (type) {
 case "i1":
  HEAP8[ptr >> 0] = value;
  break;
 case "i8":
  HEAP8[ptr >> 0] = value;
  break;
 case "i16":
  HEAP16[ptr >> 1] = value;
  break;
 case "i32":
  HEAP32[ptr >> 2] = value;
  break;
 case "i64":
  tempI64 = [ value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= +1 ? tempDouble > +0 ? (Math_min(+Math_floor(tempDouble / +4294967296), +4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / +4294967296) >>> 0 : 0) ], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
  break;
 case "float":
  HEAPF32[ptr >> 2] = value;
  break;
 case "double":
  HEAPF64[ptr >> 3] = value;
  break;
 default:
  abort("invalid type for setValue: " + type);
 }
}
Module["setValue"] = setValue;
function getValue(ptr, type, noSafe) {
 type = type || "i8";
 if (type.charAt(type.length - 1) === "*") type = "i32";
 switch (type) {
 case "i1":
  return HEAP8[ptr >> 0];
 case "i8":
  return HEAP8[ptr >> 0];
 case "i16":
  return HEAP16[ptr >> 1];
 case "i32":
  return HEAP32[ptr >> 2];
 case "i64":
  return HEAP32[ptr >> 2];
 case "float":
  return HEAPF32[ptr >> 2];
 case "double":
  return HEAPF64[ptr >> 3];
 default:
  abort("invalid type for setValue: " + type);
 }
 return null;
}
Module["getValue"] = getValue;
var ALLOC_NORMAL = 0;
var ALLOC_STACK = 1;
var ALLOC_STATIC = 2;
var ALLOC_DYNAMIC = 3;
var ALLOC_NONE = 4;
Module["ALLOC_NORMAL"] = ALLOC_NORMAL;
Module["ALLOC_STACK"] = ALLOC_STACK;
Module["ALLOC_STATIC"] = ALLOC_STATIC;
Module["ALLOC_DYNAMIC"] = ALLOC_DYNAMIC;
Module["ALLOC_NONE"] = ALLOC_NONE;
function allocate(slab, types, allocator, ptr) {
 var zeroinit, size;
 if (typeof slab === "number") {
  zeroinit = true;
  size = slab;
 } else {
  zeroinit = false;
  size = slab.length;
 }
 var singleType = typeof types === "string" ? types : null;
 var ret;
 if (allocator == ALLOC_NONE) {
  ret = ptr;
 } else {
  ret = [ typeof _malloc === "function" ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc ][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
 }
 if (zeroinit) {
  var ptr = ret, stop;
  assert((ret & 3) == 0);
  stop = ret + (size & ~3);
  for (; ptr < stop; ptr += 4) {
   HEAP32[ptr >> 2] = 0;
  }
  stop = ret + size;
  while (ptr < stop) {
   HEAP8[ptr++ >> 0] = 0;
  }
  return ret;
 }
 if (singleType === "i8") {
  if (slab.subarray || slab.slice) {
   HEAPU8.set(slab, ret);
  } else {
   HEAPU8.set(new Uint8Array(slab), ret);
  }
  return ret;
 }
 var i = 0, type, typeSize, previousType;
 while (i < size) {
  var curr = slab[i];
  if (typeof curr === "function") {
   curr = Runtime.getFunctionIndex(curr);
  }
  type = singleType || types[i];
  if (type === 0) {
   i++;
   continue;
  }
  if (type == "i64") type = "i32";
  setValue(ret + i, curr, type);
  if (previousType !== type) {
   typeSize = Runtime.getNativeTypeSize(type);
   previousType = type;
  }
  i += typeSize;
 }
 return ret;
}
Module["allocate"] = allocate;
function getMemory(size) {
 if (!staticSealed) return Runtime.staticAlloc(size);
 if (typeof _sbrk !== "undefined" && !_sbrk.called || !runtimeInitialized) return Runtime.dynamicAlloc(size);
 return _malloc(size);
}
Module["getMemory"] = getMemory;
function Pointer_stringify(ptr, length) {
 if (length === 0 || !ptr) return "";
 var hasUtf = 0;
 var t;
 var i = 0;
 while (1) {
  t = HEAPU8[ptr + i >> 0];
  hasUtf |= t;
  if (t == 0 && !length) break;
  i++;
  if (length && i == length) break;
 }
 if (!length) length = i;
 var ret = "";
 if (hasUtf < 128) {
  var MAX_CHUNK = 1024;
  var curr;
  while (length > 0) {
   curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
   ret = ret ? ret + curr : curr;
   ptr += MAX_CHUNK;
   length -= MAX_CHUNK;
  }
  return ret;
 }
 return Module["UTF8ToString"](ptr);
}
Module["Pointer_stringify"] = Pointer_stringify;
function AsciiToString(ptr) {
 var str = "";
 while (1) {
  var ch = HEAP8[ptr++ >> 0];
  if (!ch) return str;
  str += String.fromCharCode(ch);
 }
}
Module["AsciiToString"] = AsciiToString;
function stringToAscii(str, outPtr) {
 return writeAsciiToMemory(str, outPtr, false);
}
Module["stringToAscii"] = stringToAscii;
function UTF8ArrayToString(u8Array, idx) {
 var u0, u1, u2, u3, u4, u5;
 var str = "";
 while (1) {
  u0 = u8Array[idx++];
  if (!u0) return str;
  if (!(u0 & 128)) {
   str += String.fromCharCode(u0);
   continue;
  }
  u1 = u8Array[idx++] & 63;
  if ((u0 & 224) == 192) {
   str += String.fromCharCode((u0 & 31) << 6 | u1);
   continue;
  }
  u2 = u8Array[idx++] & 63;
  if ((u0 & 240) == 224) {
   u0 = (u0 & 15) << 12 | u1 << 6 | u2;
  } else {
   u3 = u8Array[idx++] & 63;
   if ((u0 & 248) == 240) {
    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;
   } else {
    u4 = u8Array[idx++] & 63;
    if ((u0 & 252) == 248) {
     u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;
    } else {
     u5 = u8Array[idx++] & 63;
     u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;
    }
   }
  }
  if (u0 < 65536) {
   str += String.fromCharCode(u0);
  } else {
   var ch = u0 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  }
 }
}
Module["UTF8ArrayToString"] = UTF8ArrayToString;
function UTF8ToString(ptr) {
 return UTF8ArrayToString(HEAPU8, ptr);
}
Module["UTF8ToString"] = UTF8ToString;
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   outU8Array[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   outU8Array[outIdx++] = 192 | u >> 6;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   outU8Array[outIdx++] = 224 | u >> 12;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 2097151) {
   if (outIdx + 3 >= endIdx) break;
   outU8Array[outIdx++] = 240 | u >> 18;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 67108863) {
   if (outIdx + 4 >= endIdx) break;
   outU8Array[outIdx++] = 248 | u >> 24;
   outU8Array[outIdx++] = 128 | u >> 18 & 63;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 5 >= endIdx) break;
   outU8Array[outIdx++] = 252 | u >> 30;
   outU8Array[outIdx++] = 128 | u >> 24 & 63;
   outU8Array[outIdx++] = 128 | u >> 18 & 63;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  }
 }
 outU8Array[outIdx] = 0;
 return outIdx - startIdx;
}
Module["stringToUTF8Array"] = stringToUTF8Array;
function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
Module["stringToUTF8"] = stringToUTF8;
function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) {
   ++len;
  } else if (u <= 2047) {
   len += 2;
  } else if (u <= 65535) {
   len += 3;
  } else if (u <= 2097151) {
   len += 4;
  } else if (u <= 67108863) {
   len += 5;
  } else {
   len += 6;
  }
 }
 return len;
}
Module["lengthBytesUTF8"] = lengthBytesUTF8;
function demangle(func) {
 var hasLibcxxabi = !!Module["___cxa_demangle"];
 if (hasLibcxxabi) {
  try {
   var buf = _malloc(func.length);
   writeStringToMemory(func.substr(1), buf);
   var status = _malloc(4);
   var ret = Module["___cxa_demangle"](buf, 0, 0, status);
   if (getValue(status, "i32") === 0 && ret) {
    return Pointer_stringify(ret);
   }
  } catch (e) {
   return func;
  } finally {
   if (buf) _free(buf);
   if (status) _free(status);
   if (ret) _free(ret);
  }
 }
 Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");
 return func;
}
function demangleAll(text) {
 return text.replace(/__Z[\w\d_]+/g, (function(x) {
  var y = demangle(x);
  return x === y ? x : x + " [" + y + "]";
 }));
}
function jsStackTrace() {
 var err = new Error;
 if (!err.stack) {
  try {
   throw new Error(0);
  } catch (e) {
   err = e;
  }
  if (!err.stack) {
   return "(no stack trace available)";
  }
 }
 return err.stack.toString();
}
function stackTrace() {
 return demangleAll(jsStackTrace());
}
Module["stackTrace"] = stackTrace;
var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
 if (x % 4096 > 0) {
  x += 4096 - x % 4096;
 }
 return x;
}
var HEAP;
var buffer;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
function updateGlobalBufferViews() {
 Module["HEAP8"] = HEAP8 = new Int8Array(buffer);
 Module["HEAP16"] = HEAP16 = new Int16Array(buffer);
 Module["HEAP32"] = HEAP32 = new Int32Array(buffer);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer);
}
var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false;
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0;
var DYNAMIC_BASE = 0, DYNAMICTOP = 0;
function abortOnCannotGrowMemory() {
 abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
}
function enlargeMemory() {
 abortOnCannotGrowMemory();
}
var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;
var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216;
var totalMemory = 64 * 1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2 * TOTAL_STACK) {
 if (totalMemory < 16 * 1024 * 1024) {
  totalMemory *= 2;
 } else {
  totalMemory += 16 * 1024 * 1024;
 }
}
if (totalMemory !== TOTAL_MEMORY) {
 TOTAL_MEMORY = totalMemory;
}
if (Module["buffer"]) {
 buffer = Module["buffer"];
} else {
 buffer = new ArrayBuffer(TOTAL_MEMORY);
}
updateGlobalBufferViews();
HEAP32[0] = 255;
if (HEAPU8[0] !== 255 || HEAPU8[3] !== 0) throw "Typed arrays 2 must be run on a little-endian system";
Module["HEAP"] = HEAP;
Module["buffer"] = buffer;
Module["HEAP8"] = HEAP8;
Module["HEAP16"] = HEAP16;
Module["HEAP32"] = HEAP32;
Module["HEAPU8"] = HEAPU8;
Module["HEAPU16"] = HEAPU16;
Module["HEAPU32"] = HEAPU32;
Module["HEAPF32"] = HEAPF32;
Module["HEAPF64"] = HEAPF64;
function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback();
   continue;
  }
  var func = callback.func;
  if (typeof func === "number") {
   if (callback.arg === undefined) {
    Runtime.dynCall("v", func);
   } else {
    Runtime.dynCall("vi", func, [ callback.arg ]);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATEXIT__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;
var runtimeExited = false;
function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}
function ensureInitRuntime() {
 if (runtimeInitialized) return;
 runtimeInitialized = true;
 callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
 callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
 callRuntimeCallbacks(__ATEXIT__);
 runtimeExited = true;
}
function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}
function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}
Module["addOnPreRun"] = addOnPreRun;
function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}
Module["addOnInit"] = addOnInit;
function addOnPreMain(cb) {
 __ATMAIN__.unshift(cb);
}
Module["addOnPreMain"] = addOnPreMain;
function addOnExit(cb) {
 __ATEXIT__.unshift(cb);
}
Module["addOnExit"] = addOnExit;
function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}
Module["addOnPostRun"] = addOnPostRun;
function intArrayFromString(stringy, dontAddNull, length) {
 var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
 var u8array = new Array(len);
 var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
 if (dontAddNull) u8array.length = numBytesWritten;
 return u8array;
}
Module["intArrayFromString"] = intArrayFromString;
function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}
Module["intArrayToString"] = intArrayToString;
function writeStringToMemory(string, buffer, dontAddNull) {
 var array = intArrayFromString(string, dontAddNull);
 var i = 0;
 while (i < array.length) {
  var chr = array[i];
  HEAP8[buffer + i >> 0] = chr;
  i = i + 1;
 }
}
Module["writeStringToMemory"] = writeStringToMemory;
function writeArrayToMemory(array, buffer) {
 for (var i = 0; i < array.length; i++) {
  HEAP8[buffer++ >> 0] = array[i];
 }
}
Module["writeArrayToMemory"] = writeArrayToMemory;
function writeAsciiToMemory(str, buffer, dontAddNull) {
 for (var i = 0; i < str.length; ++i) {
  HEAP8[buffer++ >> 0] = str.charCodeAt(i);
 }
 if (!dontAddNull) HEAP8[buffer >> 0] = 0;
}
Module["writeAsciiToMemory"] = writeAsciiToMemory;
if (!Math["imul"] || Math["imul"](4294967295, 5) !== -5) Math["imul"] = function imul(a, b) {
 var ah = a >>> 16;
 var al = a & 65535;
 var bh = b >>> 16;
 var bl = b & 65535;
 return al * bl + (ah * bl + al * bh << 16) | 0;
};
Math.imul = Math["imul"];
if (!Math["fround"]) Math["fround"] = (function(x) {
 return x;
});
if (!Math["clz32"]) Math["clz32"] = (function(x) {
 x = x >>> 0;
 for (var i = 0; i < 32; i++) {
  if (x & 1 << 31 - i) return i;
 }
 return 32;
});
Math.clz32 = Math["clz32"];
var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;
function getUniqueRunDependency(id) {
 return id;
}
function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}
Module["addRunDependency"] = addRunDependency;
function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}
Module["removeRunDependency"] = removeRunDependency;
Module["preloadedImages"] = {};
Module["preloadedAudios"] = {};
addOnPreRun((function() {
 if (Module["dynamicLibraries"]) {
  Module["dynamicLibraries"].forEach((function(lib) {
   Runtime.loadDynamicLibrary(lib);
  }));
 }
 asm["runPostSets"]();
}));
var memoryInitializer = null;
var ASM_CONSTS = [];
STATIC_BASE = 8;
STATICTOP = STATIC_BASE + 42960;
__ATINIT__.push();
memoryInitializer = "quiet-emscripten.js.mem";
var tempDoublePtr = STATICTOP;
STATICTOP += 16;
function _chainback_viterbi29() {
 return Module["_chainback_viterbi29"].apply(null, arguments);
}
function _create_viterbi39() {
 return Module["_create_viterbi39"].apply(null, arguments);
}
Module["_i64Subtract"] = _i64Subtract;
function ___assert_fail(condition, filename, line, func) {
 ABORT = true;
 throw "Assertion failed: " + Pointer_stringify(condition) + ", at: " + [ filename ? Pointer_stringify(filename) : "unknown filename", line, func ? Pointer_stringify(func) : "unknown function" ] + " at " + stackTrace();
}
Module["___assert_fail"] = ___assert_fail;
Module["_roundf"] = _roundf;
function _chainback_viterbi615() {
 return Module["_chainback_viterbi615"].apply(null, arguments);
}
Module["_memset"] = _memset;
function _chainback_viterbi27() {
 return Module["_chainback_viterbi27"].apply(null, arguments);
}
function _update_viterbi27_blk() {
 return Module["_update_viterbi27_blk"].apply(null, arguments);
}
Module["_bitshift64Shl"] = _bitshift64Shl;
function _abort() {
 Module["abort"]();
}
Module["_abort"] = _abort;
function _init_viterbi39() {
 return Module["_init_viterbi39"].apply(null, arguments);
}
function _update_viterbi39_blk() {
 return Module["_update_viterbi39_blk"].apply(null, arguments);
}
function ___lock() {}
Module["___lock"] = ___lock;
function ___unlock() {}
Module["___unlock"] = ___unlock;
function _llvm_stacksave() {
 var self = _llvm_stacksave;
 if (!self.LLVM_SAVEDSTACKS) {
  self.LLVM_SAVEDSTACKS = [];
 }
 self.LLVM_SAVEDSTACKS.push(Runtime.stackSave());
 return self.LLVM_SAVEDSTACKS.length - 1;
}
Module["_llvm_stacksave"] = _llvm_stacksave;
function _delete_viterbi39() {
 return Module["_delete_viterbi39"].apply(null, arguments);
}
var _llvm_fabs_f64 = Math_abs;
Module["_llvm_fabs_f64"] = _llvm_fabs_f64;
Module["_i64Add"] = _i64Add;
function _emscripten_memcpy_big(dest, src, num) {
 HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
 return dest;
}
Module["_emscripten_memcpy_big"] = _emscripten_memcpy_big;
Module["_memcpy"] = _memcpy;
var _llvm_pow_f32 = Math_pow;
Module["_llvm_pow_f32"] = _llvm_pow_f32;
var PROCINFO = {
 ppid: 1,
 pid: 42,
 sid: 42,
 pgid: 42
};
Module["PROCINFO"] = PROCINFO;
var ERRNO_CODES = {
 EPERM: 1,
 ENOENT: 2,
 ESRCH: 3,
 EINTR: 4,
 EIO: 5,
 ENXIO: 6,
 E2BIG: 7,
 ENOEXEC: 8,
 EBADF: 9,
 ECHILD: 10,
 EAGAIN: 11,
 EWOULDBLOCK: 11,
 ENOMEM: 12,
 EACCES: 13,
 EFAULT: 14,
 ENOTBLK: 15,
 EBUSY: 16,
 EEXIST: 17,
 EXDEV: 18,
 ENODEV: 19,
 ENOTDIR: 20,
 EISDIR: 21,
 EINVAL: 22,
 ENFILE: 23,
 EMFILE: 24,
 ENOTTY: 25,
 ETXTBSY: 26,
 EFBIG: 27,
 ENOSPC: 28,
 ESPIPE: 29,
 EROFS: 30,
 EMLINK: 31,
 EPIPE: 32,
 EDOM: 33,
 ERANGE: 34,
 ENOMSG: 42,
 EIDRM: 43,
 ECHRNG: 44,
 EL2NSYNC: 45,
 EL3HLT: 46,
 EL3RST: 47,
 ELNRNG: 48,
 EUNATCH: 49,
 ENOCSI: 50,
 EL2HLT: 51,
 EDEADLK: 35,
 ENOLCK: 37,
 EBADE: 52,
 EBADR: 53,
 EXFULL: 54,
 ENOANO: 55,
 EBADRQC: 56,
 EBADSLT: 57,
 EDEADLOCK: 35,
 EBFONT: 59,
 ENOSTR: 60,
 ENODATA: 61,
 ETIME: 62,
 ENOSR: 63,
 ENONET: 64,
 ENOPKG: 65,
 EREMOTE: 66,
 ENOLINK: 67,
 EADV: 68,
 ESRMNT: 69,
 ECOMM: 70,
 EPROTO: 71,
 EMULTIHOP: 72,
 EDOTDOT: 73,
 EBADMSG: 74,
 ENOTUNIQ: 76,
 EBADFD: 77,
 EREMCHG: 78,
 ELIBACC: 79,
 ELIBBAD: 80,
 ELIBSCN: 81,
 ELIBMAX: 82,
 ELIBEXEC: 83,
 ENOSYS: 38,
 ENOTEMPTY: 39,
 ENAMETOOLONG: 36,
 ELOOP: 40,
 EOPNOTSUPP: 95,
 EPFNOSUPPORT: 96,
 ECONNRESET: 104,
 ENOBUFS: 105,
 EAFNOSUPPORT: 97,
 EPROTOTYPE: 91,
 ENOTSOCK: 88,
 ENOPROTOOPT: 92,
 ESHUTDOWN: 108,
 ECONNREFUSED: 111,
 EADDRINUSE: 98,
 ECONNABORTED: 103,
 ENETUNREACH: 101,
 ENETDOWN: 100,
 ETIMEDOUT: 110,
 EHOSTDOWN: 112,
 EHOSTUNREACH: 113,
 EINPROGRESS: 115,
 EALREADY: 114,
 EDESTADDRREQ: 89,
 EMSGSIZE: 90,
 EPROTONOSUPPORT: 93,
 ESOCKTNOSUPPORT: 94,
 EADDRNOTAVAIL: 99,
 ENETRESET: 102,
 EISCONN: 106,
 ENOTCONN: 107,
 ETOOMANYREFS: 109,
 EUSERS: 87,
 EDQUOT: 122,
 ESTALE: 116,
 ENOTSUP: 95,
 ENOMEDIUM: 123,
 EILSEQ: 84,
 EOVERFLOW: 75,
 ECANCELED: 125,
 ENOTRECOVERABLE: 131,
 EOWNERDEAD: 130,
 ESTRPIPE: 86
};
Module["ERRNO_CODES"] = ERRNO_CODES;
var ERRNO_MESSAGES = {
 0: "Success",
 1: "Not super-user",
 2: "No such file or directory",
 3: "No such process",
 4: "Interrupted system call",
 5: "I/O error",
 6: "No such device or address",
 7: "Arg list too long",
 8: "Exec format error",
 9: "Bad file number",
 10: "No children",
 11: "No more processes",
 12: "Not enough core",
 13: "Permission denied",
 14: "Bad address",
 15: "Block device required",
 16: "Mount device busy",
 17: "File exists",
 18: "Cross-device link",
 19: "No such device",
 20: "Not a directory",
 21: "Is a directory",
 22: "Invalid argument",
 23: "Too many open files in system",
 24: "Too many open files",
 25: "Not a typewriter",
 26: "Text file busy",
 27: "File too large",
 28: "No space left on device",
 29: "Illegal seek",
 30: "Read only file system",
 31: "Too many links",
 32: "Broken pipe",
 33: "Math arg out of domain of func",
 34: "Math result not representable",
 35: "File locking deadlock error",
 36: "File or path name too long",
 37: "No record locks available",
 38: "Function not implemented",
 39: "Directory not empty",
 40: "Too many symbolic links",
 42: "No message of desired type",
 43: "Identifier removed",
 44: "Channel number out of range",
 45: "Level 2 not synchronized",
 46: "Level 3 halted",
 47: "Level 3 reset",
 48: "Link number out of range",
 49: "Protocol driver not attached",
 50: "No CSI structure available",
 51: "Level 2 halted",
 52: "Invalid exchange",
 53: "Invalid request descriptor",
 54: "Exchange full",
 55: "No anode",
 56: "Invalid request code",
 57: "Invalid slot",
 59: "Bad font file fmt",
 60: "Device not a stream",
 61: "No data (for no delay io)",
 62: "Timer expired",
 63: "Out of streams resources",
 64: "Machine is not on the network",
 65: "Package not installed",
 66: "The object is remote",
 67: "The link has been severed",
 68: "Advertise error",
 69: "Srmount error",
 70: "Communication error on send",
 71: "Protocol error",
 72: "Multihop attempted",
 73: "Cross mount point (not really error)",
 74: "Trying to read unreadable message",
 75: "Value too large for defined data type",
 76: "Given log. name not unique",
 77: "f.d. invalid for this operation",
 78: "Remote address changed",
 79: "Can   access a needed shared lib",
 80: "Accessing a corrupted shared lib",
 81: ".lib section in a.out corrupted",
 82: "Attempting to link in too many libs",
 83: "Attempting to exec a shared library",
 84: "Illegal byte sequence",
 86: "Streams pipe error",
 87: "Too many users",
 88: "Socket operation on non-socket",
 89: "Destination address required",
 90: "Message too long",
 91: "Protocol wrong type for socket",
 92: "Protocol not available",
 93: "Unknown protocol",
 94: "Socket type not supported",
 95: "Not supported",
 96: "Protocol family not supported",
 97: "Address family not supported by protocol family",
 98: "Address already in use",
 99: "Address not available",
 100: "Network interface is not configured",
 101: "Network is unreachable",
 102: "Connection reset by network",
 103: "Connection aborted",
 104: "Connection reset by peer",
 105: "No buffer space available",
 106: "Socket is already connected",
 107: "Socket is not connected",
 108: "Can't send after socket shutdown",
 109: "Too many references",
 110: "Connection timed out",
 111: "Connection refused",
 112: "Host is down",
 113: "Host is unreachable",
 114: "Socket already connected",
 115: "Connection already in progress",
 116: "Stale file handle",
 122: "Quota exceeded",
 123: "No medium (in tape drive)",
 125: "Operation canceled",
 130: "Previous owner died",
 131: "State not recoverable"
};
Module["ERRNO_MESSAGES"] = ERRNO_MESSAGES;
function ___setErrNo(value) {
 if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value;
 return value;
}
Module["___setErrNo"] = ___setErrNo;
var PATH = {
 splitPath: (function(filename) {
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  return splitPathRe.exec(filename).slice(1);
 }),
 normalizeArray: (function(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
   var last = parts[i];
   if (last === ".") {
    parts.splice(i, 1);
   } else if (last === "..") {
    parts.splice(i, 1);
    up++;
   } else if (up) {
    parts.splice(i, 1);
    up--;
   }
  }
  if (allowAboveRoot) {
   for (; up--; up) {
    parts.unshift("..");
   }
  }
  return parts;
 }),
 normalize: (function(path) {
  var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
  path = PATH.normalizeArray(path.split("/").filter((function(p) {
   return !!p;
  })), !isAbsolute).join("/");
  if (!path && !isAbsolute) {
   path = ".";
  }
  if (path && trailingSlash) {
   path += "/";
  }
  return (isAbsolute ? "/" : "") + path;
 }),
 dirname: (function(path) {
  var result = PATH.splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
   return ".";
  }
  if (dir) {
   dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
 }),
 basename: (function(path) {
  if (path === "/") return "/";
  var lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) return path;
  return path.substr(lastSlash + 1);
 }),
 extname: (function(path) {
  return PATH.splitPath(path)[3];
 }),
 join: (function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return PATH.normalize(paths.join("/"));
 }),
 join2: (function(l, r) {
  return PATH.normalize(l + "/" + r);
 }),
 resolve: (function() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
   var path = i >= 0 ? arguments[i] : FS.cwd();
   if (typeof path !== "string") {
    throw new TypeError("Arguments to path.resolve must be strings");
   } else if (!path) {
    return "";
   }
   resolvedPath = path + "/" + resolvedPath;
   resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((function(p) {
   return !!p;
  })), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
 }),
 relative: (function(from, to) {
  from = PATH.resolve(from).substr(1);
  to = PATH.resolve(to).substr(1);
  function trim(arr) {
   var start = 0;
   for (; start < arr.length; start++) {
    if (arr[start] !== "") break;
   }
   var end = arr.length - 1;
   for (; end >= 0; end--) {
    if (arr[end] !== "") break;
   }
   if (start > end) return [];
   return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
   if (fromParts[i] !== toParts[i]) {
    samePartsLength = i;
    break;
   }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
   outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
 })
};
Module["PATH"] = PATH;
var TTY = {
 ttys: [],
 init: (function() {}),
 shutdown: (function() {}),
 register: (function(dev, ops) {
  TTY.ttys[dev] = {
   input: [],
   output: [],
   ops: ops
  };
  FS.registerDevice(dev, TTY.stream_ops);
 }),
 stream_ops: {
  open: (function(stream) {
   var tty = TTY.ttys[stream.node.rdev];
   if (!tty) {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
   }
   stream.tty = tty;
   stream.seekable = false;
  }),
  close: (function(stream) {
   stream.tty.ops.flush(stream.tty);
  }),
  flush: (function(stream) {
   stream.tty.ops.flush(stream.tty);
  }),
  read: (function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.get_char) {
    throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
   }
   var bytesRead = 0;
   for (var i = 0; i < length; i++) {
    var result;
    try {
     result = stream.tty.ops.get_char(stream.tty);
    } catch (e) {
     throw new FS.ErrnoError(ERRNO_CODES.EIO);
    }
    if (result === undefined && bytesRead === 0) {
     throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
    }
    if (result === null || result === undefined) break;
    bytesRead++;
    buffer[offset + i] = result;
   }
   if (bytesRead) {
    stream.node.timestamp = Date.now();
   }
   return bytesRead;
  }),
  write: (function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.put_char) {
    throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
   }
   for (var i = 0; i < length; i++) {
    try {
     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
    } catch (e) {
     throw new FS.ErrnoError(ERRNO_CODES.EIO);
    }
   }
   if (length) {
    stream.node.timestamp = Date.now();
   }
   return i;
  })
 },
 default_tty_ops: {
  get_char: (function(tty) {
   if (!tty.input.length) {
    var result = null;
    if (ENVIRONMENT_IS_NODE) {
     var BUFSIZE = 256;
     var buf = new Buffer(BUFSIZE);
     var bytesRead = 0;
     var fd = process.stdin.fd;
     var usingDevice = false;
     try {
      fd = fs.openSync("/dev/stdin", "r");
      usingDevice = true;
     } catch (e) {}
     bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
     if (usingDevice) {
      fs.closeSync(fd);
     }
     if (bytesRead > 0) {
      result = buf.slice(0, bytesRead).toString("utf-8");
     } else {
      result = null;
     }
    } else if (typeof window != "undefined" && typeof window.prompt == "function") {
     result = window.prompt("Input: ");
     if (result !== null) {
      result += "\n";
     }
    } else if (typeof readline == "function") {
     result = readline();
     if (result !== null) {
      result += "\n";
     }
    }
    if (!result) {
     return null;
    }
    tty.input = intArrayFromString(result, true);
   }
   return tty.input.shift();
  }),
  put_char: (function(tty, val) {
   if (val === null || val === 10) {
    Module["print"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  }),
  flush: (function(tty) {
   if (tty.output && tty.output.length > 0) {
    Module["print"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  })
 },
 default_tty1_ops: {
  put_char: (function(tty, val) {
   if (val === null || val === 10) {
    Module["printErr"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  }),
  flush: (function(tty) {
   if (tty.output && tty.output.length > 0) {
    Module["printErr"](UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  })
 }
};
Module["TTY"] = TTY;
var MEMFS = {
 ops_table: null,
 mount: (function(mount) {
  return MEMFS.createNode(null, "/", 16384 | 511, 0);
 }),
 createNode: (function(parent, name, mode, dev) {
  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (!MEMFS.ops_table) {
   MEMFS.ops_table = {
    dir: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      lookup: MEMFS.node_ops.lookup,
      mknod: MEMFS.node_ops.mknod,
      rename: MEMFS.node_ops.rename,
      unlink: MEMFS.node_ops.unlink,
      rmdir: MEMFS.node_ops.rmdir,
      readdir: MEMFS.node_ops.readdir,
      symlink: MEMFS.node_ops.symlink
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek
     }
    },
    file: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek,
      read: MEMFS.stream_ops.read,
      write: MEMFS.stream_ops.write,
      allocate: MEMFS.stream_ops.allocate,
      mmap: MEMFS.stream_ops.mmap,
      msync: MEMFS.stream_ops.msync
     }
    },
    link: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      readlink: MEMFS.node_ops.readlink
     },
     stream: {}
    },
    chrdev: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: FS.chrdev_stream_ops
    }
   };
  }
  var node = FS.createNode(parent, name, mode, dev);
  if (FS.isDir(node.mode)) {
   node.node_ops = MEMFS.ops_table.dir.node;
   node.stream_ops = MEMFS.ops_table.dir.stream;
   node.contents = {};
  } else if (FS.isFile(node.mode)) {
   node.node_ops = MEMFS.ops_table.file.node;
   node.stream_ops = MEMFS.ops_table.file.stream;
   node.usedBytes = 0;
   node.contents = null;
  } else if (FS.isLink(node.mode)) {
   node.node_ops = MEMFS.ops_table.link.node;
   node.stream_ops = MEMFS.ops_table.link.stream;
  } else if (FS.isChrdev(node.mode)) {
   node.node_ops = MEMFS.ops_table.chrdev.node;
   node.stream_ops = MEMFS.ops_table.chrdev.stream;
  }
  node.timestamp = Date.now();
  if (parent) {
   parent.contents[name] = node;
  }
  return node;
 }),
 getFileDataAsRegularArray: (function(node) {
  if (node.contents && node.contents.subarray) {
   var arr = [];
   for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
   return arr;
  }
  return node.contents;
 }),
 getFileDataAsTypedArray: (function(node) {
  if (!node.contents) return new Uint8Array;
  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
  return new Uint8Array(node.contents);
 }),
 expandFileStorage: (function(node, newCapacity) {
  if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
   node.contents = MEMFS.getFileDataAsRegularArray(node);
   node.usedBytes = node.contents.length;
  }
  if (!node.contents || node.contents.subarray) {
   var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
   if (prevCapacity >= newCapacity) return;
   var CAPACITY_DOUBLING_MAX = 1024 * 1024;
   newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);
   if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
   var oldContents = node.contents;
   node.contents = new Uint8Array(newCapacity);
   if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
   return;
  }
  if (!node.contents && newCapacity > 0) node.contents = [];
  while (node.contents.length < newCapacity) node.contents.push(0);
 }),
 resizeFileStorage: (function(node, newSize) {
  if (node.usedBytes == newSize) return;
  if (newSize == 0) {
   node.contents = null;
   node.usedBytes = 0;
   return;
  }
  if (!node.contents || node.contents.subarray) {
   var oldContents = node.contents;
   node.contents = new Uint8Array(new ArrayBuffer(newSize));
   if (oldContents) {
    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
   }
   node.usedBytes = newSize;
   return;
  }
  if (!node.contents) node.contents = [];
  if (node.contents.length > newSize) node.contents.length = newSize; else while (node.contents.length < newSize) node.contents.push(0);
  node.usedBytes = newSize;
 }),
 node_ops: {
  getattr: (function(node) {
   var attr = {};
   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
   attr.ino = node.id;
   attr.mode = node.mode;
   attr.nlink = 1;
   attr.uid = 0;
   attr.gid = 0;
   attr.rdev = node.rdev;
   if (FS.isDir(node.mode)) {
    attr.size = 4096;
   } else if (FS.isFile(node.mode)) {
    attr.size = node.usedBytes;
   } else if (FS.isLink(node.mode)) {
    attr.size = node.link.length;
   } else {
    attr.size = 0;
   }
   attr.atime = new Date(node.timestamp);
   attr.mtime = new Date(node.timestamp);
   attr.ctime = new Date(node.timestamp);
   attr.blksize = 4096;
   attr.blocks = Math.ceil(attr.size / attr.blksize);
   return attr;
  }),
  setattr: (function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
   if (attr.size !== undefined) {
    MEMFS.resizeFileStorage(node, attr.size);
   }
  }),
  lookup: (function(parent, name) {
   throw FS.genericErrors[ERRNO_CODES.ENOENT];
  }),
  mknod: (function(parent, name, mode, dev) {
   return MEMFS.createNode(parent, name, mode, dev);
  }),
  rename: (function(old_node, new_dir, new_name) {
   if (FS.isDir(old_node.mode)) {
    var new_node;
    try {
     new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    if (new_node) {
     for (var i in new_node.contents) {
      throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
     }
    }
   }
   delete old_node.parent.contents[old_node.name];
   old_node.name = new_name;
   new_dir.contents[new_name] = old_node;
   old_node.parent = new_dir;
  }),
  unlink: (function(parent, name) {
   delete parent.contents[name];
  }),
  rmdir: (function(parent, name) {
   var node = FS.lookupNode(parent, name);
   for (var i in node.contents) {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
   }
   delete parent.contents[name];
  }),
  readdir: (function(node) {
   var entries = [ ".", ".." ];
   for (var key in node.contents) {
    if (!node.contents.hasOwnProperty(key)) {
     continue;
    }
    entries.push(key);
   }
   return entries;
  }),
  symlink: (function(parent, newname, oldpath) {
   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
   node.link = oldpath;
   return node;
  }),
  readlink: (function(node) {
   if (!FS.isLink(node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return node.link;
  })
 },
 stream_ops: {
  read: (function(stream, buffer, offset, length, position) {
   var contents = stream.node.contents;
   if (position >= stream.node.usedBytes) return 0;
   var size = Math.min(stream.node.usedBytes - position, length);
   assert(size >= 0);
   if (size > 8 && contents.subarray) {
    buffer.set(contents.subarray(position, position + size), offset);
   } else {
    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
   }
   return size;
  }),
  write: (function(stream, buffer, offset, length, position, canOwn) {
   if (!length) return 0;
   var node = stream.node;
   node.timestamp = Date.now();
   if (buffer.subarray && (!node.contents || node.contents.subarray)) {
    if (canOwn) {
     node.contents = buffer.subarray(offset, offset + length);
     node.usedBytes = length;
     return length;
    } else if (node.usedBytes === 0 && position === 0) {
     node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
     node.usedBytes = length;
     return length;
    } else if (position + length <= node.usedBytes) {
     node.contents.set(buffer.subarray(offset, offset + length), position);
     return length;
    }
   }
   MEMFS.expandFileStorage(node, position + length);
   if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); else {
    for (var i = 0; i < length; i++) {
     node.contents[position + i] = buffer[offset + i];
    }
   }
   node.usedBytes = Math.max(node.usedBytes, position + length);
   return length;
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.usedBytes;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return position;
  }),
  allocate: (function(stream, offset, length) {
   MEMFS.expandFileStorage(stream.node, offset + length);
   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
  }),
  mmap: (function(stream, buffer, offset, length, position, prot, flags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
   }
   var ptr;
   var allocated;
   var contents = stream.node.contents;
   if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {
    allocated = false;
    ptr = contents.byteOffset;
   } else {
    if (position > 0 || position + length < stream.node.usedBytes) {
     if (contents.subarray) {
      contents = contents.subarray(position, position + length);
     } else {
      contents = Array.prototype.slice.call(contents, position, position + length);
     }
    }
    allocated = true;
    ptr = _malloc(length);
    if (!ptr) {
     throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
    }
    buffer.set(contents, ptr);
   }
   return {
    ptr: ptr,
    allocated: allocated
   };
  }),
  msync: (function(stream, buffer, offset, length, mmapFlags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
   }
   if (mmapFlags & 2) {
    return 0;
   }
   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
   return 0;
  })
 }
};
Module["MEMFS"] = MEMFS;
var IDBFS = {
 dbs: {},
 indexedDB: (function() {
  if (typeof indexedDB !== "undefined") return indexedDB;
  var ret = null;
  if (typeof window === "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
  assert(ret, "IDBFS used, but indexedDB not supported");
  return ret;
 }),
 DB_VERSION: 21,
 DB_STORE_NAME: "FILE_DATA",
 mount: (function(mount) {
  return MEMFS.mount.apply(null, arguments);
 }),
 syncfs: (function(mount, populate, callback) {
  IDBFS.getLocalSet(mount, (function(err, local) {
   if (err) return callback(err);
   IDBFS.getRemoteSet(mount, (function(err, remote) {
    if (err) return callback(err);
    var src = populate ? remote : local;
    var dst = populate ? local : remote;
    IDBFS.reconcile(src, dst, callback);
   }));
  }));
 }),
 getDB: (function(name, callback) {
  var db = IDBFS.dbs[name];
  if (db) {
   return callback(null, db);
  }
  var req;
  try {
   req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
  } catch (e) {
   return callback(e);
  }
  req.onupgradeneeded = (function(e) {
   var db = e.target.result;
   var transaction = e.target.transaction;
   var fileStore;
   if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
    fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
   } else {
    fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
   }
   if (!fileStore.indexNames.contains("timestamp")) {
    fileStore.createIndex("timestamp", "timestamp", {
     unique: false
    });
   }
  });
  req.onsuccess = (function() {
   db = req.result;
   IDBFS.dbs[name] = db;
   callback(null, db);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 getLocalSet: (function(mount, callback) {
  var entries = {};
  function isRealDir(p) {
   return p !== "." && p !== "..";
  }
  function toAbsolute(root) {
   return (function(p) {
    return PATH.join2(root, p);
   });
  }
  var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  while (check.length) {
   var path = check.pop();
   var stat;
   try {
    stat = FS.stat(path);
   } catch (e) {
    return callback(e);
   }
   if (FS.isDir(stat.mode)) {
    check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
   }
   entries[path] = {
    timestamp: stat.mtime
   };
  }
  return callback(null, {
   type: "local",
   entries: entries
  });
 }),
 getRemoteSet: (function(mount, callback) {
  var entries = {};
  IDBFS.getDB(mount.mountpoint, (function(err, db) {
   if (err) return callback(err);
   var transaction = db.transaction([ IDBFS.DB_STORE_NAME ], "readonly");
   transaction.onerror = (function(e) {
    callback(this.error);
    e.preventDefault();
   });
   var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
   var index = store.index("timestamp");
   index.openKeyCursor().onsuccess = (function(event) {
    var cursor = event.target.result;
    if (!cursor) {
     return callback(null, {
      type: "remote",
      db: db,
      entries: entries
     });
    }
    entries[cursor.primaryKey] = {
     timestamp: cursor.key
    };
    cursor.continue();
   });
  }));
 }),
 loadLocalEntry: (function(path, callback) {
  var stat, node;
  try {
   var lookup = FS.lookupPath(path);
   node = lookup.node;
   stat = FS.stat(path);
  } catch (e) {
   return callback(e);
  }
  if (FS.isDir(stat.mode)) {
   return callback(null, {
    timestamp: stat.mtime,
    mode: stat.mode
   });
  } else if (FS.isFile(stat.mode)) {
   node.contents = MEMFS.getFileDataAsTypedArray(node);
   return callback(null, {
    timestamp: stat.mtime,
    mode: stat.mode,
    contents: node.contents
   });
  } else {
   return callback(new Error("node type not supported"));
  }
 }),
 storeLocalEntry: (function(path, entry, callback) {
  try {
   if (FS.isDir(entry.mode)) {
    FS.mkdir(path, entry.mode);
   } else if (FS.isFile(entry.mode)) {
    FS.writeFile(path, entry.contents, {
     encoding: "binary",
     canOwn: true
    });
   } else {
    return callback(new Error("node type not supported"));
   }
   FS.chmod(path, entry.mode);
   FS.utime(path, entry.timestamp, entry.timestamp);
  } catch (e) {
   return callback(e);
  }
  callback(null);
 }),
 removeLocalEntry: (function(path, callback) {
  try {
   var lookup = FS.lookupPath(path);
   var stat = FS.stat(path);
   if (FS.isDir(stat.mode)) {
    FS.rmdir(path);
   } else if (FS.isFile(stat.mode)) {
    FS.unlink(path);
   }
  } catch (e) {
   return callback(e);
  }
  callback(null);
 }),
 loadRemoteEntry: (function(store, path, callback) {
  var req = store.get(path);
  req.onsuccess = (function(event) {
   callback(null, event.target.result);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 storeRemoteEntry: (function(store, path, entry, callback) {
  var req = store.put(entry, path);
  req.onsuccess = (function() {
   callback(null);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 removeRemoteEntry: (function(store, path, callback) {
  var req = store.delete(path);
  req.onsuccess = (function() {
   callback(null);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 reconcile: (function(src, dst, callback) {
  var total = 0;
  var create = [];
  Object.keys(src.entries).forEach((function(key) {
   var e = src.entries[key];
   var e2 = dst.entries[key];
   if (!e2 || e.timestamp > e2.timestamp) {
    create.push(key);
    total++;
   }
  }));
  var remove = [];
  Object.keys(dst.entries).forEach((function(key) {
   var e = dst.entries[key];
   var e2 = src.entries[key];
   if (!e2) {
    remove.push(key);
    total++;
   }
  }));
  if (!total) {
   return callback(null);
  }
  var completed = 0;
  var db = src.type === "remote" ? src.db : dst.db;
  var transaction = db.transaction([ IDBFS.DB_STORE_NAME ], "readwrite");
  var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  function done(err) {
   if (err) {
    if (!done.errored) {
     done.errored = true;
     return callback(err);
    }
    return;
   }
   if (++completed >= total) {
    return callback(null);
   }
  }
  transaction.onerror = (function(e) {
   done(this.error);
   e.preventDefault();
  });
  create.sort().forEach((function(path) {
   if (dst.type === "local") {
    IDBFS.loadRemoteEntry(store, path, (function(err, entry) {
     if (err) return done(err);
     IDBFS.storeLocalEntry(path, entry, done);
    }));
   } else {
    IDBFS.loadLocalEntry(path, (function(err, entry) {
     if (err) return done(err);
     IDBFS.storeRemoteEntry(store, path, entry, done);
    }));
   }
  }));
  remove.sort().reverse().forEach((function(path) {
   if (dst.type === "local") {
    IDBFS.removeLocalEntry(path, done);
   } else {
    IDBFS.removeRemoteEntry(store, path, done);
   }
  }));
 })
};
Module["IDBFS"] = IDBFS;
var NODEFS = {
 isWindows: false,
 staticInit: (function() {
  NODEFS.isWindows = !!process.platform.match(/^win/);
 }),
 mount: (function(mount) {
  assert(ENVIRONMENT_IS_NODE);
  return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
 }),
 createNode: (function(parent, name, mode, dev) {
  if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var node = FS.createNode(parent, name, mode);
  node.node_ops = NODEFS.node_ops;
  node.stream_ops = NODEFS.stream_ops;
  return node;
 }),
 getMode: (function(path) {
  var stat;
  try {
   stat = fs.lstatSync(path);
   if (NODEFS.isWindows) {
    stat.mode = stat.mode | (stat.mode & 146) >> 1;
   }
  } catch (e) {
   if (!e.code) throw e;
   throw new FS.ErrnoError(ERRNO_CODES[e.code]);
  }
  return stat.mode;
 }),
 realPath: (function(node) {
  var parts = [];
  while (node.parent !== node) {
   parts.push(node.name);
   node = node.parent;
  }
  parts.push(node.mount.opts.root);
  parts.reverse();
  return PATH.join.apply(null, parts);
 }),
 flagsToPermissionStringMap: {
  0: "r",
  1: "r+",
  2: "r+",
  64: "r",
  65: "r+",
  66: "r+",
  129: "rx+",
  193: "rx+",
  514: "w+",
  577: "w",
  578: "w+",
  705: "wx",
  706: "wx+",
  1024: "a",
  1025: "a",
  1026: "a+",
  1089: "a",
  1090: "a+",
  1153: "ax",
  1154: "ax+",
  1217: "ax",
  1218: "ax+",
  4096: "rs",
  4098: "rs+"
 },
 flagsToPermissionString: (function(flags) {
  flags &= ~32768;
  flags &= ~524288;
  if (flags in NODEFS.flagsToPermissionStringMap) {
   return NODEFS.flagsToPermissionStringMap[flags];
  } else {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
 }),
 node_ops: {
  getattr: (function(node) {
   var path = NODEFS.realPath(node);
   var stat;
   try {
    stat = fs.lstatSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   if (NODEFS.isWindows && !stat.blksize) {
    stat.blksize = 4096;
   }
   if (NODEFS.isWindows && !stat.blocks) {
    stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
   }
   return {
    dev: stat.dev,
    ino: stat.ino,
    mode: stat.mode,
    nlink: stat.nlink,
    uid: stat.uid,
    gid: stat.gid,
    rdev: stat.rdev,
    size: stat.size,
    atime: stat.atime,
    mtime: stat.mtime,
    ctime: stat.ctime,
    blksize: stat.blksize,
    blocks: stat.blocks
   };
  }),
  setattr: (function(node, attr) {
   var path = NODEFS.realPath(node);
   try {
    if (attr.mode !== undefined) {
     fs.chmodSync(path, attr.mode);
     node.mode = attr.mode;
    }
    if (attr.timestamp !== undefined) {
     var date = new Date(attr.timestamp);
     fs.utimesSync(path, date, date);
    }
    if (attr.size !== undefined) {
     fs.truncateSync(path, attr.size);
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  lookup: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   var mode = NODEFS.getMode(path);
   return NODEFS.createNode(parent, name, mode);
  }),
  mknod: (function(parent, name, mode, dev) {
   var node = NODEFS.createNode(parent, name, mode, dev);
   var path = NODEFS.realPath(node);
   try {
    if (FS.isDir(node.mode)) {
     fs.mkdirSync(path, node.mode);
    } else {
     fs.writeFileSync(path, "", {
      mode: node.mode
     });
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   return node;
  }),
  rename: (function(oldNode, newDir, newName) {
   var oldPath = NODEFS.realPath(oldNode);
   var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
   try {
    fs.renameSync(oldPath, newPath);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  unlink: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   try {
    fs.unlinkSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  rmdir: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   try {
    fs.rmdirSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  readdir: (function(node) {
   var path = NODEFS.realPath(node);
   try {
    return fs.readdirSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  symlink: (function(parent, newName, oldPath) {
   var newPath = PATH.join2(NODEFS.realPath(parent), newName);
   try {
    fs.symlinkSync(oldPath, newPath);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  readlink: (function(node) {
   var path = NODEFS.realPath(node);
   try {
    path = fs.readlinkSync(path);
    path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
    return path;
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  })
 },
 stream_ops: {
  open: (function(stream) {
   var path = NODEFS.realPath(stream.node);
   try {
    if (FS.isFile(stream.node.mode)) {
     stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  close: (function(stream) {
   try {
    if (FS.isFile(stream.node.mode) && stream.nfd) {
     fs.closeSync(stream.nfd);
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
  }),
  read: (function(stream, buffer, offset, length, position) {
   if (length === 0) return 0;
   var nbuffer = new Buffer(length);
   var res;
   try {
    res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
   } catch (e) {
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   if (res > 0) {
    for (var i = 0; i < res; i++) {
     buffer[offset + i] = nbuffer[i];
    }
   }
   return res;
  }),
  write: (function(stream, buffer, offset, length, position) {
   var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
   var res;
   try {
    res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
   } catch (e) {
    throw new FS.ErrnoError(ERRNO_CODES[e.code]);
   }
   return res;
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     try {
      var stat = fs.fstatSync(stream.nfd);
      position += stat.size;
     } catch (e) {
      throw new FS.ErrnoError(ERRNO_CODES[e.code]);
     }
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return position;
  })
 }
};
Module["NODEFS"] = NODEFS;
var WORKERFS = {
 DIR_MODE: 16895,
 FILE_MODE: 33279,
 reader: null,
 mount: (function(mount) {
  assert(ENVIRONMENT_IS_WORKER);
  if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync;
  var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0);
  var createdParents = {};
  function ensureParent(path) {
   var parts = path.split("/");
   var parent = root;
   for (var i = 0; i < parts.length - 1; i++) {
    var curr = parts.slice(0, i + 1).join("/");
    if (!createdParents[curr]) {
     createdParents[curr] = WORKERFS.createNode(parent, curr, WORKERFS.DIR_MODE, 0);
    }
    parent = createdParents[curr];
   }
   return parent;
  }
  function base(path) {
   var parts = path.split("/");
   return parts[parts.length - 1];
  }
  Array.prototype.forEach.call(mount.opts["files"] || [], (function(file) {
   WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);
  }));
  (mount.opts["blobs"] || []).forEach((function(obj) {
   WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);
  }));
  (mount.opts["packages"] || []).forEach((function(pack) {
   pack["metadata"].files.forEach((function(file) {
    var name = file.filename.substr(1);
    WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack["blob"].slice(file.start, file.end));
   }));
  }));
  return root;
 }),
 createNode: (function(parent, name, mode, dev, contents, mtime) {
  var node = FS.createNode(parent, name, mode);
  node.mode = mode;
  node.node_ops = WORKERFS.node_ops;
  node.stream_ops = WORKERFS.stream_ops;
  node.timestamp = (mtime || new Date).getTime();
  assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
  if (mode === WORKERFS.FILE_MODE) {
   node.size = contents.size;
   node.contents = contents;
  } else {
   node.size = 4096;
   node.contents = {};
  }
  if (parent) {
   parent.contents[name] = node;
  }
  return node;
 }),
 node_ops: {
  getattr: (function(node) {
   return {
    dev: 1,
    ino: undefined,
    mode: node.mode,
    nlink: 1,
    uid: 0,
    gid: 0,
    rdev: undefined,
    size: node.size,
    atime: new Date(node.timestamp),
    mtime: new Date(node.timestamp),
    ctime: new Date(node.timestamp),
    blksize: 4096,
    blocks: Math.ceil(node.size / 4096)
   };
  }),
  setattr: (function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
  }),
  lookup: (function(parent, name) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }),
  mknod: (function(parent, name, mode, dev) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  rename: (function(oldNode, newDir, newName) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  unlink: (function(parent, name) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  rmdir: (function(parent, name) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  readdir: (function(node) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  symlink: (function(parent, newName, oldPath) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }),
  readlink: (function(node) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  })
 },
 stream_ops: {
  read: (function(stream, buffer, offset, length, position) {
   if (position >= stream.node.size) return 0;
   var chunk = stream.node.contents.slice(position, position + length);
   var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
   buffer.set(new Uint8Array(ab), offset);
   return chunk.size;
  }),
  write: (function(stream, buffer, offset, length, position) {
   throw new FS.ErrnoError(ERRNO_CODES.EIO);
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.size;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   return position;
  })
 }
};
Module["WORKERFS"] = WORKERFS;
var _stdin = STATICTOP;
STATICTOP += 16;
Module["_stdin"] = _stdin;
var _stdout = STATICTOP;
STATICTOP += 16;
Module["_stdout"] = _stdout;
var _stderr = STATICTOP;
STATICTOP += 16;
Module["_stderr"] = _stderr;
var FS = {
 root: null,
 mounts: [],
 devices: [ null ],
 streams: [],
 nextInode: 1,
 nameTable: null,
 currentPath: "/",
 initialized: false,
 ignorePermissions: true,
 trackingDelegate: {},
 tracking: {
  openFlags: {
   READ: 1,
   WRITE: 2
  }
 },
 ErrnoError: null,
 genericErrors: {},
 filesystems: null,
 syncFSRequests: 0,
 handleFSError: (function(e) {
  if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
  return ___setErrNo(e.errno);
 }),
 lookupPath: (function(path, opts) {
  path = PATH.resolve(FS.cwd(), path);
  opts = opts || {};
  if (!path) return {
   path: "",
   node: null
  };
  var defaults = {
   follow_mount: true,
   recurse_count: 0
  };
  for (var key in defaults) {
   if (opts[key] === undefined) {
    opts[key] = defaults[key];
   }
  }
  if (opts.recurse_count > 8) {
   throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
  }
  var parts = PATH.normalizeArray(path.split("/").filter((function(p) {
   return !!p;
  })), false);
  var current = FS.root;
  var current_path = "/";
  for (var i = 0; i < parts.length; i++) {
   var islast = i === parts.length - 1;
   if (islast && opts.parent) {
    break;
   }
   current = FS.lookupNode(current, parts[i]);
   current_path = PATH.join2(current_path, parts[i]);
   if (FS.isMountpoint(current)) {
    if (!islast || islast && opts.follow_mount) {
     current = current.mounted.root;
    }
   }
   if (!islast || opts.follow) {
    var count = 0;
    while (FS.isLink(current.mode)) {
     var link = FS.readlink(current_path);
     current_path = PATH.resolve(PATH.dirname(current_path), link);
     var lookup = FS.lookupPath(current_path, {
      recurse_count: opts.recurse_count
     });
     current = lookup.node;
     if (count++ > 40) {
      throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
     }
    }
   }
  }
  return {
   path: current_path,
   node: current
  };
 }),
 getPath: (function(node) {
  var path;
  while (true) {
   if (FS.isRoot(node)) {
    var mount = node.mount.mountpoint;
    if (!path) return mount;
    return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
   }
   path = path ? node.name + "/" + path : node.name;
   node = node.parent;
  }
 }),
 hashName: (function(parentid, name) {
  var hash = 0;
  for (var i = 0; i < name.length; i++) {
   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
  }
  return (parentid + hash >>> 0) % FS.nameTable.length;
 }),
 hashAddNode: (function(node) {
  var hash = FS.hashName(node.parent.id, node.name);
  node.name_next = FS.nameTable[hash];
  FS.nameTable[hash] = node;
 }),
 hashRemoveNode: (function(node) {
  var hash = FS.hashName(node.parent.id, node.name);
  if (FS.nameTable[hash] === node) {
   FS.nameTable[hash] = node.name_next;
  } else {
   var current = FS.nameTable[hash];
   while (current) {
    if (current.name_next === node) {
     current.name_next = node.name_next;
     break;
    }
    current = current.name_next;
   }
  }
 }),
 lookupNode: (function(parent, name) {
  var err = FS.mayLookup(parent);
  if (err) {
   throw new FS.ErrnoError(err, parent);
  }
  var hash = FS.hashName(parent.id, name);
  for (var node = FS.nameTable[hash]; node; node = node.name_next) {
   var nodeName = node.name;
   if (node.parent.id === parent.id && nodeName === name) {
    return node;
   }
  }
  return FS.lookup(parent, name);
 }),
 createNode: (function(parent, name, mode, rdev) {
  if (!FS.FSNode) {
   FS.FSNode = (function(parent, name, mode, rdev) {
    if (!parent) {
     parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
   });
   FS.FSNode.prototype = {};
   var readMode = 292 | 73;
   var writeMode = 146;
   Object.defineProperties(FS.FSNode.prototype, {
    read: {
     get: (function() {
      return (this.mode & readMode) === readMode;
     }),
     set: (function(val) {
      val ? this.mode |= readMode : this.mode &= ~readMode;
     })
    },
    write: {
     get: (function() {
      return (this.mode & writeMode) === writeMode;
     }),
     set: (function(val) {
      val ? this.mode |= writeMode : this.mode &= ~writeMode;
     })
    },
    isFolder: {
     get: (function() {
      return FS.isDir(this.mode);
     })
    },
    isDevice: {
     get: (function() {
      return FS.isChrdev(this.mode);
     })
    }
   });
  }
  var node = new FS.FSNode(parent, name, mode, rdev);
  FS.hashAddNode(node);
  return node;
 }),
 destroyNode: (function(node) {
  FS.hashRemoveNode(node);
 }),
 isRoot: (function(node) {
  return node === node.parent;
 }),
 isMountpoint: (function(node) {
  return !!node.mounted;
 }),
 isFile: (function(mode) {
  return (mode & 61440) === 32768;
 }),
 isDir: (function(mode) {
  return (mode & 61440) === 16384;
 }),
 isLink: (function(mode) {
  return (mode & 61440) === 40960;
 }),
 isChrdev: (function(mode) {
  return (mode & 61440) === 8192;
 }),
 isBlkdev: (function(mode) {
  return (mode & 61440) === 24576;
 }),
 isFIFO: (function(mode) {
  return (mode & 61440) === 4096;
 }),
 isSocket: (function(mode) {
  return (mode & 49152) === 49152;
 }),
 flagModes: {
  "r": 0,
  "rs": 1052672,
  "r+": 2,
  "w": 577,
  "wx": 705,
  "xw": 705,
  "w+": 578,
  "wx+": 706,
  "xw+": 706,
  "a": 1089,
  "ax": 1217,
  "xa": 1217,
  "a+": 1090,
  "ax+": 1218,
  "xa+": 1218
 },
 modeStringToFlags: (function(str) {
  var flags = FS.flagModes[str];
  if (typeof flags === "undefined") {
   throw new Error("Unknown file open mode: " + str);
  }
  return flags;
 }),
 flagsToPermissionString: (function(flag) {
  var perms = [ "r", "w", "rw" ][flag & 3];
  if (flag & 512) {
   perms += "w";
  }
  return perms;
 }),
 nodePermissions: (function(node, perms) {
  if (FS.ignorePermissions) {
   return 0;
  }
  if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
   return ERRNO_CODES.EACCES;
  } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
   return ERRNO_CODES.EACCES;
  } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
   return ERRNO_CODES.EACCES;
  }
  return 0;
 }),
 mayLookup: (function(dir) {
  var err = FS.nodePermissions(dir, "x");
  if (err) return err;
  if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
  return 0;
 }),
 mayCreate: (function(dir, name) {
  try {
   var node = FS.lookupNode(dir, name);
   return ERRNO_CODES.EEXIST;
  } catch (e) {}
  return FS.nodePermissions(dir, "wx");
 }),
 mayDelete: (function(dir, name, isdir) {
  var node;
  try {
   node = FS.lookupNode(dir, name);
  } catch (e) {
   return e.errno;
  }
  var err = FS.nodePermissions(dir, "wx");
  if (err) {
   return err;
  }
  if (isdir) {
   if (!FS.isDir(node.mode)) {
    return ERRNO_CODES.ENOTDIR;
   }
   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
    return ERRNO_CODES.EBUSY;
   }
  } else {
   if (FS.isDir(node.mode)) {
    return ERRNO_CODES.EISDIR;
   }
  }
  return 0;
 }),
 mayOpen: (function(node, flags) {
  if (!node) {
   return ERRNO_CODES.ENOENT;
  }
  if (FS.isLink(node.mode)) {
   return ERRNO_CODES.ELOOP;
  } else if (FS.isDir(node.mode)) {
   if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
    return ERRNO_CODES.EISDIR;
   }
  }
  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
 }),
 MAX_OPEN_FDS: 4096,
 nextfd: (function(fd_start, fd_end) {
  fd_start = fd_start || 0;
  fd_end = fd_end || FS.MAX_OPEN_FDS;
  for (var fd = fd_start; fd <= fd_end; fd++) {
   if (!FS.streams[fd]) {
    return fd;
   }
  }
  throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
 }),
 getStream: (function(fd) {
  return FS.streams[fd];
 }),
 createStream: (function(stream, fd_start, fd_end) {
  if (!FS.FSStream) {
   FS.FSStream = (function() {});
   FS.FSStream.prototype = {};
   Object.defineProperties(FS.FSStream.prototype, {
    object: {
     get: (function() {
      return this.node;
     }),
     set: (function(val) {
      this.node = val;
     })
    },
    isRead: {
     get: (function() {
      return (this.flags & 2097155) !== 1;
     })
    },
    isWrite: {
     get: (function() {
      return (this.flags & 2097155) !== 0;
     })
    },
    isAppend: {
     get: (function() {
      return this.flags & 1024;
     })
    }
   });
  }
  var newStream = new FS.FSStream;
  for (var p in stream) {
   newStream[p] = stream[p];
  }
  stream = newStream;
  var fd = FS.nextfd(fd_start, fd_end);
  stream.fd = fd;
  FS.streams[fd] = stream;
  return stream;
 }),
 closeStream: (function(fd) {
  FS.streams[fd] = null;
 }),
 chrdev_stream_ops: {
  open: (function(stream) {
   var device = FS.getDevice(stream.node.rdev);
   stream.stream_ops = device.stream_ops;
   if (stream.stream_ops.open) {
    stream.stream_ops.open(stream);
   }
  }),
  llseek: (function() {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  })
 },
 major: (function(dev) {
  return dev >> 8;
 }),
 minor: (function(dev) {
  return dev & 255;
 }),
 makedev: (function(ma, mi) {
  return ma << 8 | mi;
 }),
 registerDevice: (function(dev, ops) {
  FS.devices[dev] = {
   stream_ops: ops
  };
 }),
 getDevice: (function(dev) {
  return FS.devices[dev];
 }),
 getMounts: (function(mount) {
  var mounts = [];
  var check = [ mount ];
  while (check.length) {
   var m = check.pop();
   mounts.push(m);
   check.push.apply(check, m.mounts);
  }
  return mounts;
 }),
 syncfs: (function(populate, callback) {
  if (typeof populate === "function") {
   callback = populate;
   populate = false;
  }
  FS.syncFSRequests++;
  if (FS.syncFSRequests > 1) {
   console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
  }
  var mounts = FS.getMounts(FS.root.mount);
  var completed = 0;
  function doCallback(err) {
   assert(FS.syncFSRequests > 0);
   FS.syncFSRequests--;
   return callback(err);
  }
  function done(err) {
   if (err) {
    if (!done.errored) {
     done.errored = true;
     return doCallback(err);
    }
    return;
   }
   if (++completed >= mounts.length) {
    doCallback(null);
   }
  }
  mounts.forEach((function(mount) {
   if (!mount.type.syncfs) {
    return done(null);
   }
   mount.type.syncfs(mount, populate, done);
  }));
 }),
 mount: (function(type, opts, mountpoint) {
  var root = mountpoint === "/";
  var pseudo = !mountpoint;
  var node;
  if (root && FS.root) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  } else if (!root && !pseudo) {
   var lookup = FS.lookupPath(mountpoint, {
    follow_mount: false
   });
   mountpoint = lookup.path;
   node = lookup.node;
   if (FS.isMountpoint(node)) {
    throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
   }
   if (!FS.isDir(node.mode)) {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
   }
  }
  var mount = {
   type: type,
   opts: opts,
   mountpoint: mountpoint,
   mounts: []
  };
  var mountRoot = type.mount(mount);
  mountRoot.mount = mount;
  mount.root = mountRoot;
  if (root) {
   FS.root = mountRoot;
  } else if (node) {
   node.mounted = mount;
   if (node.mount) {
    node.mount.mounts.push(mount);
   }
  }
  return mountRoot;
 }),
 unmount: (function(mountpoint) {
  var lookup = FS.lookupPath(mountpoint, {
   follow_mount: false
  });
  if (!FS.isMountpoint(lookup.node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var node = lookup.node;
  var mount = node.mounted;
  var mounts = FS.getMounts(mount);
  Object.keys(FS.nameTable).forEach((function(hash) {
   var current = FS.nameTable[hash];
   while (current) {
    var next = current.name_next;
    if (mounts.indexOf(current.mount) !== -1) {
     FS.destroyNode(current);
    }
    current = next;
   }
  }));
  node.mounted = null;
  var idx = node.mount.mounts.indexOf(mount);
  assert(idx !== -1);
  node.mount.mounts.splice(idx, 1);
 }),
 lookup: (function(parent, name) {
  return parent.node_ops.lookup(parent, name);
 }),
 mknod: (function(path, mode, dev) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  if (!name || name === "." || name === "..") {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var err = FS.mayCreate(parent, name);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.mknod) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  return parent.node_ops.mknod(parent, name, mode, dev);
 }),
 create: (function(path, mode) {
  mode = mode !== undefined ? mode : 438;
  mode &= 4095;
  mode |= 32768;
  return FS.mknod(path, mode, 0);
 }),
 mkdir: (function(path, mode) {
  mode = mode !== undefined ? mode : 511;
  mode &= 511 | 512;
  mode |= 16384;
  return FS.mknod(path, mode, 0);
 }),
 mkdev: (function(path, mode, dev) {
  if (typeof dev === "undefined") {
   dev = mode;
   mode = 438;
  }
  mode |= 8192;
  return FS.mknod(path, mode, dev);
 }),
 symlink: (function(oldpath, newpath) {
  if (!PATH.resolve(oldpath)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  var lookup = FS.lookupPath(newpath, {
   parent: true
  });
  var parent = lookup.node;
  if (!parent) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  var newname = PATH.basename(newpath);
  var err = FS.mayCreate(parent, newname);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.symlink) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  return parent.node_ops.symlink(parent, newname, oldpath);
 }),
 rename: (function(old_path, new_path) {
  var old_dirname = PATH.dirname(old_path);
  var new_dirname = PATH.dirname(new_path);
  var old_name = PATH.basename(old_path);
  var new_name = PATH.basename(new_path);
  var lookup, old_dir, new_dir;
  try {
   lookup = FS.lookupPath(old_path, {
    parent: true
   });
   old_dir = lookup.node;
   lookup = FS.lookupPath(new_path, {
    parent: true
   });
   new_dir = lookup.node;
  } catch (e) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  if (old_dir.mount !== new_dir.mount) {
   throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
  }
  var old_node = FS.lookupNode(old_dir, old_name);
  var relative = PATH.relative(old_path, new_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  relative = PATH.relative(new_path, old_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
  }
  var new_node;
  try {
   new_node = FS.lookupNode(new_dir, new_name);
  } catch (e) {}
  if (old_node === new_node) {
   return;
  }
  var isdir = FS.isDir(old_node.mode);
  var err = FS.mayDelete(old_dir, old_name, isdir);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!old_dir.node_ops.rename) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  if (new_dir !== old_dir) {
   err = FS.nodePermissions(old_dir, "w");
   if (err) {
    throw new FS.ErrnoError(err);
   }
  }
  try {
   if (FS.trackingDelegate["willMovePath"]) {
    FS.trackingDelegate["willMovePath"](old_path, new_path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
  }
  FS.hashRemoveNode(old_node);
  try {
   old_dir.node_ops.rename(old_node, new_dir, new_name);
  } catch (e) {
   throw e;
  } finally {
   FS.hashAddNode(old_node);
  }
  try {
   if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path);
  } catch (e) {
   console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
  }
 }),
 rmdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var err = FS.mayDelete(parent, name, true);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.rmdir) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  try {
   if (FS.trackingDelegate["willDeletePath"]) {
    FS.trackingDelegate["willDeletePath"](path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
  }
  parent.node_ops.rmdir(parent, name);
  FS.destroyNode(node);
  try {
   if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
  } catch (e) {
   console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
  }
 }),
 readdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  if (!node.node_ops.readdir) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
  }
  return node.node_ops.readdir(node);
 }),
 unlink: (function(path) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var err = FS.mayDelete(parent, name, false);
  if (err) {
   if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.unlink) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
  }
  try {
   if (FS.trackingDelegate["willDeletePath"]) {
    FS.trackingDelegate["willDeletePath"](path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
  }
  parent.node_ops.unlink(parent, name);
  FS.destroyNode(node);
  try {
   if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
  } catch (e) {
   console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
  }
 }),
 readlink: (function(path) {
  var lookup = FS.lookupPath(path);
  var link = lookup.node;
  if (!link) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  if (!link.node_ops.readlink) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
 }),
 stat: (function(path, dontFollow) {
  var lookup = FS.lookupPath(path, {
   follow: !dontFollow
  });
  var node = lookup.node;
  if (!node) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  if (!node.node_ops.getattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  return node.node_ops.getattr(node);
 }),
 lstat: (function(path) {
  return FS.stat(path, true);
 }),
 chmod: (function(path, mode, dontFollow) {
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  node.node_ops.setattr(node, {
   mode: mode & 4095 | node.mode & ~4095,
   timestamp: Date.now()
  });
 }),
 lchmod: (function(path, mode) {
  FS.chmod(path, mode, true);
 }),
 fchmod: (function(fd, mode) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  FS.chmod(stream.node, mode);
 }),
 chown: (function(path, uid, gid, dontFollow) {
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  node.node_ops.setattr(node, {
   timestamp: Date.now()
  });
 }),
 lchown: (function(path, uid, gid) {
  FS.chown(path, uid, gid, true);
 }),
 fchown: (function(fd, uid, gid) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  FS.chown(stream.node, uid, gid);
 }),
 truncate: (function(path, len) {
  if (len < 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: true
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(ERRNO_CODES.EPERM);
  }
  if (FS.isDir(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
  }
  if (!FS.isFile(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var err = FS.nodePermissions(node, "w");
  if (err) {
   throw new FS.ErrnoError(err);
  }
  node.node_ops.setattr(node, {
   size: len,
   timestamp: Date.now()
  });
 }),
 ftruncate: (function(fd, len) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  FS.truncate(stream.node, len);
 }),
 utime: (function(path, atime, mtime) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  node.node_ops.setattr(node, {
   timestamp: Math.max(atime, mtime)
  });
 }),
 open: (function(path, flags, mode, fd_start, fd_end) {
  if (path === "") {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
  mode = typeof mode === "undefined" ? 438 : mode;
  if (flags & 64) {
   mode = mode & 4095 | 32768;
  } else {
   mode = 0;
  }
  var node;
  if (typeof path === "object") {
   node = path;
  } else {
   path = PATH.normalize(path);
   try {
    var lookup = FS.lookupPath(path, {
     follow: !(flags & 131072)
    });
    node = lookup.node;
   } catch (e) {}
  }
  var created = false;
  if (flags & 64) {
   if (node) {
    if (flags & 128) {
     throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
    }
   } else {
    node = FS.mknod(path, mode, 0);
    created = true;
   }
  }
  if (!node) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
  }
  if (FS.isChrdev(node.mode)) {
   flags &= ~512;
  }
  if (flags & 65536 && !FS.isDir(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
  }
  if (!created) {
   var err = FS.mayOpen(node, flags);
   if (err) {
    throw new FS.ErrnoError(err);
   }
  }
  if (flags & 512) {
   FS.truncate(node, 0);
  }
  flags &= ~(128 | 512);
  var stream = FS.createStream({
   node: node,
   path: FS.getPath(node),
   flags: flags,
   seekable: true,
   position: 0,
   stream_ops: node.stream_ops,
   ungotten: [],
   error: false
  }, fd_start, fd_end);
  if (stream.stream_ops.open) {
   stream.stream_ops.open(stream);
  }
  if (Module["logReadFiles"] && !(flags & 1)) {
   if (!FS.readFiles) FS.readFiles = {};
   if (!(path in FS.readFiles)) {
    FS.readFiles[path] = 1;
    Module["printErr"]("read file: " + path);
   }
  }
  try {
   if (FS.trackingDelegate["onOpenFile"]) {
    var trackingFlags = 0;
    if ((flags & 2097155) !== 1) {
     trackingFlags |= FS.tracking.openFlags.READ;
    }
    if ((flags & 2097155) !== 0) {
     trackingFlags |= FS.tracking.openFlags.WRITE;
    }
    FS.trackingDelegate["onOpenFile"](path, trackingFlags);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
  }
  return stream;
 }),
 close: (function(stream) {
  if (stream.getdents) stream.getdents = null;
  try {
   if (stream.stream_ops.close) {
    stream.stream_ops.close(stream);
   }
  } catch (e) {
   throw e;
  } finally {
   FS.closeStream(stream.fd);
  }
 }),
 llseek: (function(stream, offset, whence) {
  if (!stream.seekable || !stream.stream_ops.llseek) {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  }
  stream.position = stream.stream_ops.llseek(stream, offset, whence);
  stream.ungotten = [];
  return stream.position;
 }),
 read: (function(stream, buffer, offset, length, position) {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
  }
  if (!stream.stream_ops.read) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  var seeking = true;
  if (typeof position === "undefined") {
   position = stream.position;
   seeking = false;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  }
  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
  if (!seeking) stream.position += bytesRead;
  return bytesRead;
 }),
 write: (function(stream, buffer, offset, length, position, canOwn) {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
  }
  if (!stream.stream_ops.write) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if (stream.flags & 1024) {
   FS.llseek(stream, 0, 2);
  }
  var seeking = true;
  if (typeof position === "undefined") {
   position = stream.position;
   seeking = false;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
  }
  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
  if (!seeking) stream.position += bytesWritten;
  try {
   if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path);
  } catch (e) {
   console.log("FS.trackingDelegate['onWriteToFile']('" + path + "') threw an exception: " + e.message);
  }
  return bytesWritten;
 }),
 allocate: (function(stream, offset, length) {
  if (offset < 0 || length <= 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  }
  if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
  }
  if (!stream.stream_ops.allocate) {
   throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
  }
  stream.stream_ops.allocate(stream, offset, length);
 }),
 mmap: (function(stream, buffer, offset, length, position, prot, flags) {
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(ERRNO_CODES.EACCES);
  }
  if (!stream.stream_ops.mmap) {
   throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
  }
  return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
 }),
 msync: (function(stream, buffer, offset, length, mmapFlags) {
  if (!stream || !stream.stream_ops.msync) {
   return 0;
  }
  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
 }),
 munmap: (function(stream) {
  return 0;
 }),
 ioctl: (function(stream, cmd, arg) {
  if (!stream.stream_ops.ioctl) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
  }
  return stream.stream_ops.ioctl(stream, cmd, arg);
 }),
 readFile: (function(path, opts) {
  opts = opts || {};
  opts.flags = opts.flags || "r";
  opts.encoding = opts.encoding || "binary";
  if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
   throw new Error('Invalid encoding type "' + opts.encoding + '"');
  }
  var ret;
  var stream = FS.open(path, opts.flags);
  var stat = FS.stat(path);
  var length = stat.size;
  var buf = new Uint8Array(length);
  FS.read(stream, buf, 0, length, 0);
  if (opts.encoding === "utf8") {
   ret = UTF8ArrayToString(buf, 0);
  } else if (opts.encoding === "binary") {
   ret = buf;
  }
  FS.close(stream);
  return ret;
 }),
 writeFile: (function(path, data, opts) {
  opts = opts || {};
  opts.flags = opts.flags || "w";
  opts.encoding = opts.encoding || "utf8";
  if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
   throw new Error('Invalid encoding type "' + opts.encoding + '"');
  }
  var stream = FS.open(path, opts.flags, opts.mode);
  if (opts.encoding === "utf8") {
   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
   FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);
  } else if (opts.encoding === "binary") {
   FS.write(stream, data, 0, data.length, 0, opts.canOwn);
  }
  FS.close(stream);
 }),
 cwd: (function() {
  return FS.currentPath;
 }),
 chdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  if (!FS.isDir(lookup.node.mode)) {
   throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
  }
  var err = FS.nodePermissions(lookup.node, "x");
  if (err) {
   throw new FS.ErrnoError(err);
  }
  FS.currentPath = lookup.path;
 }),
 createDefaultDirectories: (function() {
  FS.mkdir("/tmp");
  FS.mkdir("/home");
  FS.mkdir("/home/web_user");
 }),
 createDefaultDevices: (function() {
  FS.mkdir("/dev");
  FS.registerDevice(FS.makedev(1, 3), {
   read: (function() {
    return 0;
   }),
   write: (function(stream, buffer, offset, length, pos) {
    return length;
   })
  });
  FS.mkdev("/dev/null", FS.makedev(1, 3));
  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
  FS.mkdev("/dev/tty", FS.makedev(5, 0));
  FS.mkdev("/dev/tty1", FS.makedev(6, 0));
  var random_device;
  if (typeof crypto !== "undefined") {
   var randomBuffer = new Uint8Array(1);
   random_device = (function() {
    crypto.getRandomValues(randomBuffer);
    return randomBuffer[0];
   });
  } else if (ENVIRONMENT_IS_NODE) {
   random_device = (function() {
    return require("crypto").randomBytes(1)[0];
   });
  } else {
   random_device = (function() {
    return Math.random() * 256 | 0;
   });
  }
  FS.createDevice("/dev", "random", random_device);
  FS.createDevice("/dev", "urandom", random_device);
  FS.mkdir("/dev/shm");
  FS.mkdir("/dev/shm/tmp");
 }),
 createSpecialDirectories: (function() {
  FS.mkdir("/proc");
  FS.mkdir("/proc/self");
  FS.mkdir("/proc/self/fd");
  FS.mount({
   mount: (function() {
    var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
    node.node_ops = {
     lookup: (function(parent, name) {
      var fd = +name;
      var stream = FS.getStream(fd);
      if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
      var ret = {
       parent: null,
       mount: {
        mountpoint: "fake"
       },
       node_ops: {
        readlink: (function() {
         return stream.path;
        })
       }
      };
      ret.parent = ret;
      return ret;
     })
    };
    return node;
   })
  }, {}, "/proc/self/fd");
 }),
 createStandardStreams: (function() {
  if (Module["stdin"]) {
   FS.createDevice("/dev", "stdin", Module["stdin"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdin");
  }
  if (Module["stdout"]) {
   FS.createDevice("/dev", "stdout", null, Module["stdout"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdout");
  }
  if (Module["stderr"]) {
   FS.createDevice("/dev", "stderr", null, Module["stderr"]);
  } else {
   FS.symlink("/dev/tty1", "/dev/stderr");
  }
  var stdin = FS.open("/dev/stdin", "r");
  assert(stdin.fd === 0, "invalid handle for stdin (" + stdin.fd + ")");
  var stdout = FS.open("/dev/stdout", "w");
  assert(stdout.fd === 1, "invalid handle for stdout (" + stdout.fd + ")");
  var stderr = FS.open("/dev/stderr", "w");
  assert(stderr.fd === 2, "invalid handle for stderr (" + stderr.fd + ")");
 }),
 ensureErrnoError: (function() {
  if (FS.ErrnoError) return;
  FS.ErrnoError = function ErrnoError(errno, node) {
   this.node = node;
   this.setErrno = (function(errno) {
    this.errno = errno;
    for (var key in ERRNO_CODES) {
     if (ERRNO_CODES[key] === errno) {
      this.code = key;
      break;
     }
    }
   });
   this.setErrno(errno);
   this.message = ERRNO_MESSAGES[errno];
  };
  FS.ErrnoError.prototype = new Error;
  FS.ErrnoError.prototype.constructor = FS.ErrnoError;
  [ ERRNO_CODES.ENOENT ].forEach((function(code) {
   FS.genericErrors[code] = new FS.ErrnoError(code);
   FS.genericErrors[code].stack = "<generic error, no stack>";
  }));
 }),
 staticInit: (function() {
  FS.ensureErrnoError();
  FS.nameTable = new Array(4096);
  FS.mount(MEMFS, {}, "/");
  FS.createDefaultDirectories();
  FS.createDefaultDevices();
  FS.createSpecialDirectories();
  FS.filesystems = {
   "MEMFS": MEMFS,
   "IDBFS": IDBFS,
   "NODEFS": NODEFS,
   "WORKERFS": WORKERFS
  };
 }),
 init: (function(input, output, error) {
  assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
  FS.init.initialized = true;
  FS.ensureErrnoError();
  Module["stdin"] = input || Module["stdin"];
  Module["stdout"] = output || Module["stdout"];
  Module["stderr"] = error || Module["stderr"];
  FS.createStandardStreams();
 }),
 quit: (function() {
  FS.init.initialized = false;
  var fflush = Module["_fflush"];
  if (fflush) fflush(0);
  for (var i = 0; i < FS.streams.length; i++) {
   var stream = FS.streams[i];
   if (!stream) {
    continue;
   }
   FS.close(stream);
  }
 }),
 getMode: (function(canRead, canWrite) {
  var mode = 0;
  if (canRead) mode |= 292 | 73;
  if (canWrite) mode |= 146;
  return mode;
 }),
 joinPath: (function(parts, forceRelative) {
  var path = PATH.join.apply(null, parts);
  if (forceRelative && path[0] == "/") path = path.substr(1);
  return path;
 }),
 absolutePath: (function(relative, base) {
  return PATH.resolve(base, relative);
 }),
 standardizePath: (function(path) {
  return PATH.normalize(path);
 }),
 findObject: (function(path, dontResolveLastLink) {
  var ret = FS.analyzePath(path, dontResolveLastLink);
  if (ret.exists) {
   return ret.object;
  } else {
   ___setErrNo(ret.error);
   return null;
  }
 }),
 analyzePath: (function(path, dontResolveLastLink) {
  try {
   var lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   path = lookup.path;
  } catch (e) {}
  var ret = {
   isRoot: false,
   exists: false,
   error: 0,
   name: null,
   path: null,
   object: null,
   parentExists: false,
   parentPath: null,
   parentObject: null
  };
  try {
   var lookup = FS.lookupPath(path, {
    parent: true
   });
   ret.parentExists = true;
   ret.parentPath = lookup.path;
   ret.parentObject = lookup.node;
   ret.name = PATH.basename(path);
   lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   ret.exists = true;
   ret.path = lookup.path;
   ret.object = lookup.node;
   ret.name = lookup.node.name;
   ret.isRoot = lookup.path === "/";
  } catch (e) {
   ret.error = e.errno;
  }
  return ret;
 }),
 createFolder: (function(parent, name, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.mkdir(path, mode);
 }),
 createPath: (function(parent, path, canRead, canWrite) {
  parent = typeof parent === "string" ? parent : FS.getPath(parent);
  var parts = path.split("/").reverse();
  while (parts.length) {
   var part = parts.pop();
   if (!part) continue;
   var current = PATH.join2(parent, part);
   try {
    FS.mkdir(current);
   } catch (e) {}
   parent = current;
  }
  return current;
 }),
 createFile: (function(parent, name, properties, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.create(path, mode);
 }),
 createDataFile: (function(parent, name, data, canRead, canWrite, canOwn) {
  var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
  var mode = FS.getMode(canRead, canWrite);
  var node = FS.create(path, mode);
  if (data) {
   if (typeof data === "string") {
    var arr = new Array(data.length);
    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
    data = arr;
   }
   FS.chmod(node, mode | 146);
   var stream = FS.open(node, "w");
   FS.write(stream, data, 0, data.length, 0, canOwn);
   FS.close(stream);
   FS.chmod(node, mode);
  }
  return node;
 }),
 createDevice: (function(parent, name, input, output) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(!!input, !!output);
  if (!FS.createDevice.major) FS.createDevice.major = 64;
  var dev = FS.makedev(FS.createDevice.major++, 0);
  FS.registerDevice(dev, {
   open: (function(stream) {
    stream.seekable = false;
   }),
   close: (function(stream) {
    if (output && output.buffer && output.buffer.length) {
     output(10);
    }
   }),
   read: (function(stream, buffer, offset, length, pos) {
    var bytesRead = 0;
    for (var i = 0; i < length; i++) {
     var result;
     try {
      result = input();
     } catch (e) {
      throw new FS.ErrnoError(ERRNO_CODES.EIO);
     }
     if (result === undefined && bytesRead === 0) {
      throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
     }
     if (result === null || result === undefined) break;
     bytesRead++;
     buffer[offset + i] = result;
    }
    if (bytesRead) {
     stream.node.timestamp = Date.now();
    }
    return bytesRead;
   }),
   write: (function(stream, buffer, offset, length, pos) {
    for (var i = 0; i < length; i++) {
     try {
      output(buffer[offset + i]);
     } catch (e) {
      throw new FS.ErrnoError(ERRNO_CODES.EIO);
     }
    }
    if (length) {
     stream.node.timestamp = Date.now();
    }
    return i;
   })
  });
  return FS.mkdev(path, mode, dev);
 }),
 createLink: (function(parent, name, target, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  return FS.symlink(target, path);
 }),
 forceLoadFile: (function(obj) {
  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
  var success = true;
  if (typeof XMLHttpRequest !== "undefined") {
   throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
  } else if (Module["read"]) {
   try {
    obj.contents = intArrayFromString(Module["read"](obj.url), true);
    obj.usedBytes = obj.contents.length;
   } catch (e) {
    success = false;
   }
  } else {
   throw new Error("Cannot load without read() or XMLHttpRequest.");
  }
  if (!success) ___setErrNo(ERRNO_CODES.EIO);
  return success;
 }),
 createLazyFile: (function(parent, name, url, canRead, canWrite) {
  function LazyUint8Array() {
   this.lengthKnown = false;
   this.chunks = [];
  }
  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
   if (idx > this.length - 1 || idx < 0) {
    return undefined;
   }
   var chunkOffset = idx % this.chunkSize;
   var chunkNum = idx / this.chunkSize | 0;
   return this.getter(chunkNum)[chunkOffset];
  };
  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
   this.getter = getter;
  };
  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
   var xhr = new XMLHttpRequest;
   xhr.open("HEAD", url, false);
   xhr.send(null);
   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
   var datalength = Number(xhr.getResponseHeader("Content-length"));
   var header;
   var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
   var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
   var chunkSize = 1024 * 1024;
   if (!hasByteServing) chunkSize = datalength;
   var doXHR = (function(from, to) {
    if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
    if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
    var xhr = new XMLHttpRequest;
    xhr.open("GET", url, false);
    if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
    if (xhr.overrideMimeType) {
     xhr.overrideMimeType("text/plain; charset=x-user-defined");
    }
    xhr.send(null);
    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
    if (xhr.response !== undefined) {
     return new Uint8Array(xhr.response || []);
    } else {
     return intArrayFromString(xhr.responseText || "", true);
    }
   });
   var lazyArray = this;
   lazyArray.setDataGetter((function(chunkNum) {
    var start = chunkNum * chunkSize;
    var end = (chunkNum + 1) * chunkSize - 1;
    end = Math.min(end, datalength - 1);
    if (typeof lazyArray.chunks[chunkNum] === "undefined") {
     lazyArray.chunks[chunkNum] = doXHR(start, end);
    }
    if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
    return lazyArray.chunks[chunkNum];
   }));
   if (usesGzip || !datalength) {
    chunkSize = datalength = 1;
    datalength = this.getter(0).length;
    chunkSize = datalength;
    console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
   }
   this._length = datalength;
   this._chunkSize = chunkSize;
   this.lengthKnown = true;
  };
  if (typeof XMLHttpRequest !== "undefined") {
   if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
   var lazyArray = new LazyUint8Array;
   Object.defineProperties(lazyArray, {
    length: {
     get: (function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._length;
     })
    },
    chunkSize: {
     get: (function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._chunkSize;
     })
    }
   });
   var properties = {
    isDevice: false,
    contents: lazyArray
   };
  } else {
   var properties = {
    isDevice: false,
    url: url
   };
  }
  var node = FS.createFile(parent, name, properties, canRead, canWrite);
  if (properties.contents) {
   node.contents = properties.contents;
  } else if (properties.url) {
   node.contents = null;
   node.url = properties.url;
  }
  Object.defineProperties(node, {
   usedBytes: {
    get: (function() {
     return this.contents.length;
    })
   }
  });
  var stream_ops = {};
  var keys = Object.keys(node.stream_ops);
  keys.forEach((function(key) {
   var fn = node.stream_ops[key];
   stream_ops[key] = function forceLoadLazyFile() {
    if (!FS.forceLoadFile(node)) {
     throw new FS.ErrnoError(ERRNO_CODES.EIO);
    }
    return fn.apply(null, arguments);
   };
  }));
  stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
   if (!FS.forceLoadFile(node)) {
    throw new FS.ErrnoError(ERRNO_CODES.EIO);
   }
   var contents = stream.node.contents;
   if (position >= contents.length) return 0;
   var size = Math.min(contents.length - position, length);
   assert(size >= 0);
   if (contents.slice) {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents[position + i];
    }
   } else {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents.get(position + i);
    }
   }
   return size;
  };
  node.stream_ops = stream_ops;
  return node;
 }),
 createPreloadedFile: (function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
  Browser.init();
  var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
  var dep = getUniqueRunDependency("cp " + fullname);
  function processData(byteArray) {
   function finish(byteArray) {
    if (preFinish) preFinish();
    if (!dontCreateFile) {
     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
    }
    if (onload) onload();
    removeRunDependency(dep);
   }
   var handled = false;
   Module["preloadPlugins"].forEach((function(plugin) {
    if (handled) return;
    if (plugin["canHandle"](fullname)) {
     plugin["handle"](byteArray, fullname, finish, (function() {
      if (onerror) onerror();
      removeRunDependency(dep);
     }));
     handled = true;
    }
   }));
   if (!handled) finish(byteArray);
  }
  addRunDependency(dep);
  if (typeof url == "string") {
   Browser.asyncLoad(url, (function(byteArray) {
    processData(byteArray);
   }), onerror);
  } else {
   processData(url);
  }
 }),
 indexedDB: (function() {
  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
 }),
 DB_NAME: (function() {
  return "EM_FS_" + window.location.pathname;
 }),
 DB_VERSION: 20,
 DB_STORE_NAME: "FILE_DATA",
 saveFilesToDB: (function(paths, onload, onerror) {
  onload = onload || (function() {});
  onerror = onerror || (function() {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
   console.log("creating db");
   var db = openRequest.result;
   db.createObjectStore(FS.DB_STORE_NAME);
  };
  openRequest.onsuccess = function openRequest_onsuccess() {
   var db = openRequest.result;
   var transaction = db.transaction([ FS.DB_STORE_NAME ], "readwrite");
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach((function(path) {
    var putRequest = files.put(FS.analyzePath(path).object.contents, path);
    putRequest.onsuccess = function putRequest_onsuccess() {
     ok++;
     if (ok + fail == total) finish();
    };
    putRequest.onerror = function putRequest_onerror() {
     fail++;
     if (ok + fail == total) finish();
    };
   }));
   transaction.onerror = onerror;
  };
  openRequest.onerror = onerror;
 }),
 loadFilesFromDB: (function(paths, onload, onerror) {
  onload = onload || (function() {});
  onerror = onerror || (function() {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = onerror;
  openRequest.onsuccess = function openRequest_onsuccess() {
   var db = openRequest.result;
   try {
    var transaction = db.transaction([ FS.DB_STORE_NAME ], "readonly");
   } catch (e) {
    onerror(e);
    return;
   }
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach((function(path) {
    var getRequest = files.get(path);
    getRequest.onsuccess = function getRequest_onsuccess() {
     if (FS.analyzePath(path).exists) {
      FS.unlink(path);
     }
     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
     ok++;
     if (ok + fail == total) finish();
    };
    getRequest.onerror = function getRequest_onerror() {
     fail++;
     if (ok + fail == total) finish();
    };
   }));
   transaction.onerror = onerror;
  };
  openRequest.onerror = onerror;
 })
};
Module["FS"] = FS;
var SYSCALLS = {
 DEFAULT_POLLMASK: 5,
 mappings: {},
 umask: 511,
 calculateAt: (function(dirfd, path) {
  if (path[0] !== "/") {
   var dir;
   if (dirfd === -100) {
    dir = FS.cwd();
   } else {
    var dirstream = FS.getStream(dirfd);
    if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
    dir = dirstream.path;
   }
   path = PATH.join2(dir, path);
  }
  return path;
 }),
 doStat: (function(func, path, buf) {
  try {
   var stat = func(path);
  } catch (e) {
   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
    return -ERRNO_CODES.ENOTDIR;
   }
   throw e;
  }
  HEAP32[buf >> 2] = stat.dev;
  HEAP32[buf + 4 >> 2] = 0;
  HEAP32[buf + 8 >> 2] = stat.ino;
  HEAP32[buf + 12 >> 2] = stat.mode;
  HEAP32[buf + 16 >> 2] = stat.nlink;
  HEAP32[buf + 20 >> 2] = stat.uid;
  HEAP32[buf + 24 >> 2] = stat.gid;
  HEAP32[buf + 28 >> 2] = stat.rdev;
  HEAP32[buf + 32 >> 2] = 0;
  HEAP32[buf + 36 >> 2] = stat.size;
  HEAP32[buf + 40 >> 2] = 4096;
  HEAP32[buf + 44 >> 2] = stat.blocks;
  HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;
  HEAP32[buf + 52 >> 2] = 0;
  HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;
  HEAP32[buf + 60 >> 2] = 0;
  HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;
  HEAP32[buf + 68 >> 2] = 0;
  HEAP32[buf + 72 >> 2] = stat.ino;
  return 0;
 }),
 doMsync: (function(addr, stream, len, flags) {
  var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
  FS.msync(stream, buffer, 0, len, flags);
 }),
 doMkdir: (function(path, mode) {
  path = PATH.normalize(path);
  if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
  FS.mkdir(path, mode, 0);
  return 0;
 }),
 doMknod: (function(path, mode, dev) {
  switch (mode & 61440) {
  case 32768:
  case 8192:
  case 24576:
  case 4096:
  case 49152:
   break;
  default:
   return -ERRNO_CODES.EINVAL;
  }
  FS.mknod(path, mode, dev);
  return 0;
 }),
 doReadlink: (function(path, buf, bufsize) {
  if (bufsize <= 0) return -ERRNO_CODES.EINVAL;
  var ret = FS.readlink(path);
  ret = ret.slice(0, Math.max(0, bufsize));
  writeStringToMemory(ret, buf, true);
  return ret.length;
 }),
 doAccess: (function(path, amode) {
  if (amode & ~7) {
   return -ERRNO_CODES.EINVAL;
  }
  var node;
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  node = lookup.node;
  var perms = "";
  if (amode & 4) perms += "r";
  if (amode & 2) perms += "w";
  if (amode & 1) perms += "x";
  if (perms && FS.nodePermissions(node, perms)) {
   return -ERRNO_CODES.EACCES;
  }
  return 0;
 }),
 doDup: (function(path, flags, suggestFD) {
  var suggest = FS.getStream(suggestFD);
  if (suggest) FS.close(suggest);
  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
 }),
 doReadv: (function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = HEAP32[iov + i * 8 >> 2];
   var len = HEAP32[iov + (i * 8 + 4) >> 2];
   var curr = FS.read(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
   if (curr < len) break;
  }
  return ret;
 }),
 doWritev: (function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = HEAP32[iov + i * 8 >> 2];
   var len = HEAP32[iov + (i * 8 + 4) >> 2];
   var curr = FS.write(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
  }
  return ret;
 }),
 varargs: 0,
 get: (function(varargs) {
  SYSCALLS.varargs += 4;
  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
  return ret;
 }),
 getStr: (function() {
  var ret = Pointer_stringify(SYSCALLS.get());
  return ret;
 }),
 getStreamFromFD: (function() {
  var stream = FS.getStream(SYSCALLS.get());
  if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  return stream;
 }),
 getSocketFromFD: (function() {
  var socket = SOCKFS.getSocket(SYSCALLS.get());
  if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
  return socket;
 }),
 getSocketAddress: (function(allowNull) {
  var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
  if (allowNull && addrp === 0) return null;
  var info = __read_sockaddr(addrp, addrlen);
  if (info.errno) throw new FS.ErrnoError(info.errno);
  info.addr = DNS.lookup_addr(info.addr) || info.addr;
  return info;
 }),
 get64: (function() {
  var low = SYSCALLS.get(), high = SYSCALLS.get();
  if (low >= 0) assert(high === 0); else assert(high === -1);
  return low;
 }),
 getZero: (function() {
  assert(SYSCALLS.get() === 0);
 })
};
Module["SYSCALLS"] = SYSCALLS;
function ___syscall20(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  return PROCINFO.pid;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall20"] = ___syscall20;
function __exit(status) {
 Module["exit"](status);
}
Module["__exit"] = __exit;
function _exit(status) {
 __exit(status);
}
Module["_exit"] = _exit;
function _create_viterbi27() {
 return Module["_create_viterbi27"].apply(null, arguments);
}
function _create_viterbi29() {
 return Module["_create_viterbi29"].apply(null, arguments);
}
function ___syscall6(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD();
  FS.close(stream);
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall6"] = ___syscall6;
function ___syscall54(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();
  switch (op) {
  case 21505:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    return 0;
   }
  case 21506:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    return 0;
   }
  case 21519:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    var argp = SYSCALLS.get();
    HEAP32[argp >> 2] = 0;
    return 0;
   }
  case 21520:
   {
    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
    return -ERRNO_CODES.EINVAL;
   }
  case 21531:
   {
    var argp = SYSCALLS.get();
    return FS.ioctl(stream, op, argp);
   }
  default:
   abort("bad ioctl syscall " + op);
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall54"] = ___syscall54;
function _init_viterbi27() {
 return Module["_init_viterbi27"].apply(null, arguments);
}
function _sysconf(name) {
 switch (name) {
 case 30:
  return PAGE_SIZE;
 case 85:
  return totalMemory / PAGE_SIZE;
 case 132:
 case 133:
 case 12:
 case 137:
 case 138:
 case 15:
 case 235:
 case 16:
 case 17:
 case 18:
 case 19:
 case 20:
 case 149:
 case 13:
 case 10:
 case 236:
 case 153:
 case 9:
 case 21:
 case 22:
 case 159:
 case 154:
 case 14:
 case 77:
 case 78:
 case 139:
 case 80:
 case 81:
 case 82:
 case 68:
 case 67:
 case 164:
 case 11:
 case 29:
 case 47:
 case 48:
 case 95:
 case 52:
 case 51:
 case 46:
  return 200809;
 case 79:
  return 0;
 case 27:
 case 246:
 case 127:
 case 128:
 case 23:
 case 24:
 case 160:
 case 161:
 case 181:
 case 182:
 case 242:
 case 183:
 case 184:
 case 243:
 case 244:
 case 245:
 case 165:
 case 178:
 case 179:
 case 49:
 case 50:
 case 168:
 case 169:
 case 175:
 case 170:
 case 171:
 case 172:
 case 97:
 case 76:
 case 32:
 case 173:
 case 35:
  return -1;
 case 176:
 case 177:
 case 7:
 case 155:
 case 8:
 case 157:
 case 125:
 case 126:
 case 92:
 case 93:
 case 129:
 case 130:
 case 131:
 case 94:
 case 91:
  return 1;
 case 74:
 case 60:
 case 69:
 case 70:
 case 4:
  return 1024;
 case 31:
 case 42:
 case 72:
  return 32;
 case 87:
 case 26:
 case 33:
  return 2147483647;
 case 34:
 case 1:
  return 47839;
 case 38:
 case 36:
  return 99;
 case 43:
 case 37:
  return 2048;
 case 0:
  return 2097152;
 case 3:
  return 65536;
 case 28:
  return 32768;
 case 44:
  return 32767;
 case 75:
  return 16384;
 case 39:
  return 1e3;
 case 89:
  return 700;
 case 71:
  return 256;
 case 40:
  return 255;
 case 2:
  return 100;
 case 180:
  return 64;
 case 25:
  return 20;
 case 5:
  return 16;
 case 6:
  return 6;
 case 73:
  return 4;
 case 84:
  {
   if (typeof navigator === "object") return navigator["hardwareConcurrency"] || 1;
   return 1;
  }
 }
 ___setErrNo(ERRNO_CODES.EINVAL);
 return -1;
}
Module["_sysconf"] = _sysconf;
Module["_bitshift64Lshr"] = _bitshift64Lshr;
function _chainback_viterbi39() {
 return Module["_chainback_viterbi39"].apply(null, arguments);
}
function _sched_yield() {
 return 0;
}
Module["_sched_yield"] = _sched_yield;
function _update_viterbi29_blk() {
 return Module["_update_viterbi29_blk"].apply(null, arguments);
}
function _pthread_cleanup_push(routine, arg) {
 __ATEXIT__.push((function() {
  Runtime.dynCall("vi", routine, [ arg ]);
 }));
 _pthread_cleanup_push.level = __ATEXIT__.length;
}
Module["_pthread_cleanup_push"] = _pthread_cleanup_push;
function _gettimeofday(ptr) {
 var now = Date.now();
 HEAP32[ptr >> 2] = now / 1e3 | 0;
 HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0;
 return 0;
}
Module["_gettimeofday"] = _gettimeofday;
function _update_viterbi615_blk() {
 return Module["_update_viterbi615_blk"].apply(null, arguments);
}
function _partab_init() {
 return Module["_partab_init"].apply(null, arguments);
}
function ___syscall3(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get();
  return FS.read(stream, HEAP8, buf, count);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall3"] = ___syscall3;
function _free_rs_char() {
 return Module["_free_rs_char"].apply(null, arguments);
}
function ___syscall5(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get();
  var stream = FS.open(pathname, flags, mode);
  return stream.fd;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall5"] = ___syscall5;
function _decode_rs_char() {
 return Module["_decode_rs_char"].apply(null, arguments);
}
function _llvm_stackrestore(p) {
 var self = _llvm_stacksave;
 var ret = self.LLVM_SAVEDSTACKS[p];
 self.LLVM_SAVEDSTACKS.splice(p, 1);
 Runtime.stackRestore(ret);
}
Module["_llvm_stackrestore"] = _llvm_stackrestore;
function _create_viterbi615() {
 return Module["_create_viterbi615"].apply(null, arguments);
}
function _delete_viterbi29() {
 return Module["_delete_viterbi29"].apply(null, arguments);
}
function _encode_rs_char() {
 return Module["_encode_rs_char"].apply(null, arguments);
}
function _sbrk(bytes) {
 var self = _sbrk;
 if (!self.called) {
  DYNAMICTOP = alignMemoryPage(DYNAMICTOP);
  self.called = true;
  assert(Runtime.dynamicAlloc);
  self.alloc = Runtime.dynamicAlloc;
  Runtime.dynamicAlloc = (function() {
   abort("cannot dynamically allocate, sbrk now has control");
  });
 }
 var ret = DYNAMICTOP;
 if (bytes != 0) {
  var success = self.alloc(bytes);
  if (!success) return -1 >>> 0;
 }
 return ret;
}
Module["_sbrk"] = _sbrk;
Module["_memmove"] = _memmove;
function _init_viterbi29() {
 return Module["_init_viterbi29"].apply(null, arguments);
}
function _delete_viterbi27() {
 return Module["_delete_viterbi27"].apply(null, arguments);
}
function _init_viterbi615() {
 return Module["_init_viterbi615"].apply(null, arguments);
}
function _init_rs_char() {
 return Module["_init_rs_char"].apply(null, arguments);
}
function _pthread_cleanup_pop() {
 assert(_pthread_cleanup_push.level == __ATEXIT__.length, "cannot pop if something else added meanwhile!");
 __ATEXIT__.pop();
 _pthread_cleanup_push.level = __ATEXIT__.length;
}
Module["_pthread_cleanup_pop"] = _pthread_cleanup_pop;
var _llvm_fabs_f32 = Math_abs;
Module["_llvm_fabs_f32"] = _llvm_fabs_f32;
function _delete_viterbi615() {
 return Module["_delete_viterbi615"].apply(null, arguments);
}
function _time(ptr) {
 var ret = Date.now() / 1e3 | 0;
 if (ptr) {
  HEAP32[ptr >> 2] = ret;
 }
 return ret;
}
Module["_time"] = _time;
function _pthread_self() {
 return 0;
}
Module["_pthread_self"] = _pthread_self;
function ___syscall140(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
  var offset = offset_low;
  assert(offset_high === 0);
  FS.llseek(stream, offset, whence);
  HEAP32[result >> 2] = stream.position;
  if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall140"] = ___syscall140;
function ___syscall146(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
  return SYSCALLS.doWritev(stream, iov, iovcnt);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall146"] = ___syscall146;
function ___syscall221(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();
  switch (cmd) {
  case 0:
   {
    var arg = SYSCALLS.get();
    if (arg < 0) {
     return -ERRNO_CODES.EINVAL;
    }
    var newStream;
    newStream = FS.open(stream.path, stream.flags, 0, arg);
    return newStream.fd;
   }
  case 1:
  case 2:
   return 0;
  case 3:
   return stream.flags;
  case 4:
   {
    var arg = SYSCALLS.get();
    stream.flags |= arg;
    return 0;
   }
  case 12:
  case 12:
   {
    var arg = SYSCALLS.get();
    var offset = 0;
    HEAP16[arg + offset >> 1] = 2;
    return 0;
   }
  case 13:
  case 14:
  case 13:
  case 14:
   return 0;
  case 16:
  case 8:
   return -ERRNO_CODES.EINVAL;
  case 9:
   ___setErrNo(ERRNO_CODES.EINVAL);
   return -1;
  default:
   {
    return -ERRNO_CODES.EINVAL;
   }
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall221"] = ___syscall221;
function ___syscall145(which, varargs) {
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
  return SYSCALLS.doReadv(stream, iov, iovcnt);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall145"] = ___syscall145;
function _P_init() {
 return Module["_P_init"].apply(null, arguments);
}
function _Partab() {
 return Module["_Partab"].apply(null, arguments);
}
FS.staticInit();
__ATINIT__.unshift((function() {
 if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
}));
__ATMAIN__.push((function() {
 FS.ignorePermissions = false;
}));
__ATEXIT__.push((function() {
 FS.quit();
}));
Module["FS_createFolder"] = FS.createFolder;
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createLink"] = FS.createLink;
Module["FS_createDevice"] = FS.createDevice;
Module["FS_unlink"] = FS.unlink;
__ATINIT__.unshift((function() {
 TTY.init();
}));
__ATEXIT__.push((function() {
 TTY.shutdown();
}));
if (ENVIRONMENT_IS_NODE) {
 var fs = require("fs");
 var NODEJS_PATH = require("path");
 NODEFS.staticInit();
}
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);
staticSealed = true;
STACK_MAX = STACK_BASE + TOTAL_STACK;
DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);
var cttz_i8 = allocate([ 8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 ], "i8", ALLOC_DYNAMIC);
var gb = Runtime.GLOBAL_BASE, fb = 0;
var setTempRet0 = Runtime.setTempRet0, getTempRet0 = Runtime.getTempRet0;
function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
 try {
  return Module["dynCall_iiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iiiiiiii(x, a0, a1, a2, a3, a4, a5, a6) {
 if (x < 0 || x >= FUNCTION_TABLE_iiiiiiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iiiiiiii[x](a0, a1, a2, a3, a4, a5, a6);
}
function invoke_iiii(index, a1, a2, a3) {
 try {
  return Module["dynCall_iiii"](index, a1, a2, a3);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iiii(x, a0, a1, a2) {
 if (x < 0 || x >= FUNCTION_TABLE_iiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iiii[x](a0, a1, a2);
}
function invoke_vi(index, a1) {
 try {
  Module["dynCall_vi"](index, a1);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_vi(x, a0) {
 if (x < 0 || x >= FUNCTION_TABLE_vi.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_vi[x](a0);
}
function invoke_ii(index, a1) {
 try {
  return Module["dynCall_ii"](index, a1);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_ii(x, a0) {
 if (x < 0 || x >= FUNCTION_TABLE_ii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_ii[x](a0);
}
function invoke_viii(index, a1, a2, a3) {
 try {
  Module["dynCall_viii"](index, a1, a2, a3);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_viii(x, a0, a1, a2) {
 if (x < 0 || x >= FUNCTION_TABLE_viii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_viii[x](a0, a1, a2);
}
function invoke_iiiii(index, a1, a2, a3, a4) {
 try {
  return Module["dynCall_iiiii"](index, a1, a2, a3, a4);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iiiii(x, a0, a1, a2, a3) {
 if (x < 0 || x >= FUNCTION_TABLE_iiiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iiiii[x](a0, a1, a2, a3);
}
function invoke_iii(index, a1, a2) {
 try {
  return Module["dynCall_iii"](index, a1, a2);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_iii(x, a0, a1) {
 if (x < 0 || x >= FUNCTION_TABLE_iii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_iii[x](a0, a1);
}
function invoke_viiii(index, a1, a2, a3, a4) {
 try {
  Module["dynCall_viiii"](index, a1, a2, a3, a4);
 } catch (e) {
  if (typeof e !== "number" && e !== "longjmp") throw e;
  asm["setThrew"](1, 0);
 }
}
function ftCall_viiii(x, a0, a1, a2, a3) {
 if (x < 0 || x >= FUNCTION_TABLE_viiii.length) {
  Module.printErr("Function table mask error (out of range)");
  Module["printErr"]("Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");
  Module["printErr"]("Build with ASSERTIONS=2 for more info.");
  abort(x);
 }
 return FUNCTION_TABLE_viiii[x](a0, a1, a2, a3);
}
var g$_P_init = (function() {
 return Module["_P_init"];
});
var g$_Partab = (function() {
 return Module["_Partab"];
});
var dynCall_iiiiiiii = ftCall_iiiiiiii;
var dynCall_iiii = ftCall_iiii;
var dynCall_vi = ftCall_vi;
var dynCall_ii = ftCall_ii;
var dynCall_viii = ftCall_viii;
var dynCall_iiiii = ftCall_iiiii;
var dynCall_iii = ftCall_iii;
var dynCall_viiii = ftCall_viiii;
Module.asmGlobalArg = {
 "Math": Math,
 "Int8Array": Int8Array,
 "Int16Array": Int16Array,
 "Int32Array": Int32Array,
 "Uint8Array": Uint8Array,
 "Uint16Array": Uint16Array,
 "Uint32Array": Uint32Array,
 "Float32Array": Float32Array,
 "Float64Array": Float64Array,
 "NaN": NaN,
 "Infinity": Infinity,
 "SIMD": SIMD
};
Module.asmLibraryArg = {
 "abort": abort,
 "assert": assert,
 "setTempRet0": setTempRet0,
 "getTempRet0": getTempRet0,
 "invoke_iiiiiiii": invoke_iiiiiiii,
 "ftCall_iiiiiiii": ftCall_iiiiiiii,
 "invoke_iiii": invoke_iiii,
 "ftCall_iiii": ftCall_iiii,
 "invoke_vi": invoke_vi,
 "ftCall_vi": ftCall_vi,
 "invoke_ii": invoke_ii,
 "ftCall_ii": ftCall_ii,
 "invoke_viii": invoke_viii,
 "ftCall_viii": ftCall_viii,
 "invoke_iiiii": invoke_iiiii,
 "ftCall_iiiii": ftCall_iiiii,
 "invoke_iii": invoke_iii,
 "ftCall_iii": ftCall_iii,
 "invoke_viiii": invoke_viiii,
 "ftCall_viiii": ftCall_viiii,
 "_pthread_cleanup_pop": _pthread_cleanup_pop,
 "___syscall221": ___syscall221,
 "_delete_viterbi615": _delete_viterbi615,
 "_chainback_viterbi615": _chainback_viterbi615,
 "_create_viterbi615": _create_viterbi615,
 "_init_viterbi39": _init_viterbi39,
 "_sched_yield": _sched_yield,
 "_abort": _abort,
 "_llvm_fabs_f64": _llvm_fabs_f64,
 "_pthread_cleanup_push": _pthread_cleanup_push,
 "_delete_viterbi29": _delete_viterbi29,
 "_delete_viterbi27": _delete_viterbi27,
 "___syscall20": ___syscall20,
 "_llvm_stackrestore": _llvm_stackrestore,
 "___assert_fail": ___assert_fail,
 "_decode_rs_char": _decode_rs_char,
 "_update_viterbi29_blk": _update_viterbi29_blk,
 "_create_viterbi27": _create_viterbi27,
 "_delete_viterbi39": _delete_viterbi39,
 "_chainback_viterbi29": _chainback_viterbi29,
 "___setErrNo": ___setErrNo,
 "_sbrk": _sbrk,
 "_chainback_viterbi39": _chainback_viterbi39,
 "_llvm_pow_f32": _llvm_pow_f32,
 "_emscripten_memcpy_big": _emscripten_memcpy_big,
 "_P_init": _P_init,
 "_llvm_fabs_f32": _llvm_fabs_f32,
 "__exit": __exit,
 "_create_viterbi29": _create_viterbi29,
 "_init_viterbi29": _init_viterbi29,
 "_encode_rs_char": _encode_rs_char,
 "_init_viterbi27": _init_viterbi27,
 "_pthread_self": _pthread_self,
 "_llvm_stacksave": _llvm_stacksave,
 "_update_viterbi27_blk": _update_viterbi27_blk,
 "_free_rs_char": _free_rs_char,
 "_update_viterbi615_blk": _update_viterbi615_blk,
 "_init_rs_char": _init_rs_char,
 "___syscall54": ___syscall54,
 "___unlock": ___unlock,
 "_partab_init": _partab_init,
 "_update_viterbi39_blk": _update_viterbi39_blk,
 "_chainback_viterbi27": _chainback_viterbi27,
 "_init_viterbi615": _init_viterbi615,
 "___syscall3": ___syscall3,
 "_sysconf": _sysconf,
 "___lock": ___lock,
 "___syscall6": ___syscall6,
 "___syscall5": ___syscall5,
 "_time": _time,
 "_Partab": _Partab,
 "_gettimeofday": _gettimeofday,
 "___syscall140": ___syscall140,
 "_exit": _exit,
 "_create_viterbi39": _create_viterbi39,
 "___syscall145": ___syscall145,
 "___syscall146": ___syscall146,
 "g$_P_init": g$_P_init,
 "g$_Partab": g$_Partab,
 "STACKTOP": STACKTOP,
 "STACK_MAX": STACK_MAX,
 "tempDoublePtr": tempDoublePtr,
 "ABORT": ABORT,
 "cttz_i8": cttz_i8,
 "gb": gb,
 "fb": fb
};
// EMSCRIPTEN_START_ASM

var asm = (function(global,env,buffer) {

  'use asm';
  
  
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;
  var gb=env.gb|0;
  var fb=env.fb|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_clz32=global.Math.clz32;
  var Math_fround=global.Math.fround;
  var abort=env.abort;
  var assert=env.assert;
  var setTempRet0=env.setTempRet0;
  var getTempRet0=env.getTempRet0;
  var invoke_iiiiiiii=env.invoke_iiiiiiii;
  var ftCall_iiiiiiii=env.ftCall_iiiiiiii;
  var invoke_iiii=env.invoke_iiii;
  var ftCall_iiii=env.ftCall_iiii;
  var invoke_vi=env.invoke_vi;
  var ftCall_vi=env.ftCall_vi;
  var invoke_ii=env.invoke_ii;
  var ftCall_ii=env.ftCall_ii;
  var invoke_viii=env.invoke_viii;
  var ftCall_viii=env.ftCall_viii;
  var invoke_iiiii=env.invoke_iiiii;
  var ftCall_iiiii=env.ftCall_iiiii;
  var invoke_iii=env.invoke_iii;
  var ftCall_iii=env.ftCall_iii;
  var invoke_viiii=env.invoke_viiii;
  var ftCall_viiii=env.ftCall_viiii;
  var _pthread_cleanup_pop=env._pthread_cleanup_pop;
  var ___syscall221=env.___syscall221;
  var _delete_viterbi615=env._delete_viterbi615;
  var _chainback_viterbi615=env._chainback_viterbi615;
  var _create_viterbi615=env._create_viterbi615;
  var _init_viterbi39=env._init_viterbi39;
  var _sched_yield=env._sched_yield;
  var _abort=env._abort;
  var _llvm_fabs_f64=env._llvm_fabs_f64;
  var _pthread_cleanup_push=env._pthread_cleanup_push;
  var _delete_viterbi29=env._delete_viterbi29;
  var _delete_viterbi27=env._delete_viterbi27;
  var ___syscall20=env.___syscall20;
  var _llvm_stackrestore=env._llvm_stackrestore;
  var ___assert_fail=env.___assert_fail;
  var _decode_rs_char=env._decode_rs_char;
  var _update_viterbi29_blk=env._update_viterbi29_blk;
  var _create_viterbi27=env._create_viterbi27;
  var _delete_viterbi39=env._delete_viterbi39;
  var _chainback_viterbi29=env._chainback_viterbi29;
  var ___setErrNo=env.___setErrNo;
  var _sbrk=env._sbrk;
  var _chainback_viterbi39=env._chainback_viterbi39;
  var _llvm_pow_f32=env._llvm_pow_f32;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _P_init=env._P_init;
  var _llvm_fabs_f32=env._llvm_fabs_f32;
  var __exit=env.__exit;
  var _create_viterbi29=env._create_viterbi29;
  var _init_viterbi29=env._init_viterbi29;
  var _encode_rs_char=env._encode_rs_char;
  var _init_viterbi27=env._init_viterbi27;
  var _pthread_self=env._pthread_self;
  var _llvm_stacksave=env._llvm_stacksave;
  var _update_viterbi27_blk=env._update_viterbi27_blk;
  var _free_rs_char=env._free_rs_char;
  var _update_viterbi615_blk=env._update_viterbi615_blk;
  var _init_rs_char=env._init_rs_char;
  var ___syscall54=env.___syscall54;
  var ___unlock=env.___unlock;
  var _partab_init=env._partab_init;
  var _update_viterbi39_blk=env._update_viterbi39_blk;
  var _chainback_viterbi27=env._chainback_viterbi27;
  var _init_viterbi615=env._init_viterbi615;
  var ___syscall3=env.___syscall3;
  var _sysconf=env._sysconf;
  var ___lock=env.___lock;
  var ___syscall6=env.___syscall6;
  var ___syscall5=env.___syscall5;
  var _time=env._time;
  var _Partab=env._Partab;
  var _gettimeofday=env._gettimeofday;
  var ___syscall140=env.___syscall140;
  var _exit=env._exit;
  var _create_viterbi39=env._create_viterbi39;
  var ___syscall145=env.___syscall145;
  var ___syscall146=env.___syscall146;
  var g$_P_init=env.g$_P_init;
  var g$_Partab=env.g$_Partab;
  var SIMD_Float32x4=global.SIMD.Float32x4;
  var SIMD_Int32x4=global.SIMD.Int32x4;
  var SIMD_Int32x4_splat=SIMD_Int32x4.splat;
  var SIMD_Int32x4_check=SIMD_Int32x4.check;
  var SIMD_Int32x4_extractLane=SIMD_Int32x4.extractLane;
  var SIMD_Int32x4_replaceLane=SIMD_Int32x4.replaceLane;
  var SIMD_Int32x4_add=SIMD_Int32x4.add;
  var SIMD_Int32x4_sub=SIMD_Int32x4.sub;
  var SIMD_Int32x4_neg=SIMD_Int32x4.neg;
  var SIMD_Int32x4_mul=SIMD_Int32x4.mul;
  var SIMD_Int32x4_equal=SIMD_Int32x4.equal;
  var SIMD_Int32x4_lessThan=SIMD_Int32x4.lessThan;
  var SIMD_Int32x4_greaterThan=SIMD_Int32x4.greaterThan;
  var SIMD_Int32x4_notEqual=SIMD_Int32x4.notEqual;
  var SIMD_Int32x4_lessThanOrEqual=SIMD_Int32x4.lessThanOrEqual;
  var SIMD_Int32x4_greaterThanOrEqual=SIMD_Int32x4.greaterThanOrEqual;
  var SIMD_Int32x4_select=SIMD_Int32x4.select;
  var SIMD_Int32x4_swizzle=SIMD_Int32x4.swizzle;
  var SIMD_Int32x4_shuffle=SIMD_Int32x4.shuffle;
  var SIMD_Int32x4_load=SIMD_Int32x4.load;
  var SIMD_Int32x4_store=SIMD_Int32x4.store;
  var SIMD_Int32x4_load1=SIMD_Int32x4.load1;
  var SIMD_Int32x4_store1=SIMD_Int32x4.store1;
  var SIMD_Int32x4_load2=SIMD_Int32x4.load2;
  var SIMD_Int32x4_store2=SIMD_Int32x4.store2;
  var SIMD_Int32x4_load3=SIMD_Int32x4.load3;
  var SIMD_Int32x4_store3=SIMD_Int32x4.store3;
  var SIMD_Int32x4_fromFloat32x4=SIMD_Int32x4.fromFloat32x4;
  var SIMD_Int32x4_fromFloat32x4Bits=SIMD_Int32x4.fromFloat32x4Bits;
  var SIMD_Int32x4_and=SIMD_Int32x4.and;
  var SIMD_Int32x4_xor=SIMD_Int32x4.xor;
  var SIMD_Int32x4_or=SIMD_Int32x4.or;
  var SIMD_Int32x4_not=SIMD_Int32x4.not;
  var SIMD_Int32x4_shiftLeftByScalar=SIMD_Int32x4.shiftLeftByScalar;
  var SIMD_Int32x4_shiftRightByScalar=SIMD_Int32x4.shiftRightByScalar;
  var SIMD_Float32x4_splat=SIMD_Float32x4.splat;
  var SIMD_Float32x4_check=SIMD_Float32x4.check;
  var SIMD_Float32x4_extractLane=SIMD_Float32x4.extractLane;
  var SIMD_Float32x4_replaceLane=SIMD_Float32x4.replaceLane;
  var SIMD_Float32x4_add=SIMD_Float32x4.add;
  var SIMD_Float32x4_sub=SIMD_Float32x4.sub;
  var SIMD_Float32x4_neg=SIMD_Float32x4.neg;
  var SIMD_Float32x4_mul=SIMD_Float32x4.mul;
  var SIMD_Float32x4_equal=SIMD_Float32x4.equal;
  var SIMD_Float32x4_lessThan=SIMD_Float32x4.lessThan;
  var SIMD_Float32x4_greaterThan=SIMD_Float32x4.greaterThan;
  var SIMD_Float32x4_notEqual=SIMD_Float32x4.notEqual;
  var SIMD_Float32x4_lessThanOrEqual=SIMD_Float32x4.lessThanOrEqual;
  var SIMD_Float32x4_greaterThanOrEqual=SIMD_Float32x4.greaterThanOrEqual;
  var SIMD_Float32x4_select=SIMD_Float32x4.select;
  var SIMD_Float32x4_swizzle=SIMD_Float32x4.swizzle;
  var SIMD_Float32x4_shuffle=SIMD_Float32x4.shuffle;
  var SIMD_Float32x4_load=SIMD_Float32x4.load;
  var SIMD_Float32x4_store=SIMD_Float32x4.store;
  var SIMD_Float32x4_load1=SIMD_Float32x4.load1;
  var SIMD_Float32x4_store1=SIMD_Float32x4.store1;
  var SIMD_Float32x4_load2=SIMD_Float32x4.load2;
  var SIMD_Float32x4_store2=SIMD_Float32x4.store2;
  var SIMD_Float32x4_load3=SIMD_Float32x4.load3;
  var SIMD_Float32x4_store3=SIMD_Float32x4.store3;
  var SIMD_Float32x4_fromInt32x4=SIMD_Float32x4.fromInt32x4;
  var SIMD_Float32x4_fromInt32x4Bits=SIMD_Float32x4.fromInt32x4Bits;
  var SIMD_Float32x4_div=SIMD_Float32x4.div;
  var SIMD_Float32x4_min=SIMD_Float32x4.min;
  var SIMD_Float32x4_max=SIMD_Float32x4.max;
  var SIMD_Float32x4_minNum=SIMD_Float32x4.minNum;
  var SIMD_Float32x4_maxNum=SIMD_Float32x4.maxNum;
  var SIMD_Float32x4_sqrt=SIMD_Float32x4.sqrt;
  var SIMD_Float32x4_abs=SIMD_Float32x4.abs;
  var SIMD_Float32x4_reciprocalApproximation=SIMD_Float32x4.reciprocalApproximation;
  var SIMD_Float32x4_reciprocalSqrtApproximation=SIMD_Float32x4.reciprocalSqrtApproximation;
  var tempFloat = Math_fround(0);
  const f0 = Math_fround(0);

// EMSCRIPTEN_START_FUNCS

function _ofdmframesync_debug_print(i32, i37) {
 i32 = i32 | 0;
 i37 = i37 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i38 = 0, i39 = 0, d40 = 0.0, d41 = 0.0;
 i39 = STACKTOP;
 STACKTOP = STACKTOP + 464 | 0;
 i38 = i39 + 456 | 0;
 i33 = i39 + 432 | 0;
 i31 = i39 + 416 | 0;
 i30 = i39 + 400 | 0;
 i26 = i39 + 392 | 0;
 i29 = i39 + 384 | 0;
 i28 = i39 + 368 | 0;
 i27 = i39 + 352 | 0;
 i25 = i39 + 328 | 0;
 i24 = i39 + 304 | 0;
 i23 = i39 + 280 | 0;
 i22 = i39 + 256 | 0;
 i21 = i39 + 232 | 0;
 i20 = i39 + 208 | 0;
 i19 = i39 + 192 | 0;
 i18 = i39 + 184 | 0;
 i17 = i39 + 160 | 0;
 i16 = i39 + 136 | 0;
 i15 = i39 + 112 | 0;
 i14 = i39 + 88 | 0;
 i13 = i39 + 80 | 0;
 i12 = i39 + 72 | 0;
 i11 = i39 + 64 | 0;
 i10 = i39 + 56 | 0;
 i9 = i39 + 48 | 0;
 i8 = i39 + 40 | 0;
 i5 = i39 + 32 | 0;
 i7 = i39 + 24 | 0;
 i6 = i39 + 16 | 0;
 i2 = i39 + 8 | 0;
 i1 = i39;
 if (!(HEAP32[i32 + 172 >> 2] | 0)) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   STACKTOP = i39;
   return;
  } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i1 - i2 | 0) >>> 0 < 86) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33835 | 0, 86) | 0;
   STACKTOP = i39;
   return;
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33835 | 0, 86) | 0) >>> 0 < 86) {
   STACKTOP = i39;
   return;
  } else {
   i1 = 0;
   i3 = gb + 33835 + 86 | 0;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i1 = 86;
   i3 = gb + 33835 | 0;
  } while (0);
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  STACKTOP = i39;
  return;
 }
 i36 = _fopen(i37, gb + 33922 | 0) | 0;
 if (!i36) {
  HEAP32[i1 >> 2] = i37;
  _fprintf(gb + 8728 | 0, gb + 33924 | 0, i1);
  STACKTOP = i39;
  return;
 }
 HEAP32[i2 >> 2] = gb + 34018;
 _fprintf(i36, gb + 33989 | 0, i2);
 i34 = i36 + 16 | 0;
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i4 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i4 + 255 | i4;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 20;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 20;
 } while (0);
 do if ((i35 | 0) == 20) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34049 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34049 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 34049 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 34049 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i4 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i4 + 255 | i4;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 31;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 31;
 } while (0);
 do if ((i35 | 0) == 31) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34061 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34061 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 34061 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 34061 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 HEAP32[i6 >> 2] = 2048;
 _fprintf(i36, gb + 34073 | 0, i6);
 HEAP32[i7 >> 2] = HEAP32[i32 >> 2];
 _fprintf(i36, gb + 34082 | 0, i7);
 HEAP32[i5 >> 2] = HEAP32[i32 + 16 >> 2];
 _fprintf(i36, gb + 34091 | 0, i5);
 i6 = i32 + 20 | 0;
 HEAP32[i8 >> 2] = HEAP32[i6 >> 2];
 _fprintf(i36, gb + 34106 | 0, i8);
 HEAP32[i9 >> 2] = HEAP32[i32 + 24 >> 2];
 _fprintf(i36, gb + 34121 | 0, i9);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i9 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i9 + 255 | i9;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 42;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 42;
 } while (0);
 do if ((i35 | 0) == 42) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34136 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34136 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 34136 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 34136 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 if (HEAP32[i32 >> 2] | 0) {
  i1 = i32 + 12 | 0;
  i2 = 0;
  do {
   i9 = HEAPU8[(HEAP32[i1 >> 2] | 0) + i2 >> 0] | 0;
   i2 = i2 + 1 | 0;
   HEAP32[i10 >> 2] = i2;
   HEAP32[i10 + 4 >> 2] = i9;
   _fprintf(i36, gb + 34153 | 0, i10);
  } while (i2 >>> 0 < (HEAP32[i32 >> 2] | 0) >>> 0);
 }
 HEAP32[i11 >> 2] = 0;
 _fprintf(i36, gb + 34167 | 0, i11);
 HEAP32[i12 >> 2] = 1;
 _fprintf(i36, gb + 34191 | 0, i12);
 HEAP32[i13 >> 2] = 2;
 _fprintf(i36, gb + 34215 | 0, i13);
 if (HEAP32[i32 >> 2] | 0) {
  i1 = i32 + 64 | 0;
  i2 = i32 + 72 | 0;
  i3 = 0;
  do {
   i13 = i3;
   i3 = i3 + 1 | 0;
   i12 = HEAP32[i1 >> 2] | 0;
   d40 = +HEAPF32[i12 + (i13 << 3) >> 2];
   d41 = +HEAPF32[i12 + (i13 << 3) + 4 >> 2];
   HEAP32[i14 >> 2] = i3;
   HEAPF64[i14 + 8 >> 3] = d40;
   HEAPF64[i14 + 16 >> 3] = d41;
   _fprintf(i36, gb + 34239 | 0, i14);
   i12 = HEAP32[i2 >> 2] | 0;
   d41 = +HEAPF32[i12 + (i13 << 3) >> 2];
   d40 = +HEAPF32[i12 + (i13 << 3) + 4 >> 2];
   HEAP32[i15 >> 2] = i3;
   HEAPF64[i15 + 8 >> 3] = d41;
   HEAPF64[i15 + 16 >> 3] = d40;
   _fprintf(i36, gb + 34269 | 0, i15);
  } while (i3 >>> 0 < (HEAP32[i32 >> 2] | 0) >>> 0);
 }
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i15 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i15 + 255 | i15;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 59;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 59;
 } while (0);
 do if ((i35 | 0) == 59) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34299 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34299 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 34299 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 34299 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i32 + 176 >> 2] | 0;
 i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 3) | 0;
 i2 = 0;
 do {
  d40 = +HEAPF32[i1 + (i2 << 3) >> 2];
  d41 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
  i2 = i2 + 1 | 0;
  HEAP32[i16 >> 2] = i2;
  HEAPF64[i16 + 8 >> 3] = d40;
  HEAPF64[i16 + 16 >> 3] = d41;
  _fprintf(i36, gb + 34316 | 0, i16);
 } while ((i2 | 0) != 2048);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i16 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i16 + 255 | i16;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 72;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 72;
 } while (0);
 do if ((i35 | 0) == 72) {
  if ((i1 - i2 | 0) >>> 0 < 8) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
   i1 = 0;
   i3 = gb + 34345 + 8 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 8;
   i3 = gb + 34345 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i16 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i16 + 255 | i16;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 83;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 83;
 } while (0);
 do if ((i35 | 0) == 83) {
  if ((i1 - i2 | 0) >>> 0 < 39) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34354 | 0, 39) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34354 | 0, 39) | 0) >>> 0 < 39) break;
   i1 = 0;
   i3 = gb + 34354 + 39 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 39;
   i3 = gb + 34354 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i16 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i16 + 255 | i16;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 94;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 94;
 } while (0);
 do if ((i35 | 0) == 94) {
  if ((i1 - i2 | 0) >>> 0 < 24) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34394 | 0, 24) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34394 | 0, 24) | 0) >>> 0 < 24) break;
   i1 = 0;
   i3 = gb + 34394 + 24 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 24;
   i3 = gb + 34394 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i16 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i16 + 255 | i16;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 105;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 105;
 } while (0);
 do if ((i35 | 0) == 105) {
  if ((i1 - i2 | 0) >>> 0 < 30) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34419 | 0, 30) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34419 | 0, 30) | 0) >>> 0 < 30) break;
   i1 = 0;
   i3 = gb + 34419 + 30 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 30;
   i3 = gb + 34419 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i16 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i16 + 255 | i16;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 116;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 116;
 } while (0);
 do if ((i35 | 0) == 116) {
  if ((i1 - i2 | 0) >>> 0 < 9) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34450 | 0, 9) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34450 | 0, 9) | 0) >>> 0 < 9) break;
   i1 = 0;
   i3 = gb + 34450 + 9 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 9;
   i3 = gb + 34450 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 if (HEAP32[i32 >> 2] | 0) {
  i1 = i32 + 76 | 0;
  i2 = 0;
  do {
   i16 = HEAP32[i1 >> 2] | 0;
   d40 = +HEAPF32[i16 + (i2 << 3) >> 2];
   d41 = +HEAPF32[i16 + (i2 << 3) + 4 >> 2];
   i2 = i2 + 1 | 0;
   HEAP32[i17 >> 2] = i2;
   HEAPF64[i17 + 8 >> 3] = d40;
   HEAPF64[i17 + 16 >> 3] = d41;
   _fprintf(i36, gb + 34460 | 0, i17);
  } while (i2 >>> 0 < (HEAP32[i32 >> 2] | 0) >>> 0);
 }
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i17 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i17 + 255 | i17;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 130;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 130;
 } while (0);
 do if ((i35 | 0) == 130) {
  if ((i1 - i2 | 0) >>> 0 < 2) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
   i1 = 0;
   i3 = gb + 34490 + 2 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 2;
   i3 = gb + 34490 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 HEAP32[i18 >> 2] = 2048;
 _fprintf(i36, gb + 34493 | 0, i18);
 i1 = HEAP32[i32 + 180 >> 2] | 0;
 i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 2) | 0;
 i2 = 0;
 do {
  d41 = +HEAPF32[i1 + (i2 << 2) >> 2];
  i2 = i2 + 1 | 0;
  HEAP32[i19 >> 2] = i2;
  HEAPF64[i19 + 8 >> 3] = d41;
  _fprintf(i36, gb + 34518 | 0, i19);
 } while ((i2 | 0) != 2048);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 143;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 143;
 } while (0);
 do if ((i35 | 0) == 143) {
  if ((i1 - i2 | 0) >>> 0 < 91) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34543 | 0, 91) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34543 | 0, 91) | 0) >>> 0 < 91) break;
   i1 = 0;
   i3 = gb + 34543 + 91 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 91;
   i3 = gb + 34543 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 154;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 154;
 } while (0);
 do if ((i35 | 0) == 154) {
  if ((i1 - i2 | 0) >>> 0 < 33) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34635 | 0, 33) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34635 | 0, 33) | 0) >>> 0 < 33) break;
   i1 = 0;
   i3 = gb + 34635 + 33 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 33;
   i3 = gb + 34635 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 165;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 165;
 } while (0);
 do if ((i35 | 0) == 165) {
  if ((i1 - i2 | 0) >>> 0 < 8) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
   i1 = 0;
   i3 = gb + 34345 + 8 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 8;
   i3 = gb + 34345 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 176;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 176;
 } while (0);
 do if ((i35 | 0) == 176) {
  if ((i1 - i2 | 0) >>> 0 < 15) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34669 | 0, 15) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34669 | 0, 15) | 0) >>> 0 < 15) break;
   i1 = 0;
   i3 = gb + 34669 + 15 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 15;
   i3 = gb + 34669 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 187;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 187;
 } while (0);
 do if ((i35 | 0) == 187) {
  if ((i1 - i2 | 0) >>> 0 < 21) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34685 | 0, 21) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34685 | 0, 21) | 0) >>> 0 < 21) break;
   i1 = 0;
   i3 = gb + 34685 + 21 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 21;
   i3 = gb + 34685 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 198;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 198;
 } while (0);
 do if ((i35 | 0) == 198) {
  if ((i1 - i2 | 0) >>> 0 < 2) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
   i1 = 0;
   i3 = gb + 34490 + 2 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 2;
   i3 = gb + 34490 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 209;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 209;
 } while (0);
 do if ((i35 | 0) == 209) {
  if ((i1 - i2 | 0) >>> 0 < 17) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34707 | 0, 17) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34707 | 0, 17) | 0) >>> 0 < 17) break;
   i1 = 0;
   i3 = gb + 34707 + 17 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 17;
   i3 = gb + 34707 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i19 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i19 + 255 | i19;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 220;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 220;
 } while (0);
 do if ((i35 | 0) == 220) {
  if ((i1 - i2 | 0) >>> 0 < 17) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34725 | 0, 17) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34725 | 0, 17) | 0) >>> 0 < 17) break;
   i1 = 0;
   i3 = gb + 34725 + 17 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 17;
   i3 = gb + 34725 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 if (HEAP32[i32 >> 2] | 0) {
  i1 = i32 + 64 | 0;
  i2 = i32 + 72 | 0;
  i3 = 0;
  do {
   i19 = i3;
   i3 = i3 + 1 | 0;
   i18 = HEAP32[i1 >> 2] | 0;
   d41 = +HEAPF32[i18 + (i19 << 3) >> 2];
   d40 = +HEAPF32[i18 + (i19 << 3) + 4 >> 2];
   HEAP32[i20 >> 2] = i3;
   HEAPF64[i20 + 8 >> 3] = d41;
   HEAPF64[i20 + 16 >> 3] = d40;
   _fprintf(i36, gb + 34743 | 0, i20);
   i18 = HEAP32[i2 >> 2] | 0;
   d40 = +HEAPF32[i18 + (i19 << 3) >> 2];
   d41 = +HEAPF32[i18 + (i19 << 3) + 4 >> 2];
   HEAP32[i21 >> 2] = i3;
   HEAPF64[i21 + 8 >> 3] = d40;
   HEAPF64[i21 + 16 >> 3] = d41;
   _fprintf(i36, gb + 34773 | 0, i21);
  } while (i3 >>> 0 < (HEAP32[i32 >> 2] | 0) >>> 0);
 }
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i21 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i21 + 255 | i21;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 234;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 234;
 } while (0);
 do if ((i35 | 0) == 234) {
  if ((i1 - i2 | 0) >>> 0 < 2) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
   i1 = 0;
   i3 = gb + 34490 + 2 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 2;
   i3 = gb + 34490 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i21 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i21 + 255 | i21;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 245;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 245;
 } while (0);
 do if ((i35 | 0) == 245) {
  if ((i1 - i2 | 0) >>> 0 < 21) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34803 | 0, 21) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34803 | 0, 21) | 0) >>> 0 < 21) break;
   i1 = 0;
   i3 = gb + 34803 + 21 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 21;
   i3 = gb + 34803 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i21 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i21 + 255 | i21;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 256;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 256;
 } while (0);
 do if ((i35 | 0) == 256) {
  if ((i1 - i2 | 0) >>> 0 < 21) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34825 | 0, 21) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34825 | 0, 21) | 0) >>> 0 < 21) break;
   i1 = 0;
   i3 = gb + 34825 + 21 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 21;
   i3 = gb + 34825 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i21 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i21 + 255 | i21;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 267;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 267;
 } while (0);
 do if ((i35 | 0) == 267) {
  if ((i1 - i2 | 0) >>> 0 < 21) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34847 | 0, 21) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34847 | 0, 21) | 0) >>> 0 < 21) break;
   i1 = 0;
   i3 = gb + 34847 + 21 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 21;
   i3 = gb + 34847 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i21 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i21 + 255 | i21;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 278;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 278;
 } while (0);
 do if ((i35 | 0) == 278) {
  if ((i1 - i2 | 0) >>> 0 < 21) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34869 | 0, 21) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34869 | 0, 21) | 0) >>> 0 < 21) break;
   i1 = 0;
   i3 = gb + 34869 + 21 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 21;
   i3 = gb + 34869 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 if (HEAP32[i32 >> 2] | 0) {
  i1 = i32 + 84 | 0;
  i2 = i32 + 88 | 0;
  i3 = i32 + 188 | 0;
  i4 = i32 + 92 | 0;
  i5 = 0;
  do {
   i21 = i5;
   i5 = i5 + 1 | 0;
   i20 = HEAP32[i1 >> 2] | 0;
   d41 = +HEAPF32[i20 + (i21 << 3) >> 2];
   d40 = +HEAPF32[i20 + (i21 << 3) + 4 >> 2];
   HEAP32[i22 >> 2] = i5;
   HEAPF64[i22 + 8 >> 3] = d41;
   HEAPF64[i22 + 16 >> 3] = d40;
   _fprintf(i36, gb + 34891 | 0, i22);
   i20 = HEAP32[i2 >> 2] | 0;
   d40 = +HEAPF32[i20 + (i21 << 3) >> 2];
   d41 = +HEAPF32[i20 + (i21 << 3) + 4 >> 2];
   HEAP32[i23 >> 2] = i5;
   HEAPF64[i23 + 8 >> 3] = d40;
   HEAPF64[i23 + 16 >> 3] = d41;
   _fprintf(i36, gb + 34924 | 0, i23);
   i20 = HEAP32[i3 >> 2] | 0;
   d41 = +HEAPF32[i20 + (i21 << 3) >> 2];
   d40 = +HEAPF32[i20 + (i21 << 3) + 4 >> 2];
   HEAP32[i24 >> 2] = i5;
   HEAPF64[i24 + 8 >> 3] = d41;
   HEAPF64[i24 + 16 >> 3] = d40;
   _fprintf(i36, gb + 34957 | 0, i24);
   i20 = HEAP32[i4 >> 2] | 0;
   d40 = +HEAPF32[i20 + (i21 << 3) >> 2];
   d41 = +HEAPF32[i20 + (i21 << 3) + 4 >> 2];
   HEAP32[i25 >> 2] = i5;
   HEAPF64[i25 + 8 >> 3] = d40;
   HEAPF64[i25 + 16 >> 3] = d41;
   _fprintf(i36, gb + 34990 | 0, i25);
  } while (i5 >>> 0 < (HEAP32[i32 >> 2] | 0) >>> 0);
 }
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 292;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 292;
 } while (0);
 do if ((i35 | 0) == 292) {
  if ((i1 - i2 | 0) >>> 0 < 15) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35023 | 0, 15) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35023 | 0, 15) | 0) >>> 0 < 15) break;
   i1 = 0;
   i3 = gb + 35023 + 15 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 15;
   i3 = gb + 35023 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 303;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 303;
 } while (0);
 do if ((i35 | 0) == 303) {
  if ((i1 - i2 | 0) >>> 0 < 8) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
   i1 = 0;
   i3 = gb + 34345 + 8 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 8;
   i3 = gb + 34345 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 314;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 314;
 } while (0);
 do if ((i35 | 0) == 314) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35039 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35039 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 35039 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 35039 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 325;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 325;
 } while (0);
 do if ((i35 | 0) == 325) {
  if ((i1 - i2 | 0) >>> 0 < 40) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35056 | 0, 40) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35056 | 0, 40) | 0) >>> 0 < 40) break;
   i1 = 0;
   i3 = gb + 35056 + 40 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 40;
   i3 = gb + 35056 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 336;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 336;
 } while (0);
 do if ((i35 | 0) == 336) {
  if ((i1 - i2 | 0) >>> 0 < 48) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35097 | 0, 48) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35097 | 0, 48) | 0) >>> 0 < 48) break;
   i1 = 0;
   i3 = gb + 35097 + 48 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 48;
   i3 = gb + 35097 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 347;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 347;
 } while (0);
 do if ((i35 | 0) == 347) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 35146 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 35146 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 358;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 358;
 } while (0);
 do if ((i35 | 0) == 358) {
  if ((i1 - i2 | 0) >>> 0 < 30) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35158 | 0, 30) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35158 | 0, 30) | 0) >>> 0 < 30) break;
   i1 = 0;
   i3 = gb + 35158 + 30 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 30;
   i3 = gb + 35158 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 369;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 369;
 } while (0);
 do if ((i35 | 0) == 369) {
  if ((i1 - i2 | 0) >>> 0 < 33) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35189 | 0, 33) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35189 | 0, 33) | 0) >>> 0 < 33) break;
   i1 = 0;
   i3 = gb + 35189 + 33 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 33;
   i3 = gb + 35189 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 380;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 380;
 } while (0);
 do if ((i35 | 0) == 380) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35223 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35223 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 35223 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 35223 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 391;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 391;
 } while (0);
 do if ((i35 | 0) == 391) {
  if ((i1 - i2 | 0) >>> 0 < 58) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35240 | 0, 58) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35240 | 0, 58) | 0) >>> 0 < 58) break;
   i1 = 0;
   i3 = gb + 35240 + 58 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 58;
   i3 = gb + 35240 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 402;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 402;
 } while (0);
 do if ((i35 | 0) == 402) {
  if ((i1 - i2 | 0) >>> 0 < 48) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35299 | 0, 48) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35299 | 0, 48) | 0) >>> 0 < 48) break;
   i1 = 0;
   i3 = gb + 35299 + 48 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 48;
   i3 = gb + 35299 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 413;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 413;
 } while (0);
 do if ((i35 | 0) == 413) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 35146 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 35146 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 424;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 424;
 } while (0);
 do if ((i35 | 0) == 424) {
  if ((i1 - i2 | 0) >>> 0 < 30) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35158 | 0, 30) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35158 | 0, 30) | 0) >>> 0 < 30) break;
   i1 = 0;
   i3 = gb + 35158 + 30 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 30;
   i3 = gb + 35158 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 435;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 435;
 } while (0);
 do if ((i35 | 0) == 435) {
  if ((i1 - i2 | 0) >>> 0 < 35) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35348 | 0, 35) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35348 | 0, 35) | 0) >>> 0 < 35) break;
   i1 = 0;
   i3 = gb + 35348 + 35 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 35;
   i3 = gb + 35348 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 446;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 446;
 } while (0);
 do if ((i35 | 0) == 446) {
  if ((i1 - i2 | 0) >>> 0 < 2) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
   i1 = 0;
   i3 = gb + 34490 + 2 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 2;
   i3 = gb + 34490 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 457;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 457;
 } while (0);
 do if ((i35 | 0) == 457) {
  if ((i1 - i2 | 0) >>> 0 < 23) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35384 | 0, 23) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35384 | 0, 23) | 0) >>> 0 < 23) break;
   i1 = 0;
   i3 = gb + 35384 + 23 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 23;
   i3 = gb + 35384 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i25 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i25 + 255 | i25;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 468;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 468;
 } while (0);
 do if ((i35 | 0) == 468) {
  if ((i1 - i2 | 0) >>> 0 < 23) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35408 | 0, 23) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35408 | 0, 23) | 0) >>> 0 < 23) break;
   i1 = 0;
   i3 = gb + 35408 + 23 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 23;
   i3 = gb + 35408 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 if (HEAP32[i6 >> 2] | 0) {
  i1 = i32 + 192 | 0;
  i2 = i32 + 196 | 0;
  i3 = 0;
  do {
   i25 = i3;
   i3 = i3 + 1 | 0;
   d41 = +HEAPF32[(HEAP32[i1 >> 2] | 0) + (i25 << 2) >> 2];
   HEAP32[i27 >> 2] = i3;
   HEAPF64[i27 + 8 >> 3] = d41;
   _fprintf(i36, gb + 35432 | 0, i27);
   d41 = +HEAPF32[(HEAP32[i2 >> 2] | 0) + (i25 << 2) >> 2];
   HEAP32[i28 >> 2] = i3;
   HEAPF64[i28 + 8 >> 3] = d41;
   _fprintf(i36, gb + 35451 | 0, i28);
  } while (i3 >>> 0 < (HEAP32[i6 >> 2] | 0) >>> 0);
 }
 HEAPF64[i29 >> 3] = +HEAPF32[i32 + 200 >> 2];
 _fprintf(i36, gb + 35470 | 0, i29);
 HEAPF64[i26 >> 3] = +HEAPF32[i32 + 204 >> 2];
 _fprintf(i36, gb + 35492 | 0, i26);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i29 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i29 + 255 | i29;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 482;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 482;
 } while (0);
 do if ((i35 | 0) == 482) {
  if ((i1 - i2 | 0) >>> 0 < 17) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35514 | 0, 17) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35514 | 0, 17) | 0) >>> 0 < 17) break;
   i1 = 0;
   i3 = gb + 35514 + 17 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 17;
   i3 = gb + 35514 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i32 + 208 >> 2] | 0;
 i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 2) | 0;
 i2 = 0;
 do {
  d41 = +HEAPF32[i1 + (i2 << 2) >> 2];
  i2 = i2 + 1 | 0;
  HEAP32[i30 >> 2] = i2;
  HEAPF64[i30 + 8 >> 3] = d41;
  _fprintf(i36, gb + 35532 | 0, i30);
 } while ((i2 | 0) != 2048);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i30 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i30 + 255 | i30;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 495;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 495;
 } while (0);
 do if ((i35 | 0) == 495) {
  if ((i1 - i2 | 0) >>> 0 < 17) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35551 | 0, 17) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35551 | 0, 17) | 0) >>> 0 < 17) break;
   i1 = 0;
   i3 = gb + 35551 + 17 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 17;
   i3 = gb + 35551 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i32 + 212 >> 2] | 0;
 i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 2) | 0;
 i2 = 0;
 do {
  d41 = +HEAPF32[i1 + (i2 << 2) >> 2];
  i2 = i2 + 1 | 0;
  HEAP32[i31 >> 2] = i2;
  HEAPF64[i31 + 8 >> 3] = d41;
  _fprintf(i36, gb + 35569 | 0, i31);
 } while ((i2 | 0) != 2048);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 508;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 508;
 } while (0);
 do if ((i35 | 0) == 508) {
  if ((i1 - i2 | 0) >>> 0 < 8) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
   i1 = 0;
   i3 = gb + 34345 + 8 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 8;
   i3 = gb + 34345 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 519;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 519;
 } while (0);
 do if ((i35 | 0) == 519) {
  if ((i1 - i2 | 0) >>> 0 < 19) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35588 | 0, 19) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35588 | 0, 19) | 0) >>> 0 < 19) break;
   i1 = 0;
   i3 = gb + 35588 + 19 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 19;
   i3 = gb + 35588 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 530;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 530;
 } while (0);
 do if ((i35 | 0) == 530) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35608 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35608 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 35608 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 35608 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 541;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 541;
 } while (0);
 do if ((i35 | 0) == 541) {
  if ((i1 - i2 | 0) >>> 0 < 24) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35625 | 0, 24) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35625 | 0, 24) | 0) >>> 0 < 24) break;
   i1 = 0;
   i3 = gb + 35625 + 24 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 24;
   i3 = gb + 35625 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 552;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 552;
 } while (0);
 do if ((i35 | 0) == 552) {
  if ((i1 - i2 | 0) >>> 0 < 40) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35650 | 0, 40) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35650 | 0, 40) | 0) >>> 0 < 40) break;
   i1 = 0;
   i3 = gb + 35650 + 40 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 40;
   i3 = gb + 35650 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 563;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 563;
 } while (0);
 do if ((i35 | 0) == 563) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 35146 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 35146 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 574;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 574;
 } while (0);
 do if ((i35 | 0) == 574) {
  if ((i1 - i2 | 0) >>> 0 < 32) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35691 | 0, 32) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35691 | 0, 32) | 0) >>> 0 < 32) break;
   i1 = 0;
   i3 = gb + 35691 + 32 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 32;
   i3 = gb + 35691 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 585;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 585;
 } while (0);
 do if ((i35 | 0) == 585) {
  if ((i1 - i2 | 0) >>> 0 < 24) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35724 | 0, 24) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35724 | 0, 24) | 0) >>> 0 < 24) break;
   i1 = 0;
   i3 = gb + 35724 + 24 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 24;
   i3 = gb + 35724 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 596;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 596;
 } while (0);
 do if ((i35 | 0) == 596) {
  if ((i1 - i2 | 0) >>> 0 < 19) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35749 | 0, 19) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35749 | 0, 19) | 0) >>> 0 < 19) break;
   i1 = 0;
   i3 = gb + 35749 + 19 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 19;
   i3 = gb + 35749 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 607;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 607;
 } while (0);
 do if ((i35 | 0) == 607) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35769 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35769 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 35769 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 35769 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 618;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 618;
 } while (0);
 do if ((i35 | 0) == 618) {
  if ((i1 - i2 | 0) >>> 0 < 26) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35786 | 0, 26) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35786 | 0, 26) | 0) >>> 0 < 26) break;
   i1 = 0;
   i3 = gb + 35786 + 26 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 26;
   i3 = gb + 35786 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 629;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 629;
 } while (0);
 do if ((i35 | 0) == 629) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 35146 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 35146 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 640;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 640;
 } while (0);
 do if ((i35 | 0) == 640) {
  if ((i1 - i2 | 0) >>> 0 < 31) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35813 | 0, 31) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35813 | 0, 31) | 0) >>> 0 < 31) break;
   i1 = 0;
   i3 = gb + 35813 + 31 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 31;
   i3 = gb + 35813 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 651;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 651;
 } while (0);
 do if ((i35 | 0) == 651) {
  if ((i1 - i2 | 0) >>> 0 < 16) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35845 | 0, 16) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35845 | 0, 16) | 0) >>> 0 < 16) break;
   i1 = 0;
   i3 = gb + 35845 + 16 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 16;
   i3 = gb + 35845 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 662;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 662;
 } while (0);
 do if ((i35 | 0) == 662) {
  if ((i1 - i2 | 0) >>> 0 < 26) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35862 | 0, 26) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35862 | 0, 26) | 0) >>> 0 < 26) break;
   i1 = 0;
   i3 = gb + 35862 + 26 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 26;
   i3 = gb + 35862 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 673;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 673;
 } while (0);
 do if ((i35 | 0) == 673) {
  if ((i1 - i2 | 0) >>> 0 < 11) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35146 | 0, 11) | 0) >>> 0 < 11) break;
   i1 = 0;
   i3 = gb + 35146 + 11 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 11;
   i3 = gb + 35146 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 684;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 684;
 } while (0);
 do if ((i35 | 0) == 684) {
  if ((i1 - i2 | 0) >>> 0 < 30) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35889 | 0, 30) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35889 | 0, 30) | 0) >>> 0 < 30) break;
   i1 = 0;
   i3 = gb + 35889 + 30 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 30;
   i3 = gb + 35889 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i31 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i31 + 255 | i31;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 695;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 695;
 } while (0);
 do if ((i35 | 0) == 695) {
  if ((i1 - i2 | 0) >>> 0 < 24) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35920 | 0, 24) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35920 | 0, 24) | 0) >>> 0 < 24) break;
   i1 = 0;
   i3 = gb + 35920 + 24 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 24;
   i3 = gb + 35920 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i32 + 184 >> 2] | 0;
 i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 3) | 0;
 i2 = 0;
 do {
  d40 = +HEAPF32[i1 + (i2 << 3) >> 2];
  d41 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
  i2 = i2 + 1 | 0;
  HEAP32[i33 >> 2] = i2;
  HEAPF64[i33 + 8 >> 3] = d40;
  HEAPF64[i33 + 16 >> 3] = d41;
  _fprintf(i36, gb + 35945 | 0, i33);
 } while ((i2 | 0) != 2048);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 708;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 708;
 } while (0);
 do if ((i35 | 0) == 708) {
  if ((i1 - i2 | 0) >>> 0 < 8) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
   i1 = 0;
   i3 = gb + 34345 + 8 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 8;
   i3 = gb + 34345 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 719;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 719;
 } while (0);
 do if ((i35 | 0) == 719) {
  if ((i1 - i2 | 0) >>> 0 < 45) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35982 | 0, 45) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 35982 | 0, 45) | 0) >>> 0 < 45) break;
   i1 = 0;
   i3 = gb + 35982 + 45 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 45;
   i3 = gb + 35982 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 730;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 730;
 } while (0);
 do if ((i35 | 0) == 730) {
  if ((i1 - i2 | 0) >>> 0 < 13) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36028 | 0, 13) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36028 | 0, 13) | 0) >>> 0 < 13) break;
   i1 = 0;
   i3 = gb + 36028 + 13 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 13;
   i3 = gb + 36028 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 741;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 741;
 } while (0);
 do if ((i35 | 0) == 741) {
  if ((i1 - i2 | 0) >>> 0 < 13) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36042 | 0, 13) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36042 | 0, 13) | 0) >>> 0 < 13) break;
   i1 = 0;
   i3 = gb + 36042 + 13 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 13;
   i3 = gb + 36042 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 752;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 752;
 } while (0);
 do if ((i35 | 0) == 752) {
  if ((i1 - i2 | 0) >>> 0 < 23) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36056 | 0, 23) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36056 | 0, 23) | 0) >>> 0 < 23) break;
   i1 = 0;
   i3 = gb + 36056 + 23 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 23;
   i3 = gb + 36056 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 763;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 763;
 } while (0);
 do if ((i35 | 0) == 763) {
  if ((i1 - i2 | 0) >>> 0 < 13) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36080 | 0, 13) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36080 | 0, 13) | 0) >>> 0 < 13) break;
   i1 = 0;
   i3 = gb + 36080 + 13 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 13;
   i3 = gb + 36080 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 i1 = HEAP32[i34 >> 2] | 0;
 do if (!i1) {
  i1 = i36 + 74 | 0;
  i33 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i33 + 255 | i33;
  i1 = HEAP32[i36 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i36 + 8 >> 2] = 0;
   HEAP32[i36 + 4 >> 2] = 0;
   i2 = HEAP32[i36 + 44 >> 2] | 0;
   HEAP32[i36 + 28 >> 2] = i2;
   i4 = i36 + 20 | 0;
   HEAP32[i4 >> 2] = i2;
   i1 = i2 + (HEAP32[i36 + 48 >> 2] | 0) | 0;
   HEAP32[i34 >> 2] = i1;
   i35 = 774;
   break;
  } else {
   HEAP32[i36 >> 2] = i1 | 32;
   break;
  }
 } else {
  i2 = i36 + 20 | 0;
  i4 = i2;
  i2 = HEAP32[i2 >> 2] | 0;
  i35 = 774;
 } while (0);
 do if ((i35 | 0) == 774) {
  if ((i1 - i2 | 0) >>> 0 < 9) {
   mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36094 | 0, 9) | 0;
   break;
  }
  if ((HEAP8[i36 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[i36 + 36 >> 2] | 0, i36 | 0, gb + 36094 | 0, 9) | 0) >>> 0 < 9) break;
   i1 = 0;
   i3 = gb + 36094 + 9 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else {
   i1 = 9;
   i3 = gb + 36094 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 } while (0);
 _fclose(i36);
 HEAP32[i38 >> 2] = i37;
 _printf(gb + 36104 | 0, i38);
 STACKTOP = i39;
 return;
}

function _quiet_decoder_recv(i19, i24, i23) {
 i19 = i19 | 0;
 i24 = i24 | 0;
 i23 = i23 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i20 = 0, i21 = 0, i22 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, d51 = 0.0, d52 = 0.0;
 i50 = STACKTOP;
 STACKTOP = STACKTOP + 432 | 0;
 i48 = i50 + 360 | 0;
 i47 = i50 + 344 | 0;
 i46 = i50 + 328 | 0;
 i45 = i50 + 304 | 0;
 i44 = i50 + 296 | 0;
 i43 = i50 + 288 | 0;
 i41 = i50 + 280 | 0;
 i40 = i50 + 272 | 0;
 i39 = i50 + 264 | 0;
 i38 = i50 + 240 | 0;
 i37 = i50 + 216 | 0;
 i36 = i50 + 208 | 0;
 i35 = i50 + 184 | 0;
 i33 = i50 + 160 | 0;
 i32 = i50 + 152 | 0;
 i31 = i50 + 128 | 0;
 i30 = i50 + 104 | 0;
 i29 = i50 + 80 | 0;
 i28 = i50 + 56 | 0;
 i27 = i50 + 32 | 0;
 i42 = i50 + 24 | 0;
 i34 = i50 + 16 | 0;
 i26 = i50 + 8 | 0;
 i25 = i50;
 i21 = i50 + 368 | 0;
 i22 = i50 + 364 | 0;
 if (!i19) {
  i49 = 0;
  STACKTOP = i50;
  return i49 | 0;
 }
 i15 = i19 + 64 | 0;
 i16 = Math_imul(HEAP32[HEAP32[i15 >> 2] >> 2] | 0, HEAP32[i19 + 84 >> 2] | 0) | 0;
 L4 : do if (i23 | 0) {
  i17 = i19 + 96 | 0;
  i18 = i19 + 104 | 0;
  i8 = i19 + 100 | 0;
  i9 = i19 + 80 | 0;
  i10 = i19 + 52 | 0;
  i11 = i19 + 60 | 0;
  i12 = i19 + 56 | 0;
  i13 = i19 + 88 | 0;
  i14 = i19 + 60 | 0;
  i20 = 0;
  while (1) {
   i1 = HEAP32[i17 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i18 >> 2] | 0;
    i2 = i1 + (i23 - i20) | 0;
    i2 = i2 >>> 0 < i16 >>> 0 ? i2 : i16;
    _memmove((HEAP32[i8 >> 2] | 0) + (i1 << 2) | 0, i24 + (i20 << 2) | 0, i2 - i1 << 2 | 0) | 0;
    i1 = i2 - (HEAP32[i18 >> 2] | 0) | 0;
   } else {
    i2 = HEAP32[i18 >> 2] | 0;
    _resamp_rrrf_execute_output_block(i1, i24 + (i20 << 2) | 0, i23 - i20 | 0, i21, (HEAP32[i8 >> 2] | 0) + (i2 << 2) | 0, i16 - i2 | 0, i22);
    i1 = HEAP32[i21 >> 2] | 0;
    i2 = (HEAP32[i18 >> 2] | 0) + (HEAP32[i22 >> 2] | 0) | 0;
   }
   i20 = i1 + i20 | 0;
   i7 = HEAP32[i15 >> 2] | 0;
   i3 = (i2 >>> 0) % ((HEAP32[i7 >> 2] | 0) >>> 0) | 0;
   i1 = i2 - i3 | 0;
   i2 = _demodulator_recv(i7, HEAP32[i8 >> 2] | 0, i1, HEAP32[i9 >> 2] | 0) | 0;
   if (i3 | 0) {
    i7 = HEAP32[i8 >> 2] | 0;
    _memmove(i7 | 0, i7 + (i1 << 2) | 0, i3 << 2 | 0) | 0;
   }
   HEAP32[i18 >> 2] = i3;
   switch (HEAP32[i10 >> 2] | 0) {
   case 0:
    {
     _ofdmframesync_execute(HEAP32[(HEAP32[i11 >> 2] | 0) + 184 >> 2] | 0, HEAP32[i9 >> 2] | 0, i2);
     if (HEAP8[i12 >> 0] | 0) {
      HEAP32[i25 >> 2] = HEAP32[i13 >> 2];
      _sprintf(i21, gb + 9664 | 0, i25);
      _ofdmframesync_debug_print(HEAP32[(HEAP32[i11 >> 2] | 0) + 184 >> 2] | 0, i21);
      HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + 1;
     }
     break;
    }
   case 1:
    {
     _flexframesync_execute(HEAP32[i14 >> 2] | 0, HEAP32[i9 >> 2] | 0, i2);
     if (HEAP8[i12 >> 0] | 0) {
      HEAP32[i26 >> 2] = HEAP32[i13 >> 2];
      _sprintf(i21, gb + 9664 | 0, i26);
      i5 = HEAP32[i14 >> 2] | 0;
      L20 : do if (!(HEAP32[i5 + 208 >> 2] | 0)) {
       i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i1) {
        i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
        i1 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i2;
         HEAP32[gb + 8728 + 20 >> 2] = i2;
         i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i1;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i1 | 32;
         break L20;
        }
       } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
       if ((i1 - i2 | 0) >>> 0 < 90) {
        mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24009 | 0, 90) | 0;
        break;
       }
       if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
        if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24009 | 0, 90) | 0) >>> 0 < 90) break;
        i1 = 0;
        i3 = gb + 24009 + 90 | 0;
        i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       } else {
        i1 = 90;
        i3 = gb + 24009 | 0;
       }
       _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
       HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
      } else {
       i7 = _fopen(i21, gb + 33922 | 0) | 0;
       HEAP32[i34 >> 2] = i21;
       _fprintf(i7, gb + 25623 | 0, i34);
       i6 = i7 + 16 | 0;
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 32;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 32;
       } while (0);
       do if ((i49 | 0) == 32) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 43;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 43;
       } while (0);
       do if ((i49 | 0) == 43) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 11) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34061 | 0, 11) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34061 | 0, 11) | 0) >>> 0 < 11) break;
         i1 = 0;
         i3 = gb + 34061 + 11 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 11;
         i3 = gb + 34061 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 54;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 54;
       } while (0);
       do if ((i49 | 0) == 54) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 12) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25650 | 0, 12) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25650 | 0, 12) | 0) >>> 0 < 12) break;
         i1 = 0;
         i3 = gb + 25650 + 12 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 12;
         i3 = gb + 25650 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       HEAP32[i42 >> 2] = 2e3;
       _fprintf(i7, gb + 34073 | 0, i42);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 65;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 65;
       } while (0);
       do if ((i49 | 0) == 65) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 54) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24100 | 0, 54) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24100 | 0, 54) | 0) >>> 0 < 54) break;
         i1 = 0;
         i3 = gb + 24100 + 54 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 54;
         i3 = gb + 24100 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 76;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 76;
       } while (0);
       do if ((i49 | 0) == 76) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 16) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34299 | 0, 16) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34299 | 0, 16) | 0) >>> 0 < 16) break;
         i1 = 0;
         i3 = gb + 34299 + 16 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 16;
         i3 = gb + 34299 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i5 + 216 >> 2] | 0;
       i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 3) | 0;
       i2 = 0;
       do {
        d52 = +HEAPF32[i1 + (i2 << 3) >> 2];
        d51 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
        i2 = i2 + 1 | 0;
        HEAP32[i27 >> 2] = i2;
        HEAPF64[i27 + 8 >> 3] = d52;
        HEAPF64[i27 + 16 >> 3] = d51;
        _fprintf(i7, gb + 34316 | 0, i27);
       } while ((i2 | 0) != 2e3);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 89;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 89;
       } while (0);
       do if ((i49 | 0) == 89) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 100;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 100;
       } while (0);
       do if ((i49 | 0) == 100) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 18) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24155 | 0, 18) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24155 | 0, 18) | 0) >>> 0 < 18) break;
         i1 = 0;
         i3 = gb + 24155 + 18 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 18;
         i3 = gb + 24155 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 111;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 111;
       } while (0);
       do if ((i49 | 0) == 111) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 48) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25733 | 0, 48) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25733 | 0, 48) | 0) >>> 0 < 48) break;
         i1 = 0;
         i3 = gb + 25733 + 48 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 48;
         i3 = gb + 25733 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 122;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 122;
       } while (0);
       do if ((i49 | 0) == 122) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 9) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36094 | 0, 9) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36094 | 0, 9) | 0) >>> 0 < 9) break;
         i1 = 0;
         i3 = gb + 36094 + 9 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 9;
         i3 = gb + 36094 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 133;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 133;
       } while (0);
       do if ((i49 | 0) == 133) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 24) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34394 | 0, 24) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34394 | 0, 24) | 0) >>> 0 < 24) break;
         i1 = 0;
         i3 = gb + 34394 + 24 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 24;
         i3 = gb + 34394 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 144;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 144;
       } while (0);
       do if ((i49 | 0) == 144) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 30) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34419 | 0, 30) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34419 | 0, 30) | 0) >>> 0 < 30) break;
         i1 = 0;
         i3 = gb + 34419 + 30 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 30;
         i3 = gb + 34419 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 155;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 155;
       } while (0);
       do if ((i49 | 0) == 155) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 27) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24174 | 0, 27) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24174 | 0, 27) | 0) >>> 0 < 27) break;
         i1 = 0;
         i3 = gb + 24174 + 27 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 27;
         i3 = gb + 24174 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i5 + 116 >> 2] | 0;
       d51 = +HEAPF32[i1 >> 2];
       d52 = +HEAPF32[i1 + 4 >> 2];
       HEAP32[i28 >> 2] = 1;
       HEAPF64[i28 + 8 >> 3] = d51;
       HEAPF64[i28 + 16 >> 3] = d52;
       _fprintf(i7, gb + 24202 | 0, i28);
       i2 = 1;
       do {
        d51 = +HEAPF32[i1 + (i2 << 3) >> 2];
        d52 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
        i2 = i2 + 1 | 0;
        HEAP32[i29 >> 2] = i2;
        HEAPF64[i29 + 8 >> 3] = d51;
        HEAPF64[i29 + 16 >> 3] = d52;
        _fprintf(i7, gb + 24202 | 0, i29);
       } while ((i2 | 0) != 64);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 168;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 168;
       } while (0);
       do if ((i49 | 0) == 168) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 27) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24242 | 0, 27) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24242 | 0, 27) | 0) >>> 0 < 27) break;
         i1 = 0;
         i3 = gb + 24242 + 27 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 27;
         i3 = gb + 24242 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i5 + 120 >> 2] | 0;
       d51 = +HEAPF32[i1 >> 2];
       d52 = +HEAPF32[i1 + 4 >> 2];
       HEAP32[i30 >> 2] = 1;
       HEAPF64[i30 + 8 >> 3] = d51;
       HEAPF64[i30 + 16 >> 3] = d52;
       _fprintf(i7, gb + 24270 | 0, i30);
       i2 = 1;
       do {
        d51 = +HEAPF32[i1 + (i2 << 3) >> 2];
        d52 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
        i2 = i2 + 1 | 0;
        HEAP32[i31 >> 2] = i2;
        HEAPF64[i31 + 8 >> 3] = d51;
        HEAPF64[i31 + 16 >> 3] = d52;
        _fprintf(i7, gb + 24270 | 0, i31);
       } while ((i2 | 0) != 64);
       i1 = i5 + 140 | 0;
       HEAP32[i32 >> 2] = HEAP32[i1 >> 2];
       _fprintf(i7, gb + 24310 | 0, i32);
       do if (HEAP32[i1 >> 2] | 0) {
        i2 = HEAP32[i5 + 136 >> 2] | 0;
        d51 = +HEAPF32[i2 >> 2];
        d52 = +HEAPF32[i2 + 4 >> 2];
        HEAP32[i33 >> 2] = 1;
        HEAPF64[i33 + 8 >> 3] = d51;
        HEAPF64[i33 + 16 >> 3] = d52;
        _fprintf(i7, gb + 24337 | 0, i33);
        if ((HEAP32[i1 >> 2] | 0) >>> 0 > 1) i3 = 1; else break;
        do {
         d51 = +HEAPF32[i2 + (i3 << 3) >> 2];
         d52 = +HEAPF32[i2 + (i3 << 3) + 4 >> 2];
         i3 = i3 + 1 | 0;
         HEAP32[i35 >> 2] = i3;
         HEAPF64[i35 + 8 >> 3] = d51;
         HEAPF64[i35 + 16 >> 3] = d52;
         _fprintf(i7, gb + 24337 | 0, i35);
        } while (i3 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
       } while (0);
       i3 = i5 + 172 | 0;
       HEAP32[i36 >> 2] = HEAP32[i3 >> 2];
       _fprintf(i7, gb + 24375 | 0, i36);
       do if (HEAP32[i3 >> 2] | 0) {
        i1 = HEAP32[i5 + 168 >> 2] | 0;
        d51 = +HEAPF32[i1 >> 2];
        d52 = +HEAPF32[i1 + 4 >> 2];
        HEAP32[i37 >> 2] = 1;
        HEAPF64[i37 + 8 >> 3] = d51;
        HEAPF64[i37 + 16 >> 3] = d52;
        _fprintf(i7, gb + 24403 | 0, i37);
        if ((HEAP32[i3 >> 2] | 0) >>> 0 > 1) i2 = 1; else break;
        do {
         d51 = +HEAPF32[i1 + (i2 << 3) >> 2];
         d52 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
         i2 = i2 + 1 | 0;
         HEAP32[i38 >> 2] = i2;
         HEAPF64[i38 + 8 >> 3] = d51;
         HEAPF64[i38 + 16 >> 3] = d52;
         _fprintf(i7, gb + 24403 | 0, i38);
        } while (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 187;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 187;
       } while (0);
       do if ((i49 | 0) == 187) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 20) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24442 | 0, 20) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24442 | 0, 20) | 0) >>> 0 < 20) break;
         i1 = 0;
         i3 = gb + 24442 + 20 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 20;
         i3 = gb + 24442 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 198;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 198;
       } while (0);
       do if ((i49 | 0) == 198) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 45) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24463 | 0, 45) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24463 | 0, 45) | 0) >>> 0 < 45) break;
         i1 = 0;
         i3 = gb + 24463 + 45 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 45;
         i3 = gb + 24463 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 209;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 209;
       } while (0);
       do if ((i49 | 0) == 209) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 20) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24509 | 0, 20) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24509 | 0, 20) | 0) >>> 0 < 20) break;
         i1 = 0;
         i3 = gb + 24509 + 20 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 20;
         i3 = gb + 24509 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 220;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 220;
       } while (0);
       do if ((i49 | 0) == 220) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 28) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24530 | 0, 28) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24530 | 0, 28) | 0) >>> 0 < 28) break;
         i1 = 0;
         i3 = gb + 24530 + 28 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 28;
         i3 = gb + 24530 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 231;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 231;
       } while (0);
       do if ((i49 | 0) == 231) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 9) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36094 | 0, 9) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36094 | 0, 9) | 0) >>> 0 < 9) break;
         i1 = 0;
         i3 = gb + 36094 + 9 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 9;
         i3 = gb + 36094 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 242;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 242;
       } while (0);
       do if ((i49 | 0) == 242) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 23) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24559 | 0, 23) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24559 | 0, 23) | 0) >>> 0 < 23) break;
         i1 = 0;
         i3 = gb + 24559 + 23 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 23;
         i3 = gb + 24559 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 253;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 253;
       } while (0);
       do if ((i49 | 0) == 253) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 13) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36080 | 0, 13) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36080 | 0, 13) | 0) >>> 0 < 13) break;
         i1 = 0;
         i3 = gb + 36080 + 13 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 13;
         i3 = gb + 36080 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 264;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 264;
       } while (0);
       do if ((i49 | 0) == 264) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 34) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24583 | 0, 34) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24583 | 0, 34) | 0) >>> 0 < 34) break;
         i1 = 0;
         i3 = gb + 24583 + 34 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 34;
         i3 = gb + 24583 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 275;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 275;
       } while (0);
       do if ((i49 | 0) == 275) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 20) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24618 | 0, 20) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24618 | 0, 20) | 0) >>> 0 < 20) break;
         i1 = 0;
         i3 = gb + 24618 + 20 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 20;
         i3 = gb + 24618 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 286;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 286;
       } while (0);
       do if ((i49 | 0) == 286) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 47) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24639 | 0, 47) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24639 | 0, 47) | 0) >>> 0 < 47) break;
         i1 = 0;
         i3 = gb + 24639 + 47 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 47;
         i3 = gb + 24639 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 297;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 297;
       } while (0);
       do if ((i49 | 0) == 297) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 20) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24509 | 0, 20) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24509 | 0, 20) | 0) >>> 0 < 20) break;
         i1 = 0;
         i3 = gb + 24509 + 20 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 20;
         i3 = gb + 24509 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 308;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 308;
       } while (0);
       do if ((i49 | 0) == 308) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 28) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24530 | 0, 28) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24530 | 0, 28) | 0) >>> 0 < 28) break;
         i1 = 0;
         i3 = gb + 24530 + 28 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 28;
         i3 = gb + 24530 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 319;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 319;
       } while (0);
       do if ((i49 | 0) == 319) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 9) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36094 | 0, 9) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36094 | 0, 9) | 0) >>> 0 < 9) break;
         i1 = 0;
         i3 = gb + 36094 + 9 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 9;
         i3 = gb + 36094 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 330;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 330;
       } while (0);
       do if ((i49 | 0) == 330) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 23) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24559 | 0, 23) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24559 | 0, 23) | 0) >>> 0 < 23) break;
         i1 = 0;
         i3 = gb + 24559 + 23 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 23;
         i3 = gb + 24559 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 341;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 341;
       } while (0);
       do if ((i49 | 0) == 341) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 13) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36080 | 0, 13) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 36080 | 0, 13) | 0) >>> 0 < 13) break;
         i1 = 0;
         i3 = gb + 36080 + 13 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 13;
         i3 = gb + 36080 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 352;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 352;
       } while (0);
       do if ((i49 | 0) == 352) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 35) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24687 | 0, 35) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 24687 | 0, 35) | 0) >>> 0 < 35) break;
         i1 = 0;
         i3 = gb + 24687 + 35 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 35;
         i3 = gb + 24687 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 363;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 363;
       } while (0);
       do if ((i49 | 0) == 363) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       _fclose(i7);
       HEAP32[i39 >> 2] = i21;
       _printf(gb + 24723 | 0, i39);
      } while (0);
      HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + 1;
     }
     break;
    }
   case 2:
    {
     _gmskframesync_execute(HEAP32[i14 >> 2] | 0, HEAP32[i9 >> 2] | 0, i2);
     if (HEAP8[i12 >> 0] | 0) {
      HEAP32[i40 >> 2] = HEAP32[i13 >> 2];
      _sprintf(i21, gb + 9664 | 0, i40);
      i5 = HEAP32[i14 >> 2] | 0;
      L539 : do if (!(HEAP32[i5 + 236 >> 2] | 0)) {
       i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i1) {
        i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
        i1 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i2;
         HEAP32[gb + 8728 + 20 >> 2] = i2;
         i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i1;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i1 | 32;
         break L539;
        }
       } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
       if ((i1 - i2 | 0) >>> 0 < 86) {
        mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25467 | 0, 86) | 0;
        break;
       }
       if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
        if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25467 | 0, 86) | 0) >>> 0 < 86) break;
        i1 = 0;
        i3 = gb + 25467 + 86 | 0;
        i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       } else {
        i1 = 86;
        i3 = gb + 25467 | 0;
       }
       _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
       HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
      } else {
       i7 = _fopen(i21, gb + 33922 | 0) | 0;
       if (!i7) {
        HEAP32[i41 >> 2] = i21;
        _fprintf(gb + 8728 | 0, gb + 25554 | 0, i41);
        break;
       }
       HEAP32[i43 >> 2] = i21;
       _fprintf(i7, gb + 25623 | 0, i43);
       i6 = i7 + 16 | 0;
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 391;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 391;
       } while (0);
       do if ((i49 | 0) == 391) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 402;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 402;
       } while (0);
       do if ((i49 | 0) == 402) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 11) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34061 | 0, 11) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34061 | 0, 11) | 0) >>> 0 < 11) break;
         i1 = 0;
         i3 = gb + 34061 + 11 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 11;
         i3 = gb + 34061 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 413;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 413;
       } while (0);
       do if ((i49 | 0) == 413) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 12) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25650 | 0, 12) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25650 | 0, 12) | 0) >>> 0 < 12) break;
         i1 = 0;
         i3 = gb + 25650 + 12 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 12;
         i3 = gb + 25650 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       HEAP32[i44 >> 2] = 2e3;
       _fprintf(i7, gb + 25663 | 0, i44);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 424;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 424;
       } while (0);
       do if ((i49 | 0) == 424) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 23) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25682 | 0, 23) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25682 | 0, 23) | 0) >>> 0 < 23) break;
         i1 = 0;
         i3 = gb + 25682 + 23 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 23;
         i3 = gb + 25682 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 435;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 435;
       } while (0);
       do if ((i49 | 0) == 435) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 26) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25706 | 0, 26) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25706 | 0, 26) | 0) >>> 0 < 26) break;
         i1 = 0;
         i3 = gb + 25706 + 26 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 26;
         i3 = gb + 25706 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i5 + 240 >> 2] | 0;
       i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 3) | 0;
       i2 = 0;
       do {
        d51 = +HEAPF32[i1 + (i2 << 3) >> 2];
        d52 = +HEAPF32[i1 + (i2 << 3) + 4 >> 2];
        i2 = i2 + 1 | 0;
        HEAP32[i45 >> 2] = i2;
        HEAPF64[i45 + 8 >> 3] = d51;
        HEAPF64[i45 + 16 >> 3] = d52;
        _fprintf(i7, gb + 34316 | 0, i45);
       } while ((i2 | 0) != 2e3);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 448;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 448;
       } while (0);
       do if ((i49 | 0) == 448) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 459;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 459;
       } while (0);
       do if ((i49 | 0) == 459) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 8) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34345 | 0, 8) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
         i1 = 0;
         i3 = gb + 34345 + 8 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 8;
         i3 = gb + 34345 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 470;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 470;
       } while (0);
       do if ((i49 | 0) == 470) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 48) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25733 | 0, 48) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25733 | 0, 48) | 0) >>> 0 < 48) break;
         i1 = 0;
         i3 = gb + 25733 + 48 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 48;
         i3 = gb + 25733 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 481;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 481;
       } while (0);
       do if ((i49 | 0) == 481) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 30) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34419 | 0, 30) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34419 | 0, 30) | 0) >>> 0 < 30) break;
         i1 = 0;
         i3 = gb + 34419 + 30 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 30;
         i3 = gb + 34419 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 492;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 492;
       } while (0);
       do if ((i49 | 0) == 492) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 503;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 503;
       } while (0);
       do if ((i49 | 0) == 503) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 27) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25782 | 0, 27) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25782 | 0, 27) | 0) >>> 0 < 27) break;
         i1 = 0;
         i3 = gb + 25782 + 27 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 27;
         i3 = gb + 25782 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i5 + 244 >> 2] | 0;
       i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 2) | 0;
       i2 = 0;
       do {
        d52 = +HEAPF32[i1 + (i2 << 2) >> 2];
        i2 = i2 + 1 | 0;
        HEAP32[i46 >> 2] = i2;
        HEAPF64[i46 + 8 >> 3] = d52;
        _fprintf(i7, gb + 25810 | 0, i46);
       } while ((i2 | 0) != 2e3);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 516;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 516;
       } while (0);
       do if ((i49 | 0) == 516) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 527;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 527;
       } while (0);
       do if ((i49 | 0) == 527) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 8) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34345 | 0, 8) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
         i1 = 0;
         i3 = gb + 34345 + 8 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 8;
         i3 = gb + 34345 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 538;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 538;
       } while (0);
       do if ((i49 | 0) == 538) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 23) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25829 | 0, 23) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25829 | 0, 23) | 0) >>> 0 < 23) break;
         i1 = 0;
         i3 = gb + 25829 + 23 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 23;
         i3 = gb + 25829 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 549;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 549;
       } while (0);
       do if ((i49 | 0) == 549) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 23) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25853 | 0, 23) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25853 | 0, 23) | 0) >>> 0 < 23) break;
         i1 = 0;
         i3 = gb + 25853 + 23 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 23;
         i3 = gb + 25853 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 560;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 560;
       } while (0);
       do if ((i49 | 0) == 560) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i4 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i4 + 255 | i4;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 571;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 571;
       } while (0);
       do if ((i49 | 0) == 571) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 27) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25877 | 0, 27) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25877 | 0, 27) | 0) >>> 0 < 27) break;
         i1 = 0;
         i3 = gb + 25877 + 27 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 27;
         i3 = gb + 25877 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i5 + 248 >> 2] | 0;
       i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 2) | 0;
       i2 = 0;
       do {
        d52 = +HEAPF32[i1 + (i2 << 2) >> 2];
        i2 = i2 + 1 | 0;
        HEAP32[i47 >> 2] = i2;
        HEAPF64[i47 + 8 >> 3] = d52;
        _fprintf(i7, gb + 25905 | 0, i47);
       } while ((i2 | 0) != 2e3);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 584;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 584;
       } while (0);
       do if ((i49 | 0) == 584) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 595;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 595;
       } while (0);
       do if ((i49 | 0) == 595) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 8) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34345 | 0, 8) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34345 | 0, 8) | 0) >>> 0 < 8) break;
         i1 = 0;
         i3 = gb + 34345 + 8 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 8;
         i3 = gb + 34345 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 606;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 606;
       } while (0);
       do if ((i49 | 0) == 606) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 23) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25924 | 0, 23) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25924 | 0, 23) | 0) >>> 0 < 23) break;
         i1 = 0;
         i3 = gb + 25924 + 23 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 23;
         i3 = gb + 25924 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 617;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 617;
       } while (0);
       do if ((i49 | 0) == 617) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 21) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25948 | 0, 21) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 25948 | 0, 21) | 0) >>> 0 < 21) break;
         i1 = 0;
         i3 = gb + 25948 + 21 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 21;
         i3 = gb + 25948 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       i1 = HEAP32[i6 >> 2] | 0;
       do if (!i1) {
        i1 = i7 + 74 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        HEAP8[i1 >> 0] = i5 + 255 | i5;
        i1 = HEAP32[i7 >> 2] | 0;
        if (!(i1 & 8)) {
         HEAP32[i7 + 8 >> 2] = 0;
         HEAP32[i7 + 4 >> 2] = 0;
         i2 = HEAP32[i7 + 44 >> 2] | 0;
         HEAP32[i7 + 28 >> 2] = i2;
         i4 = i7 + 20 | 0;
         HEAP32[i4 >> 2] = i2;
         i1 = i2 + (HEAP32[i7 + 48 >> 2] | 0) | 0;
         HEAP32[i6 >> 2] = i1;
         i49 = 628;
         break;
        } else {
         HEAP32[i7 >> 2] = i1 | 32;
         break;
        }
       } else {
        i2 = i7 + 20 | 0;
        i4 = i2;
        i2 = HEAP32[i2 >> 2] | 0;
        i49 = 628;
       } while (0);
       do if ((i49 | 0) == 628) {
        i49 = 0;
        if ((i1 - i2 | 0) >>> 0 < 2) {
         mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0;
         break;
        }
        if ((HEAP8[i7 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, gb + 34490 | 0, 2) | 0) >>> 0 < 2) break;
         i1 = 0;
         i3 = gb + 34490 + 2 | 0;
         i2 = HEAP32[i4 >> 2] | 0;
        } else {
         i1 = 2;
         i3 = gb + 34490 | 0;
        }
        _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
        HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
       } while (0);
       _fclose(i7);
       HEAP32[i48 >> 2] = i21;
       _printf(gb + 25970 | 0, i48);
      } while (0);
      HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + 1;
     }
     break;
    }
   default:
    {}
   }
   if (i20 >>> 0 >= i23 >>> 0) break L4;
  }
 } while (0);
 i49 = HEAP32[i19 + 76 >> 2] | 0;
 STACKTOP = i50;
 return i49 | 0;
}

function _lex_scan(i41, i40) {
 i41 = i41 | 0;
 i40 = i40 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, d7 = 0.0, i8 = 0, d9 = 0.0, i10 = 0, i11 = 0, d12 = 0.0, d13 = 0.0, i14 = 0, i15 = 0, d16 = 0.0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i42 = 0, i43 = 0, d44 = 0.0;
 i43 = STACKTOP;
 STACKTOP = STACKTOP + 736 | 0;
 i36 = i43 + 96 | 0;
 i32 = i43 + 88 | 0;
 i31 = i43 + 80 | 0;
 i29 = i43 + 72 | 0;
 i28 = i43 + 64 | 0;
 i27 = i43 + 56 | 0;
 i26 = i43 + 48 | 0;
 i25 = i43 + 40 | 0;
 i21 = i43 + 32 | 0;
 i20 = i43 + 24 | 0;
 i23 = i43 + 16 | 0;
 i22 = i43 + 8 | 0;
 i19 = i43;
 i35 = i43 + 216 | 0;
 i34 = i43 + 104 | 0;
 i39 = i41 + 44 | 0;
 HEAP32[i39 >> 2] = 0;
 i37 = i41 + 40 | 0;
 HEAP8[HEAP32[i37 >> 2] >> 0] = 0;
 i42 = i41 + 56 | 0;
 if ((HEAP32[i42 >> 2] | 0) == 256) {
  i1 = i41 + 64 | 0;
  i4 = HEAP32[i1 >> 2] | 0;
  if (i4 | 0) _free(i4);
  HEAP32[i1 >> 2] = 0;
  HEAP32[i1 + 4 >> 2] = 0;
 }
 L7 : while (1) {
  i1 = _stream_get(i41, i40) | 0;
  switch (i1 | 0) {
  case 9:
  case 10:
  case 13:
  case 32:
   break;
  case -1:
   {
    i38 = 7;
    break L7;
   }
  case -2:
   {
    i38 = 8;
    break L7;
   }
  default:
   {
    i38 = 9;
    break L7;
   }
  }
 }
 if ((i38 | 0) == 7) {
  HEAP32[i42 >> 2] = 0;
  STACKTOP = i43;
  return;
 } else if ((i38 | 0) == 8) {
  HEAP32[i42 >> 2] = -1;
  STACKTOP = i43;
  return;
 } else if ((i38 | 0) == 9) {
  i10 = i1 & 255;
  i33 = i41 + 48 | 0;
  i6 = HEAP32[i33 >> 2] | 0;
  i4 = HEAP32[i39 >> 2] | 0;
  if ((i6 - i4 | 0) >>> 0 <= 1) {
   if ((!((i6 | 0) < 0 | i4 >>> 0 > 4294967293) ? (i6 = i6 << 1, i8 = i4 + 2 | 0, i8 = i6 >>> 0 > i8 >>> 0 ? i6 : i8, i8 | 0) : 0) ? (i5 = _malloc(i8) | 0, i5 | 0) : 0) {
    _memcpy(i5 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
    i4 = HEAP32[i37 >> 2] | 0;
    if (i4 | 0) _free(i4);
    HEAP32[i37 >> 2] = i5;
    HEAP32[i33 >> 2] = i8;
    i4 = HEAP32[i39 >> 2] | 0;
    i38 = 17;
   }
  } else {
   i5 = HEAP32[i37 >> 2] | 0;
   i38 = 17;
  }
  if ((i38 | 0) == 17) {
   HEAP8[i5 + i4 >> 0] = i10;
   i10 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
   HEAP32[i39 >> 2] = i10;
   HEAP8[(HEAP32[i37 >> 2] | 0) + i10 >> 0] = 0;
  }
  i10 = i1 | 32;
  if ((i1 | 0) == 44 | ((i1 | 0) == 58 | ((i10 | 0) == 125 | (i10 | 0) == 123))) {
   HEAP32[i42 >> 2] = i1;
   STACKTOP = i43;
   return;
  }
  if ((i1 | 0) == 34) {
   i11 = i41 + 64 | 0;
   HEAP32[i11 >> 2] = 0;
   HEAP32[i42 >> 2] = -1;
   i6 = _stream_get(i41, i40) | 0;
   do if (i6 >>> 0 < 4294967294) {
    i5 = i6 & 255;
    i1 = HEAP32[i33 >> 2] | 0;
    i2 = HEAP32[i39 >> 2] | 0;
    if ((i1 - i2 | 0) >>> 0 > 1) {
     i4 = HEAP32[i37 >> 2] | 0;
     i1 = i2;
    } else {
     if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) break;
     i36 = i1 << 1;
     i1 = i2 + 2 | 0;
     i1 = i36 >>> 0 > i1 >>> 0 ? i36 : i1;
     if (!i1) break;
     i2 = _malloc(i1) | 0;
     if (!i2) break;
     _memcpy(i2 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
     i4 = HEAP32[i37 >> 2] | 0;
     if (i4 | 0) _free(i4);
     HEAP32[i37 >> 2] = i2;
     HEAP32[i33 >> 2] = i1;
     i4 = i2;
     i1 = HEAP32[i39 >> 2] | 0;
    }
    HEAP8[i4 + i1 >> 0] = i5;
    i36 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
    HEAP32[i39 >> 2] = i36;
    HEAP8[(HEAP32[i37 >> 2] | 0) + i36 >> 0] = 0;
   } while (0);
   i10 = i41 + 40 | 0;
   i4 = i6;
   L42 : while (1) {
    switch (i4 | 0) {
    case 34:
     {
      i38 = 102;
      break L42;
     }
    case -2:
     break L42;
    case -1:
     {
      i38 = 33;
      break L42;
     }
    default:
     {}
    }
    if (i4 >>> 0 < 32) {
     i38 = 35;
     break;
    }
    i5 = (i4 | 0) == 92;
    i6 = _stream_get(i41, i40) | 0;
    do if (i6 >>> 0 < 4294967294) {
     i8 = i6 & 255;
     i1 = HEAP32[i33 >> 2] | 0;
     i2 = HEAP32[i39 >> 2] | 0;
     if ((i1 - i2 | 0) >>> 0 > 1) {
      i4 = HEAP32[i10 >> 2] | 0;
      i1 = i2;
     } else {
      if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) break;
      i37 = i1 << 1;
      i1 = i2 + 2 | 0;
      i1 = i37 >>> 0 > i1 >>> 0 ? i37 : i1;
      if (!i1) break;
      i2 = _malloc(i1) | 0;
      if (!i2) break;
      _memcpy(i2 | 0, HEAP32[i10 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
      i4 = HEAP32[i10 >> 2] | 0;
      if (i4 | 0) _free(i4);
      HEAP32[i10 >> 2] = i2;
      HEAP32[i33 >> 2] = i1;
      i4 = i2;
      i1 = HEAP32[i39 >> 2] | 0;
     }
     HEAP8[i4 + i1 >> 0] = i8;
     i37 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
     HEAP32[i39 >> 2] = i37;
     HEAP8[(HEAP32[i10 >> 2] | 0) + i37 >> 0] = 0;
    } while (0);
    if (!i5) {
     i4 = i6;
     continue;
    }
    if ((i6 | 0) != 117) {
     if ((i6 | 4 | 0) != 102) switch (i6 | 0) {
     case 34:
     case 47:
     case 92:
     case 110:
     case 114:
     case 116:
      break;
     default:
      {
       i38 = 101;
       break L42;
      }
     }
     i5 = _stream_get(i41, i40) | 0;
     if (i5 >>> 0 >= 4294967294) {
      i4 = i5;
      continue;
     }
     i6 = i5 & 255;
     i1 = HEAP32[i33 >> 2] | 0;
     i2 = HEAP32[i39 >> 2] | 0;
     if ((i1 - i2 | 0) >>> 0 > 1) {
      i4 = HEAP32[i10 >> 2] | 0;
      i1 = i2;
     } else {
      if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) {
       i4 = i5;
       continue;
      }
      i37 = i1 << 1;
      i1 = i2 + 2 | 0;
      i1 = i37 >>> 0 > i1 >>> 0 ? i37 : i1;
      if (!i1) {
       i4 = i5;
       continue;
      }
      i2 = _malloc(i1) | 0;
      if (!i2) {
       i4 = i5;
       continue;
      }
      _memcpy(i2 | 0, HEAP32[i10 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
      i4 = HEAP32[i10 >> 2] | 0;
      if (i4 | 0) _free(i4);
      HEAP32[i10 >> 2] = i2;
      HEAP32[i33 >> 2] = i1;
      i4 = i2;
      i1 = HEAP32[i39 >> 2] | 0;
     }
     HEAP8[i4 + i1 >> 0] = i6;
     i4 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
     HEAP32[i39 >> 2] = i4;
     HEAP8[(HEAP32[i10 >> 2] | 0) + i4 >> 0] = 0;
     i4 = i5;
     continue;
    }
    i2 = _stream_get(i41, i40) | 0;
    do if (i2 >>> 0 < 4294967294) {
     i6 = i2 & 255;
     i1 = HEAP32[i33 >> 2] | 0;
     i4 = HEAP32[i39 >> 2] | 0;
     if ((i1 - i4 | 0) >>> 0 > 1) {
      i5 = HEAP32[i10 >> 2] | 0;
      i1 = i4;
     } else {
      if ((i1 | 0) < 0 | i4 >>> 0 > 4294967293) {
       i1 = 0;
       break;
      }
      i37 = i1 << 1;
      i1 = i4 + 2 | 0;
      i1 = i37 >>> 0 > i1 >>> 0 ? i37 : i1;
      if (!i1) {
       i1 = 0;
       break;
      }
      i4 = _malloc(i1) | 0;
      if (!i4) {
       i1 = 0;
       break;
      }
      _memcpy(i4 | 0, HEAP32[i10 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
      i5 = HEAP32[i10 >> 2] | 0;
      if (i5 | 0) _free(i5);
      HEAP32[i10 >> 2] = i4;
      HEAP32[i33 >> 2] = i1;
      i5 = i4;
      i1 = HEAP32[i39 >> 2] | 0;
     }
     HEAP8[i5 + i1 >> 0] = i6;
     i1 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
     HEAP32[i39 >> 2] = i1;
     HEAP8[(HEAP32[i10 >> 2] | 0) + i1 >> 0] = 0;
     i1 = 0;
    } else i1 = 0; while (0);
    while (1) {
     if ((i2 + -48 | 0) >>> 0 >= 10) switch (i2 | 0) {
     case 65:
     case 66:
     case 67:
     case 68:
     case 69:
     case 70:
     case 97:
     case 98:
     case 99:
     case 100:
     case 101:
     case 102:
      break;
     default:
      {
       i38 = 77;
       break L42;
      }
     }
     i2 = _stream_get(i41, i40) | 0;
     do if (i2 >>> 0 < 4294967294) {
      i8 = i2 & 255;
      i4 = HEAP32[i33 >> 2] | 0;
      i5 = HEAP32[i39 >> 2] | 0;
      if ((i4 - i5 | 0) >>> 0 > 1) {
       i6 = HEAP32[i10 >> 2] | 0;
       i4 = i5;
      } else {
       if ((i4 | 0) < 0 | i5 >>> 0 > 4294967293) break;
       i37 = i4 << 1;
       i4 = i5 + 2 | 0;
       i4 = i37 >>> 0 > i4 >>> 0 ? i37 : i4;
       if (!i4) break;
       i5 = _malloc(i4) | 0;
       if (!i5) break;
       _memcpy(i5 | 0, HEAP32[i10 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
       i6 = HEAP32[i10 >> 2] | 0;
       if (i6 | 0) _free(i6);
       HEAP32[i10 >> 2] = i5;
       HEAP32[i33 >> 2] = i4;
       i6 = i5;
       i4 = HEAP32[i39 >> 2] | 0;
      }
      HEAP8[i6 + i4 >> 0] = i8;
      i37 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
      HEAP32[i39 >> 2] = i37;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i37 >> 0] = 0;
     } while (0);
     i1 = i1 + 1 | 0;
     if ((i1 | 0) >= 4) {
      i4 = i2;
      continue L42;
     }
    }
   }
   L107 : do if ((i38 | 0) == 33) _error_set(i40, i41, gb + 37788 | 0, i19); else if ((i38 | 0) == 35) {
    if ((i4 | 1 | 0) != -1) {
     i42 = i41 + 36 | 0;
     HEAP32[i42 >> 2] = (HEAP32[i42 >> 2] | 0) + -1;
     do if ((i4 | 0) == 10) {
      i42 = i41 + 24 | 0;
      HEAP32[i42 >> 2] = (HEAP32[i42 >> 2] | 0) + -1;
      HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
     } else {
      i1 = i4 & 255;
      if (i1 << 24 >> 24 <= -1) {
       if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) break;
       if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) break;
      }
      i42 = i41 + 28 | 0;
      HEAP32[i42 >> 2] = (HEAP32[i42 >> 2] | 0) + -1;
     } while (0);
     i1 = i41 + 16 | 0;
     i2 = HEAP32[i1 >> 2] | 0;
     if (!i2) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
     i42 = i2 + -1 | 0;
     HEAP32[i1 >> 2] = i42;
     if ((HEAP8[i41 + 8 + i42 >> 0] | 0) != (i4 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
    }
    i1 = HEAP32[i39 >> 2] | 0;
    if (!i1) i1 = 0; else {
     i42 = i1 + -1 | 0;
     HEAP32[i39 >> 2] = i42;
     i42 = (HEAP32[i10 >> 2] | 0) + i42 | 0;
     i1 = HEAP8[i42 >> 0] | 0;
     HEAP8[i42 >> 0] = 0;
    }
    if ((i1 << 24 >> 24 | 0) != (i4 | 0)) ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
    if ((i4 | 0) == 10) {
     HEAP32[i22 >> 2] = 10;
     _error_set(i40, i41, gb + 37911 | 0, i22);
     break;
    } else {
     HEAP32[i23 >> 2] = i4;
     _error_set(i40, i41, gb + 37930 | 0, i23);
     break;
    }
   } else if ((i38 | 0) == 77) _error_set(i40, i41, gb + 37953 | 0, i20); else if ((i38 | 0) == 101) _error_set(i40, i41, gb + 37953 | 0, i21); else if (((i38 | 0) == 102 ? (i18 = (HEAP32[i39 >> 2] | 0) + 1 | 0, i18 | 0) : 0) ? (i3 = _malloc(i18) | 0, i3 | 0) : 0) {
    HEAP32[i11 >> 2] = i3;
    i2 = (HEAP32[i10 >> 2] | 0) + 1 | 0;
    i1 = HEAP8[i2 >> 0] | 0;
    L111 : do if (i1 << 24 >> 24 != 34) {
     L112 : while (1) {
      i4 = i2 + 1 | 0;
      do if (i1 << 24 >> 24 == 92) {
       i1 = HEAP8[i4 >> 0] | 0;
       if (i1 << 24 >> 24 != 117) {
        switch (i1 << 24 >> 24 | 0) {
        case 47:
        case 92:
        case 34:
         {
          HEAP8[i3 >> 0] = i1;
          break;
         }
        case 98:
         {
          HEAP8[i3 >> 0] = 8;
          break;
         }
        case 102:
         {
          HEAP8[i3 >> 0] = 12;
          break;
         }
        case 110:
         {
          HEAP8[i3 >> 0] = 10;
          break;
         }
        case 114:
         {
          HEAP8[i3 >> 0] = 13;
          break;
         }
        case 116:
         {
          HEAP8[i3 >> 0] = 9;
          break;
         }
        default:
         {
          i38 = 136;
          break L112;
         }
        }
        i2 = i2 + 2 | 0;
        break;
       }
       i1 = _decode_unicode_escape(i4) | 0;
       if ((i1 | 0) < 0) {
        i38 = 108;
        break L112;
       }
       i5 = i2 + 6 | 0;
       switch (i1 & -1024 | 0) {
       case 56320:
        {
         i38 = 117;
         break L112;
        }
       case 55296:
        {
         if ((HEAP8[i5 >> 0] | 0) != 92) {
          i38 = 116;
          break L112;
         }
         i4 = i2 + 7 | 0;
         if ((HEAP8[i4 >> 0] | 0) != 117) {
          i38 = 116;
          break L112;
         }
         i4 = _decode_unicode_escape(i4) | 0;
         if ((i4 | 0) < 0) {
          i38 = 113;
          break L112;
         }
         if ((i4 & -1024 | 0) != 56320) {
          i38 = 115;
          break L112;
         }
         i1 = (i1 << 10) + -56613888 + i4 | 0;
         if ((i1 | 0) < 0) {
          i38 = 127;
          break L112;
         } else i2 = i2 + 12 | 0;
         break;
        }
       default:
        i2 = i5;
       }
       do if ((i1 | 0) < 128) {
        HEAP8[i3 >> 0] = i1;
        i1 = 1;
       } else {
        if ((i1 | 0) < 2048) {
         HEAP8[i3 >> 0] = i1 >>> 6 & 31 | 192;
         HEAP8[i3 + 1 >> 0] = i1 & 63 | 128;
         i1 = 2;
         break;
        }
        if ((i1 | 0) < 65536) {
         HEAP8[i3 >> 0] = i1 >>> 12 & 15 | 224;
         HEAP8[i3 + 1 >> 0] = i1 >>> 6 & 63 | 128;
         HEAP8[i3 + 2 >> 0] = i1 & 63 | 128;
         i1 = 3;
         break;
        }
        if ((i1 | 0) >= 1114112) {
         i38 = 127;
         break L112;
        }
        HEAP8[i3 >> 0] = i1 >>> 18 & 7 | 240;
        HEAP8[i3 + 1 >> 0] = i1 >>> 12 & 63 | 128;
        HEAP8[i3 + 2 >> 0] = i1 >>> 6 & 63 | 128;
        HEAP8[i3 + 3 >> 0] = i1 & 63 | 128;
        i1 = 4;
       } while (0);
       i3 = i3 + i1 | 0;
       i1 = HEAP8[i2 >> 0] | 0;
       if (i1 << 24 >> 24 == 34) {
        i24 = i3;
        break L111;
       } else continue L112;
      } else {
       HEAP8[i3 >> 0] = i1;
       i2 = i4;
      } while (0);
      i3 = i3 + 1 | 0;
      i1 = HEAP8[i2 >> 0] | 0;
      if (i1 << 24 >> 24 == 34) {
       i24 = i3;
       break L111;
      }
     }
     if ((i38 | 0) == 108) {
      HEAP32[i25 >> 2] = i2;
      _error_set(i40, i41, gb + 38004 | 0, i25);
      break L107;
     } else if ((i38 | 0) == 113) {
      HEAP32[i26 >> 2] = i5;
      _error_set(i40, i41, gb + 38004 | 0, i26);
      break L107;
     } else if ((i38 | 0) == 115) {
      HEAP32[i27 >> 2] = i1;
      HEAP32[i27 + 4 >> 2] = i4;
      _error_set(i40, i41, gb + 38034 | 0, i27);
      break L107;
     } else if ((i38 | 0) == 116) {
      HEAP32[i28 >> 2] = i1;
      _error_set(i40, i41, gb + 38065 | 0, i28);
      break L107;
     } else if ((i38 | 0) == 117) {
      HEAP32[i29 >> 2] = i1;
      _error_set(i40, i41, gb + 38065 | 0, i29);
      break L107;
     } else if ((i38 | 0) == 127) ___assert_fail(gb + 41240 | 0, gb + 37743 | 0, 441, gb + 38090 | 0); else if ((i38 | 0) == 136) ___assert_fail(gb + 41240 | 0, gb + 37743 | 0, 453, gb + 38090 | 0);
    } else i24 = i3; while (0);
    HEAP8[i24 >> 0] = 0;
    HEAP32[i11 + 4 >> 2] = i24 - (HEAP32[i11 >> 2] | 0);
    HEAP32[i42 >> 2] = 256;
    STACKTOP = i43;
    return;
   } while (0);
   i1 = HEAP32[i11 >> 2] | 0;
   if (i1 | 0) _free(i1);
   HEAP32[i11 >> 2] = 0;
   HEAP32[i11 + 4 >> 2] = 0;
   STACKTOP = i43;
   return;
  }
  i3 = (i1 | 0) == 45;
  if (!(i3 | (i1 + -48 | 0) >>> 0 < 10)) {
   if (((i1 & -33) + -65 | 0) >>> 0 >= 26) {
    i6 = i41 + 16 | 0;
    i1 = HEAP8[(HEAP32[i6 >> 2] | 0) + (i41 + 8) >> 0] | 0;
    if (i1 << 24 >> 24) {
     i5 = i41 + 40 | 0;
     i8 = i41 + 36 | 0;
     do {
      i2 = HEAP32[i33 >> 2] | 0;
      i3 = HEAP32[i39 >> 2] | 0;
      if ((i2 - i3 | 0) >>> 0 <= 1) {
       if ((!((i2 | 0) < 0 | i3 >>> 0 > 4294967293) ? (i40 = i2 << 1, i11 = i3 + 2 | 0, i11 = i40 >>> 0 > i11 >>> 0 ? i40 : i11, i11 | 0) : 0) ? (i14 = _malloc(i11) | 0, i14 | 0) : 0) {
        _memcpy(i14 | 0, HEAP32[i5 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
        i2 = HEAP32[i5 >> 2] | 0;
        if (i2 | 0) _free(i2);
        HEAP32[i5 >> 2] = i14;
        HEAP32[i33 >> 2] = i11;
        i4 = i14;
        i2 = HEAP32[i39 >> 2] | 0;
        i38 = 735;
       }
      } else {
       i4 = HEAP32[i5 >> 2] | 0;
       i2 = i3;
       i38 = 735;
      }
      if ((i38 | 0) == 735) {
       i38 = 0;
       HEAP8[i4 + i2 >> 0] = i1;
       i40 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
       HEAP32[i39 >> 2] = i40;
       HEAP8[(HEAP32[i5 >> 2] | 0) + i40 >> 0] = 0;
      }
      i1 = (HEAP32[i6 >> 2] | 0) + 1 | 0;
      HEAP32[i6 >> 2] = i1;
      HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + 1;
      i1 = HEAP8[i41 + 8 + i1 >> 0] | 0;
     } while (i1 << 24 >> 24 != 0);
    }
    HEAP32[i42 >> 2] = -1;
    STACKTOP = i43;
    return;
   }
   do {
    i6 = _stream_get(i41, i40) | 0;
    i4 = i6 >>> 0 < 4294967294;
    do if (i4) {
     i5 = i6 & 255;
     i1 = HEAP32[i33 >> 2] | 0;
     i2 = HEAP32[i39 >> 2] | 0;
     if ((i1 - i2 | 0) >>> 0 > 1) {
      i3 = HEAP32[i37 >> 2] | 0;
      i1 = i2;
     } else {
      if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) break;
      i36 = i1 << 1;
      i1 = i2 + 2 | 0;
      i1 = i36 >>> 0 > i1 >>> 0 ? i36 : i1;
      if (!i1) break;
      i2 = _malloc(i1) | 0;
      if (!i2) break;
      _memcpy(i2 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
      i3 = HEAP32[i37 >> 2] | 0;
      if (i3 | 0) _free(i3);
      HEAP32[i37 >> 2] = i2;
      HEAP32[i33 >> 2] = i1;
      i3 = i2;
      i1 = HEAP32[i39 >> 2] | 0;
     }
     HEAP8[i3 + i1 >> 0] = i5;
     i36 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
     HEAP32[i39 >> 2] = i36;
     HEAP8[(HEAP32[i37 >> 2] | 0) + i36 >> 0] = 0;
    } while (0);
   } while (((i6 & -33) + -65 | 0) >>> 0 < 26);
   if (i4) {
    if ((i6 | 1 | 0) != -1) {
     i40 = i41 + 36 | 0;
     HEAP32[i40 >> 2] = (HEAP32[i40 >> 2] | 0) + -1;
     do if ((i6 | 0) == 10) {
      i40 = i41 + 24 | 0;
      HEAP32[i40 >> 2] = (HEAP32[i40 >> 2] | 0) + -1;
      HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
     } else {
      i1 = i6 & 255;
      if (i1 << 24 >> 24 <= -1) {
       if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) break;
       if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) break;
      }
      i40 = i41 + 28 | 0;
      HEAP32[i40 >> 2] = (HEAP32[i40 >> 2] | 0) + -1;
     } while (0);
     i1 = i41 + 16 | 0;
     i2 = HEAP32[i1 >> 2] | 0;
     if (!i2) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
     i40 = i2 + -1 | 0;
     HEAP32[i1 >> 2] = i40;
     if ((HEAP8[i41 + 8 + i40 >> 0] | 0) != (i6 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
    }
    i1 = HEAP32[i39 >> 2] | 0;
    if (!i1) i1 = 0; else {
     i1 = i1 + -1 | 0;
     HEAP32[i39 >> 2] = i1;
     i41 = (HEAP32[i41 + 40 >> 2] | 0) + i1 | 0;
     i1 = HEAP8[i41 >> 0] | 0;
     HEAP8[i41 >> 0] = 0;
    }
    if ((i1 << 24 >> 24 | 0) != (i6 | 0)) ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
   }
   i1 = HEAP32[i37 >> 2] | 0;
   i4 = HEAP8[i1 >> 0] | 0;
   L253 : do switch (i4 << 24 >> 24) {
   case 116:
    {
     i2 = gb + 38227 | 0;
     do {
      i1 = i1 + 1 | 0;
      i2 = i2 + 1 | 0;
      i3 = HEAP8[i1 >> 0] | 0;
      i4 = HEAP8[i2 >> 0] | 0;
     } while (!(i3 << 24 >> 24 == 0 ? 1 : i3 << 24 >> 24 != i4 << 24 >> 24));
     if (i3 << 24 >> 24 == i4 << 24 >> 24) {
      HEAP32[i42 >> 2] = 259;
      STACKTOP = i43;
      return;
     }
     break;
    }
   case 102:
    {
     i2 = i1;
     i3 = gb + 38232 | 0;
     do {
      i2 = i2 + 1 | 0;
      i3 = i3 + 1 | 0;
      i5 = HEAP8[i2 >> 0] | 0;
      i6 = HEAP8[i3 >> 0] | 0;
     } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
     if (i5 << 24 >> 24 != i6 << 24 >> 24) if (i4 << 24 >> 24 == 110) {
      i3 = i1;
      i4 = gb + 38238 | 0;
      i38 = 721;
      break L253;
     } else break L253;
     HEAP32[i42 >> 2] = 260;
     STACKTOP = i43;
     return;
    }
   case 110:
    {
     i3 = i1;
     i4 = gb + 38238 | 0;
     i38 = 721;
     break;
    }
   default:
    {}
   } while (0);
   if ((i38 | 0) == 721) {
    while (1) {
     i3 = i3 + 1 | 0;
     i4 = i4 + 1 | 0;
     i1 = HEAP8[i3 >> 0] | 0;
     i2 = HEAP8[i4 >> 0] | 0;
     if (i1 << 24 >> 24 == 0 ? 1 : i1 << 24 >> 24 != i2 << 24 >> 24) break; else i38 = 721;
    }
    if (i1 << 24 >> 24 == i2 << 24 >> 24) {
     HEAP32[i42 >> 2] = 261;
     STACKTOP = i43;
     return;
    }
   }
   HEAP32[i42 >> 2] = -1;
   STACKTOP = i43;
   return;
  }
  HEAP32[i42 >> 2] = -1;
  do if (i3) {
   i1 = _stream_get(i41, i40) | 0;
   if (i1 >>> 0 < 4294967294) {
    i6 = i1 & 255;
    i3 = HEAP32[i33 >> 2] | 0;
    i4 = HEAP32[i39 >> 2] | 0;
    if ((i3 - i4 | 0) >>> 0 > 1) {
     i5 = HEAP32[i37 >> 2] | 0;
     i3 = i4;
    } else {
     if ((i3 | 0) < 0 | i4 >>> 0 > 4294967293) {
      i38 = 156;
      break;
     }
     i38 = i3 << 1;
     i3 = i4 + 2 | 0;
     i3 = i38 >>> 0 > i3 >>> 0 ? i38 : i3;
     if (!i3) {
      i38 = 156;
      break;
     }
     i4 = _malloc(i3) | 0;
     if (!i4) {
      i38 = 156;
      break;
     }
     _memcpy(i4 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
     i5 = HEAP32[i37 >> 2] | 0;
     if (i5 | 0) _free(i5);
     HEAP32[i37 >> 2] = i4;
     HEAP32[i33 >> 2] = i3;
     i5 = i4;
     i3 = HEAP32[i39 >> 2] | 0;
    }
    HEAP8[i5 + i3 >> 0] = i6;
    i38 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
    HEAP32[i39 >> 2] = i38;
    HEAP8[(HEAP32[i37 >> 2] | 0) + i38 >> 0] = 0;
    i38 = 156;
   } else i38 = 181;
  } else i38 = 156; while (0);
  if ((i38 | 0) == 156) if ((i1 | 0) == 48) {
   i6 = _stream_get(i41, i40) | 0;
   do if (i6 >>> 0 < 4294967294) {
    i5 = i6 & 255;
    i1 = HEAP32[i33 >> 2] | 0;
    i3 = HEAP32[i39 >> 2] | 0;
    if ((i1 - i3 | 0) >>> 0 > 1) {
     i4 = HEAP32[i37 >> 2] | 0;
     i1 = i3;
    } else {
     if ((i1 | 0) < 0 | i3 >>> 0 > 4294967293) break;
     i29 = i1 << 1;
     i1 = i3 + 2 | 0;
     i1 = i29 >>> 0 > i1 >>> 0 ? i29 : i1;
     if (!i1) break;
     i3 = _malloc(i1) | 0;
     if (!i3) break;
     _memcpy(i3 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
     i4 = HEAP32[i37 >> 2] | 0;
     if (i4 | 0) _free(i4);
     HEAP32[i37 >> 2] = i3;
     HEAP32[i33 >> 2] = i1;
     i4 = i3;
     i1 = HEAP32[i39 >> 2] | 0;
    }
    HEAP8[i4 + i1 >> 0] = i5;
    i29 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
    HEAP32[i39 >> 2] = i29;
    HEAP8[(HEAP32[i37 >> 2] | 0) + i29 >> 0] = 0;
   } while (0);
   if ((i6 + -48 | 0) >>> 0 < 10) {
    if ((i6 | 1 | 0) != -1) {
     i1 = i41 + 36 | 0;
     HEAP32[i1 >> 2] = (HEAP32[i1 >> 2] | 0) + -1;
     i1 = i6 & 255;
     if (i1 << 24 >> 24 <= -1) {
      if (!((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) ? (i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32) : 0) i38 = 172;
     } else i38 = 172;
     if ((i38 | 0) == 172) {
      i29 = i41 + 28 | 0;
      HEAP32[i29 >> 2] = (HEAP32[i29 >> 2] | 0) + -1;
     }
     i1 = i41 + 16 | 0;
     i3 = HEAP32[i1 >> 2] | 0;
     if (!i3) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
     i29 = i3 + -1 | 0;
     HEAP32[i1 >> 2] = i29;
     if ((HEAP8[i41 + 8 + i29 >> 0] | 0) != (i6 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
    }
    i1 = HEAP32[i39 >> 2] | 0;
    if (!i1) i1 = 0; else {
     i29 = i1 + -1 | 0;
     HEAP32[i39 >> 2] = i29;
     i29 = (HEAP32[i41 + 40 >> 2] | 0) + i29 | 0;
     i1 = HEAP8[i29 >> 0] | 0;
     HEAP8[i29 >> 0] = 0;
    }
    if ((i1 << 24 >> 24 | 0) == (i6 | 0)) {
     STACKTOP = i43;
     return;
    } else ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
   } else i15 = i6;
  } else i38 = 181;
  L324 : do if ((i38 | 0) == 181) {
   if ((i1 + -48 | 0) >>> 0 < 10) {
    i5 = i41 + 40 | 0;
    while (1) {
     i6 = _stream_get(i41, i40) | 0;
     do if (i6 >>> 0 < 4294967294) {
      i8 = i6 & 255;
      i1 = HEAP32[i33 >> 2] | 0;
      i3 = HEAP32[i39 >> 2] | 0;
      if ((i1 - i3 | 0) >>> 0 > 1) {
       i4 = HEAP32[i5 >> 2] | 0;
       i1 = i3;
      } else {
       if ((i1 | 0) < 0 | i3 >>> 0 > 4294967293) break;
       i29 = i1 << 1;
       i1 = i3 + 2 | 0;
       i1 = i29 >>> 0 > i1 >>> 0 ? i29 : i1;
       if (!i1) break;
       i3 = _malloc(i1) | 0;
       if (!i3) break;
       _memcpy(i3 | 0, HEAP32[i5 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
       i4 = HEAP32[i5 >> 2] | 0;
       if (i4 | 0) _free(i4);
       HEAP32[i5 >> 2] = i3;
       HEAP32[i33 >> 2] = i1;
       i4 = i3;
       i1 = HEAP32[i39 >> 2] | 0;
      }
      HEAP8[i4 + i1 >> 0] = i8;
      i29 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
      HEAP32[i39 >> 2] = i29;
      HEAP8[(HEAP32[i5 >> 2] | 0) + i29 >> 0] = 0;
     } while (0);
     if ((i6 + -48 | 0) >>> 0 >= 10) {
      i15 = i6;
      break L324;
     }
    }
   }
   if (i1 >>> 0 >= 4294967294) {
    STACKTOP = i43;
    return;
   }
   if ((i1 | 1 | 0) != -1) {
    i29 = i41 + 36 | 0;
    HEAP32[i29 >> 2] = (HEAP32[i29 >> 2] | 0) + -1;
    do if ((i1 | 0) == 10) {
     i29 = i41 + 24 | 0;
     HEAP32[i29 >> 2] = (HEAP32[i29 >> 2] | 0) + -1;
     HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
    } else {
     i3 = i1 & 255;
     if (i3 << 24 >> 24 <= -1) {
      if ((i3 & 255) < 192 | (i3 & -2) << 24 >> 24 == -64) break;
      if (!((i3 + 16 & 255) < 5 | ((i3 + 62 & 255) < 30 | (i3 & -16) << 24 >> 24 == -32))) break;
     }
     i29 = i41 + 28 | 0;
     HEAP32[i29 >> 2] = (HEAP32[i29 >> 2] | 0) + -1;
    } while (0);
    i3 = i41 + 16 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (!i4) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
    i29 = i4 + -1 | 0;
    HEAP32[i3 >> 2] = i29;
    if ((HEAP8[i41 + 8 + i29 >> 0] | 0) != (i1 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
   }
   i3 = HEAP32[i39 >> 2] | 0;
   if (!i3) i3 = 0; else {
    i29 = i3 + -1 | 0;
    HEAP32[i39 >> 2] = i29;
    i29 = (HEAP32[i41 + 40 >> 2] | 0) + i29 | 0;
    i3 = HEAP8[i29 >> 0] | 0;
    HEAP8[i29 >> 0] = 0;
   }
   if ((i3 << 24 >> 24 | 0) == (i1 | 0)) {
    STACKTOP = i43;
    return;
   } else ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
  } while (0);
  L369 : do if (!(HEAP32[i41 + 52 >> 2] & 8)) {
   switch (i15 | 0) {
   case 46:
    {
     i38 = 288;
     break L369;
    }
   case 101:
   case 69:
    {
     i1 = i15;
     break L369;
    }
   default:
    {}
   }
   if (i15 >>> 0 < 4294967294) {
    if ((i15 | 1 | 0) != -1) {
     i38 = i41 + 36 | 0;
     HEAP32[i38 >> 2] = (HEAP32[i38 >> 2] | 0) + -1;
     do if ((i15 | 0) == 10) {
      i38 = i41 + 24 | 0;
      HEAP32[i38 >> 2] = (HEAP32[i38 >> 2] | 0) + -1;
      HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
     } else {
      i1 = i15 & 255;
      if (i1 << 24 >> 24 <= -1) {
       if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) break;
       if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) break;
      }
      i38 = i41 + 28 | 0;
      HEAP32[i38 >> 2] = (HEAP32[i38 >> 2] | 0) + -1;
     } while (0);
     i1 = i41 + 16 | 0;
     i2 = HEAP32[i1 >> 2] | 0;
     if (!i2) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
     i38 = i2 + -1 | 0;
     HEAP32[i1 >> 2] = i38;
     if ((HEAP8[i41 + 8 + i38 >> 0] | 0) != (i15 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
    }
    i1 = HEAP32[i39 >> 2] | 0;
    if (!i1) i1 = 0; else {
     i38 = i1 + -1 | 0;
     HEAP32[i39 >> 2] = i38;
     i38 = (HEAP32[i41 + 40 >> 2] | 0) + i38 | 0;
     i1 = HEAP8[i38 >> 0] | 0;
     HEAP8[i38 >> 0] = 0;
    }
    if ((i1 << 24 >> 24 | 0) != (i15 | 0)) ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
   }
   i1 = HEAP32[i41 + 40 >> 2] | 0;
   if (!(HEAP32[gb + 41360 >> 2] | 0)) i14 = gb + 41404 | 0; else i14 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
   HEAP32[i14 >> 2] = 0;
   HEAP32[i35 >> 2] = 0;
   i15 = i35 + 4 | 0;
   HEAP32[i15 >> 2] = i1;
   HEAP32[i35 + 44 >> 2] = i1;
   i2 = (i1 | 0) < 0 ? -1 : i1 + 2147483647 | 0;
   i17 = i35 + 8 | 0;
   HEAP32[i17 >> 2] = i2;
   HEAP32[i35 + 76 >> 2] = -1;
   i3 = i35 + 104 | 0;
   HEAP32[i3 >> 2] = 0;
   i38 = i2;
   i18 = i35 + 108 | 0;
   HEAP32[i18 >> 2] = i38 - i1;
   i11 = i35 + 100 | 0;
   HEAP32[i11 >> 2] = i38;
   L397 : while (1) {
    if (i1 >>> 0 < i2 >>> 0) {
     HEAP32[i15 >> 2] = i1 + 1;
     i1 = HEAPU8[i1 >> 0] | 0;
    } else i1 = ___shgetc(i35) | 0;
    switch (i1 | 0) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
     break;
    default:
     break L397;
    }
    i1 = HEAP32[i15 >> 2] | 0;
    i2 = HEAP32[i11 >> 2] | 0;
   }
   L405 : do switch (i1 | 0) {
   case 43:
   case 45:
    {
     i2 = ((i1 | 0) == 45) << 31 >> 31;
     i1 = HEAP32[i15 >> 2] | 0;
     if (i1 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0) {
      HEAP32[i15 >> 2] = i1 + 1;
      i1 = HEAPU8[i1 >> 0] | 0;
      i10 = i2;
      break L405;
     } else {
      i1 = ___shgetc(i35) | 0;
      i10 = i2;
      break L405;
     }
    }
   default:
    i10 = 0;
   } while (0);
   do if ((HEAPU8[gb + 38543 + 1 + i1 >> 0] | 0) < 10) {
    i2 = i1 + -48 | 0;
    if (i2 >>> 0 < 10) {
     i3 = 0;
     do {
      i3 = (i3 * 10 | 0) + i2 | 0;
      i1 = HEAP32[i15 >> 2] | 0;
      if (i1 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0) {
       HEAP32[i15 >> 2] = i1 + 1;
       i1 = HEAPU8[i1 >> 0] | 0;
      } else i1 = ___shgetc(i35) | 0;
      i2 = i1 + -48 | 0;
     } while (i3 >>> 0 < 429496729 & i2 >>> 0 < 10);
     i2 = 0;
    } else {
     i3 = 0;
     i2 = 0;
    }
    i4 = i1 + -48 | 0;
    if (i4 >>> 0 < 10) {
     do {
      i5 = ___muldi3(i3 | 0, i2 | 0, 10, 0) | 0;
      i6 = getTempRet0() | 0;
      i8 = ((i4 | 0) < 0) << 31 >> 31;
      i38 = ~i8;
      if (i6 >>> 0 > i38 >>> 0 | (i6 | 0) == (i38 | 0) & i5 >>> 0 > ~i4 >>> 0) break;
      i3 = _i64Add(i5 | 0, i6 | 0, i4 | 0, i8 | 0) | 0;
      i2 = getTempRet0() | 0;
      i1 = HEAP32[i15 >> 2] | 0;
      if (i1 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0) {
       HEAP32[i15 >> 2] = i1 + 1;
       i1 = HEAPU8[i1 >> 0] | 0;
      } else i1 = ___shgetc(i35) | 0;
      i4 = i1 + -48 | 0;
     } while ((i2 >>> 0 < 429496729 | (i2 | 0) == 429496729 & i3 >>> 0 < 2576980378) & i4 >>> 0 < 10);
     if (i4 >>> 0 <= 9 ? (HEAPU8[gb + 38543 + 1 + i1 >> 0] | 0) < 10 : 0) {
      do {
       i1 = HEAP32[i15 >> 2] | 0;
       if (i1 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0) {
        HEAP32[i15 >> 2] = i1 + 1;
        i1 = HEAPU8[i1 >> 0] | 0;
       } else i1 = ___shgetc(i35) | 0;
      } while ((HEAPU8[gb + 38543 + 1 + i1 >> 0] | 0) < 10);
      if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
      HEAP32[i1 >> 2] = 34;
      i2 = -2147483648;
      i1 = 0;
     } else i1 = i3;
    } else i1 = i3;
    if (HEAP32[i11 >> 2] | 0) HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + -1;
    if (!((i2 | 0) > -1 | (i2 | 0) == -1 & i1 >>> 0 > 4294967295)) {
     if (!i10) {
      if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
      HEAP32[i1 >> 2] = 34;
      i1 = 2147483647;
      i2 = -1;
      break;
     }
     if (i2 >>> 0 > 2147483648 | (i2 | 0) == -2147483648 & i1 >>> 0 > 0) {
      if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
      HEAP32[i1 >> 2] = 34;
      i1 = -2147483648;
      i2 = 0;
      break;
     }
    }
    i38 = ((i10 | 0) < 0) << 31 >> 31;
    i2 = _i64Subtract(i1 ^ i10 | 0, i2 ^ i38 | 0, i10 | 0, i38 | 0) | 0;
    i1 = getTempRet0() | 0;
   } else {
    if (!(HEAP32[i11 >> 2] | 0)) i1 = HEAP32[i15 >> 2] | 0; else {
     i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
     HEAP32[i15 >> 2] = i1;
    }
    HEAP32[i3 >> 2] = 0;
    i38 = HEAP32[i17 >> 2] | 0;
    HEAP32[i18 >> 2] = i38 - i1;
    HEAP32[i11 >> 2] = i38;
    if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
    HEAP32[i1 >> 2] = 22;
    i1 = 0;
    i2 = 0;
   } while (0);
   if ((HEAP32[i14 >> 2] | 0) != 34) {
    if (((HEAP32[i15 >> 2] | 0) + (HEAP32[i18 >> 2] | 0) - (HEAP32[i17 >> 2] | 0) | 0) != (HEAP32[i39 >> 2] | 0)) ___assert_fail(gb + 38147 | 0, gb + 37743 | 0, 530, gb + 38190 | 0);
    HEAP32[i42 >> 2] = 257;
    i42 = i41 + 64 | 0;
    HEAP32[i42 >> 2] = i2;
    HEAP32[i42 + 4 >> 2] = i1;
    STACKTOP = i43;
    return;
   }
   if ((i1 | 0) < 0) {
    _error_set(i40, i41, gb + 38106 | 0, i31);
    STACKTOP = i43;
    return;
   } else {
    _error_set(i40, i41, gb + 38131 | 0, i32);
    STACKTOP = i43;
    return;
   }
  } else if ((i15 | 0) == 46) i38 = 288; else i1 = i15; while (0);
  if ((i38 | 0) == 288) {
   i4 = _stream_get(i41, i40) | 0;
   if ((i4 + -48 | 0) >>> 0 >= 10) {
    if ((i4 | 1 | 0) == -1) {
     STACKTOP = i43;
     return;
    }
    i32 = i41 + 36 | 0;
    HEAP32[i32 >> 2] = (HEAP32[i32 >> 2] | 0) + -1;
    do if ((i4 | 0) == 10) {
     i32 = i41 + 24 | 0;
     HEAP32[i32 >> 2] = (HEAP32[i32 >> 2] | 0) + -1;
     HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
    } else {
     i1 = i4 & 255;
     if (i1 << 24 >> 24 <= -1) {
      if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) break;
      if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) break;
     }
     i32 = i41 + 28 | 0;
     HEAP32[i32 >> 2] = (HEAP32[i32 >> 2] | 0) + -1;
    } while (0);
    i1 = i41 + 16 | 0;
    i3 = HEAP32[i1 >> 2] | 0;
    if (!i3) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
    i32 = i3 + -1 | 0;
    HEAP32[i1 >> 2] = i32;
    if ((HEAP8[i41 + 8 + i32 >> 0] | 0) == (i4 | 0)) {
     STACKTOP = i43;
     return;
    } else ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
   }
   i4 = i4 & 255;
   i3 = HEAP32[i33 >> 2] | 0;
   i1 = HEAP32[i39 >> 2] | 0;
   if ((i3 - i1 | 0) >>> 0 <= 1) {
    if ((!((i3 | 0) < 0 | i1 >>> 0 > 4294967293) ? (i32 = i3 << 1, i17 = i1 + 2 | 0, i17 = i32 >>> 0 > i17 >>> 0 ? i32 : i17, i17 | 0) : 0) ? (i2 = _malloc(i17) | 0, i2 | 0) : 0) {
     _memcpy(i2 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
     i1 = HEAP32[i37 >> 2] | 0;
     if (i1 | 0) _free(i1);
     HEAP32[i37 >> 2] = i2;
     HEAP32[i33 >> 2] = i17;
     i1 = HEAP32[i39 >> 2] | 0;
     i38 = 308;
    }
   } else {
    i2 = HEAP32[i37 >> 2] | 0;
    i38 = 308;
   }
   if ((i38 | 0) == 308) {
    HEAP8[i2 + i1 >> 0] = i4;
    i32 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
    HEAP32[i39 >> 2] = i32;
    HEAP8[(HEAP32[i37 >> 2] | 0) + i32 >> 0] = 0;
   }
   do {
    i1 = _stream_get(i41, i40) | 0;
    do if (i1 >>> 0 < 4294967294) {
     i5 = i1 & 255;
     i2 = HEAP32[i33 >> 2] | 0;
     i3 = HEAP32[i39 >> 2] | 0;
     if ((i2 - i3 | 0) >>> 0 > 1) {
      i4 = HEAP32[i37 >> 2] | 0;
      i2 = i3;
     } else {
      if ((i2 | 0) < 0 | i3 >>> 0 > 4294967293) break;
      i32 = i2 << 1;
      i2 = i3 + 2 | 0;
      i2 = i32 >>> 0 > i2 >>> 0 ? i32 : i2;
      if (!i2) break;
      i3 = _malloc(i2) | 0;
      if (!i3) break;
      _memcpy(i3 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
      i4 = HEAP32[i37 >> 2] | 0;
      if (i4 | 0) _free(i4);
      HEAP32[i37 >> 2] = i3;
      HEAP32[i33 >> 2] = i2;
      i4 = i3;
      i2 = HEAP32[i39 >> 2] | 0;
     }
     HEAP8[i4 + i2 >> 0] = i5;
     i32 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
     HEAP32[i39 >> 2] = i32;
     HEAP8[(HEAP32[i37 >> 2] | 0) + i32 >> 0] = 0;
    } while (0);
   } while ((i1 + -48 | 0) >>> 0 < 10);
  }
  L530 : do if ((i1 | 32 | 0) == 101) {
   i4 = _stream_get(i41, i40) | 0;
   do if (i4 >>> 0 < 4294967294) {
    i5 = i4 & 255;
    i1 = HEAP32[i33 >> 2] | 0;
    i2 = HEAP32[i39 >> 2] | 0;
    if ((i1 - i2 | 0) >>> 0 > 1) {
     i3 = HEAP32[i37 >> 2] | 0;
     i1 = i2;
    } else {
     if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) break;
     i32 = i1 << 1;
     i1 = i2 + 2 | 0;
     i1 = i32 >>> 0 > i1 >>> 0 ? i32 : i1;
     if (!i1) break;
     i2 = _malloc(i1) | 0;
     if (!i2) break;
     _memcpy(i2 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
     i3 = HEAP32[i37 >> 2] | 0;
     if (i3 | 0) _free(i3);
     HEAP32[i37 >> 2] = i2;
     HEAP32[i33 >> 2] = i1;
     i3 = i2;
     i1 = HEAP32[i39 >> 2] | 0;
    }
    HEAP8[i3 + i1 >> 0] = i5;
    i32 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
    HEAP32[i39 >> 2] = i32;
    HEAP8[(HEAP32[i37 >> 2] | 0) + i32 >> 0] = 0;
   } while (0);
   L545 : do switch (i4 | 0) {
   case 43:
   case 45:
    {
     i4 = _stream_get(i41, i40) | 0;
     if (i4 >>> 0 < 4294967294) {
      i5 = i4 & 255;
      i1 = HEAP32[i33 >> 2] | 0;
      i2 = HEAP32[i39 >> 2] | 0;
      if ((i1 - i2 | 0) >>> 0 > 1) {
       i3 = HEAP32[i37 >> 2] | 0;
       i1 = i2;
      } else {
       if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) {
        i3 = i4;
        break L545;
       }
       i32 = i1 << 1;
       i1 = i2 + 2 | 0;
       i1 = i32 >>> 0 > i1 >>> 0 ? i32 : i1;
       if (!i1) {
        i3 = i4;
        break L545;
       }
       i2 = _malloc(i1) | 0;
       if (!i2) {
        i3 = i4;
        break L545;
       }
       _memcpy(i2 | 0, HEAP32[i37 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
       i3 = HEAP32[i37 >> 2] | 0;
       if (i3 | 0) _free(i3);
       HEAP32[i37 >> 2] = i2;
       HEAP32[i33 >> 2] = i1;
       i3 = i2;
       i1 = HEAP32[i39 >> 2] | 0;
      }
      HEAP8[i3 + i1 >> 0] = i5;
      i3 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
      HEAP32[i39 >> 2] = i3;
      HEAP8[(HEAP32[i37 >> 2] | 0) + i3 >> 0] = 0;
      i3 = i4;
     } else i3 = i4;
     break;
    }
   default:
    i3 = i4;
   } while (0);
   if ((i3 + -48 | 0) >>> 0 < 10) {
    i4 = i41 + 40 | 0;
    while (1) {
     i5 = _stream_get(i41, i40) | 0;
     do if (i5 >>> 0 < 4294967294) {
      i6 = i5 & 255;
      i1 = HEAP32[i33 >> 2] | 0;
      i2 = HEAP32[i39 >> 2] | 0;
      if ((i1 - i2 | 0) >>> 0 > 1) {
       i3 = HEAP32[i4 >> 2] | 0;
       i1 = i2;
      } else {
       if ((i1 | 0) < 0 | i2 >>> 0 > 4294967293) break;
       i32 = i1 << 1;
       i1 = i2 + 2 | 0;
       i1 = i32 >>> 0 > i1 >>> 0 ? i32 : i1;
       if (!i1) break;
       i2 = _malloc(i1) | 0;
       if (!i2) break;
       _memcpy(i2 | 0, HEAP32[i4 >> 2] | 0, HEAP32[i39 >> 2] | 0) | 0;
       i3 = HEAP32[i4 >> 2] | 0;
       if (i3 | 0) _free(i3);
       HEAP32[i4 >> 2] = i2;
       HEAP32[i33 >> 2] = i1;
       i3 = i2;
       i1 = HEAP32[i39 >> 2] | 0;
      }
      HEAP8[i3 + i1 >> 0] = i6;
      i32 = (HEAP32[i39 >> 2] | 0) + 1 | 0;
      HEAP32[i39 >> 2] = i32;
      HEAP8[(HEAP32[i4 >> 2] | 0) + i32 >> 0] = 0;
     } while (0);
     if ((i5 + -48 | 0) >>> 0 >= 10) {
      i30 = i5;
      break L530;
     }
    }
   }
   if (i3 >>> 0 >= 4294967294) {
    STACKTOP = i43;
    return;
   }
   if ((i3 | 1 | 0) != -1) {
    i33 = i41 + 36 | 0;
    HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + -1;
    do if ((i3 | 0) == 10) {
     i33 = i41 + 24 | 0;
     HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + -1;
     HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
    } else {
     i1 = i3 & 255;
     if (i1 << 24 >> 24 <= -1) {
      if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) break;
      if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) break;
     }
     i33 = i41 + 28 | 0;
     HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + -1;
    } while (0);
    i1 = i41 + 16 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    if (!i2) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
    i33 = i2 + -1 | 0;
    HEAP32[i1 >> 2] = i33;
    if ((HEAP8[i41 + 8 + i33 >> 0] | 0) != (i3 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
   }
   i1 = HEAP32[i39 >> 2] | 0;
   if (!i1) i1 = 0; else {
    i33 = i1 + -1 | 0;
    HEAP32[i39 >> 2] = i33;
    i33 = (HEAP32[i41 + 40 >> 2] | 0) + i33 | 0;
    i1 = HEAP8[i33 >> 0] | 0;
    HEAP8[i33 >> 0] = 0;
   }
   if ((i1 << 24 >> 24 | 0) == (i3 | 0)) {
    STACKTOP = i43;
    return;
   } else ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
  } else i30 = i1; while (0);
  if (i30 >>> 0 < 4294967294) {
   if ((i30 | 1 | 0) != -1) {
    i33 = i41 + 36 | 0;
    HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + -1;
    do if ((i30 | 0) == 10) {
     i33 = i41 + 24 | 0;
     HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + -1;
     HEAP32[i41 + 28 >> 2] = HEAP32[i41 + 32 >> 2];
    } else {
     i1 = i30 & 255;
     if (i1 << 24 >> 24 <= -1) {
      if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) break;
      if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) break;
     }
     i33 = i41 + 28 | 0;
     HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + -1;
    } while (0);
    i1 = i41 + 16 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    if (!i2) ___assert_fail(gb + 37811 | 0, gb + 37743 | 0, 228, gb + 37834 | 0);
    i33 = i2 + -1 | 0;
    HEAP32[i1 >> 2] = i33;
    if ((HEAP8[i41 + 8 + i33 >> 0] | 0) != (i30 | 0)) ___assert_fail(gb + 37847 | 0, gb + 37743 | 0, 230, gb + 37834 | 0);
   }
   i1 = HEAP32[i39 >> 2] | 0;
   if (!i1) i1 = 0; else {
    i33 = i1 + -1 | 0;
    HEAP32[i39 >> 2] = i33;
    i33 = (HEAP32[i41 + 40 >> 2] | 0) + i33 | 0;
    i1 = HEAP8[i33 >> 0] | 0;
    HEAP8[i33 >> 0] = 0;
   }
   if ((i1 << 24 >> 24 | 0) != (i30 | 0)) ___assert_fail(gb + 37887 | 0, gb + 37743 | 0, 272, gb + 37894 | 0);
  }
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i27 = gb + 41404 | 0; else i27 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i27 >> 2] = 0;
  i28 = HEAP32[i37 >> 2] | 0;
  i1 = i34;
  i2 = i1 + 100 | 0;
  do {
   HEAP32[i1 >> 2] = 0;
   i1 = i1 + 4 | 0;
  } while ((i1 | 0) < (i2 | 0));
  i24 = i34 + 4 | 0;
  HEAP32[i24 >> 2] = i28;
  i25 = i34 + 8 | 0;
  HEAP32[i25 >> 2] = -1;
  HEAP32[i34 + 44 >> 2] = i28;
  HEAP32[i34 + 76 >> 2] = -1;
  i21 = i34 + 104 | 0;
  HEAP32[i21 >> 2] = 0;
  i26 = i34 + 108 | 0;
  HEAP32[i26 >> 2] = ~i28;
  i22 = i34 + 100 | 0;
  HEAP32[i22 >> 2] = -1;
  i1 = i28;
  i2 = -1;
  L627 : while (1) {
   if (i1 >>> 0 < i2 >>> 0) {
    HEAP32[i24 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i34) | 0;
   switch (i1 | 0) {
   case 9:
   case 10:
   case 11:
   case 12:
   case 13:
   case 32:
    break;
   default:
    break L627;
   }
   i1 = HEAP32[i24 >> 2] | 0;
   i2 = HEAP32[i22 >> 2] | 0;
  }
  L635 : do switch (i1 | 0) {
  case 43:
  case 45:
   {
    i2 = 1 - (((i1 | 0) == 45 & 1) << 1) | 0;
    i1 = HEAP32[i24 >> 2] | 0;
    if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
     HEAP32[i24 >> 2] = i1 + 1;
     i1 = HEAPU8[i1 >> 0] | 0;
     i23 = i2;
     break L635;
    } else {
     i1 = ___shgetc(i34) | 0;
     i23 = i2;
     break L635;
    }
   }
  default:
   i23 = 1;
  } while (0);
  i2 = i1;
  i1 = 0;
  do {
   if ((i2 | 32 | 0) != (HEAP8[gb + 41220 + i1 >> 0] | 0)) break;
   do if (i1 >>> 0 < 7) {
    i2 = HEAP32[i24 >> 2] | 0;
    if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
     HEAP32[i24 >> 2] = i2 + 1;
     i2 = HEAPU8[i2 >> 0] | 0;
     break;
    } else {
     i2 = ___shgetc(i34) | 0;
     break;
    }
   } while (0);
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < 8);
  L651 : do switch (i1 | 0) {
  case 8:
   {
    i38 = 415;
    break;
   }
  case 3:
   {
    i38 = 409;
    break;
   }
  default:
   {
    if (i1 >>> 0 > 3) if ((i1 | 0) == 8) {
     i38 = 415;
     break L651;
    } else {
     i38 = 409;
     break L651;
    }
    L656 : do if (!i1) {
     i1 = 0;
     do {
      if ((i2 | 32 | 0) != (HEAP8[gb + 41229 + i1 >> 0] | 0)) break L656;
      do if (i1 >>> 0 < 2) {
       i2 = HEAP32[i24 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i24 >> 2] = i2 + 1;
        i2 = HEAPU8[i2 >> 0] | 0;
        break;
       } else {
        i2 = ___shgetc(i34) | 0;
        break;
       }
      } while (0);
      i1 = i1 + 1 | 0;
     } while (i1 >>> 0 < 3);
    } while (0);
    switch (i1 | 0) {
    case 3:
     {
      i1 = HEAP32[i24 >> 2] | 0;
      if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
       HEAP32[i24 >> 2] = i1 + 1;
       i1 = HEAPU8[i1 >> 0] | 0;
      } else i1 = ___shgetc(i34) | 0;
      if ((i1 | 0) == 40) i1 = 1; else {
       if (!(HEAP32[i22 >> 2] | 0)) {
        d7 = nan;
        break L651;
       }
       HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
       d7 = nan;
       break L651;
      }
      while (1) {
       i2 = HEAP32[i24 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i24 >> 2] = i2 + 1;
        i2 = HEAPU8[i2 >> 0] | 0;
       } else i2 = ___shgetc(i34) | 0;
       if (!((i2 + -48 | 0) >>> 0 < 10 | (i2 + -65 | 0) >>> 0 < 26) ? !((i2 | 0) == 95 | (i2 + -97 | 0) >>> 0 < 26) : 0) break;
       i1 = i1 + 1 | 0;
      }
      if ((i2 | 0) == 41) {
       d7 = nan;
       break L651;
      }
      i2 = (HEAP32[i22 >> 2] | 0) == 0;
      if (!i2) HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
      if (!i1) {
       d7 = nan;
       break L651;
      }
      do {
       i1 = i1 + -1 | 0;
       if (!i2) HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
      } while ((i1 | 0) != 0);
      d7 = nan;
      break;
     }
    case 0:
     {
      do if ((i2 | 0) == 48) {
       i1 = HEAP32[i24 >> 2] | 0;
       if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i24 >> 2] = i1 + 1;
        i1 = HEAPU8[i1 >> 0] | 0;
       } else i1 = ___shgetc(i34) | 0;
       if ((i1 | 32 | 0) != 120) {
        if (!(HEAP32[i22 >> 2] | 0)) {
         i1 = 48;
         break;
        }
        HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
        i1 = 48;
        break;
       }
       i1 = HEAP32[i24 >> 2] | 0;
       if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i24 >> 2] = i1 + 1;
        i1 = HEAPU8[i1 >> 0] | 0;
        i3 = 0;
       } else {
        i1 = ___shgetc(i34) | 0;
        i3 = 0;
       }
       L716 : while (1) {
        switch (i1 | 0) {
        case 46:
         {
          i38 = 460;
          break L716;
         }
        case 48:
         break;
        default:
         {
          i17 = 0;
          i4 = 0;
          i15 = 0;
          i2 = 0;
          i10 = i3;
          i14 = 0;
          i11 = 0;
          d12 = 1.0;
          i3 = 0;
          d7 = 0.0;
          break L716;
         }
        }
        i1 = HEAP32[i24 >> 2] | 0;
        if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i24 >> 2] = i1 + 1;
         i1 = HEAPU8[i1 >> 0] | 0;
         i3 = 1;
         continue;
        } else {
         i1 = ___shgetc(i34) | 0;
         i3 = 1;
         continue;
        }
       }
       do if ((i38 | 0) == 460) {
        i1 = HEAP32[i24 >> 2] | 0;
        if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i24 >> 2] = i1 + 1;
         i1 = HEAPU8[i1 >> 0] | 0;
        } else i1 = ___shgetc(i34) | 0;
        if ((i1 | 0) == 48) {
         i3 = 0;
         i2 = 0;
        } else {
         i17 = 0;
         i4 = 0;
         i15 = 0;
         i2 = 0;
         i10 = i3;
         i14 = 1;
         i11 = 0;
         d12 = 1.0;
         i3 = 0;
         d7 = 0.0;
         break;
        }
        do {
         i1 = HEAP32[i24 >> 2] | 0;
         if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
          HEAP32[i24 >> 2] = i1 + 1;
          i1 = HEAPU8[i1 >> 0] | 0;
         } else i1 = ___shgetc(i34) | 0;
         i3 = _i64Add(i3 | 0, i2 | 0, -1, -1) | 0;
         i2 = getTempRet0() | 0;
        } while ((i1 | 0) == 48);
        i17 = 0;
        i4 = 0;
        i15 = i3;
        i10 = 1;
        i14 = 1;
        i11 = 0;
        d12 = 1.0;
        i3 = 0;
        d7 = 0.0;
       } while (0);
       L734 : while (1) {
        i6 = i1 + -48 | 0;
        i5 = i1 | 32;
        do if (i6 >>> 0 >= 10) {
         i8 = (i1 | 0) == 46;
         if (!(i8 | (i5 + -97 | 0) >>> 0 < 6)) break L734;
         if (!i8) {
          i38 = 472;
          break;
         }
         if (!i14) {
          i8 = i4;
          i2 = i17;
          i6 = i17;
          i14 = 1;
          i5 = i11;
          d9 = d12;
         } else {
          i1 = 46;
          break L734;
         }
        } else i38 = 472; while (0);
        if ((i38 | 0) == 472) {
         i38 = 0;
         i1 = (i1 | 0) > 57 ? i5 + -87 | 0 : i6;
         do if ((i17 | 0) < 0 | (i17 | 0) == 0 & i4 >>> 0 < 8) {
          i5 = i11;
          d9 = d12;
          i3 = i1 + (i3 << 4) | 0;
         } else {
          if ((i17 | 0) < 0 | (i17 | 0) == 0 & i4 >>> 0 < 14) {
           d16 = d12 * .0625;
           i5 = i11;
           d9 = d16;
           d7 = d7 + d16 * +(i1 | 0);
           break;
          }
          if ((i11 | 0) != 0 | (i1 | 0) == 0) {
           i5 = i11;
           d9 = d12;
           break;
          }
          i5 = 1;
          d9 = d12;
          d7 = d7 + d12 * .5;
         } while (0);
         i4 = _i64Add(i4 | 0, i17 | 0, 1, 0) | 0;
         i8 = i15;
         i6 = getTempRet0() | 0;
         i10 = 1;
        }
        i1 = HEAP32[i24 >> 2] | 0;
        if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i24 >> 2] = i1 + 1;
         i17 = i6;
         i15 = i8;
         i1 = HEAPU8[i1 >> 0] | 0;
         i11 = i5;
         d12 = d9;
         continue;
        } else {
         i17 = i6;
         i15 = i8;
         i1 = ___shgetc(i34) | 0;
         i11 = i5;
         d12 = d9;
         continue;
        }
       }
       if (!i10) {
        do if (HEAP32[i22 >> 2] | 0) {
         i1 = HEAP32[i24 >> 2] | 0;
         HEAP32[i24 >> 2] = i1 + -2;
         if (!i14) break;
         HEAP32[i24 >> 2] = i1 + -3;
        } while (0);
        d7 = +(i23 | 0) * 0.0;
        break L651;
       }
       i5 = (i14 | 0) == 0;
       i6 = i5 ? i4 : i15;
       i5 = i5 ? i17 : i2;
       if ((i17 | 0) < 0 | (i17 | 0) == 0 & i4 >>> 0 < 8) {
        i2 = i17;
        do {
         i3 = i3 << 4;
         i4 = _i64Add(i4 | 0, i2 | 0, 1, 0) | 0;
         i2 = getTempRet0() | 0;
        } while ((i2 | 0) < 0 | (i2 | 0) == 0 & i4 >>> 0 < 8);
       }
       do if ((i1 | 32 | 0) == 112) {
        i2 = _scanexp(i34, 1) | 0;
        i1 = getTempRet0() | 0;
        if (!((i2 | 0) == 0 & (i1 | 0) == -2147483648)) break;
        if (!(HEAP32[i22 >> 2] | 0)) {
         i2 = 0;
         i1 = 0;
         break;
        }
        HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
        i2 = 0;
        i1 = 0;
       } else {
        if (!(HEAP32[i22 >> 2] | 0)) {
         i2 = 0;
         i1 = 0;
         break;
        }
        HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
        i2 = 0;
        i1 = 0;
       } while (0);
       i35 = _bitshift64Shl(i6 | 0, i5 | 0, 2) | 0;
       i35 = _i64Add(i35 | 0, getTempRet0() | 0, -32, -1) | 0;
       i1 = _i64Add(i35 | 0, getTempRet0() | 0, i2 | 0, i1 | 0) | 0;
       i2 = getTempRet0() | 0;
       if (!i3) {
        d7 = +(i23 | 0) * 0.0;
        break L651;
       }
       if ((i2 | 0) > 0 | (i2 | 0) == 0 & i1 >>> 0 > 1074) {
        if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
        HEAP32[i1 >> 2] = 34;
        d7 = +(i23 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;
        break L651;
       }
       if ((i2 | 0) < -1 | (i2 | 0) == -1 & i1 >>> 0 < 4294966116) {
        if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
        HEAP32[i1 >> 2] = 34;
        d7 = +(i23 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;
        break L651;
       }
       if ((i3 | 0) > -1) {
        do {
         i34 = !(d7 >= .5);
         i35 = i34 & 1 | i3 << 1;
         i3 = i35 ^ 1;
         d7 = d7 + (i34 ? d7 : d7 + -1.0);
         i1 = _i64Add(i1 | 0, i2 | 0, -1, -1) | 0;
         i2 = getTempRet0() | 0;
        } while ((i35 | 0) > -1);
        i5 = i1;
        i4 = i3;
        d12 = d7;
       } else {
        i5 = i1;
        i4 = i3;
        d12 = d7;
       }
       i1 = _i64Add(i5 | 0, i2 | 0, 1106, 0) | 0;
       i35 = getTempRet0() | 0;
       do if ((i35 | 0) < 0 | (i35 | 0) == 0 & i1 >>> 0 < 53) {
        if ((i1 | 0) >= 0) {
         if ((i1 | 0) >= 53) {
          i38 = 510;
          break;
         }
        } else i1 = 0;
        i2 = 84 - i1 | 0;
        do if ((i2 | 0) > 1023) {
         i3 = i2 + -1023 | 0;
         if ((i3 | 0) <= 1023) {
          i2 = i3;
          d7 = 8988465674311579538646525.0e283;
          break;
         }
         i2 = i2 + -2046 | 0;
         i2 = (i2 | 0) > 1023 ? 1023 : i2;
         d7 = inf;
        } else {
         if ((i2 | 0) >= -1022) {
          d7 = 1.0;
          break;
         }
         i3 = i2 + 1022 | 0;
         if ((i3 | 0) >= -1022) {
          i2 = i3;
          d7 = 2.2250738585072014e-308;
          break;
         }
         i2 = i2 + 2044 | 0;
         i2 = (i2 | 0) < -1022 ? -1022 : i2;
         d7 = 0.0;
        } while (0);
        i34 = _bitshift64Shl(i2 + 1023 | 0, 0, 52) | 0;
        i35 = getTempRet0() | 0;
        HEAP32[tempDoublePtr >> 2] = i34;
        HEAP32[tempDoublePtr + 4 >> 2] = i35;
        d9 = d7 * +HEAPF64[tempDoublePtr >> 3];
        d7 = +(i23 | 0);
        HEAPF64[tempDoublePtr >> 3] = d7;
        i35 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
        d9 = +Math_abs(+d9);
        HEAPF64[tempDoublePtr >> 3] = d9;
        i35 = HEAP32[tempDoublePtr + 4 >> 2] | i35 & -2147483648;
        HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
        HEAP32[tempDoublePtr + 4 >> 2] = i35;
        d9 = +HEAPF64[tempDoublePtr >> 3];
       } else {
        i1 = 53;
        i38 = 510;
       } while (0);
       if ((i38 | 0) == 510) {
        d7 = +(i23 | 0);
        d9 = 0.0;
       }
       i35 = (i4 & 1 | 0) == 0 & (d12 != 0.0 & (i1 | 0) < 32);
       d7 = d7 * (i35 ? 0.0 : d12) + (d9 + d7 * +(((i35 & 1) + i4 | 0) >>> 0)) - d9;
       if (!(d7 != 0.0)) {
        if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
        HEAP32[i1 >> 2] = 34;
       }
       do if ((i5 | 0) > 1023) {
        d7 = d7 * 8988465674311579538646525.0e283;
        i1 = i5 + -1023 | 0;
        if ((i1 | 0) <= 1023) break;
        i1 = i5 + -2046 | 0;
        i1 = (i1 | 0) > 1023 ? 1023 : i1;
        d7 = d7 * 8988465674311579538646525.0e283;
       } else {
        if ((i5 | 0) >= -1022) {
         i1 = i5;
         break;
        }
        d7 = d7 * 2.2250738585072014e-308;
        i1 = i5 + 1022 | 0;
        if ((i1 | 0) >= -1022) break;
        i1 = i5 + 2044 | 0;
        i1 = (i1 | 0) < -1022 ? -1022 : i1;
        d7 = d7 * 2.2250738585072014e-308;
       } while (0);
       i34 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
       i35 = getTempRet0() | 0;
       HEAP32[tempDoublePtr >> 2] = i34;
       HEAP32[tempDoublePtr + 4 >> 2] = i35;
       d7 = d7 * +HEAPF64[tempDoublePtr >> 3];
       break L651;
      } else i1 = i2; while (0);
      i4 = 0;
      L821 : while (1) {
       switch (i1 | 0) {
       case 46:
        {
         i38 = 536;
         break L821;
        }
       case 48:
        break;
       default:
        {
         i2 = 0;
         i3 = 0;
         i14 = 0;
         break L821;
        }
       }
       i1 = HEAP32[i24 >> 2] | 0;
       if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i24 >> 2] = i1 + 1;
        i1 = HEAPU8[i1 >> 0] | 0;
        i4 = 1;
        continue;
       } else {
        i1 = ___shgetc(i34) | 0;
        i4 = 1;
        continue;
       }
      }
      if ((i38 | 0) == 536) {
       i1 = HEAP32[i24 >> 2] | 0;
       if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
        HEAP32[i24 >> 2] = i1 + 1;
        i1 = HEAPU8[i1 >> 0] | 0;
       } else i1 = ___shgetc(i34) | 0;
       if ((i1 | 0) == 48) {
        i2 = 0;
        i1 = 0;
        while (1) {
         i2 = _i64Add(i2 | 0, i1 | 0, -1, -1) | 0;
         i3 = getTempRet0() | 0;
         i1 = HEAP32[i24 >> 2] | 0;
         if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
          HEAP32[i24 >> 2] = i1 + 1;
          i1 = HEAPU8[i1 >> 0] | 0;
         } else i1 = ___shgetc(i34) | 0;
         if ((i1 | 0) == 48) i1 = i3; else {
          i4 = 1;
          i14 = 1;
          break;
         }
        }
       } else {
        i2 = 0;
        i3 = 0;
        i14 = 1;
       }
      }
      HEAP32[i35 >> 2] = 0;
      i6 = i1 + -48 | 0;
      i5 = (i1 | 0) == 46;
      L840 : do if (i5 | i6 >>> 0 < 10) {
       i20 = i35 + 496 | 0;
       i11 = 0;
       i10 = 0;
       i18 = i5;
       i8 = i4;
       i17 = i14;
       i19 = 0;
       i4 = 0;
       i5 = 0;
       L842 : while (1) {
        do if (i18) if (!i17) {
         i2 = i11;
         i3 = i10;
         i15 = i11;
         i17 = 1;
        } else break L842; else {
         i11 = _i64Add(i11 | 0, i10 | 0, 1, 0) | 0;
         i10 = getTempRet0() | 0;
         i14 = (i1 | 0) != 48;
         if ((i4 | 0) >= 125) {
          if (!i14) {
           i15 = i11;
           break;
          }
          HEAP32[i20 >> 2] = HEAP32[i20 >> 2] | 1;
          i15 = i11;
          break;
         }
         i8 = i35 + (i4 << 2) | 0;
         if (i19) i6 = i1 + -48 + ((HEAP32[i8 >> 2] | 0) * 10 | 0) | 0;
         HEAP32[i8 >> 2] = i6;
         i19 = i19 + 1 | 0;
         i38 = (i19 | 0) == 9;
         i15 = i11;
         i8 = 1;
         i19 = i38 ? 0 : i19;
         i4 = (i38 & 1) + i4 | 0;
         i5 = i14 ? i11 : i5;
        } while (0);
        i1 = HEAP32[i24 >> 2] | 0;
        if (i1 >>> 0 < (HEAP32[i22 >> 2] | 0) >>> 0) {
         HEAP32[i24 >> 2] = i1 + 1;
         i1 = HEAPU8[i1 >> 0] | 0;
        } else i1 = ___shgetc(i34) | 0;
        i6 = i1 + -48 | 0;
        i18 = (i1 | 0) == 46;
        if (!(i18 | i6 >>> 0 < 10)) {
         i11 = i15;
         i6 = i17;
         i15 = i5;
         i38 = 559;
         break L840;
        } else i11 = i15;
       }
       i6 = i10;
       i8 = (i8 | 0) != 0;
       i1 = i19;
       i38 = 565;
      } else {
       i11 = 0;
       i10 = 0;
       i8 = i4;
       i6 = i14;
       i19 = 0;
       i4 = 0;
       i15 = 0;
       i38 = 559;
      } while (0);
      do if ((i38 | 0) == 559) {
       i5 = (i6 | 0) == 0;
       i2 = i5 ? i11 : i2;
       i3 = i5 ? i10 : i3;
       i5 = (i8 | 0) != 0;
       if (!((i1 | 32 | 0) == 101 & i5)) if ((i1 | 0) > -1) {
        i6 = i10;
        i8 = i5;
        i1 = i19;
        i5 = i15;
        i38 = 565;
        break;
       } else {
        i6 = i10;
        i8 = i5;
        i1 = i19;
        i5 = i15;
        i38 = 567;
        break;
       }
       i5 = _scanexp(i34, 1) | 0;
       i1 = getTempRet0() | 0;
       do if ((i5 | 0) == 0 & (i1 | 0) == -2147483648) {
        if (!(HEAP32[i22 >> 2] | 0)) {
         i5 = 0;
         i1 = 0;
         break;
        }
        HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
        i5 = 0;
        i1 = 0;
       } while (0);
       i14 = _i64Add(i5 | 0, i1 | 0, i2 | 0, i3 | 0) | 0;
       i8 = i11;
       i3 = getTempRet0() | 0;
       i6 = i10;
       i1 = i19;
       i5 = i15;
       i38 = 571;
      } while (0);
      if ((i38 | 0) == 565) if (HEAP32[i22 >> 2] | 0) {
       HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
       if (i8) {
        i14 = i2;
        i8 = i11;
        i38 = 571;
       } else i38 = 568;
      } else i38 = 567;
      if ((i38 | 0) == 567) if (i8) {
       i14 = i2;
       i8 = i11;
       i38 = 571;
      } else i38 = 568;
      L874 : do if ((i38 | 0) == 568) {
       if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
       HEAP32[i1 >> 2] = 22;
       HEAP32[i21 >> 2] = 0;
       i35 = HEAP32[i25 >> 2] | 0;
       HEAP32[i26 >> 2] = i35 - (HEAP32[i24 >> 2] | 0);
       HEAP32[i22 >> 2] = i35;
       d7 = 0.0;
      } else if ((i38 | 0) == 571) {
       i2 = HEAP32[i35 >> 2] | 0;
       if (!i2) {
        d7 = +(i23 | 0) * 0.0;
        break;
       }
       if (((i6 | 0) < 0 | (i6 | 0) == 0 & i8 >>> 0 < 10) & ((i14 | 0) == (i8 | 0) & (i3 | 0) == (i6 | 0))) {
        d7 = +(i23 | 0) * +(i2 >>> 0);
        break;
       }
       if ((i3 | 0) > 0 | (i3 | 0) == 0 & i14 >>> 0 > 537) {
        if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
        HEAP32[i1 >> 2] = 34;
        d7 = +(i23 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;
        break;
       }
       if ((i3 | 0) < -1 | (i3 | 0) == -1 & i14 >>> 0 < 4294966116) {
        if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
        HEAP32[i1 >> 2] = 34;
        d7 = +(i23 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;
        break;
       }
       if (i1) {
        if ((i1 | 0) < 9) {
         i2 = i35 + (i4 << 2) | 0;
         i3 = HEAP32[i2 >> 2] | 0;
         do {
          i3 = i3 * 10 | 0;
          i1 = i1 + 1 | 0;
         } while ((i1 | 0) != 9);
         HEAP32[i2 >> 2] = i3;
        }
        i4 = i4 + 1 | 0;
       }
       do if ((i5 | 0) < 9) {
        if (!((i5 | 0) <= (i14 | 0) & (i14 | 0) < 18)) break;
        if ((i14 | 0) == 9) {
         d7 = +(i23 | 0) * +((HEAP32[i35 >> 2] | 0) >>> 0);
         break L874;
        }
        if ((i14 | 0) < 9) {
         d7 = +(i23 | 0) * +((HEAP32[i35 >> 2] | 0) >>> 0) / +(HEAP32[gb + 9068 + (8 - i14 << 2) >> 2] | 0);
         break L874;
        }
        i34 = (Math_imul(i14, -3) | 0) + 80 | 0;
        i1 = HEAP32[i35 >> 2] | 0;
        if (!((i34 | 0) > 30 | (i1 >>> i34 | 0) == 0)) break;
        d7 = +(i23 | 0) * +(i1 >>> 0) * +(HEAP32[gb + 9068 + (i14 + -10 << 2) >> 2] | 0);
        break L874;
       } while (0);
       i1 = (i14 | 0) % 9 | 0;
       if (!i1) {
        i1 = 0;
        i2 = 0;
        i5 = i14;
       } else {
        i10 = (i14 | 0) > -1 ? i1 : i1 + 9 | 0;
        i2 = HEAP32[gb + 9068 + (8 - i10 << 2) >> 2] | 0;
        do if (!i4) {
         i1 = 0;
         i3 = i14;
         i4 = 0;
        } else {
         i5 = 1e9 / (i2 | 0) | 0;
         i1 = 0;
         i6 = 0;
         i8 = 0;
         i3 = i14;
         do {
          i32 = i35 + (i8 << 2) | 0;
          i33 = HEAP32[i32 >> 2] | 0;
          i34 = ((i33 >>> 0) / (i2 >>> 0) | 0) + i6 | 0;
          HEAP32[i32 >> 2] = i34;
          i6 = Math_imul((i33 >>> 0) % (i2 >>> 0) | 0, i5) | 0;
          i34 = (i8 | 0) == (i1 | 0) & (i34 | 0) == 0;
          i8 = i8 + 1 | 0;
          i3 = i34 ? i3 + -9 | 0 : i3;
          i1 = i34 ? i8 & 127 : i1;
         } while ((i8 | 0) != (i4 | 0));
         if (!i6) break;
         HEAP32[i35 + (i4 << 2) >> 2] = i6;
         i4 = i4 + 1 | 0;
        } while (0);
        i2 = 0;
        i5 = 9 - i10 + i3 | 0;
       }
       L923 : while (1) {
        i11 = (i5 | 0) < 18;
        i14 = (i5 | 0) == 18;
        i15 = i35 + (i1 << 2) | 0;
        do {
         if (!i11) {
          if (!i14) break L923;
          if ((HEAP32[i15 >> 2] | 0) >>> 0 >= 9007199) {
           i5 = 18;
           break L923;
          }
         }
         i6 = 0;
         i3 = i4 + 127 | 0;
         while (1) {
          i10 = i3 & 127;
          i8 = i35 + (i10 << 2) | 0;
          i3 = _bitshift64Shl(HEAP32[i8 >> 2] | 0, 0, 29) | 0;
          i3 = _i64Add(i3 | 0, getTempRet0() | 0, i6 | 0, 0) | 0;
          i6 = getTempRet0() | 0;
          if (i6 >>> 0 > 0 | (i6 | 0) == 0 & i3 >>> 0 > 1e9) {
           i34 = ___udivdi3(i3 | 0, i6 | 0, 1e9, 0) | 0;
           getTempRet0() | 0;
           i3 = ___uremdi3(i3 | 0, i6 | 0, 1e9, 0) | 0;
           getTempRet0() | 0;
           i6 = i34;
          } else i6 = 0;
          HEAP32[i8 >> 2] = i3;
          i34 = (i10 | 0) == (i1 | 0);
          i4 = (i10 | 0) != (i4 + 127 & 127 | 0) | i34 ? i4 : (i3 | 0) == 0 ? i10 : i4;
          if (i34) break; else i3 = i10 + -1 | 0;
         }
         i2 = i2 + -29 | 0;
        } while (!(i6 | 0));
        i1 = i1 + 127 & 127;
        if ((i1 | 0) == (i4 | 0)) {
         i34 = i4 + 127 & 127;
         i4 = i35 + ((i4 + 126 & 127) << 2) | 0;
         HEAP32[i4 >> 2] = HEAP32[i4 >> 2] | HEAP32[i35 + (i34 << 2) >> 2];
         i4 = i34;
        }
        HEAP32[i35 + (i1 << 2) >> 2] = i6;
        i5 = i5 + 9 | 0;
       }
       L941 : while (1) {
        i3 = i4 + 1 & 127;
        i15 = i35 + ((i4 + 127 & 127) << 2) | 0;
        while (1) {
         i11 = (i5 | 0) == 18;
         i14 = (i5 | 0) > 27 ? 9 : 1;
         i10 = i11 ^ 1;
         i17 = i1;
         while (1) {
          i1 = i17 & 127;
          i8 = (i1 | 0) == (i4 | 0);
          do if (!i8) {
           i6 = HEAP32[i35 + (i1 << 2) >> 2] | 0;
           if (i6 >>> 0 < 9007199) {
            i38 = 620;
            break;
           }
           if (i6 >>> 0 > 9007199) break;
           i6 = i17 + 1 & 127;
           if ((i6 | 0) == (i4 | 0)) {
            i38 = 620;
            break;
           }
           i6 = HEAP32[i35 + (i6 << 2) >> 2] | 0;
           if (i6 >>> 0 < 254740991) {
            i38 = 620;
            break;
           }
           if (!(i6 >>> 0 > 254740991 | i10)) {
            i3 = i4;
            break L941;
           }
          } else i38 = 620; while (0);
          if ((i38 | 0) == 620 ? (i38 = 0, i11) : 0) {
           i38 = 621;
           break L941;
          }
          i2 = i2 + i14 | 0;
          if ((i17 | 0) == (i4 | 0)) i17 = i4; else break;
         }
         i8 = (1 << i14) + -1 | 0;
         i10 = 1e9 >>> i14;
         i1 = i17;
         i11 = 0;
         i6 = i17;
         do {
          i32 = i35 + (i6 << 2) | 0;
          i33 = HEAP32[i32 >> 2] | 0;
          i34 = (i33 >>> i14) + i11 | 0;
          HEAP32[i32 >> 2] = i34;
          i11 = Math_imul(i33 & i8, i10) | 0;
          i34 = (i6 | 0) == (i1 | 0) & (i34 | 0) == 0;
          i6 = i6 + 1 & 127;
          i5 = i34 ? i5 + -9 | 0 : i5;
          i1 = i34 ? i6 : i1;
         } while ((i6 | 0) != (i4 | 0));
         if (!i11) continue;
         if ((i3 | 0) != (i1 | 0)) break;
         HEAP32[i15 >> 2] = HEAP32[i15 >> 2] | 1;
        }
        HEAP32[i35 + (i4 << 2) >> 2] = i11;
        i4 = i3;
       }
       do if ((i38 | 0) == 621) {
        if (!i8) {
         i3 = i4;
         break;
        }
        HEAP32[i35 + (i3 + -1 << 2) >> 2] = 0;
        i1 = i4;
       } while (0);
       d7 = +((HEAP32[i35 + (i1 << 2) >> 2] | 0) >>> 0);
       i1 = i17 + 1 & 127;
       if ((i1 | 0) == (i3 | 0)) {
        i3 = i17 + 2 & 127;
        HEAP32[i35 + (i3 + -1 << 2) >> 2] = 0;
       }
       d16 = +(i23 | 0);
       d12 = d16 * (d7 * 1.0e9 + +((HEAP32[i35 + (i1 << 2) >> 2] | 0) >>> 0));
       i8 = i2 + 53 | 0;
       i10 = i2 + 1127 | 0;
       i11 = (i10 | 0) < 53;
       i1 = i11 & 1;
       i6 = i11 ? ((i10 | 0) < 0 ? 0 : i10) : 53;
       if ((i6 | 0) < 53) {
        i4 = 105 - i6 | 0;
        do if ((i4 | 0) > 1023) {
         i5 = i4 + -1023 | 0;
         if ((i5 | 0) <= 1023) {
          i4 = i5;
          d7 = 8988465674311579538646525.0e283;
          break;
         }
         i4 = i4 + -2046 | 0;
         i4 = (i4 | 0) > 1023 ? 1023 : i4;
         d7 = inf;
        } else {
         if ((i4 | 0) >= -1022) {
          d7 = 1.0;
          break;
         }
         i5 = i4 + 1022 | 0;
         if ((i5 | 0) >= -1022) {
          i4 = i5;
          d7 = 2.2250738585072014e-308;
          break;
         }
         i4 = i4 + 2044 | 0;
         i4 = (i4 | 0) < -1022 ? -1022 : i4;
         d7 = 0.0;
        } while (0);
        i34 = _bitshift64Shl(i4 + 1023 | 0, 0, 52) | 0;
        i4 = getTempRet0() | 0;
        HEAP32[tempDoublePtr >> 2] = i34;
        HEAP32[tempDoublePtr + 4 >> 2] = i4;
        d9 = d7 * +HEAPF64[tempDoublePtr >> 3];
        HEAPF64[tempDoublePtr >> 3] = d12;
        i4 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
        d9 = +Math_abs(+d9);
        HEAPF64[tempDoublePtr >> 3] = d9;
        i4 = HEAP32[tempDoublePtr + 4 >> 2] | i4 & -2147483648;
        HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
        HEAP32[tempDoublePtr + 4 >> 2] = i4;
        d9 = +HEAPF64[tempDoublePtr >> 3];
        i4 = 53 - i6 | 0;
        do if ((i4 | 0) > 1023) {
         i5 = i4 + -1023 | 0;
         if ((i5 | 0) <= 1023) {
          i4 = i5;
          d7 = 8988465674311579538646525.0e283;
          break;
         }
         i4 = i4 + -2046 | 0;
         i4 = (i4 | 0) > 1023 ? 1023 : i4;
         d7 = inf;
        } else {
         if ((i4 | 0) >= -1022) {
          d7 = 1.0;
          break;
         }
         i5 = i4 + 1022 | 0;
         if ((i5 | 0) >= -1022) {
          i4 = i5;
          d7 = 2.2250738585072014e-308;
          break;
         }
         i4 = i4 + 2044 | 0;
         i4 = (i4 | 0) < -1022 ? -1022 : i4;
         d7 = 0.0;
        } while (0);
        i33 = _bitshift64Shl(i4 + 1023 | 0, 0, 52) | 0;
        i34 = getTempRet0() | 0;
        HEAP32[tempDoublePtr >> 2] = i33;
        HEAP32[tempDoublePtr + 4 >> 2] = i34;
        d44 = +_fmod(d12, d7 * +HEAPF64[tempDoublePtr >> 3]);
        d13 = d9;
        d7 = d44;
        d12 = d12 - d44 + d9;
       } else {
        d13 = 0.0;
        d7 = 0.0;
       }
       i4 = i17 + 2 & 127;
       do if ((i4 | 0) == (i3 | 0)) d9 = d7; else {
        i4 = HEAP32[i35 + (i4 << 2) >> 2] | 0;
        do if (i4 >>> 0 >= 5e8) {
         if (i4 >>> 0 > 5e8) {
          d7 = d16 * .75 + d7;
          break;
         }
         if ((i17 + 3 & 127 | 0) == (i3 | 0)) {
          d7 = d16 * .5 + d7;
          break;
         } else {
          d7 = d16 * .75 + d7;
          break;
         }
        } else {
         if ((i4 | 0) == 0 ? (i17 + 3 & 127 | 0) == (i3 | 0) : 0) break;
         d7 = d16 * .25 + d7;
        } while (0);
        if ((53 - i6 | 0) <= 1) {
         d9 = d7;
         break;
        }
        if (+_fmod(d7, 1.0) != 0.0) {
         d9 = d7;
         break;
        }
        d9 = d7 + 1.0;
       } while (0);
       d7 = d12 + d9 - d13;
       do if ((i8 & 2147483644) >>> 0 > 1019) {
        if (+Math_abs(+d7) >= 9007199254740992.0) {
         i1 = i11 & (i6 | 0) == (i10 | 0) ? 0 : i1;
         i2 = i2 + 1 | 0;
         d7 = d7 * .5;
        }
        if ((i2 + 50 | 0) <= 1021 ? !(d9 != 0.0 & (i1 | 0) != 0) : 0) break;
        if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
        HEAP32[i1 >> 2] = 34;
       } while (0);
       do if ((i2 | 0) > 1023) {
        d7 = d7 * 8988465674311579538646525.0e283;
        i1 = i2 + -1023 | 0;
        if ((i1 | 0) <= 1023) break;
        i1 = i2 + -2046 | 0;
        i1 = (i1 | 0) > 1023 ? 1023 : i1;
        d7 = d7 * 8988465674311579538646525.0e283;
       } else {
        if ((i2 | 0) >= -1022) {
         i1 = i2;
         break;
        }
        d7 = d7 * 2.2250738585072014e-308;
        i1 = i2 + 1022 | 0;
        if ((i1 | 0) >= -1022) break;
        i1 = i2 + 2044 | 0;
        i1 = (i1 | 0) < -1022 ? -1022 : i1;
        d7 = d7 * 2.2250738585072014e-308;
       } while (0);
       i34 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
       i35 = getTempRet0() | 0;
       HEAP32[tempDoublePtr >> 2] = i34;
       HEAP32[tempDoublePtr + 4 >> 2] = i35;
       d7 = d7 * +HEAPF64[tempDoublePtr >> 3];
      } while (0);
      break L651;
     }
    default:
     {
      if (HEAP32[i22 >> 2] | 0) HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
      if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
      HEAP32[i1 >> 2] = 22;
      HEAP32[i21 >> 2] = 0;
      i35 = HEAP32[i25 >> 2] | 0;
      HEAP32[i26 >> 2] = i35 - (HEAP32[i24 >> 2] | 0);
      HEAP32[i22 >> 2] = i35;
      d7 = 0.0;
      break L651;
     }
    }
   }
  } while (0);
  if ((i38 | 0) == 409) {
   i2 = (HEAP32[i22 >> 2] | 0) == 0;
   if (!i2) HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
   if (i1 >>> 0 > 3) {
    do {
     if (!i2) HEAP32[i24 >> 2] = (HEAP32[i24 >> 2] | 0) + -1;
     i1 = i1 + -1 | 0;
    } while (i1 >>> 0 > 3);
    i38 = 415;
   } else i38 = 415;
  }
  if ((i38 | 0) == 415) d7 = +(i23 | 0) * inf;
  i38 = (HEAP32[i24 >> 2] | 0) - (HEAP32[i25 >> 2] | 0) + (HEAP32[i26 >> 2] | 0) | 0;
  if (((i38 | 0 ? i28 + i38 | 0 : i28) | 0) != ((HEAP32[i37 >> 2] | 0) + (HEAP32[i39 >> 2] | 0) | 0)) ___assert_fail(gb + 38459 | 0, gb + 38503 | 0, 71, gb + 38513 | 0);
  if (d7 == inf | d7 == -inf ? (HEAP32[i27 >> 2] | 0) == 34 : 0) {
   _error_set(i40, i41, gb + 38206 | 0, i36);
   STACKTOP = i43;
   return;
  }
  HEAP32[i42 >> 2] = 258;
  HEAPF64[i41 + 64 >> 3] = d7;
  STACKTOP = i43;
  return;
 }
}

function _flexframesync_execute(i116, i117, i115) {
 i116 = i116 | 0;
 i117 = i117 | 0;
 i115 = i115 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, d16 = 0.0, d17 = 0.0, i18 = 0, i19 = 0, d20 = 0.0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, i74 = 0, i75 = 0, i76 = 0, i77 = 0, i78 = 0, i79 = 0, i80 = 0, i81 = 0, i82 = 0, i83 = 0, i84 = 0, i85 = 0, i86 = 0, i87 = 0, i88 = 0, i89 = 0, i90 = 0, i91 = 0, i92 = 0, i93 = 0, i94 = 0, i95 = 0, i96 = 0, i97 = 0, i98 = 0, i99 = 0, i100 = 0, i101 = 0, i102 = 0, i103 = 0, i104 = 0, i105 = 0, i106 = 0, i107 = 0, i108 = 0, i109 = 0, i110 = 0, i111 = 0, i112 = 0, i113 = 0, i114 = 0, i118 = 0, i119 = 0, i120 = 0, i121 = 0, i122 = 0, i123 = 0, i124 = 0, i125 = 0, i126 = 0, i127 = 0, i128 = 0, i129 = 0;
 i124 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i33 = i124 + 72 | 0;
 i120 = i124 + 24 | 0;
 i122 = i124 + 16 | 0;
 i121 = i124 + 8 | 0;
 i119 = i124;
 i34 = i124 + 64 | 0;
 i35 = i124 + 56 | 0;
 i46 = i124 + 48 | 0;
 i57 = i124 + 40 | 0;
 i68 = i124 + 32 | 0;
 if (!i115) {
  STACKTOP = i124;
  return;
 }
 i89 = i116 + 204 | 0;
 i100 = i116 + 200 | 0;
 i112 = i116 + 212 | 0;
 i114 = i116 + 216 | 0;
 i36 = i116 + 72 | 0;
 i37 = i116 + 76 | 0;
 i38 = i116 + 88 | 0;
 i39 = i116 + 80 | 0;
 i40 = i116 + 84 | 0;
 i41 = i116 + 104 | 0;
 i42 = i116 + 112 | 0;
 i43 = i116 + 108 | 0;
 i44 = i116 + 100 | 0;
 i45 = i116 + 92 | 0;
 i47 = i68 + 4 | 0;
 i48 = i57 + 4 | 0;
 i49 = i33 + 4 | 0;
 i50 = i34 + 4 | 0;
 i51 = i35 + 4 | 0;
 i52 = i46 + 4 | 0;
 i53 = i35 + 4 | 0;
 i54 = i46 + 4 | 0;
 i55 = i57 + 4 | 0;
 i56 = i34 + 4 | 0;
 i58 = i33 + 4 | 0;
 i59 = i33 + 4 | 0;
 i60 = i116 + 64 | 0;
 i61 = i116 + 192 | 0;
 i62 = i116 + 120 | 0;
 i63 = i33 + 4 | 0;
 i64 = i116 + 196 | 0;
 i65 = i116 + 124 | 0;
 i66 = i116 + 128 | 0;
 i67 = i116 + 132 | 0;
 i69 = i116 + 136 | 0;
 i70 = i116 + 144 | 0;
 i71 = i116 + 156 | 0;
 i72 = i116 + 160 | 0;
 i73 = i116 + 48 | 0;
 i74 = i116 + 96 | 0;
 i75 = i116 + 8 | 0;
 i76 = i116 + 8 | 0;
 i77 = i116 + 12 | 0;
 i78 = i116 + 16 | 0;
 i79 = i116 + 20 | 0;
 i80 = i116 + 4 | 0;
 i81 = i116 + 148 | 0;
 i82 = i116 + 184 | 0;
 i83 = i116 + 164 | 0;
 i84 = i116 + 176 | 0;
 i85 = i116 + 172 | 0;
 i86 = i116 + 168 | 0;
 i87 = i116 + 180 | 0;
 i88 = i34 + 4 | 0;
 i90 = i57 + 4 | 0;
 i91 = i68 + 4 | 0;
 i92 = i34 + 4 | 0;
 i93 = i35 + 4 | 0;
 i94 = i46 + 4 | 0;
 i95 = i33 + 4 | 0;
 i96 = i33 + 4 | 0;
 i97 = i33 + 4 | 0;
 i98 = i34 + 4 | 0;
 i99 = i33 + 4 | 0;
 i101 = i116 + 188 | 0;
 i102 = i116 + 52 | 0;
 i103 = i116 + 56 | 0;
 i104 = i116 + 60 | 0;
 i105 = i116 + 24 | 0;
 i106 = i116 + 28 | 0;
 i107 = i116 + 32 | 0;
 i108 = i116 + 36 | 0;
 i110 = i116 + 40 | 0;
 i111 = i116 + 44 | 0;
 i113 = i34 + 4 | 0;
 i118 = 0;
 L4 : while (1) {
  if (HEAP32[i89 >> 2] | 0 ? (HEAP32[i112 >> 2] | 0) == 0 : 0) {
   i4 = HEAP32[i114 >> 2] | 0;
   i12 = HEAP32[i117 + (i118 << 3) >> 2] | 0;
   i13 = HEAP32[i117 + (i118 << 3) + 4 >> 2] | 0;
   i5 = i4 + 24 | 0;
   i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
   HEAP32[i5 >> 2] = i2;
   if (!i2) {
    i2 = HEAP32[i4 >> 2] | 0;
    i11 = i4 + 4 | 0;
    _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
    i2 = HEAP32[i5 >> 2] | 0;
   } else i11 = i4 + 4 | 0;
   i32 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
   i31 = HEAP32[i4 >> 2] | 0;
   HEAP32[i31 + (i32 << 3) >> 2] = i12;
   HEAP32[i31 + (i32 << 3) + 4 >> 2] = i13;
  }
  L14 : do switch (HEAP32[i100 >> 2] | 0) {
  case 0:
   {
    i2 = HEAP32[i117 + (i118 << 3) >> 2] | 0;
    i4 = HEAP32[i117 + (i118 << 3) + 4 >> 2] | 0;
    i32 = HEAP32[i36 >> 2] | 0;
    i31 = i32 + 88 | 0;
    switch (HEAP32[i31 >> 2] | 0) {
    case 0:
     {
      i29 = i32 + 44 | 0;
      i27 = HEAP32[i29 >> 2] | 0;
      HEAP32[i29 >> 2] = i27 + 1;
      i30 = i32 + 16 | 0;
      i28 = HEAP32[i30 >> 2] | 0;
      HEAP32[i28 + (i27 << 3) >> 2] = i2;
      HEAP32[i28 + (i27 << 3) + 4 >> 2] = i4;
      d17 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
      d20 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
      i27 = i32 + 64 | 0;
      HEAPF32[i27 >> 2] = d17 * d17 + d20 * d20 + +HEAPF32[i27 >> 2];
      i28 = i32 + 32 | 0;
      i2 = HEAP32[i28 >> 2] | 0;
      do if ((HEAP32[i29 >> 2] | 0) >>> 0 >= i2 >>> 0) {
       HEAP32[i29 >> 2] = i2 >>> 1;
       i26 = HEAP32[i32 + 36 >> 2] | 0;
       mftCall_vi(HEAP32[i26 + 28 >> 2] | 0, i26 | 0);
       i26 = i32 + 60 | 0;
       i5 = HEAP32[i28 >> 2] | 0;
       d3 = +(i5 >>> 0);
       i25 = i32 + 52 | 0;
       i24 = HEAP32[i25 >> 2] | 0;
       i2 = 0 - i24 | 0;
       if ((i24 | 0) < (i2 | 0)) {
        i4 = 0;
        i2 = 0;
        d3 = 0.0;
       } else {
        d17 = +Math_sqrt(+(+HEAPF32[i26 >> 2] + +HEAPF32[i27 >> 2]));
        d17 = d3 * (d17 * +Math_sqrt(+(+((HEAP32[i32 >> 2] | 0) >>> 0) / d3)));
        d17 = 1.0 / (d17 * +Math_sqrt(+(+HEAPF32[i32 + 12 >> 2])));
        i19 = i32 + 40 | 0;
        i21 = i32 + 28 | 0;
        i22 = i32 + 20 | 0;
        i23 = i32 + 8 | 0;
        i24 = i32 + 24 | 0;
        i18 = i2;
        i4 = 0;
        i2 = 0;
        d3 = 0.0;
        while (1) {
         if (i5 | 0) {
          i11 = 0;
          do {
           i15 = ((i5 - i18 + i11 | 0) >>> 0) % (i5 >>> 0) | 0;
           i14 = HEAP32[i22 >> 2] | 0;
           d8 = +HEAPF32[i14 + (i11 << 3) >> 2];
           d9 = +HEAPF32[i14 + (i11 << 3) + 4 >> 2];
           i14 = HEAP32[i23 >> 2] | 0;
           d10 = +HEAPF32[i14 + (i15 << 3) >> 2];
           d16 = -+HEAPF32[i14 + (i15 << 3) + 4 >> 2];
           d7 = d8 * d10 - d9 * d16;
           d6 = d9 * d10 + d8 * d16;
           if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
            ___mulsc3(i68, d8, d9, d10, d16);
            d7 = +HEAPF32[i68 >> 2];
            d6 = +HEAPF32[i47 >> 2];
           }
           i5 = HEAP32[i24 >> 2] | 0;
           HEAPF32[i5 + (i11 << 3) >> 2] = d7;
           HEAPF32[i5 + (i11 << 3) + 4 >> 2] = d6;
           i11 = i11 + 1 | 0;
           i5 = HEAP32[i28 >> 2] | 0;
          } while (i11 >>> 0 < i5 >>> 0);
         }
         i14 = HEAP32[i19 >> 2] | 0;
         mftCall_vi(HEAP32[i14 + 28 >> 2] | 0, i14 | 0);
         i14 = HEAP32[i21 >> 2] | 0;
         i15 = HEAP32[i28 >> 2] | 0;
         i5 = i15 & -4;
         if (!i5) i5 = 0; else {
          i13 = 0;
          do {
           i11 = i14 + (i13 << 3) | 0;
           d8 = +HEAPF32[i11 >> 2];
           i12 = i14 + (i13 << 3) + 4 | 0;
           d9 = +HEAPF32[i12 >> 2];
           d7 = d17 * d8 - d9 * 0.0;
           d6 = d8 * 0.0 + d17 * d9;
           if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
            ___mulsc3(i33, d8, d9, d17, 0.0);
            d7 = +HEAPF32[i33 >> 2];
            d6 = +HEAPF32[i49 >> 2];
           }
           HEAPF32[i11 >> 2] = d7;
           HEAPF32[i12 >> 2] = d6;
           i12 = i13 | 1;
           i11 = i14 + (i12 << 3) | 0;
           d8 = +HEAPF32[i11 >> 2];
           i12 = i14 + (i12 << 3) + 4 | 0;
           d9 = +HEAPF32[i12 >> 2];
           d7 = d17 * d8 - d9 * 0.0;
           d6 = d8 * 0.0 + d17 * d9;
           if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
            ___mulsc3(i34, d8, d9, d17, 0.0);
            d7 = +HEAPF32[i34 >> 2];
            d6 = +HEAPF32[i50 >> 2];
           }
           HEAPF32[i11 >> 2] = d7;
           HEAPF32[i12 >> 2] = d6;
           i12 = i13 | 2;
           i11 = i14 + (i12 << 3) | 0;
           d8 = +HEAPF32[i11 >> 2];
           i12 = i14 + (i12 << 3) + 4 | 0;
           d9 = +HEAPF32[i12 >> 2];
           d7 = d17 * d8 - d9 * 0.0;
           d6 = d8 * 0.0 + d17 * d9;
           if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
            ___mulsc3(i35, d8, d9, d17, 0.0);
            d7 = +HEAPF32[i35 >> 2];
            d6 = +HEAPF32[i51 >> 2];
           }
           HEAPF32[i11 >> 2] = d7;
           HEAPF32[i12 >> 2] = d6;
           i12 = i13 | 3;
           i11 = i14 + (i12 << 3) | 0;
           d8 = +HEAPF32[i11 >> 2];
           i12 = i14 + (i12 << 3) + 4 | 0;
           d9 = +HEAPF32[i12 >> 2];
           d7 = d17 * d8 - d9 * 0.0;
           d6 = d8 * 0.0 + d17 * d9;
           if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
            ___mulsc3(i46, d8, d9, d17, 0.0);
            d7 = +HEAPF32[i46 >> 2];
            d6 = +HEAPF32[i52 >> 2];
           }
           HEAPF32[i11 >> 2] = d7;
           HEAPF32[i12 >> 2] = d6;
           i13 = i13 + 4 | 0;
          } while (i13 >>> 0 < i5 >>> 0);
         }
         if (i5 >>> 0 < i15 >>> 0) do {
          i11 = i14 + (i5 << 3) | 0;
          d8 = +HEAPF32[i11 >> 2];
          i12 = i14 + (i5 << 3) + 4 | 0;
          d9 = +HEAPF32[i12 >> 2];
          d7 = d17 * d8 - d9 * 0.0;
          d6 = d8 * 0.0 + d17 * d9;
          if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
           ___mulsc3(i57, d8, d9, d17, 0.0);
           d7 = +HEAPF32[i57 >> 2];
           d6 = +HEAPF32[i48 >> 2];
          }
          HEAPF32[i11 >> 2] = d7;
          HEAPF32[i12 >> 2] = d6;
          i5 = i5 + 1 | 0;
         } while ((i5 | 0) != (i15 | 0));
         i5 = HEAP32[i28 >> 2] | 0;
         if (!i5) i5 = 0; else {
          i13 = HEAP32[i21 >> 2] | 0;
          i14 = 0;
          do {
           d7 = +Math_abs(+(+HEAPF32[i13 + (i14 << 3) >> 2]));
           i15 = (HEAPF32[tempDoublePtr >> 2] = d7, HEAP32[tempDoublePtr >> 2] | 0);
           d7 = +Math_abs(+(+HEAPF32[i13 + (i14 << 3) + 4 >> 2]));
           i12 = (HEAPF32[tempDoublePtr >> 2] = d7, HEAP32[tempDoublePtr >> 2] | 0);
           i129 = i15 >>> 0 < i12 >>> 0;
           i11 = i129 ? i12 : i15;
           i12 = i129 ? i15 : i12;
           d7 = (HEAP32[tempDoublePtr >> 2] = i11, +HEAPF32[tempDoublePtr >> 2]);
           d6 = (HEAP32[tempDoublePtr >> 2] = i12, +HEAPF32[tempDoublePtr >> 2]);
           do if ((i12 | 0) != 2139095040) {
            if (i11 >>> 0 > 2139095039 | (i12 | 0) == 0 | (i11 - i12 | 0) >>> 0 > 209715199) {
             d6 = d7 + d6;
             break;
            }
            do if (i11 >>> 0 > 1568669695) {
             d6 = d6 * 8.077935669463161e-28;
             d7 = d7 * 8.077935669463161e-28;
             d8 = 1237940039285380274899124.0e3;
            } else {
             if (i12 >>> 0 >= 562036736) {
              d8 = 1.0;
              break;
             }
             d6 = d6 * 1237940039285380274899124.0e3;
             d7 = d7 * 1237940039285380274899124.0e3;
             d8 = 8.077935669463161e-28;
            } while (0);
            d20 = d7;
            d6 = d8 * +Math_sqrt(+(d20 * d20 + d6 * d6));
           } while (0);
           i129 = d6 > d3;
           d3 = i129 ? d6 : d3;
           i4 = i129 ? i14 : i4;
           i2 = i129 ? i18 : i2;
           i14 = i14 + 1 | 0;
          } while ((i14 | 0) != (i5 | 0));
         }
         if ((i18 | 0) < (HEAP32[i25 >> 2] | 0)) i18 = i18 + 1 | 0; else break;
        }
       }
       i129 = i32 + 56 | 0;
       HEAP32[i129 >> 2] = (HEAP32[i129 >> 2] | 0) + 1;
       if (d3 > +HEAPF32[i32 + 48 >> 2] ? i4 >>> 0 < (i5 - (HEAP32[i32 >> 2] | 0) | 0) >>> 0 : 0) {
        HEAP32[i31 >> 2] = 1;
        HEAP32[i32 + 68 >> 2] = i2;
        i129 = HEAP32[i30 >> 2] | 0;
        _memmove(i129 | 0, i129 + (i4 << 3) | 0, i5 - i4 << 3 | 0) | 0;
        HEAP32[i29 >> 2] = (HEAP32[i28 >> 2] | 0) - i4;
        break;
       }
       i31 = HEAP32[i30 >> 2] | 0;
       i129 = i5 >>> 1;
       _memmove(i31 | 0, i31 + (i129 << 3) | 0, i129 << 3 | 0) | 0;
       HEAP32[i26 >> 2] = HEAP32[i27 >> 2];
       HEAPF32[i27 >> 2] = 0.0;
      } while (0);
      break;
     }
    case 1:
     {
      i21 = i32 + 44 | 0;
      i18 = HEAP32[i21 >> 2] | 0;
      HEAP32[i21 >> 2] = i18 + 1;
      i19 = i32 + 16 | 0;
      i129 = HEAP32[i19 >> 2] | 0;
      HEAP32[i129 + (i18 << 3) >> 2] = i2;
      HEAP32[i129 + (i18 << 3) + 4 >> 2] = i4;
      i18 = i32 + 32 | 0;
      if ((HEAP32[i21 >> 2] | 0) >>> 0 >= (HEAP32[i18 >> 2] | 0) >>> 0) {
       i14 = i32 + 36 | 0;
       i2 = HEAP32[i14 >> 2] | 0;
       mftCall_vi(HEAP32[i2 + 28 >> 2] | 0, i2 | 0);
       i2 = HEAP32[i18 >> 2] | 0;
       if (i2 | 0) {
        i5 = i32 + 68 | 0;
        i11 = i32 + 20 | 0;
        i12 = i32 + 8 | 0;
        i13 = i32 + 24 | 0;
        i4 = 0;
        do {
         i129 = ((i4 + i2 - (HEAP32[i5 >> 2] | 0) | 0) >>> 0) % (i2 >>> 0) | 0;
         i30 = HEAP32[i11 >> 2] | 0;
         d7 = +HEAPF32[i30 + (i4 << 3) >> 2];
         d8 = +HEAPF32[i30 + (i4 << 3) + 4 >> 2];
         i30 = HEAP32[i12 >> 2] | 0;
         d9 = +HEAPF32[i30 + (i129 << 3) >> 2];
         d10 = -+HEAPF32[i30 + (i129 << 3) + 4 >> 2];
         d6 = d7 * d9 - d8 * d10;
         d3 = d8 * d9 + d7 * d10;
         if ((d6 != d6 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
          ___mulsc3(i33, d7, d8, d9, d10);
          d6 = +HEAPF32[i33 >> 2];
          d3 = +HEAPF32[i58 >> 2];
         }
         i2 = HEAP32[i13 >> 2] | 0;
         HEAPF32[i2 + (i4 << 3) >> 2] = d6;
         HEAPF32[i2 + (i4 << 3) + 4 >> 2] = d3;
         i4 = i4 + 1 | 0;
         i2 = HEAP32[i18 >> 2] | 0;
        } while (i4 >>> 0 < i2 >>> 0);
       }
       i5 = HEAP32[i32 + 40 >> 2] | 0;
       mftCall_vi(HEAP32[i5 + 28 >> 2] | 0, i5 | 0);
       i5 = HEAP32[i18 >> 2] | 0;
       i4 = i5 + -1 | 0;
       i15 = i32 + 28 | 0;
       i11 = HEAP32[i15 >> 2] | 0;
       d6 = +Math_abs(+(+HEAPF32[i11 + (i4 << 3) >> 2]));
       i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       d6 = +Math_abs(+(+HEAPF32[i11 + (i4 << 3) + 4 >> 2]));
       i4 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       i30 = i129 >>> 0 < i4 >>> 0;
       i2 = i30 ? i4 : i129;
       i4 = i30 ? i129 : i4;
       d6 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
       d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
       do if ((i4 | 0) != 2139095040) {
        if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
         d3 = d6 + d3;
         break;
        }
        if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
         d3 = d3 * 1237940039285380274899124.0e3;
         d6 = d6 * 1237940039285380274899124.0e3;
         d7 = 8.077935669463161e-28;
        } else d7 = 1.0; else {
         d3 = d3 * 8.077935669463161e-28;
         d6 = d6 * 8.077935669463161e-28;
         d7 = 1237940039285380274899124.0e3;
        }
        d20 = d6;
        d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
       } while (0);
       d9 = +Math_sqrt(+d3);
       d6 = +Math_abs(+(+HEAPF32[i11 >> 2]));
       i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       d6 = +Math_abs(+(+HEAPF32[i11 + 4 >> 2]));
       i4 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       i30 = i129 >>> 0 < i4 >>> 0;
       i2 = i30 ? i4 : i129;
       i4 = i30 ? i129 : i4;
       d6 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
       d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
       do if ((i4 | 0) != 2139095040) {
        if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
         d3 = d6 + d3;
         break;
        }
        if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
         d3 = d3 * 1237940039285380274899124.0e3;
         d6 = d6 * 1237940039285380274899124.0e3;
         d7 = 8.077935669463161e-28;
        } else d7 = 1.0; else {
         d3 = d3 * 8.077935669463161e-28;
         d6 = d6 * 8.077935669463161e-28;
         d7 = 1237940039285380274899124.0e3;
        }
        d20 = d6;
        d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
       } while (0);
       d8 = +Math_sqrt(+d3);
       d6 = +Math_abs(+(+HEAPF32[i11 + 8 >> 2]));
       i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       d6 = +Math_abs(+(+HEAPF32[i11 + 12 >> 2]));
       i4 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       i30 = i129 >>> 0 < i4 >>> 0;
       i2 = i30 ? i4 : i129;
       i4 = i30 ? i129 : i4;
       d6 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
       d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
       do if ((i4 | 0) != 2139095040) {
        if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
         d3 = d6 + d3;
         break;
        }
        if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
         d3 = d3 * 1237940039285380274899124.0e3;
         d6 = d6 * 1237940039285380274899124.0e3;
         d7 = 8.077935669463161e-28;
        } else d7 = 1.0; else {
         d3 = d3 * 8.077935669463161e-28;
         d6 = d6 * 8.077935669463161e-28;
         d7 = 1237940039285380274899124.0e3;
        }
        d20 = d6;
        d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
       } while (0);
       d16 = +Math_sqrt(+d3);
       d17 = (d9 + d16) * .5 - d8;
       d16 = (d16 - d9) * .5;
       d20 = -d16 / (d17 * 2.0);
       HEAPF32[i32 + 72 >> 2] = d20;
       d20 = d8 + (d16 * d20 + d20 * (d17 * d20));
       HEAPF32[i32 + 76 >> 2] = d20 * d20 / (+(i5 >>> 0) * +HEAPF32[i32 + 12 >> 2]);
       _memmove(i11 | 0, HEAP32[i19 >> 2] | 0, i5 << 3 | 0) | 0;
       if (HEAP32[i18 >> 2] | 0) {
        i2 = i32 + 4 | 0;
        i11 = 0;
        do {
         if (i11 >>> 0 < (HEAP32[i32 >> 2] | 0) >>> 0) {
          i129 = HEAP32[i2 >> 2] | 0;
          d9 = +HEAPF32[i129 + (i11 << 3) >> 2];
          d10 = -+HEAPF32[i129 + (i11 << 3) + 4 >> 2];
         } else {
          d9 = 0.0;
          d10 = 0.0;
         }
         i5 = HEAP32[i19 >> 2] | 0;
         i4 = i5 + (i11 << 3) | 0;
         d7 = +HEAPF32[i4 >> 2];
         i5 = i5 + (i11 << 3) + 4 | 0;
         d8 = +HEAPF32[i5 >> 2];
         d6 = d9 * d7 - d10 * d8;
         d3 = d10 * d7 + d9 * d8;
         if ((d6 != d6 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
          ___mulsc3(i34, d7, d8, d9, d10);
          d6 = +HEAPF32[i34 >> 2];
          d3 = +HEAPF32[i56 >> 2];
         }
         HEAPF32[i4 >> 2] = d6;
         HEAPF32[i5 >> 2] = d3;
         i11 = i11 + 1 | 0;
        } while (i11 >>> 0 < (HEAP32[i18 >> 2] | 0) >>> 0);
       }
       i2 = HEAP32[i14 >> 2] | 0;
       mftCall_vi(HEAP32[i2 + 28 >> 2] | 0, i2 | 0);
       i2 = HEAP32[i18 >> 2] | 0;
       i13 = HEAP32[i32 + 20 >> 2] | 0;
       if (!i2) {
        i4 = 0;
        i12 = 0;
        d9 = 0.0;
       } else {
        i12 = 0;
        i5 = 0;
        d8 = 0.0;
        while (1) {
         d6 = +Math_abs(+(+HEAPF32[i13 + (i12 << 3) >> 2]));
         i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
         d6 = +Math_abs(+(+HEAPF32[i13 + (i12 << 3) + 4 >> 2]));
         i11 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
         i30 = i129 >>> 0 < i11 >>> 0;
         i4 = i30 ? i11 : i129;
         i11 = i30 ? i129 : i11;
         d6 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
         d3 = (HEAP32[tempDoublePtr >> 2] = i11, +HEAPF32[tempDoublePtr >> 2]);
         do if ((i11 | 0) != 2139095040) {
          if (i4 >>> 0 > 2139095039 | (i11 | 0) == 0 | (i4 - i11 | 0) >>> 0 > 209715199) {
           d3 = d6 + d3;
           break;
          }
          do if (i4 >>> 0 > 1568669695) {
           d3 = d3 * 8.077935669463161e-28;
           d6 = d6 * 8.077935669463161e-28;
           d7 = 1237940039285380274899124.0e3;
          } else {
           if (i11 >>> 0 >= 562036736) {
            d7 = 1.0;
            break;
           }
           d3 = d3 * 1237940039285380274899124.0e3;
           d6 = d6 * 1237940039285380274899124.0e3;
           d7 = 8.077935669463161e-28;
          } while (0);
          d20 = d6;
          d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
         } while (0);
         i129 = d3 > d8;
         i5 = i129 ? i12 : i5;
         d3 = i129 ? d3 : d8;
         i12 = i12 + 1 | 0;
         if ((i12 | 0) == (i2 | 0)) {
          i4 = i2;
          i12 = i5;
          d9 = d3;
          break;
         } else d8 = d3;
        }
       }
       i5 = ((i4 + -1 + i12 | 0) >>> 0) % (i4 >>> 0) | 0;
       i11 = ((i12 + 1 | 0) >>> 0) % (i4 >>> 0) | 0;
       d3 = +Math_abs(+(+HEAPF32[i13 + (i5 << 3) >> 2]));
       i129 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
       d3 = +Math_abs(+(+HEAPF32[i13 + (i5 << 3) + 4 >> 2]));
       i5 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
       i30 = i129 >>> 0 < i5 >>> 0;
       i4 = i30 ? i5 : i129;
       i5 = i30 ? i129 : i5;
       d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
       d7 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
       do if ((i5 | 0) == 2139095040) d8 = d7; else {
        if (i4 >>> 0 > 2139095039 | (i5 | 0) == 0 | (i4 - i5 | 0) >>> 0 > 209715199) {
         d8 = d3 + d7;
         break;
        }
        if (i4 >>> 0 <= 1568669695) if (i5 >>> 0 < 562036736) {
         d7 = d7 * 1237940039285380274899124.0e3;
         d3 = d3 * 1237940039285380274899124.0e3;
         d6 = 8.077935669463161e-28;
        } else d6 = 1.0; else {
         d7 = d7 * 8.077935669463161e-28;
         d3 = d3 * 8.077935669463161e-28;
         d6 = 1237940039285380274899124.0e3;
        }
        d20 = d3;
        d8 = d7;
        d8 = d6 * +Math_sqrt(+(d20 * d20 + d8 * d8));
       } while (0);
       d6 = +Math_abs(+(+HEAPF32[i13 + (i11 << 3) >> 2]));
       i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       d6 = +Math_abs(+(+HEAPF32[i13 + (i11 << 3) + 4 >> 2]));
       i5 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
       i30 = i129 >>> 0 < i5 >>> 0;
       i4 = i30 ? i5 : i129;
       i5 = i30 ? i129 : i5;
       d6 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
       d3 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
       do if ((i5 | 0) != 2139095040) {
        if (i4 >>> 0 > 2139095039 | (i5 | 0) == 0 | (i4 - i5 | 0) >>> 0 > 209715199) {
         d3 = d6 + d3;
         break;
        }
        if (i4 >>> 0 <= 1568669695) if (i5 >>> 0 < 562036736) {
         d3 = d3 * 1237940039285380274899124.0e3;
         d6 = d6 * 1237940039285380274899124.0e3;
         d7 = 8.077935669463161e-28;
        } else d7 = 1.0; else {
         d3 = d3 * 8.077935669463161e-28;
         d6 = d6 * 8.077935669463161e-28;
         d7 = 1237940039285380274899124.0e3;
        }
        d20 = d6;
        d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
       } while (0);
       d20 = +(i12 >>> 0) + -((d3 - d8) * .5) / (((d8 + d3) * .5 - d9) * 2.0);
       d3 = +(i2 >>> 0);
       d3 = (i12 >>> 0 > i2 >>> 1 >>> 0 ? d20 - d3 : d20) * 2.0 * 3.141592653589793 / d3;
       i4 = i32 + 80 | 0;
       HEAPF32[i4 >> 2] = d3;
       if (!(HEAP32[i32 >> 2] | 0)) {
        d6 = 0.0;
        d3 = 0.0;
       } else {
        i2 = 0;
        d6 = 0.0;
        d20 = 0.0;
        while (1) {
         i129 = HEAP32[i19 >> 2] | 0;
         d16 = +HEAPF32[i129 + (i2 << 3) >> 2];
         d17 = +HEAPF32[i129 + (i2 << 3) + 4 >> 2];
         d10 = d3 * -0.0;
         d8 = -d3;
         d9 = +(i2 >>> 0);
         d7 = d10 * d9 - d10;
         d3 = d10 * 0.0 + d9 * d8;
         if ((d7 != d7 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
          ___mulsc3(i35, d10, d8, d9, 0.0);
          d7 = +HEAPF32[i35 >> 2];
          d3 = +HEAPF32[i53 >> 2];
         }
         _cexpf(i46, d7, d3);
         d8 = +HEAPF32[i46 >> 2];
         d9 = +HEAPF32[i54 >> 2];
         d3 = d16 * d8 - d17 * d9;
         d7 = d17 * d8 + d16 * d9;
         if ((d3 != d3 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
          ___mulsc3(i57, d16, d17, d8, d9);
          d3 = +HEAPF32[i57 >> 2];
          d7 = +HEAPF32[i55 >> 2];
         }
         d6 = d6 + d3;
         d7 = d20 + d7;
         i2 = i2 + 1 | 0;
         if (i2 >>> 0 >= (HEAP32[i32 >> 2] | 0) >>> 0) break;
         d3 = +HEAPF32[i4 >> 2];
         d20 = d7;
        }
        i2 = HEAP32[i18 >> 2] | 0;
        d3 = d7;
       }
       HEAPF32[i32 + 84 >> 2] = +Math_atan2(+d3, +d6);
       HEAP32[i32 + 92 >> 2] = 1;
       i11 = i2 >>> 1;
       _memmove(HEAP32[i19 >> 2] | 0, (HEAP32[i15 >> 2] | 0) + (i11 << 3) | 0, i11 << 3 | 0) | 0;
       HEAP32[i31 >> 2] = 0;
       i11 = HEAP32[i19 >> 2] | 0;
       i12 = HEAP32[i18 >> 2] | 0;
       i5 = i12 & -2;
       i2 = i12 & -4;
       if (!i2) {
        i2 = 0;
        d3 = 0.0;
       } else {
        i4 = 0;
        d3 = 0.0;
        do {
         d10 = +HEAPF32[i11 + (i4 << 2) >> 2];
         d16 = +HEAPF32[i11 + ((i4 | 1) << 2) >> 2];
         d17 = +HEAPF32[i11 + ((i4 | 2) << 2) >> 2];
         d20 = +HEAPF32[i11 + ((i4 | 3) << 2) >> 2];
         d3 = d3 + d10 * d10 + d16 * d16 + d17 * d17 + d20 * d20;
         i4 = i4 + 4 | 0;
        } while (i4 >>> 0 < i2 >>> 0);
       }
       if (i2 >>> 0 < i5 >>> 0) do {
        d20 = +HEAPF32[i11 + (i2 << 2) >> 2];
        d3 = d3 + d20 * d20;
        i2 = i2 + 1 | 0;
       } while ((i2 | 0) != (i5 | 0));
       HEAPF32[i32 + 60 >> 2] = d3;
       HEAPF32[i32 + 64 >> 2] = 0.0;
       HEAP32[i21 >> 2] = i12 >>> 1;
      }
      break;
     }
    default:
     {}
    }
    i2 = i32 + 92 | 0;
    if (HEAP32[i2 >> 2] | 0 ? (HEAP32[i2 >> 2] = 0, i109 = HEAP32[i32 + 28 >> 2] | 0, i109 | 0) : 0) {
     i12 = HEAP32[i36 >> 2] | 0;
     i5 = HEAP32[i12 + 72 >> 2] | 0;
     HEAP32[i37 >> 2] = i5;
     i129 = HEAP32[i12 + 76 >> 2] | 0;
     HEAP32[i38 >> 2] = i129;
     i4 = HEAP32[i12 + 80 >> 2] | 0;
     HEAP32[i39 >> 2] = i4;
     i11 = HEAP32[i12 + 84 >> 2] | 0;
     HEAP32[i40 >> 2] = i11;
     d6 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
     i5 = HEAP32[i41 >> 2] | 0;
     d7 = (HEAP32[tempDoublePtr >> 2] = i129, +HEAPF32[tempDoublePtr >> 2]);
     d3 = (HEAP32[tempDoublePtr >> 2] = i11, +HEAPF32[tempDoublePtr >> 2]);
     if (d6 > 0.0) {
      d6 = d6 * +(i5 >>> 0);
      i2 = 0;
     } else {
      d6 = (d6 + 1.0) * +(i5 >>> 0);
      i2 = 1;
     }
     HEAP32[i42 >> 2] = (~~d6 >>> 0 >>> 0) % (i5 >>> 0) | 0;
     HEAP32[i43 >> 2] = i2;
     HEAPF32[(HEAP32[i44 >> 2] | 0) + 24 >> 2] = .5 / d7;
     i2 = HEAP32[i45 >> 2] | 0;
     HEAP32[i2 + 8 >> 2] = i4;
     i2 = i2 + 4 | 0;
     HEAP32[i2 >> 2] = i11;
     if (!(d3 > 3.141592653589793)) {
      if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
     } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
     HEAP32[i100 >> 2] = 1;
     HEAP32[i112 >> 2] = 1;
     _flexframesync_execute(i116, i109, HEAP32[i12 + 32 >> 2] | 0);
     HEAP32[i112 >> 2] = 0;
    }
    break;
   }
  case 1:
   {
    d3 = +HEAPF32[i117 + (i118 << 3) >> 2];
    d6 = +HEAPF32[i117 + (i118 << 3) + 4 >> 2];
    i129 = HEAP32[i45 >> 2] | 0;
    mftCall_vi(HEAP32[i129 + 1048 >> 2] | 0, i129 | 0);
    d8 = +HEAPF32[i129 + 1040 >> 2];
    d7 = +HEAPF32[i129 + 1044 >> 2] - d8 * 0.0;
    d8 = -d8;
    d9 = d3 * d7 - d6 * d8;
    d10 = d3 * d8 + d6 * d7;
    if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
     ___mulsc3(i33, d3, d6, d7, d8);
     d9 = +HEAPF32[i33 >> 2];
     d10 = +HEAPF32[i59 >> 2];
    }
    i129 = HEAP32[i45 >> 2] | 0;
    i2 = i129 + 4 | 0;
    d3 = +HEAPF32[i129 + 8 >> 2] + +HEAPF32[i2 >> 2];
    HEAPF32[i2 >> 2] = d3;
    if (!(d3 > 3.141592653589793)) {
     if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
    } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
    i4 = HEAP32[(HEAP32[i44 >> 2] | 0) + 16 >> 2] | 0;
    i5 = i4 + 24 | 0;
    i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
    HEAP32[i5 >> 2] = i2;
    if (!i2) {
     i2 = HEAP32[i4 >> 2] | 0;
     i11 = i4 + 4 | 0;
     _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
     i2 = HEAP32[i5 >> 2] | 0;
    } else i11 = i4 + 4 | 0;
    i12 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
    i4 = HEAP32[i4 >> 2] | 0;
    HEAPF32[i4 + (i12 << 3) >> 2] = d9;
    HEAPF32[i4 + (i12 << 3) + 4 >> 2] = d10;
    i12 = HEAP32[i44 >> 2] | 0;
    i4 = HEAP32[i42 >> 2] | 0;
    i2 = HEAP32[i12 + 12 >> 2] | 0;
    if (i2 >>> 0 <= i4 >>> 0) {
     i123 = 146;
     break L4;
    }
    i11 = HEAP32[i12 + 16 >> 2] | 0;
    i11 = (HEAP32[i11 >> 2] | 0) + (HEAP32[i11 + 24 >> 2] << 3) | 0;
    i4 = HEAP32[(HEAP32[i12 + 20 >> 2] | 0) + (i4 << 2) >> 2] | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    i4 = HEAP32[i4 + 4 >> 2] | 0;
    if (!i4) {
     d3 = 0.0;
     d6 = 0.0;
    } else {
     i5 = 0;
     d3 = 0.0;
     d6 = 0.0;
     do {
      d20 = +HEAPF32[i2 + (i5 << 2) >> 2];
      d3 = d3 + d20 * +HEAPF32[i11 + (i5 << 3) >> 2];
      d6 = d6 + d20 * +HEAPF32[i11 + (i5 << 3) + 4 >> 2];
      i5 = i5 + 1 | 0;
     } while ((i5 | 0) != (i4 | 0));
    }
    d20 = +HEAPF32[i12 + 24 >> 2];
    d7 = d3 * d20;
    d3 = d6 * d20;
    i2 = HEAP32[i43 >> 2] | 0;
    HEAP32[i43 >> 2] = i2 + 1;
    if ((i2 | 0) > -1) {
     HEAP32[i43 >> 2] = i2 + -1;
     i4 = HEAP32[i60 >> 2] << 1;
     i2 = HEAP32[i61 >> 2] | 0;
     if (i2 >>> 0 >= i4 >>> 0) {
      i2 = i2 - i4 | 0;
      i129 = HEAP32[i62 >> 2] | 0;
      HEAPF32[i129 + (i2 << 3) >> 2] = d7;
      HEAPF32[i129 + (i2 << 3) + 4 >> 2] = d3;
      i2 = HEAP32[i61 >> 2] | 0;
     }
     HEAP32[i61 >> 2] = i2 + 1;
     if ((i2 | 0) == (i4 + 63 | 0)) HEAP32[i100 >> 2] = 2;
    }
    break;
   }
  case 2:
   {
    d3 = +HEAPF32[i117 + (i118 << 3) >> 2];
    d6 = +HEAPF32[i117 + (i118 << 3) + 4 >> 2];
    i129 = HEAP32[i45 >> 2] | 0;
    mftCall_vi(HEAP32[i129 + 1048 >> 2] | 0, i129 | 0);
    d8 = +HEAPF32[i129 + 1040 >> 2];
    d7 = +HEAPF32[i129 + 1044 >> 2] - d8 * 0.0;
    d8 = -d8;
    d9 = d3 * d7 - d6 * d8;
    d10 = d3 * d8 + d6 * d7;
    if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
     ___mulsc3(i33, d3, d6, d7, d8);
     d9 = +HEAPF32[i33 >> 2];
     d10 = +HEAPF32[i63 >> 2];
    }
    i129 = HEAP32[i45 >> 2] | 0;
    i2 = i129 + 4 | 0;
    d3 = +HEAPF32[i129 + 8 >> 2] + +HEAPF32[i2 >> 2];
    HEAPF32[i2 >> 2] = d3;
    if (!(d3 > 3.141592653589793)) {
     if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
    } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
    i4 = HEAP32[(HEAP32[i44 >> 2] | 0) + 16 >> 2] | 0;
    i5 = i4 + 24 | 0;
    i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
    HEAP32[i5 >> 2] = i2;
    if (!i2) {
     i2 = HEAP32[i4 >> 2] | 0;
     i11 = i4 + 4 | 0;
     _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
     i2 = HEAP32[i5 >> 2] | 0;
    } else i11 = i4 + 4 | 0;
    i12 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
    i4 = HEAP32[i4 >> 2] | 0;
    HEAPF32[i4 + (i12 << 3) >> 2] = d9;
    HEAPF32[i4 + (i12 << 3) + 4 >> 2] = d10;
    i12 = HEAP32[i44 >> 2] | 0;
    i4 = HEAP32[i42 >> 2] | 0;
    i2 = HEAP32[i12 + 12 >> 2] | 0;
    if (i2 >>> 0 <= i4 >>> 0) {
     i123 = 164;
     break L4;
    }
    i11 = HEAP32[i12 + 16 >> 2] | 0;
    i11 = (HEAP32[i11 >> 2] | 0) + (HEAP32[i11 + 24 >> 2] << 3) | 0;
    i4 = HEAP32[(HEAP32[i12 + 20 >> 2] | 0) + (i4 << 2) >> 2] | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    i4 = HEAP32[i4 + 4 >> 2] | 0;
    if (!i4) {
     d7 = 0.0;
     d6 = 0.0;
    } else {
     i5 = 0;
     d7 = 0.0;
     d6 = 0.0;
     do {
      d20 = +HEAPF32[i2 + (i5 << 2) >> 2];
      d7 = d7 + d20 * +HEAPF32[i11 + (i5 << 3) >> 2];
      d6 = d6 + d20 * +HEAPF32[i11 + (i5 << 3) + 4 >> 2];
      i5 = i5 + 1 | 0;
     } while ((i5 | 0) != (i4 | 0));
    }
    d3 = +HEAPF32[i12 + 24 >> 2];
    i2 = HEAP32[i43 >> 2] | 0;
    HEAP32[i43 >> 2] = i2 + 1;
    if ((i2 | 0) > -1 ? (HEAP32[i43 >> 2] = i2 + -1, i129 = HEAP32[i64 >> 2] | 0, i32 = HEAP32[i65 >> 2] | 0, HEAPF32[i32 + (i129 << 3) >> 2] = d7 * d3, HEAPF32[i32 + (i129 << 3) + 4 >> 2] = d6 * d3, i129 = (HEAP32[i64 >> 2] | 0) + 1 | 0, HEAP32[i64 >> 2] = i129, (i129 | 0) == (HEAP32[i66 >> 2] | 0)) : 0) {
     i19 = HEAP32[i67 >> 2] | 0;
     i21 = HEAP32[i65 >> 2] | 0;
     i22 = HEAP32[i69 >> 2] | 0;
     i18 = i19 + 8 | 0;
     if (HEAP32[i18 >> 2] | 0) {
      i2 = i19 + 4 | 0;
      i4 = i19 + 16 | 0;
      i5 = i19 + 24 | 0;
      i11 = 0;
      do {
       i129 = Math_imul(HEAP32[i2 >> 2] | 0, i11) | 0;
       d7 = +HEAPF32[i21 + (i129 << 3) >> 2];
       d8 = +HEAPF32[i21 + (i129 << 3) + 4 >> 2];
       i129 = HEAP32[i4 >> 2] | 0;
       d9 = +HEAPF32[i129 + (i11 << 3) >> 2];
       d10 = -+HEAPF32[i129 + (i11 << 3) + 4 >> 2];
       d6 = d7 * d9 - d8 * d10;
       d3 = d8 * d9 + d7 * d10;
       if ((d6 != d6 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
        ___mulsc3(i33, d7, d8, d9, d10);
        d6 = +HEAPF32[i33 >> 2];
        d3 = +HEAPF32[i95 >> 2];
       }
       i129 = HEAP32[i5 >> 2] | 0;
       HEAPF32[i129 + (i11 << 3) >> 2] = d6;
       HEAPF32[i129 + (i11 << 3) + 4 >> 2] = d3;
       i11 = i11 + 1 | 0;
      } while (i11 >>> 0 < (HEAP32[i18 >> 2] | 0) >>> 0);
     }
     i14 = HEAP32[i19 + 32 >> 2] | 0;
     mftCall_vi(HEAP32[i14 + 28 >> 2] | 0, i14 | 0);
     i14 = HEAP32[i19 + 20 >> 2] | 0;
     i13 = HEAP32[i19 + 28 >> 2] | 0;
     if (!i14) {
      i2 = 0;
      i11 = 0;
      d9 = 0.0;
     } else {
      i11 = i13 + 4 | 0;
      i12 = 0;
      i4 = 0;
      d10 = 0.0;
      while (1) {
       if (i12) {
        d6 = +HEAPF32[i13 + (i12 << 3) >> 2];
        d3 = +HEAPF32[i13 + (i12 << 3) + 4 >> 2];
        d8 = +Math_abs(+d6);
        i129 = (HEAPF32[tempDoublePtr >> 2] = d8, HEAP32[tempDoublePtr >> 2] | 0);
        d8 = +Math_abs(+d3);
        i5 = (HEAPF32[tempDoublePtr >> 2] = d8, HEAP32[tempDoublePtr >> 2] | 0);
        i32 = i129 >>> 0 < i5 >>> 0;
        i2 = i32 ? i5 : i129;
        i5 = i32 ? i129 : i5;
        d8 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
        d7 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
        do if ((i5 | 0) != 2139095040) {
         if (i2 >>> 0 > 2139095039 | (i5 | 0) == 0 | (i2 - i5 | 0) >>> 0 > 209715199) {
          d7 = d8 + d7;
          break;
         }
         do if (i2 >>> 0 > 1568669695) {
          d7 = d7 * 8.077935669463161e-28;
          d8 = d8 * 8.077935669463161e-28;
          d9 = 1237940039285380274899124.0e3;
         } else {
          if (i5 >>> 0 >= 562036736) {
           d9 = 1.0;
           break;
          }
          d7 = d7 * 1237940039285380274899124.0e3;
          d8 = d8 * 1237940039285380274899124.0e3;
          d9 = 8.077935669463161e-28;
         } while (0);
         d20 = d8;
         d7 = d9 * +Math_sqrt(+(d20 * d20 + d7 * d7));
        } while (0);
        if (d7 > d10) i123 = 187; else d6 = d10;
       } else {
        d6 = +HEAPF32[i13 >> 2];
        d3 = +HEAPF32[i11 >> 2];
        i123 = 187;
       }
       do if ((i123 | 0) == 187) {
        i123 = 0;
        d6 = +Math_abs(+d6);
        i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
        d3 = +Math_abs(+d3);
        i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
        i32 = i129 >>> 0 < i4 >>> 0;
        i2 = i32 ? i4 : i129;
        i4 = i32 ? i129 : i4;
        d3 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
        d6 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
        if ((i4 | 0) == 2139095040) i4 = i12; else {
         if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
          i4 = i12;
          d6 = d3 + d6;
          break;
         }
         do if (i2 >>> 0 > 1568669695) {
          d6 = d6 * 8.077935669463161e-28;
          d3 = d3 * 8.077935669463161e-28;
          d7 = 1237940039285380274899124.0e3;
         } else {
          if (i4 >>> 0 >= 562036736) {
           d7 = 1.0;
           break;
          }
          d6 = d6 * 1237940039285380274899124.0e3;
          d3 = d3 * 1237940039285380274899124.0e3;
          d7 = 8.077935669463161e-28;
         } while (0);
         d20 = d3;
         i4 = i12;
         d6 = d7 * +Math_sqrt(+(d20 * d20 + d6 * d6));
        }
       } while (0);
       i12 = i12 + 1 | 0;
       if ((i12 | 0) == (i14 | 0)) {
        i2 = i14;
        i11 = i4;
        d9 = d6;
        break;
       } else d10 = d6;
      }
     }
     i5 = ((i2 + -1 + i11 | 0) >>> 0) % (i2 >>> 0) | 0;
     i4 = ((i11 + 1 | 0) >>> 0) % (i2 >>> 0) | 0;
     d3 = +Math_abs(+(+HEAPF32[i13 + (i4 << 3) >> 2]));
     i129 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     d3 = +Math_abs(+(+HEAPF32[i13 + (i4 << 3) + 4 >> 2]));
     i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     i32 = i129 >>> 0 < i4 >>> 0;
     i2 = i32 ? i4 : i129;
     i4 = i32 ? i129 : i4;
     d3 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
     d7 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) == 2139095040) d8 = d7; else {
      if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
       d8 = d3 + d7;
       break;
      }
      if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
       d7 = d7 * 1237940039285380274899124.0e3;
       d3 = d3 * 1237940039285380274899124.0e3;
       d6 = 8.077935669463161e-28;
      } else d6 = 1.0; else {
       d7 = d7 * 8.077935669463161e-28;
       d3 = d3 * 8.077935669463161e-28;
       d6 = 1237940039285380274899124.0e3;
      }
      d20 = d3;
      d8 = d7;
      d8 = d6 * +Math_sqrt(+(d20 * d20 + d8 * d8));
     } while (0);
     d6 = +Math_abs(+(+HEAPF32[i13 + (i5 << 3) >> 2]));
     i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
     d6 = +Math_abs(+(+HEAPF32[i13 + (i5 << 3) + 4 >> 2]));
     i4 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
     i32 = i129 >>> 0 < i4 >>> 0;
     i2 = i32 ? i4 : i129;
     i4 = i32 ? i129 : i4;
     d6 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
     d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) != 2139095040) {
      if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
       d3 = d6 + d3;
       break;
      }
      if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
       d3 = d3 * 1237940039285380274899124.0e3;
       d6 = d6 * 1237940039285380274899124.0e3;
       d7 = 8.077935669463161e-28;
      } else d7 = 1.0; else {
       d3 = d3 * 8.077935669463161e-28;
       d6 = d6 * 8.077935669463161e-28;
       d7 = 1237940039285380274899124.0e3;
      }
      d20 = d6;
      d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
     } while (0);
     d3 = +(i11 >>> 0) + -((d8 - d3) * .5) / (((d8 + d3) * .5 - d9) * 2.0);
     i15 = i19 + 4 | 0;
     d3 = (i11 >>> 0 > i14 >>> 1 >>> 0 ? d3 - +(i14 >>> 0) : d3) * 2.0 * 3.141592653589793 / +((Math_imul(HEAP32[i15 >> 2] | 0, i14) | 0) >>> 0);
     i13 = i19 + 36 | 0;
     HEAPF32[i13 >> 2] = d3;
     if (!(HEAP32[i18 >> 2] | 0)) {
      d8 = 0.0;
      d6 = 0.0;
      d3 = 0.0;
     } else {
      i5 = i19 + 24 | 0;
      i4 = 0;
      d6 = 0.0;
      d20 = 0.0;
      while (1) {
       i129 = HEAP32[i5 >> 2] | 0;
       d16 = +HEAPF32[i129 + (i4 << 3) >> 2];
       d17 = +HEAPF32[i129 + (i4 << 3) + 4 >> 2];
       d10 = d3 * -0.0;
       d8 = -d3;
       d9 = +(i4 >>> 0);
       d7 = d10 * d9 - d10;
       d3 = d10 * 0.0 + d9 * d8;
       if ((d7 != d7 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
        ___mulsc3(i34, d10, d8, d9, 0.0);
        d7 = +HEAPF32[i34 >> 2];
        d3 = +HEAPF32[i92 >> 2];
       }
       d8 = +((HEAP32[i15 >> 2] | 0) >>> 0);
       _cexpf(i35, d7 * d8, d3 * d8);
       d8 = +HEAPF32[i35 >> 2];
       d9 = +HEAPF32[i93 >> 2];
       d3 = d16 * d8 - d17 * d9;
       d7 = d17 * d8 + d16 * d9;
       if ((d3 != d3 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
        ___mulsc3(i46, d16, d17, d8, d9);
        d3 = +HEAPF32[i46 >> 2];
        d7 = +HEAPF32[i94 >> 2];
       }
       d6 = d6 + d3;
       d7 = d20 + d7;
       i4 = i4 + 1 | 0;
       i2 = HEAP32[i18 >> 2] | 0;
       if (i4 >>> 0 >= i2 >>> 0) break;
       d3 = +HEAPF32[i13 >> 2];
       d20 = d7;
      }
      d8 = +(i2 >>> 0);
      d3 = d7;
     }
     i12 = i19 + 40 | 0;
     HEAPF32[i12 >> 2] = +Math_atan2(+d3, +d6);
     d6 = +Math_abs(+d6);
     i129 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
     d6 = +Math_abs(+d3);
     i4 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
     i32 = i129 >>> 0 < i4 >>> 0;
     i2 = i32 ? i4 : i129;
     i4 = i32 ? i129 : i4;
     d6 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
     d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) != 2139095040) {
      if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
       d3 = d6 + d3;
       break;
      }
      do if (i2 >>> 0 > 1568669695) {
       d3 = d3 * 8.077935669463161e-28;
       d6 = d6 * 8.077935669463161e-28;
       d7 = 1237940039285380274899124.0e3;
      } else {
       if (i4 >>> 0 >= 562036736) {
        d7 = 1.0;
        break;
       }
       d3 = d3 * 1237940039285380274899124.0e3;
       d6 = d6 * 1237940039285380274899124.0e3;
       d7 = 8.077935669463161e-28;
      } while (0);
      d20 = d6;
      d3 = d7 * +Math_sqrt(+(d20 * d20 + d3 * d3));
     } while (0);
     d16 = d3 / d8;
     HEAPF32[i19 + 44 >> 2] = d16;
     d16 = 1.0 / d16;
     i11 = i19 + 12 | 0;
     i2 = HEAP32[i11 >> 2] | 0;
     if (i2 | 0) {
      i5 = 0;
      i4 = 0;
      do {
       if ((i5 >>> 0) % ((HEAP32[i15 >> 2] | 0) >>> 0) | 0) {
        d7 = d16 * +HEAPF32[i21 + (i5 << 3) >> 2];
        d8 = d16 * +HEAPF32[i21 + (i5 << 3) + 4 >> 2];
        d9 = +(i5 >>> 0) * +HEAPF32[i13 >> 2] + +HEAPF32[i12 >> 2];
        _cexpf(i57, d9 * -0.0, -d9);
        d9 = +HEAPF32[i57 >> 2];
        d10 = +HEAPF32[i90 >> 2];
        d6 = d7 * d9 - d8 * d10;
        d3 = d8 * d9 + d7 * d10;
        if ((d6 != d6 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
         ___mulsc3(i68, d7, d8, d9, d10);
         d6 = +HEAPF32[i68 >> 2];
         d3 = +HEAPF32[i91 >> 2];
        }
        HEAPF32[i22 + (i4 << 3) >> 2] = d6;
        HEAPF32[i22 + (i4 << 3) + 4 >> 2] = d3;
        i2 = HEAP32[i11 >> 2] | 0;
        i4 = i4 + 1 | 0;
       }
       i5 = i5 + 1 | 0;
      } while (i5 >>> 0 < i2 >>> 0);
     }
     i14 = HEAP32[i70 >> 2] | 0;
     i4 = HEAP32[i69 >> 2] | 0;
     i15 = HEAP32[i71 >> 2] | 0;
     i5 = i14 + 32 | 0;
     if (!(HEAP32[i5 >> 2] | 0)) i2 = i14 + 16 | 0; else {
      i2 = i14 + 16 | 0;
      i11 = i14 + 24 | 0;
      i12 = i14 + 8 | 0;
      i13 = 0;
      do {
       i129 = HEAP32[i14 >> 2] | 0;
       i31 = HEAP32[i4 + (i13 << 3) + 4 >> 2] | 0;
       i32 = HEAP32[i129 + 240 >> 2] | 0;
       HEAP32[i34 >> 2] = HEAP32[i4 + (i13 << 3) >> 2];
       HEAP32[i88 >> 2] = i31;
       HEAP32[i33 >> 2] = HEAP32[i34 >> 2];
       HEAP32[i33 + 4 >> 2] = HEAP32[i34 + 4 >> 2];
       mftCall_viii(i32 | 0, i129 | 0, i33 | 0, i35 | 0);
       i129 = HEAP32[i12 >> 2] | 0;
       i32 = Math_imul(i129, i13) | 0;
       _liquid_pack_array(HEAP32[i2 >> 2] | 0, HEAP32[i11 >> 2] | 0, i32, i129, HEAP32[i35 >> 2] | 0);
       i13 = i13 + 1 | 0;
      } while (i13 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
     }
     i129 = _packetizer_decode(HEAP32[i14 + 4 >> 2] | 0, HEAP32[i2 >> 2] | 0, i15) | 0;
     HEAP32[i72 >> 2] = i129;
     L345 : do if (i129 | 0) {
      i2 = HEAP32[i67 >> 2] | 0;
      d3 = +HEAPF32[i2 + 36 >> 2];
      d20 = +HEAPF32[i2 + 40 >> 2];
      i2 = HEAP32[i74 >> 2] | 0;
      HEAPF32[i2 + 8 >> 2] = d3;
      d3 = d20 + d3 * +((HEAP32[i66 >> 2] | 0) >>> 0);
      i2 = i2 + 4 | 0;
      HEAPF32[i2 >> 2] = d3;
      do if (d3 > 3.141592653589793) HEAPF32[i2 >> 2] = d3 + -6.283185307179586; else {
       if (!(d3 < -3.141592653589793)) break;
       HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
      } while (0);
      i4 = HEAP32[i81 >> 2] | 0;
      i5 = HEAP32[i71 >> 2] | 0;
      i2 = HEAP8[i5 + i4 >> 0] | 0;
      if (i2 << 24 >> 24 != 101) {
       HEAP32[i122 >> 2] = i2 & 255;
       HEAP32[i122 + 4 >> 2] = 101;
       _fprintf(gb + 8728 | 0, gb + 23495 | 0, i122);
       HEAP32[i72 >> 2] = 0;
       break;
      }
      i11 = HEAPU8[i5 + (i4 + 1) >> 0] << 8 | HEAPU8[i5 + (i4 + 2) >> 0];
      HEAP32[i82 >> 2] = i11;
      i129 = HEAP8[i5 + (i4 + 3) >> 0] | 0;
      i12 = i129 & 255;
      i14 = HEAPU8[i5 + (i4 + 4) >> 0] | 0;
      i13 = i14 >>> 5;
      i14 = i14 & 31;
      i4 = HEAPU8[i5 + (i4 + 5) >> 0] & 31;
      if ((i129 + -1 & 255) > 58) {
       i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i2) {
        i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
        i2 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i2 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i2;
         i123 = 252;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i2 | 32;
         break;
        }
       } else {
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        i123 = 252;
       } while (0);
       do if ((i123 | 0) == 252) {
        i123 = 0;
        if ((i2 - i4 | 0) >>> 0 < 66) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23578 | 0, 66) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23578 | 0, 66) | 0) >>> 0 < 66) break;
         i2 = 0;
         i5 = gb + 23578 + 66 | 0;
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 66;
         i5 = gb + 23578 | 0;
        }
        _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       HEAP32[i72 >> 2] = 0;
       break;
      }
      switch (i13 | 0) {
      case 0:
      case 7:
       {
        i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
        do if (!i2) {
         i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
         HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
         i2 = HEAP32[gb + 8728 >> 2] | 0;
         if (!(i2 & 8)) {
          HEAP32[gb + 8728 + 8 >> 2] = 0;
          HEAP32[gb + 8728 + 4 >> 2] = 0;
          i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
          HEAP32[gb + 8728 + 28 >> 2] = i4;
          HEAP32[gb + 8728 + 20 >> 2] = i4;
          i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
          HEAP32[gb + 8728 + 16 >> 2] = i2;
          i123 = 265;
          break;
         } else {
          HEAP32[gb + 8728 >> 2] = i2 | 32;
          break;
         }
        } else {
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
         i123 = 265;
        } while (0);
        do if ((i123 | 0) == 265) {
         i123 = 0;
         if ((i2 - i4 | 0) >>> 0 < 70) {
          mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23645 | 0, 70) | 0;
          break;
         }
         if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
          if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23645 | 0, 70) | 0) >>> 0 < 70) break;
          i2 = 0;
          i5 = gb + 23645 + 70 | 0;
          i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
         } else {
          i2 = 70;
          i5 = gb + 23645 | 0;
         }
         _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
         HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
        } while (0);
        HEAP32[i72 >> 2] = 0;
        break L345;
       }
      default:
       {}
      }
      if ((i14 + -1 | 0) >>> 0 > 26) {
       i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i2) {
        i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
        i2 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i2 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i2;
         i123 = 278;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i2 | 32;
         break;
        }
       } else {
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        i123 = 278;
       } while (0);
       do if ((i123 | 0) == 278) {
        i123 = 0;
        if ((i2 - i4 | 0) >>> 0 < 78) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23716 | 0, 78) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23716 | 0, 78) | 0) >>> 0 < 78) break;
         i2 = 0;
         i5 = gb + 23716 + 78 | 0;
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 78;
         i5 = gb + 23716 | 0;
        }
        _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       HEAP32[i72 >> 2] = 0;
       break;
      }
      if ((i4 + -1 | 0) >>> 0 > 26) {
       i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i2) {
        i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
        i2 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i2 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i2;
         i123 = 291;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i2 | 32;
         break;
        }
       } else {
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        i123 = 291;
       } while (0);
       do if ((i123 | 0) == 291) {
        i123 = 0;
        if ((i2 - i4 | 0) >>> 0 < 78) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23795 | 0, 78) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23795 | 0, 78) | 0) >>> 0 < 78) break;
         i2 = 0;
         i5 = gb + 23795 + 78 | 0;
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 78;
         i5 = gb + 23795 | 0;
        }
        _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       HEAP32[i72 >> 2] = 0;
       break;
      }
      i2 = HEAP32[i83 >> 2] | 0;
      if ((HEAP32[i2 >> 2] | 0) != (i12 | 0)) {
       _modem_destroy(i2);
       i2 = _modem_create(i12) | 0;
      }
      HEAP32[i83 >> 2] = i2;
      _qpacketmodem_configure(HEAP32[i84 >> 2] | 0, i11, i13, i14, i4, i12);
      i129 = HEAP32[(HEAP32[i84 >> 2] | 0) + 32 >> 2] | 0;
      HEAP32[i85 >> 2] = i129;
      HEAP32[i86 >> 2] = _realloc(HEAP32[i86 >> 2] | 0, i129 << 3) | 0;
      i129 = _realloc(HEAP32[i87 >> 2] | 0, HEAP32[i82 >> 2] | 0) | 0;
      HEAP32[i87 >> 2] = i129;
      if (!((i129 | 0) == 0 | (HEAP32[i86 >> 2] | 0) == 0)) {
       if (!(HEAP32[i72 >> 2] | 0)) break;
       HEAP32[i64 >> 2] = 0;
       HEAP32[i100 >> 2] = 3;
       break L14;
      }
      i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
      do if (!i2) {
       i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
       HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
       i2 = HEAP32[gb + 8728 >> 2] | 0;
       if (!(i2 & 8)) {
        HEAP32[gb + 8728 + 8 >> 2] = 0;
        HEAP32[gb + 8728 + 4 >> 2] = 0;
        i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
        HEAP32[gb + 8728 + 28 >> 2] = i4;
        HEAP32[gb + 8728 + 20 >> 2] = i4;
        i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
        HEAP32[gb + 8728 + 16 >> 2] = i2;
        i123 = 306;
        break;
       } else {
        HEAP32[gb + 8728 >> 2] = i2 | 32;
        break;
       }
      } else {
       i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       i123 = 306;
      } while (0);
      do if ((i123 | 0) == 306) {
       i123 = 0;
       if ((i2 - i4 | 0) >>> 0 < 75) {
        mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23874 | 0, 75) | 0;
        break;
       }
       if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
        if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23874 | 0, 75) | 0) >>> 0 < 75) break;
        i2 = 0;
        i5 = gb + 23874 + 75 | 0;
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       } else {
        i2 = 75;
        i5 = gb + 23874 | 0;
       }
       _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
       HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
      } while (0);
      HEAP32[i72 >> 2] = 0;
     } while (0);
     HEAP32[i73 >> 2] = (HEAP32[i73 >> 2] | 0) + 1;
     i5 = HEAP32[i116 >> 2] | 0;
     if (i5 | 0) {
      HEAPF32[i76 >> 2] = 0.0;
      d3 = +HEAPF32[i38 >> 2];
      i2 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
      i4 = (i2 | 0) < 0;
      do if (i2 >>> 0 < 8388608 | i4) {
       d20 = +Math_abs(+d3);
       if (!((HEAPF32[tempDoublePtr >> 2] = d20, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
        d3 = -1.0 / (d3 * d3);
        break;
       }
       if (i4) {
        d3 = (d3 - d3) / 0.0;
        break;
       } else {
        i2 = (HEAPF32[tempDoublePtr >> 2] = d3 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
        i4 = -152;
        i123 = 324;
        break;
       }
      } else {
       if (i2 >>> 0 > 2139095039) break;
       if ((i2 | 0) == 1065353216) d3 = 0.0; else {
        i4 = -127;
        i123 = 324;
       }
      } while (0);
      if ((i123 | 0) == 324) {
       i123 = 0;
       i129 = i2 + 4913933 | 0;
       d9 = (HEAP32[tempDoublePtr >> 2] = (i129 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
       d10 = d9 / (d9 + 2.0);
       d17 = d10 * d10;
       d3 = d17 * d17;
       d16 = d9 * (d9 * .5);
       d20 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d9 - d16, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
       d3 = d9 - d20 - d16 + d10 * (d16 + (d17 * (d3 * .2849878668785095 + .6666666269302368) + d3 * (d3 * .24279078841209412 + .40000972151756287)));
       d17 = +((i129 >>> 23) + i4 | 0);
       d3 = d17 * .3010292053222656 + (d20 * .434326171875 + (d3 * .434326171875 + (d17 * 7.903415166765626e-07 - (d20 + d3) * 3.168997136526741e-05)));
      }
      HEAPF32[i77 >> 2] = d3 * 20.0;
      HEAP32[i78 >> 2] = HEAP32[(HEAP32[i45 >> 2] | 0) + 8 >> 2];
      HEAP32[i79 >> 2] = 0;
      HEAP32[i79 + 4 >> 2] = 0;
      HEAP32[i79 + 8 >> 2] = 0;
      HEAP32[i79 + 12 >> 2] = 0;
      HEAP32[i79 + 16 >> 2] = 0;
      HEAP32[i79 + 20 >> 2] = 0;
      HEAP32[i79 + 24 >> 2] = 0;
      i2 = HEAP32[i71 >> 2] | 0;
      i4 = HEAP32[i80 >> 2] | 0;
      i12 = i33;
      i13 = i76;
      i14 = i12 + 40 | 0;
      do {
       HEAP32[i12 >> 2] = HEAP32[i13 >> 2];
       i12 = i12 + 4 | 0;
       i13 = i13 + 4 | 0;
      } while ((i12 | 0) < (i14 | 0));
      mftCall_iiiiiiii(i5 | 0, i2 | 0, 0, 0, 0, 0, i33 | 0, i4 | 0) | 0;
     }
     i129 = HEAP32[i45 >> 2] | 0;
     HEAPF32[i129 + 4 >> 2] = 0.0;
     HEAPF32[i129 + 8 >> 2] = 0.0;
     HEAP32[i129 + 1036 >> 2] = 0;
     HEAPF32[i129 + 1040 >> 2] = 0.0;
     HEAPF32[i129 + 1044 >> 2] = 1.0;
     i129 = HEAP32[i74 >> 2] | 0;
     HEAPF32[i129 + 4 >> 2] = 0.0;
     HEAPF32[i129 + 8 >> 2] = 0.0;
     HEAP32[i129 + 1036 >> 2] = 0;
     HEAPF32[i129 + 1040 >> 2] = 0.0;
     HEAPF32[i129 + 1044 >> 2] = 1.0;
     i129 = HEAP32[(HEAP32[i44 >> 2] | 0) + 16 >> 2] | 0;
     HEAP32[i129 + 24 >> 2] = 0;
     _memset(HEAP32[i129 >> 2] | 0, 0, HEAP32[i129 + 20 >> 2] << 3 | 0) | 0;
     HEAP32[i100 >> 2] = 0;
     HEAP32[i61 >> 2] = 0;
     HEAP32[i64 >> 2] = 0;
     HEAPF32[i75 >> 2] = 0.0;
    }
    break;
   }
  case 3:
   {
    d3 = +HEAPF32[i117 + (i118 << 3) >> 2];
    d6 = +HEAPF32[i117 + (i118 << 3) + 4 >> 2];
    i129 = HEAP32[i45 >> 2] | 0;
    mftCall_vi(HEAP32[i129 + 1048 >> 2] | 0, i129 | 0);
    d8 = +HEAPF32[i129 + 1040 >> 2];
    d7 = +HEAPF32[i129 + 1044 >> 2] - d8 * 0.0;
    d8 = -d8;
    d9 = d3 * d7 - d6 * d8;
    d10 = d3 * d8 + d6 * d7;
    if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
     ___mulsc3(i33, d3, d6, d7, d8);
     d9 = +HEAPF32[i33 >> 2];
     d10 = +HEAPF32[i96 >> 2];
    }
    i129 = HEAP32[i45 >> 2] | 0;
    i2 = i129 + 4 | 0;
    d3 = +HEAPF32[i129 + 8 >> 2] + +HEAPF32[i2 >> 2];
    HEAPF32[i2 >> 2] = d3;
    if (!(d3 > 3.141592653589793)) {
     if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
    } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
    i4 = HEAP32[(HEAP32[i44 >> 2] | 0) + 16 >> 2] | 0;
    i5 = i4 + 24 | 0;
    i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
    HEAP32[i5 >> 2] = i2;
    if (!i2) {
     i2 = HEAP32[i4 >> 2] | 0;
     i11 = i4 + 4 | 0;
     _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
     i2 = HEAP32[i5 >> 2] | 0;
    } else i11 = i4 + 4 | 0;
    i12 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
    i4 = HEAP32[i4 >> 2] | 0;
    HEAPF32[i4 + (i12 << 3) >> 2] = d9;
    HEAPF32[i4 + (i12 << 3) + 4 >> 2] = d10;
    i12 = HEAP32[i44 >> 2] | 0;
    i4 = HEAP32[i42 >> 2] | 0;
    i2 = HEAP32[i12 + 12 >> 2] | 0;
    if (i2 >>> 0 <= i4 >>> 0) {
     i123 = 337;
     break L4;
    }
    i11 = HEAP32[i12 + 16 >> 2] | 0;
    i11 = (HEAP32[i11 >> 2] | 0) + (HEAP32[i11 + 24 >> 2] << 3) | 0;
    i4 = HEAP32[(HEAP32[i12 + 20 >> 2] | 0) + (i4 << 2) >> 2] | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    i4 = HEAP32[i4 + 4 >> 2] | 0;
    if (!i4) {
     d7 = 0.0;
     d6 = 0.0;
    } else {
     i5 = 0;
     d7 = 0.0;
     d6 = 0.0;
     do {
      d20 = +HEAPF32[i2 + (i5 << 2) >> 2];
      d7 = d7 + d20 * +HEAPF32[i11 + (i5 << 3) >> 2];
      d6 = d6 + d20 * +HEAPF32[i11 + (i5 << 3) + 4 >> 2];
      i5 = i5 + 1 | 0;
     } while ((i5 | 0) != (i4 | 0));
    }
    d3 = +HEAPF32[i12 + 24 >> 2];
    i2 = HEAP32[i43 >> 2] | 0;
    HEAP32[i43 >> 2] = i2 + 1;
    if ((i2 | 0) > -1) {
     d10 = d6 * d3;
     d8 = d7 * d3;
     HEAP32[i43 >> 2] = i2 + -1;
     i129 = HEAP32[i74 >> 2] | 0;
     mftCall_vi(HEAP32[i129 + 1048 >> 2] | 0, i129 | 0);
     d6 = +HEAPF32[i129 + 1040 >> 2];
     d3 = +HEAPF32[i129 + 1044 >> 2] - d6 * 0.0;
     d6 = -d6;
     d7 = d8 * d3 - d10 * d6;
     d9 = d8 * d6 + d10 * d3;
     if ((d7 != d7 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
      ___mulsc3(i33, d8, d10, d3, d6);
      d7 = +HEAPF32[i33 >> 2];
      d9 = +HEAPF32[i97 >> 2];
     }
     i129 = HEAP32[i83 >> 2] | 0;
     i32 = HEAP32[i129 + 240 >> 2] | 0;
     HEAPF32[i34 >> 2] = d7;
     HEAPF32[i98 >> 2] = d9;
     HEAP32[i33 >> 2] = HEAP32[i34 >> 2];
     HEAP32[i33 + 4 >> 2] = HEAP32[i34 + 4 >> 2];
     mftCall_viii(i32 | 0, i129 | 0, i33 | 0, i46 | 0);
     i129 = HEAP32[i83 >> 2] | 0;
     d8 = +HEAPF32[i129 + 84 >> 2];
     d16 = +HEAPF32[i129 + 88 >> 2];
     d3 = +HEAPF32[i129 + 92 >> 2];
     d10 = +HEAPF32[i129 + 96 >> 2];
     d6 = -d10;
     d20 = d8 * d3 - d16 * d6;
     d17 = d16 * d3 + d8 * d6;
     if ((d20 != d20 | 0.0 != 0.0) & (d17 != d17 | 0.0 != 0.0)) {
      ___mulsc3(i33, d8, d16, d3, d6);
      i129 = HEAP32[i83 >> 2] | 0;
      d3 = +HEAPF32[i129 + 92 >> 2];
      d8 = +HEAPF32[i129 + 84 >> 2];
      d10 = +HEAPF32[i129 + 96 >> 2];
      d6 = +HEAPF32[i129 + 88 >> 2];
      d17 = +HEAPF32[i99 >> 2];
     } else d6 = d16;
     d3 = +Math_abs(+(d3 - d8));
     i129 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     d3 = +Math_abs(+(d10 - d6));
     i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     i32 = i129 >>> 0 < i4 >>> 0;
     i2 = i32 ? i4 : i129;
     i4 = i32 ? i129 : i4;
     d3 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
     d8 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) != 2139095040) {
      if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
       d8 = d3 + d8;
       break;
      }
      if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
       d8 = d8 * 1237940039285380274899124.0e3;
       d3 = d3 * 1237940039285380274899124.0e3;
       d6 = 8.077935669463161e-28;
      } else d6 = 1.0; else {
       d8 = d8 * 8.077935669463161e-28;
       d3 = d3 * 8.077935669463161e-28;
       d6 = 1237940039285380274899124.0e3;
      }
      d20 = d3;
      d8 = d6 * +Math_sqrt(+(d20 * d20 + d8 * d8));
     } while (0);
     i129 = HEAP32[i74 >> 2] | 0;
     i2 = i129 + 8 | 0;
     d10 = +HEAPF32[i2 >> 2] + d17 * +HEAPF32[i129 + 1052 >> 2];
     HEAPF32[i2 >> 2] = d10;
     i2 = i129 + 4 | 0;
     d3 = +HEAPF32[i2 >> 2] + d17 * +HEAPF32[i129 + 1056 >> 2];
     HEAPF32[i2 >> 2] = d3;
     d6 = d3;
     if (!(d6 > 3.141592653589793)) {
      if (d6 < -3.141592653589793) {
       d3 = d6 + 6.283185307179586;
       HEAPF32[i2 >> 2] = d3;
      }
     } else {
      d3 = d6 + -6.283185307179586;
      HEAPF32[i2 >> 2] = d3;
     }
     d3 = d10 + d3;
     HEAPF32[i2 >> 2] = d3;
     if (!(d3 > 3.141592653589793)) {
      if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
     } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
     HEAPF32[i76 >> 2] = d8 * d8 + +HEAPF32[i76 >> 2];
     i129 = HEAP32[i64 >> 2] | 0;
     i32 = HEAP32[i86 >> 2] | 0;
     HEAPF32[i32 + (i129 << 3) >> 2] = d7;
     HEAPF32[i32 + (i129 << 3) + 4 >> 2] = d9;
     i129 = (HEAP32[i64 >> 2] | 0) + 1 | 0;
     HEAP32[i64 >> 2] = i129;
     if ((i129 | 0) != (HEAP32[i85 >> 2] | 0)) break L14;
     i14 = HEAP32[i84 >> 2] | 0;
     i4 = HEAP32[i86 >> 2] | 0;
     i15 = HEAP32[i87 >> 2] | 0;
     i5 = i14 + 32 | 0;
     if (!(HEAP32[i5 >> 2] | 0)) i2 = i14 + 16 | 0; else {
      i2 = i14 + 16 | 0;
      i11 = i14 + 24 | 0;
      i12 = i14 + 8 | 0;
      i13 = 0;
      do {
       i129 = HEAP32[i14 >> 2] | 0;
       i31 = HEAP32[i4 + (i13 << 3) + 4 >> 2] | 0;
       i32 = HEAP32[i129 + 240 >> 2] | 0;
       HEAP32[i34 >> 2] = HEAP32[i4 + (i13 << 3) >> 2];
       HEAP32[i113 >> 2] = i31;
       HEAP32[i33 >> 2] = HEAP32[i34 >> 2];
       HEAP32[i33 + 4 >> 2] = HEAP32[i34 + 4 >> 2];
       mftCall_viii(i32 | 0, i129 | 0, i33 | 0, i35 | 0);
       i129 = HEAP32[i12 >> 2] | 0;
       i32 = Math_imul(i129, i13) | 0;
       _liquid_pack_array(HEAP32[i2 >> 2] | 0, HEAP32[i11 >> 2] | 0, i32, i129, HEAP32[i35 >> 2] | 0);
       i13 = i13 + 1 | 0;
      } while (i13 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
     }
     i15 = _packetizer_decode(HEAP32[i14 + 4 >> 2] | 0, HEAP32[i2 >> 2] | 0, i15) | 0;
     HEAP32[i101 >> 2] = i15;
     HEAP32[i73 >> 2] = (HEAP32[i73 >> 2] | 0) + 1;
     HEAP32[i102 >> 2] = (HEAP32[i102 >> 2] | 0) + 1;
     HEAP32[i103 >> 2] = (HEAP32[i103 >> 2] | 0) + i15;
     i18 = HEAP32[i82 >> 2] | 0;
     HEAP32[i104 >> 2] = (HEAP32[i104 >> 2] | 0) + i18;
     i19 = HEAP32[i116 >> 2] | 0;
     if (i19 | 0) {
      i5 = HEAP32[i84 >> 2] | 0;
      i11 = HEAP32[HEAP32[i5 >> 2] >> 2] | 0;
      i12 = HEAP32[i85 >> 2] | 0;
      d3 = +HEAPF32[i76 >> 2] / +(i12 >>> 0);
      i2 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
      i4 = (i2 | 0) < 0;
      do if (i2 >>> 0 < 8388608 | i4) {
       d20 = +Math_abs(+d3);
       if (!((HEAPF32[tempDoublePtr >> 2] = d20, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
        d3 = -1.0 / (d3 * d3);
        break;
       }
       if (i4) {
        d3 = (d3 - d3) / 0.0;
        break;
       } else {
        i2 = (HEAPF32[tempDoublePtr >> 2] = d3 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
        i4 = -152;
        i123 = 375;
        break;
       }
      } else {
       if (i2 >>> 0 > 2139095039) break;
       if ((i2 | 0) == 1065353216) d3 = 0.0; else {
        i4 = -127;
        i123 = 375;
       }
      } while (0);
      if ((i123 | 0) == 375) {
       i123 = 0;
       i129 = i2 + 4913933 | 0;
       d9 = (HEAP32[tempDoublePtr >> 2] = (i129 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
       d10 = d9 / (d9 + 2.0);
       d17 = d10 * d10;
       d3 = d17 * d17;
       d16 = d9 * (d9 * .5);
       d20 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d9 - d16, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
       d3 = d9 - d20 - d16 + d10 * (d16 + (d17 * (d3 * .2849878668785095 + .6666666269302368) + d3 * (d3 * .24279078841209412 + .40000972151756287)));
       d17 = +((i129 >>> 23) + i4 | 0);
       d3 = d17 * .3010292053222656 + (d20 * .434326171875 + (d3 * .434326171875 + (d17 * 7.903415166765626e-07 - (d20 + d3) * 3.168997136526741e-05)));
      }
      HEAPF32[i76 >> 2] = d3 * 10.0;
      d3 = +HEAPF32[i38 >> 2];
      i2 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
      i4 = (i2 | 0) < 0;
      do if (i2 >>> 0 < 8388608 | i4) {
       d20 = +Math_abs(+d3);
       if (!((HEAPF32[tempDoublePtr >> 2] = d20, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
        d3 = -1.0 / (d3 * d3);
        break;
       }
       if (i4) {
        d3 = (d3 - d3) / 0.0;
        break;
       } else {
        i2 = (HEAPF32[tempDoublePtr >> 2] = d3 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
        i4 = -152;
        i123 = 384;
        break;
       }
      } else {
       if (i2 >>> 0 > 2139095039) break;
       if ((i2 | 0) == 1065353216) d3 = 0.0; else {
        i4 = -127;
        i123 = 384;
       }
      } while (0);
      if ((i123 | 0) == 384) {
       i123 = 0;
       i129 = i2 + 4913933 | 0;
       d9 = (HEAP32[tempDoublePtr >> 2] = (i129 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
       d10 = d9 / (d9 + 2.0);
       d17 = d10 * d10;
       d3 = d17 * d17;
       d16 = d9 * (d9 * .5);
       d20 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d9 - d16, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
       d3 = d9 - d20 - d16 + d10 * (d16 + (d17 * (d3 * .2849878668785095 + .6666666269302368) + d3 * (d3 * .24279078841209412 + .40000972151756287)));
       d17 = +((i129 >>> 23) + i4 | 0);
       d3 = d17 * .3010292053222656 + (d20 * .434326171875 + (d3 * .434326171875 + (d17 * 7.903415166765626e-07 - (d20 + d3) * 3.168997136526741e-05)));
      }
      HEAPF32[i77 >> 2] = d3 * 20.0;
      HEAP32[i78 >> 2] = HEAP32[(HEAP32[i45 >> 2] | 0) + 8 >> 2];
      HEAP32[i79 >> 2] = HEAP32[i86 >> 2];
      HEAP32[i105 >> 2] = i12;
      HEAP32[i106 >> 2] = i11;
      HEAP32[i107 >> 2] = HEAP32[gb + 508 + (i11 << 4) + 12 >> 2];
      i2 = HEAP32[i5 + 4 >> 2] | 0;
      HEAP32[i108 >> 2] = HEAP32[i2 + 8 >> 2];
      i2 = HEAP32[i2 + 16 >> 2] | 0;
      HEAP32[i110 >> 2] = HEAP32[i2 + 8 >> 2];
      HEAP32[i111 >> 2] = HEAP32[i2 + 28 >> 2];
      i2 = HEAP32[i71 >> 2] | 0;
      i4 = HEAP32[i72 >> 2] | 0;
      i5 = HEAP32[i87 >> 2] | 0;
      i11 = HEAP32[i80 >> 2] | 0;
      i12 = i33;
      i13 = i76;
      i14 = i12 + 40 | 0;
      do {
       HEAP32[i12 >> 2] = HEAP32[i13 >> 2];
       i12 = i12 + 4 | 0;
       i13 = i13 + 4 | 0;
      } while ((i12 | 0) < (i14 | 0));
      mftCall_iiiiiiii(i19 | 0, i2 | 0, i4 | 0, i5 | 0, i18 | 0, i15 | 0, i33 | 0, i11 | 0) | 0;
     }
     i129 = HEAP32[i45 >> 2] | 0;
     HEAPF32[i129 + 4 >> 2] = 0.0;
     HEAPF32[i129 + 8 >> 2] = 0.0;
     HEAP32[i129 + 1036 >> 2] = 0;
     HEAPF32[i129 + 1040 >> 2] = 0.0;
     HEAPF32[i129 + 1044 >> 2] = 1.0;
     i129 = HEAP32[i74 >> 2] | 0;
     HEAPF32[i129 + 4 >> 2] = 0.0;
     HEAPF32[i129 + 8 >> 2] = 0.0;
     HEAP32[i129 + 1036 >> 2] = 0;
     HEAPF32[i129 + 1040 >> 2] = 0.0;
     HEAPF32[i129 + 1044 >> 2] = 1.0;
     i129 = HEAP32[(HEAP32[i44 >> 2] | 0) + 16 >> 2] | 0;
     HEAP32[i129 + 24 >> 2] = 0;
     _memset(HEAP32[i129 >> 2] | 0, 0, HEAP32[i129 + 20 >> 2] << 3 | 0) | 0;
     HEAP32[i100 >> 2] = 0;
     HEAP32[i61 >> 2] = 0;
     HEAP32[i64 >> 2] = 0;
     HEAPF32[i75 >> 2] = 0.0;
    }
    break;
   }
  default:
   {
    i123 = 388;
    break L4;
   }
  } while (0);
  i118 = i118 + 1 | 0;
  if (i118 >>> 0 >= i115 >>> 0) {
   i123 = 401;
   break;
  }
 }
 if ((i123 | 0) == 146) {
  HEAP32[i119 >> 2] = i4;
  HEAP32[i119 + 4 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i119);
  _exit(1);
 } else if ((i123 | 0) == 164) {
  HEAP32[i121 >> 2] = i4;
  HEAP32[i121 + 4 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i121);
  _exit(1);
 } else if ((i123 | 0) == 337) {
  HEAP32[i120 >> 2] = i4;
  HEAP32[i120 + 4 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i120);
  _exit(1);
 } else if ((i123 | 0) == 388) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i125 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i125;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i125 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i125 - i1 | 0) >>> 0 < 58) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23950 | 0, 58) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23950 | 0, 58) | 0) >>> 0 < 58) _exit(1); else {
   i126 = 0;
   i127 = gb + 23950 + 58 | 0;
   i128 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i126 = 58;
   i127 = gb + 23950 | 0;
   i128 = i1;
  } while (0);
  _memcpy(i128 | 0, i127 | 0, i126 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i126;
  _exit(1);
 } else if ((i123 | 0) == 401) {
  STACKTOP = i124;
  return;
 }
}

function _quiet_decoder_create(i73, d74) {
 i73 = i73 | 0;
 d74 = +d74;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i75 = 0, i76 = 0, d77 = 0.0, d78 = 0.0, d79 = 0.0;
 i76 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i72 = i76 + 40 | 0;
 i48 = i76 + 32 | 0;
 i42 = i76 + 24 | 0;
 i69 = i76 + 16 | 0;
 i51 = i76 + 8 | 0;
 i36 = i76;
 if (!i73) {
  i75 = 0;
  STACKTOP = i76;
  return i75 | 0;
 }
 i75 = _malloc(112) | 0;
 i5 = i75;
 i4 = i73;
 i8 = i5 + 60 | 0;
 do {
  HEAP32[i5 >> 2] = HEAP32[i4 >> 2];
  i5 = i5 + 4 | 0;
  i4 = i4 + 4 | 0;
 } while ((i5 | 0) < (i8 | 0));
 HEAP32[i75 + 68 >> 2] = _malloc(8192) | 0;
 HEAP32[i75 + 72 >> 2] = 8192;
 HEAP32[i75 + 76 >> 2] = 0;
 switch (HEAP32[i75 + 52 >> 2] | 0) {
 case 0:
  {
   i1 = HEAP32[i73 >> 2] | 0;
   i24 = _malloc(i1) | 0;
   _ofdmframe_init_default_sctype(i1, i24);
   i1 = (HEAP32[i73 >> 2] | 0) >>> 1;
   i3 = i1;
   while (1) if (!(HEAP8[i24 + i3 >> 0] | 0)) i3 = i3 + -1 | 0; else break;
   while (1) {
    i2 = i24 + i1 | 0;
    if (!(HEAP8[i2 >> 0] | 0)) i1 = i1 + 1 | 0; else break;
   }
   i1 = HEAP32[i73 + 16 >> 2] | 0;
   if (i1 | 0) {
    i49 = i1 >>> 0 > 1 ? i1 : 1;
    _memset(i24 + (i3 + 1 - i49) | 0, 0, i49 | 0) | 0;
   }
   i1 = HEAP32[i73 + 12 >> 2] | 0;
   if (i1 | 0) _memset(i2 | 0, 0, (i1 >>> 0 > 1 ? i1 : 1) | 0) | 0;
   i10 = HEAP32[i73 >> 2] | 0;
   i22 = i73 + 4 | 0;
   i20 = HEAP32[i22 >> 2] | 0;
   i4 = HEAP32[i73 + 8 >> 2] | 0;
   i23 = _malloc(208) | 0;
   i16 = i10 >>> 0 < 8;
   L17 : do if (!i16) {
    if (i10 & 1 | 0) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i11 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i11;
       HEAP32[gb + 8728 + 20 >> 2] = i11;
       i9 = i11 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i9;
       break;
      }
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      _exit(1);
     } else {
      i9 = i1;
      i11 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     } while (0);
     if ((i9 - i11 | 0) >>> 0 < 70) {
      mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26572 | 0, 70) | 0;
      _exit(1);
     }
     i1 = i11;
     do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26572 | 0, 70) | 0) >>> 0 < 70) _exit(1); else {
      i12 = 0;
      i13 = gb + 26572 + 70 | 0;
      i14 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      break;
     } else {
      i12 = 70;
      i13 = gb + 26572 | 0;
      i14 = i1;
     } while (0);
     _memcpy(i14 | 0, i13 | 0, i12 | 0) | 0;
     HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i12;
     _exit(1);
    }
    if (i20 >>> 0 > i10 >>> 0) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i17 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i17;
       HEAP32[gb + 8728 + 20 >> 2] = i17;
       i15 = i17 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i15;
       break;
      }
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      _exit(1);
     } else {
      i15 = i1;
      i17 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     } while (0);
     if ((i15 - i17 | 0) >>> 0 < 92) {
      mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26643 | 0, 92) | 0;
      _exit(1);
     }
     i1 = i17;
     do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26643 | 0, 92) | 0) >>> 0 < 92) _exit(1); else {
      i18 = 0;
      i19 = gb + 26643 + 92 | 0;
      i21 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      break;
     } else {
      i18 = 92;
      i19 = gb + 26643 | 0;
      i21 = i1;
     } while (0);
     _memcpy(i21 | 0, i19 | 0, i18 | 0) | 0;
     HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i18;
     _exit(1);
    }
   } else {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i1;
      break;
     } else {
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      break L17;
     }
    } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
    if ((i1 - i2 | 0) >>> 0 < 61) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26510 | 0, 61) | 0;
     break;
    }
    if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
     if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26510 | 0, 61) | 0) >>> 0 < 61) break;
     i1 = 0;
     i3 = gb + 26510 + 61 | 0;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } else {
     i1 = 61;
     i3 = gb + 26510 | 0;
    }
    _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
   } while (0);
   HEAP32[i23 >> 2] = i10;
   HEAP32[i23 + 4 >> 2] = i20;
   HEAP32[i23 + 8 >> 2] = i4;
   HEAP32[i23 + 132 >> 2] = fb + 1;
   HEAP32[i23 + 136 >> 2] = i75;
   i1 = _malloc(i10) | 0;
   i2 = i23 + 12 | 0;
   HEAP32[i2 >> 2] = i1;
   i15 = (i24 | 0) == 0;
   if (i15) {
    _ofdmframe_init_default_sctype(i10, i1);
    i13 = HEAP32[i23 >> 2] | 0;
    i1 = HEAP32[i2 >> 2] | 0;
   } else {
    _memcpy(i1 | 0, i24 | 0, i10 | 0) | 0;
    i13 = i10;
   }
   i8 = i23 + 16 | 0;
   i9 = i23 + 20 | 0;
   i11 = i23 + 24 | 0;
   L81 : do if (!i13) {
    i33 = 0;
    i34 = 0;
    i35 = 0;
   } else {
    i5 = 0;
    i3 = 0;
    i4 = 0;
    i12 = 0;
    L82 : while (1) {
     i2 = HEAP8[i1 + i12 >> 0] | 0;
     switch (i2 << 24 >> 24) {
     case 0:
      {
       i2 = i5;
       i3 = i3 + 1 | 0;
       break;
      }
     case 1:
      {
       i2 = i5;
       i4 = i4 + 1 | 0;
       break;
      }
     case 2:
      {
       i2 = i5 + 1 | 0;
       break;
      }
     default:
      break L82;
     }
     i12 = i12 + 1 | 0;
     if (i12 >>> 0 >= i13 >>> 0) {
      i33 = i2;
      i34 = i3;
      i35 = i4;
      break L81;
     } else i5 = i2;
    }
    HEAP32[i36 >> 2] = i2 & 255;
    _fprintf(gb + 8728 | 0, gb + 32703 | 0, i36);
    _exit(1);
   } while (0);
   HEAP32[i8 >> 2] = i34;
   HEAP32[i9 >> 2] = i35;
   HEAP32[i11 >> 2] = i33;
   i17 = _malloc(216) | 0;
   L91 : do if (!i16) {
    if (i10 & 1 | 0) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i38 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i38;
       HEAP32[gb + 8728 + 20 >> 2] = i38;
       i37 = i38 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i37;
       break;
      }
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      _exit(1);
     } else {
      i37 = i1;
      i38 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     } while (0);
     if ((i37 - i38 | 0) >>> 0 < 66) {
      mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33326 | 0, 66) | 0;
      _exit(1);
     }
     i1 = i38;
     do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33326 | 0, 66) | 0) >>> 0 < 66) _exit(1); else {
      i39 = 0;
      i40 = gb + 33326 + 66 | 0;
      i41 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      break;
     } else {
      i39 = 66;
      i40 = gb + 33326 | 0;
      i41 = i1;
     } while (0);
     _memcpy(i41 | 0, i40 | 0, i39 | 0) | 0;
     HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i39;
     _exit(1);
    }
    if (i20 >>> 0 > i10 >>> 0) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i44 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i44;
       HEAP32[gb + 8728 + 20 >> 2] = i44;
       i43 = i44 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i43;
       break;
      }
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      _exit(1);
     } else {
      i43 = i1;
      i44 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     } while (0);
     if ((i43 - i44 | 0) >>> 0 < 88) {
      mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33393 | 0, 88) | 0;
      _exit(1);
     }
     i1 = i44;
     do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33393 | 0, 88) | 0) >>> 0 < 88) _exit(1); else {
      i45 = 0;
      i46 = gb + 33393 + 88 | 0;
      i47 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      break;
     } else {
      i45 = 88;
      i46 = gb + 33393 | 0;
      i47 = i1;
     } while (0);
     _memcpy(i47 | 0, i46 | 0, i45 | 0) | 0;
     HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i45;
     _exit(1);
    }
   } else {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i1;
      break;
     } else {
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      break L91;
     }
    } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
    if ((i1 - i2 | 0) >>> 0 < 57) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33268 | 0, 57) | 0;
     break;
    }
    if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
     if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33268 | 0, 57) | 0) >>> 0 < 57) break;
     i1 = 0;
     i3 = gb + 33268 + 57 | 0;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } else {
     i1 = 57;
     i3 = gb + 33268 | 0;
    }
    _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
   } while (0);
   HEAP32[i17 >> 2] = i10;
   i14 = i17 + 8 | 0;
   HEAP32[i14 >> 2] = i20;
   HEAP32[i17 + 4 >> 2] = i10 >>> 1;
   i1 = _malloc(i10) | 0;
   i13 = i17 + 12 | 0;
   HEAP32[i13 >> 2] = i1;
   if (i15) {
    _ofdmframe_init_default_sctype(i10, i1);
    i10 = HEAP32[i17 >> 2] | 0;
    i1 = HEAP32[i13 >> 2] | 0;
   } else _memcpy(i1 | 0, i24 | 0, i10 | 0) | 0;
   i8 = i17 + 16 | 0;
   i11 = i17 + 20 | 0;
   i12 = i17 + 24 | 0;
   L155 : do if (!i10) {
    i57 = 0;
    i50 = 0;
    i63 = 0;
   } else {
    i5 = 0;
    i3 = 0;
    i4 = 0;
    i9 = 0;
    L156 : while (1) {
     i2 = HEAP8[i1 + i9 >> 0] | 0;
     switch (i2 << 24 >> 24) {
     case 0:
      {
       i2 = i5;
       i3 = i3 + 1 | 0;
       break;
      }
     case 1:
      {
       i2 = i5;
       i4 = i4 + 1 | 0;
       break;
      }
     case 2:
      {
       i2 = i5 + 1 | 0;
       break;
      }
     default:
      break L156;
     }
     i9 = i9 + 1 | 0;
     if (i9 >>> 0 >= i10 >>> 0) {
      i57 = i2;
      i50 = i3;
      i63 = i4;
      break L155;
     } else i5 = i2;
    }
    HEAP32[i51 >> 2] = i2 & 255;
    _fprintf(gb + 8728 | 0, gb + 32703 | 0, i51);
    _exit(1);
   } while (0);
   HEAP32[i8 >> 2] = i50;
   HEAP32[i11 >> 2] = i63;
   HEAP32[i12 >> 2] = i57;
   if ((i63 | 0) == (0 - i57 | 0)) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i53 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i53;
      HEAP32[gb + 8728 + 20 >> 2] = i53;
      i52 = i53 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i52;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i52 = i1;
     i53 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i52 - i53 | 0) >>> 0 < 73) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33482 | 0, 73) | 0;
     _exit(1);
    }
    i1 = i53;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33482 | 0, 73) | 0) >>> 0 < 73) _exit(1); else {
     i54 = 0;
     i55 = gb + 33482 + 73 | 0;
     i56 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i54 = 73;
     i55 = gb + 33482 | 0;
     i56 = i1;
    } while (0);
    _memcpy(i56 | 0, i55 | 0, i54 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i54;
    _exit(1);
   }
   if (!i57) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i59 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i59;
      HEAP32[gb + 8728 + 20 >> 2] = i59;
      i58 = i59 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i58;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i58 = i1;
     i59 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i58 - i59 | 0) >>> 0 < 71) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33556 | 0, 71) | 0;
     _exit(1);
    }
    i1 = i59;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33556 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
     i60 = 0;
     i61 = gb + 33556 + 71 | 0;
     i62 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i60 = 71;
     i61 = gb + 33556 | 0;
     i62 = i1;
    } while (0);
    _memcpy(i62 | 0, i61 | 0, i60 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i60;
    _exit(1);
   }
   if (i63 >>> 0 < 2) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i65 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i65;
      HEAP32[gb + 8728 + 20 >> 2] = i65;
      i64 = i65 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i64;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i64 = i1;
     i65 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i64 - i65 | 0) >>> 0 < 72) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33628 | 0, 72) | 0;
     _exit(1);
    }
    i1 = i65;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33628 | 0, 72) | 0) >>> 0 < 72) _exit(1); else {
     i66 = 0;
     i67 = gb + 33628 + 72 | 0;
     i68 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i66 = 72;
     i67 = gb + 33628 | 0;
     i68 = i1;
    } while (0);
    _memcpy(i68 | 0, i67 | 0, i66 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i66;
    _exit(1);
   }
   i66 = HEAP32[i17 >> 2] | 0;
   i64 = i66 << 3;
   i1 = _malloc(i64) | 0;
   HEAP32[i17 + 52 >> 2] = i1;
   i64 = _malloc(i64) | 0;
   HEAP32[i17 + 56 >> 2] = i64;
   HEAP32[i17 + 48 >> 2] = _fft_create_plan(i66, i64, i1, 1, 0) | 0;
   HEAP32[i17 + 60 >> 2] = _windowcf_create((HEAP32[i14 >> 2] | 0) + (HEAP32[i17 >> 2] | 0) | 0) | 0;
   i1 = HEAP32[i17 >> 2] | 0;
   i64 = i1 << 3;
   i66 = _malloc(i64) | 0;
   HEAP32[i17 + 64 >> 2] = i66;
   i67 = _malloc(i64) | 0;
   HEAP32[i17 + 68 >> 2] = i67;
   i65 = i17 + 72 | 0;
   HEAP32[i65 >> 2] = _malloc(i64) | 0;
   i68 = i17 + 76 | 0;
   HEAP32[i68 >> 2] = _malloc(i64) | 0;
   i64 = i17 + 28 | 0;
   _ofdmframe_init_S0(HEAP32[i13 >> 2] | 0, i1, i66, i67, i64);
   i67 = i17 + 32 | 0;
   _ofdmframe_init_S1(HEAP32[i13 >> 2] | 0, HEAP32[i17 >> 2] | 0, HEAP32[i65 >> 2] | 0, HEAP32[i68 >> 2] | 0, i67);
   i68 = HEAP32[i17 >> 2] | 0;
   d6 = +(i68 >>> 0);
   d7 = +Math_sqrt(+d6);
   HEAPF32[i17 + 36 >> 2] = d7 / +Math_sqrt(+(+(((HEAP32[i12 >> 2] | 0) + (HEAP32[i11 >> 2] | 0) | 0) >>> 0)));
   HEAPF32[i17 + 40 >> 2] = d7 / +Math_sqrt(+(+((HEAP32[i64 >> 2] | 0) >>> 0)));
   HEAPF32[i17 + 44 >> 2] = d7 / +Math_sqrt(+(+((HEAP32[i67 >> 2] | 0) >>> 0)));
   HEAPF32[i17 + 80 >> 2] = 1.0;
   i67 = i68 << 3;
   i64 = _malloc(i67) | 0;
   HEAP32[i17 + 84 >> 2] = i64;
   i65 = _malloc(i67) | 0;
   HEAP32[i17 + 88 >> 2] = i65;
   i66 = _malloc(i67) | 0;
   HEAP32[i17 + 92 >> 2] = i66;
   i1 = _malloc(i67) | 0;
   i2 = i17 + 96 | 0;
   HEAP32[i2 >> 2] = i1;
   HEAP32[i17 + 100 >> 2] = _malloc(i67) | 0;
   _memset(i64 | 0, 0, i67 | 0) | 0;
   _memset(i65 | 0, 0, i67 | 0) | 0;
   _memset(i66 | 0, 0, i67 | 0) | 0;
   _memset(i1 | 0, 0, i67 | 0) | 0;
   i67 = HEAP32[i14 >> 2] | 0;
   i67 = i67 >>> 0 < 2 ? i67 : 2;
   HEAP32[i17 + 132 >> 2] = i67;
   d6 = +(i67 >>> 0) * 2.0 * 3.141592653589793 / d6;
   if (i68 | 0 ? (d77 = d6 * 0.0, d7 = +Math_sin(+d77), HEAPF32[i1 >> 2] = +Math_cos(+d77) + d7 * 0.0, HEAPF32[i1 + 4 >> 2] = d7, (HEAP32[i17 >> 2] | 0) >>> 0 > 1) : 0) {
    i1 = 1;
    do {
     i68 = HEAP32[i2 >> 2] | 0;
     d7 = d6 * +(i1 >>> 0);
     d77 = +Math_sin(+d7);
     HEAPF32[i68 + (i1 << 3) >> 2] = +Math_cos(+d7) + d77 * 0.0;
     HEAPF32[i68 + (i1 << 3) + 4 >> 2] = d77;
     i1 = i1 + 1 | 0;
    } while (i1 >>> 0 < (HEAP32[i17 >> 2] | 0) >>> 0);
   }
   HEAP32[i17 + 160 >> 2] = fb + 1;
   HEAP32[i17 + 164 >> 2] = i23;
   i3 = _malloc(1060) | 0;
   HEAP32[i3 >> 2] = 0;
   i1 = i3 + 12 | 0;
   i2 = 0;
   do {
    HEAPF32[i1 + (i2 << 2) >> 2] = +Math_sin(+(+(i2 >>> 0) * 6.283185307179586 * .00390625));
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != 256);
   HEAPF32[i3 + 1052 >> 2] = .10000000149011612;
   HEAPF32[i3 + 1056 >> 2] = .3162277638912201;
   i1 = HEAP32[i3 >> 2] | 0;
   switch (i1 | 0) {
   case 0:
    {
     HEAP32[i3 + 1048 >> 2] = fb + 1;
     break;
    }
   case 1:
    {
     HEAP32[i3 + 1048 >> 2] = fb + 2;
     break;
    }
   default:
    {
     HEAP32[i69 >> 2] = i1;
     _fprintf(gb + 8728 | 0, gb + 36150 | 0, i69);
     _exit(1);
    }
   }
   HEAPF32[i3 + 4 >> 2] = 0.0;
   HEAPF32[i3 + 8 >> 2] = 0.0;
   HEAP32[i3 + 1036 >> 2] = 0;
   HEAPF32[i3 + 1040 >> 2] = 0.0;
   HEAPF32[i3 + 1044 >> 2] = 1.0;
   i69 = i17 + 108 | 0;
   HEAP32[i69 >> 2] = i3;
   i1 = _malloc(24) | 0;
   HEAP32[i1 >> 2] = HEAP32[gb + 6864 + 192 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[gb + 6864 + 192 + 4 >> 2];
   HEAP32[i1 + 8 >> 2] = HEAP32[gb + 6864 + 192 + 8 >> 2];
   HEAP32[i1 + 12 >> 2] = HEAP32[gb + 6864 + 192 + 12 >> 2];
   HEAP32[i1 + 16 >> 2] = HEAP32[gb + 6864 + 192 + 16 >> 2];
   HEAP32[i1 + 20 >> 2] = HEAP32[gb + 6864 + 192 + 20 >> 2];
   HEAP32[i17 + 112 >> 2] = i1;
   i69 = HEAP32[i69 >> 2] | 0;
   HEAPF32[i69 + 4 >> 2] = 0.0;
   HEAPF32[i69 + 8 >> 2] = 0.0;
   HEAP32[i69 + 1036 >> 2] = 0;
   HEAPF32[i69 + 1040 >> 2] = 0.0;
   HEAPF32[i69 + 1044 >> 2] = 1.0;
   HEAP32[i1 + 16 >> 2] = 128;
   i1 = i17 + 136 | 0;
   i69 = i17 + 116 | 0;
   HEAP32[i69 >> 2] = 0;
   HEAP32[i69 + 4 >> 2] = 0;
   HEAP32[i69 + 8 >> 2] = 0;
   HEAP32[i69 + 12 >> 2] = 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   i1 = HEAP32[i17 >> 2] | 0;
   if (i1 >>> 0 > 44) {
    HEAPF32[i17 + 152 >> 2] = .3499999940395355;
    d6 = .30000001192092896;
   } else {
    d6 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
    HEAPF32[i17 + 152 >> 2] = d6 + .3499999940395355;
    d6 = d6 + .30000001192092896;
   }
   HEAPF32[i17 + 156 >> 2] = d6;
   HEAP32[i17 + 104 >> 2] = 0;
   i3 = i17 + 168 | 0;
   HEAP32[i17 + 208 >> 2] = 0;
   HEAP32[i17 + 212 >> 2] = 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   HEAP32[i3 + 16 >> 2] = 0;
   HEAP32[i3 + 20 >> 2] = 0;
   HEAP32[i3 + 24 >> 2] = 0;
   HEAP32[i3 + 28 >> 2] = 0;
   i3 = i23 + 184 | 0;
   HEAP32[i3 >> 2] = i17;
   i5 = i23 + 36 | 0;
   HEAP32[i5 >> 2] = 0;
   HEAP32[i5 + 4 >> 2] = 0;
   HEAP32[i5 + 8 >> 2] = 0;
   HEAP32[i5 + 12 >> 2] = 0;
   HEAP32[i5 + 16 >> 2] = 0;
   _ofdmflexframesync_set_header_len(i23, 8);
   i5 = i23 + 84 | 0;
   i69 = i23 + 76 | 0;
   SIMD_Int32x4_store(HEAPU8, i69, SIMD_Int32x4(48, 2, 1, 1));
   i69 = i23 + 92 | 0;
   HEAP32[i69 >> 2] = 1;
   i8 = i23 + 96 | 0;
   HEAP32[i8 >> 2] = 1;
   i68 = _malloc(252) | 0;
   HEAP32[i68 >> 2] = 48;
   HEAP32[i68 + 76 >> 2] = 0;
   HEAP32[i68 + 80 >> 2] = 0;
   HEAP32[i68 + 4 >> 2] = 2;
   HEAP32[i68 + 8 >> 2] = 4;
   i67 = i68 + 236 | 0;
   HEAP32[i67 >> 2] = 0;
   HEAP32[i67 + 4 >> 2] = 0;
   HEAP32[i67 + 8 >> 2] = 0;
   HEAP32[i67 + 12 >> 2] = 0;
   HEAP32[i67 >> 2] = fb + 1;
   HEAP32[i68 + 240 >> 2] = fb + 2;
   HEAPF32[i68 + 84 >> 2] = 1.0;
   HEAPF32[i68 + 88 >> 2] = 0.0;
   HEAP32[i68 + 92 >> 2] = 1065353216;
   HEAPF32[i68 + 96 >> 2] = 0.0;
   HEAP32[i23 + 104 >> 2] = i68;
   i8 = _packetizer_create(HEAP32[i5 >> 2] | 0, HEAP32[i23 + 88 >> 2] | 0, HEAP32[i69 >> 2] | 0, HEAP32[i8 >> 2] | 0) | 0;
   HEAP32[i23 + 100 >> 2] = i8;
   i8 = HEAP32[i8 + 4 >> 2] | 0;
   HEAP32[i23 + 116 >> 2] = i8;
   HEAP32[i23 + 108 >> 2] = _malloc(i8) | 0;
   i5 = HEAP32[i5 >> 2] | 0;
   HEAP32[i23 + 112 >> 2] = _malloc(i5) | 0;
   HEAP32[i23 + 128 >> 2] = _malloc(i5 << 3) | 0;
   HEAP32[i23 + 120 >> 2] = 0;
   i5 = i23 + 188 | 0;
   HEAP32[i5 >> 2] = 0;
   HEAP32[i5 + 4 >> 2] = 0;
   HEAP32[i5 + 8 >> 2] = 0;
   HEAP32[i5 + 12 >> 2] = 0;
   HEAP32[i5 + 16 >> 2] = 0;
   HEAPF32[i23 + 180 >> 2] = 9.999999960041972e-13;
   i5 = i23 + 140 | 0;
   i8 = i5 + 40 | 0;
   do {
    HEAP32[i5 >> 2] = 0;
    i5 = i5 + 4 | 0;
   } while ((i5 | 0) < (i8 | 0));
   i2 = HEAP32[i3 >> 2] | 0;
   i1 = HEAP32[i2 + 108 >> 2] | 0;
   HEAPF32[i1 + 4 >> 2] = 0.0;
   HEAPF32[i1 + 8 >> 2] = 0.0;
   HEAP32[i1 + 1036 >> 2] = 0;
   HEAPF32[i1 + 1040 >> 2] = 0.0;
   HEAPF32[i1 + 1044 >> 2] = 1.0;
   i1 = HEAP32[i2 + 112 >> 2] | 0;
   HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
   i1 = i2 + 136 | 0;
   i69 = i2 + 116 | 0;
   HEAP32[i69 >> 2] = 0;
   HEAP32[i69 + 4 >> 2] = 0;
   HEAP32[i69 + 8 >> 2] = 0;
   HEAP32[i69 + 12 >> 2] = 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   i1 = HEAP32[i2 >> 2] | 0;
   if (i1 >>> 0 > 44) {
    d6 = .3499999940395355;
    d7 = .30000001192092896;
   } else {
    d7 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
    d6 = d7 + .3499999940395355;
    d7 = d7 + .30000001192092896;
   }
   HEAPF32[i2 + 152 >> 2] = d6;
   HEAPF32[i2 + 156 >> 2] = d7;
   HEAP32[i2 + 104 >> 2] = 0;
   _ofdmflexframesync_set_header_len(i23, 0);
   if (HEAP8[i73 + 56 >> 0] | 0 ? (i70 = HEAP32[i3 >> 2] | 0, i71 = i70 + 172 | 0, (HEAP32[i71 >> 2] | 0) == 0) : 0) {
    i69 = _malloc(28) | 0;
    HEAP32[i69 + 4 >> 2] = 2048;
    HEAP32[i69 + 8 >> 2] = 12;
    HEAP32[i69 + 12 >> 2] = 4096;
    HEAP32[i69 + 16 >> 2] = 4095;
    HEAP32[i69 + 20 >> 2] = 6143;
    i68 = _malloc(49144) | 0;
    HEAP32[i69 >> 2] = i68;
    HEAP32[i69 + 24 >> 2] = 0;
    _memset(i68 | 0, 0, 49144) | 0;
    HEAP32[i70 + 176 >> 2] = i69;
    i69 = _malloc(28) | 0;
    HEAP32[i69 + 4 >> 2] = 2048;
    HEAP32[i69 + 8 >> 2] = 12;
    HEAP32[i69 + 12 >> 2] = 4096;
    HEAP32[i69 + 16 >> 2] = 4095;
    HEAP32[i69 + 20 >> 2] = 6143;
    i68 = _malloc(24572) | 0;
    HEAP32[i69 >> 2] = i68;
    HEAP32[i69 + 24 >> 2] = 0;
    _memset(i68 | 0, 0, 24572) | 0;
    HEAP32[i70 + 180 >> 2] = i69;
    i69 = _malloc(28) | 0;
    HEAP32[i69 + 4 >> 2] = 2048;
    HEAP32[i69 + 8 >> 2] = 12;
    HEAP32[i69 + 12 >> 2] = 4096;
    HEAP32[i69 + 16 >> 2] = 4095;
    HEAP32[i69 + 20 >> 2] = 6143;
    i68 = _malloc(49144) | 0;
    HEAP32[i69 >> 2] = i68;
    HEAP32[i69 + 24 >> 2] = 0;
    _memset(i68 | 0, 0, 49144) | 0;
    HEAP32[i70 + 184 >> 2] = i69;
    HEAP32[i70 + 188 >> 2] = _malloc(HEAP32[i70 >> 2] << 3) | 0;
    i69 = HEAP32[i70 + 20 >> 2] << 2;
    HEAP32[i70 + 192 >> 2] = _malloc(i69) | 0;
    HEAP32[i70 + 196 >> 2] = _malloc(i69) | 0;
    i69 = _malloc(28) | 0;
    HEAP32[i69 + 4 >> 2] = 2048;
    HEAP32[i69 + 8 >> 2] = 12;
    HEAP32[i69 + 12 >> 2] = 4096;
    HEAP32[i69 + 16 >> 2] = 4095;
    HEAP32[i69 + 20 >> 2] = 6143;
    i68 = _malloc(24572) | 0;
    HEAP32[i69 >> 2] = i68;
    HEAP32[i69 + 24 >> 2] = 0;
    _memset(i68 | 0, 0, 24572) | 0;
    HEAP32[i70 + 208 >> 2] = i69;
    i69 = _malloc(28) | 0;
    HEAP32[i69 + 4 >> 2] = 2048;
    HEAP32[i69 + 8 >> 2] = 12;
    HEAP32[i69 + 12 >> 2] = 4096;
    HEAP32[i69 + 16 >> 2] = 4095;
    HEAP32[i69 + 20 >> 2] = 6143;
    i68 = _malloc(24572) | 0;
    HEAP32[i69 >> 2] = i68;
    HEAP32[i69 + 24 >> 2] = 0;
    _memset(i68 | 0, 0, 24572) | 0;
    HEAP32[i70 + 212 >> 2] = i69;
    HEAP32[i70 + 168 >> 2] = 1;
    HEAP32[i71 >> 2] = 1;
   }
   i71 = (HEAP32[i22 >> 2] | 0) + (HEAP32[i73 >> 2] | 0) | 0;
   HEAP32[i75 + 80 >> 2] = _malloc(i71 << 3) | 0;
   HEAP32[i75 + 84 >> 2] = i71;
   _free(i24);
   HEAP32[i75 + 60 >> 2] = i23;
   break;
  }
 case 1:
  {
   i18 = _malloc(220) | 0;
   HEAP32[i18 >> 2] = fb + 1;
   HEAP32[i18 + 4 >> 2] = i75;
   i16 = i18 + 64 | 0;
   HEAP32[i16 >> 2] = 7;
   i17 = i18 + 68 | 0;
   HEAPF32[i17 >> 2] = .30000001192092896;
   i5 = i18 + 116 | 0;
   HEAP32[i5 >> 2] = _malloc(512) | 0;
   HEAP32[i18 + 120 >> 2] = _malloc(512) | 0;
   i8 = _malloc(24) | 0;
   i9 = i8 + 4 | 0;
   i10 = i8 + 12 | 0;
   i11 = i8;
   SIMD_Int32x4_store(HEAPU8, i11, SIMD_Int32x4(7, 68, 64, 127));
   i11 = i8 + 16 | 0;
   HEAP32[i11 >> 2] = 64;
   i12 = i8 + 20 | 0;
   HEAP32[i12 >> 2] = 0;
   i13 = 68;
   i14 = 64;
   i15 = 127;
   i4 = 0;
   while (1) {
    i69 = i13 & i14;
    i69 = (HEAPU8[(i69 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i69 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i69 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i69 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    i71 = (i69 | i14 << 1) & i15;
    i70 = i71 & i13;
    i70 = (HEAPU8[(i70 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i70 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i70 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i70 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    HEAP32[i12 >> 2] = i70;
    HEAP32[i11 >> 2] = (i70 | i71 << 1) & i15;
    i70 = (i70 | 0) != 0;
    i71 = HEAP32[i5 >> 2] | 0;
    HEAPF32[i71 + (i4 << 3) >> 2] = (i69 | 0 ? .7071067811865476 : -.7071067811865476) + (i70 ? 0.0 : -0.0);
    HEAPF32[i71 + (i4 << 3) + 4 >> 2] = i70 ? .7071067690849304 : -.7071067690849304;
    i4 = i4 + 1 | 0;
    if ((i4 | 0) == 64) break;
    i13 = HEAP32[i9 >> 2] | 0;
    i14 = HEAP32[i11 >> 2] | 0;
    i15 = HEAP32[i10 >> 2] | 0;
   }
   _free(i8);
   i11 = HEAP32[i5 >> 2] | 0;
   i5 = HEAP32[i16 >> 2] | 0;
   d6 = +HEAPF32[i17 >> 2];
   if ((i5 + -1 | 0) >>> 0 > 99) {
    i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i4) {
     i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
     i4 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i4 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i3;
      HEAP32[gb + 8728 + 20 >> 2] = i3;
      i20 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i20;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i4 | 32;
     _exit(1);
    } else {
     i20 = i4;
     i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i20 - i3 | 0) >>> 0 < 71) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27363 | 0, 71) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27363 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
     i22 = 0;
     i23 = gb + 27363 + 71 | 0;
     i24 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i22 = 71;
     i23 = gb + 27363 | 0;
     i24 = i3;
    } while (0);
    _memcpy(i24 | 0, i23 | 0, i22 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i22;
    _exit(1);
   }
   if (d6 < 0.0 | d6 > 1.0) {
    i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i3) {
     i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
     i3 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i3 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i25 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i25;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i3 | 32;
     _exit(1);
    } else {
     i25 = i3;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i25 - i2 | 0) >>> 0 < 80) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27435 | 0, 80) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27435 | 0, 80) | 0) >>> 0 < 80) _exit(1); else {
     i26 = 0;
     i27 = gb + 27435 + 80 | 0;
     i28 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i26 = 80;
     i27 = gb + 27435 | 0;
     i28 = i2;
    } while (0);
    _memcpy(i28 | 0, i27 | 0, i26 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i26;
    _exit(1);
   }
   i8 = (i5 << 1) + 64 | 0;
   i4 = i8 << 1;
   i9 = i8 << 4;
   i10 = _malloc(i9) | 0;
   i2 = _firinterp_crcf_create_prototype(i5, d6) | 0;
   if (i8 | 0) {
    i3 = 0;
    do {
     if (i3 >>> 0 < 64) {
      d6 = +HEAPF32[i11 + (i3 << 3) >> 2];
      d7 = +HEAPF32[i11 + (i3 << 3) + 4 >> 2];
     } else {
      d6 = 0.0;
      d7 = 0.0;
     }
     _firinterp_crcf_execute(i2, d6, d7, i10 + (i3 << 1 << 3) | 0);
     i3 = i3 + 1 | 0;
    } while ((i3 | 0) != (i8 | 0));
   }
   _firinterp_crcf_destroy(i2);
   if (!i4) {
    i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i2) {
     i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
     i2 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i2 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i1;
      HEAP32[gb + 8728 + 20 >> 2] = i1;
      i29 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i29;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i2 | 32;
     _exit(1);
    } else {
     i29 = i2;
     i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i29 - i1 | 0) >>> 0 < 63) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27299 | 0, 63) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27299 | 0, 63) | 0) >>> 0 < 63) _exit(1); else {
     i30 = 0;
     i31 = gb + 27299 + 63 | 0;
     i32 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i30 = 63;
     i31 = gb + 27299 | 0;
     i32 = i1;
    } while (0);
    _memcpy(i32 | 0, i31 | 0, i30 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i30;
    _exit(1);
   }
   i5 = _malloc(96) | 0;
   HEAP32[i5 >> 2] = i4;
   i3 = _malloc(i9) | 0;
   i4 = i5 + 4 | 0;
   HEAP32[i4 >> 2] = i3;
   _memcpy(i3 | 0, i10 | 0, i9 | 0) | 0;
   i1 = i8 << 2;
   if (!i1) d6 = 0.0; else {
    i2 = 0;
    d6 = 0.0;
    do {
     d79 = +HEAPF32[i3 + (i2 << 2) >> 2];
     d78 = +HEAPF32[i3 + ((i2 | 1) << 2) >> 2];
     d7 = +HEAPF32[i3 + ((i2 | 2) << 2) >> 2];
     d77 = +HEAPF32[i3 + ((i2 | 3) << 2) >> 2];
     d6 = d6 + d79 * d79 + d78 * d78 + d7 * d7 + d77 * d77;
     i2 = i2 + 4 | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   HEAPF32[i5 + 12 >> 2] = d6;
   i67 = 1 << (_liquid_nextpow2(HEAP32[i5 >> 2] << 1) | 0);
   i3 = i5 + 32 | 0;
   HEAP32[i3 >> 2] = i67;
   i71 = i67 << 3;
   i68 = _malloc(i71) | 0;
   i8 = i5 + 16 | 0;
   HEAP32[i8 >> 2] = i68;
   i69 = _malloc(i71) | 0;
   i1 = i5 + 20 | 0;
   HEAP32[i1 >> 2] = i69;
   i2 = i5 + 24 | 0;
   HEAP32[i2 >> 2] = _malloc(i71) | 0;
   i70 = i5 + 28 | 0;
   HEAP32[i70 >> 2] = _malloc(i71) | 0;
   i71 = i5 + 36 | 0;
   HEAP32[i71 >> 2] = _fft_create_plan(i67, i68, i69, 1, 0) | 0;
   HEAP32[i5 + 40 >> 2] = _fft_create_plan(HEAP32[i3 >> 2] | 0, HEAP32[i2 >> 2] | 0, HEAP32[i70 >> 2] | 0, -1, 0) | 0;
   i70 = HEAP32[i3 >> 2] << 3;
   i2 = i5 + 8 | 0;
   HEAP32[i2 >> 2] = _malloc(i70) | 0;
   _memset(HEAP32[i8 >> 2] | 0, 0, i70 | 0) | 0;
   _memmove(HEAP32[i8 >> 2] | 0, HEAP32[i4 >> 2] | 0, HEAP32[i5 >> 2] << 3 | 0) | 0;
   i71 = HEAP32[i71 >> 2] | 0;
   mftCall_vi(HEAP32[i71 + 28 >> 2] | 0, i71 | 0);
   _memmove(HEAP32[i2 >> 2] | 0, HEAP32[i1 >> 2] | 0, HEAP32[i3 >> 2] << 3 | 0) | 0;
   i1 = HEAP32[i3 >> 2] | 0;
   HEAP32[i5 + 44 >> 2] = i1 >>> 1;
   HEAP32[i5 + 56 >> 2] = 0;
   HEAPF32[i5 + 60 >> 2] = 0.0;
   HEAPF32[i5 + 64 >> 2] = 0.0;
   HEAP32[i5 + 88 >> 2] = 0;
   HEAP32[i5 + 92 >> 2] = 0;
   _memset(HEAP32[i8 >> 2] | 0, 0, i1 << 3 | 0) | 0;
   i1 = i5 + 72 | 0;
   i8 = i5 + 48 | 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   HEAPF32[i8 >> 2] = .5;
   i3 = ~~(+((HEAP32[i3 >> 2] | 0) >>> 0) * .30000001192092896 / 6.283185307179586);
   HEAP32[i5 + 52 >> 2] = (i3 | 0) < 0 ? 0 : i3;
   _free(i10);
   HEAP32[i18 + 72 >> 2] = i5;
   HEAPF32[i8 >> 2] = .5;
   HEAP32[i18 + 104 >> 2] = 32;
   i8 = i18 + 100 | 0;
   HEAP32[i8 >> 2] = _firpfb_crcf_create_rnyquist(HEAP32[i16 >> 2] | 0, +HEAPF32[i17 >> 2]) | 0;
   i3 = _malloc(1060) | 0;
   HEAP32[i3 >> 2] = 0;
   i1 = i3 + 12 | 0;
   i2 = 0;
   do {
    HEAPF32[i1 + (i2 << 2) >> 2] = +Math_sin(+(+(i2 >>> 0) * 6.283185307179586 * .00390625));
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != 256);
   HEAPF32[i3 + 1052 >> 2] = .10000000149011612;
   HEAPF32[i3 + 1056 >> 2] = .3162277638912201;
   i1 = HEAP32[i3 >> 2] | 0;
   switch (i1 | 0) {
   case 0:
    {
     HEAP32[i3 + 1048 >> 2] = fb + 1;
     break;
    }
   case 1:
    {
     HEAP32[i3 + 1048 >> 2] = fb + 2;
     break;
    }
   default:
    {
     HEAP32[i42 >> 2] = i1;
     _fprintf(gb + 8728 | 0, gb + 36150 | 0, i42);
     _exit(1);
    }
   }
   HEAPF32[i3 + 4 >> 2] = 0.0;
   HEAPF32[i3 + 8 >> 2] = 0.0;
   HEAP32[i3 + 1036 >> 2] = 0;
   HEAPF32[i3 + 1040 >> 2] = 0.0;
   HEAPF32[i3 + 1044 >> 2] = 1.0;
   i5 = i18 + 92 | 0;
   HEAP32[i5 >> 2] = i3;
   i4 = _malloc(1060) | 0;
   HEAP32[i4 >> 2] = 0;
   i1 = i4 + 12 | 0;
   i2 = 0;
   do {
    HEAPF32[i1 + (i2 << 2) >> 2] = +Math_sin(+(+(i2 >>> 0) * 6.283185307179586 * .00390625));
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != 256);
   i1 = i4 + 1052 | 0;
   HEAPF32[i1 >> 2] = .10000000149011612;
   i2 = i4 + 1056 | 0;
   HEAPF32[i2 >> 2] = .3162277638912201;
   i3 = HEAP32[i4 >> 2] | 0;
   switch (i3 | 0) {
   case 0:
    {
     HEAP32[i4 + 1048 >> 2] = fb + 1;
     break;
    }
   case 1:
    {
     HEAP32[i4 + 1048 >> 2] = fb + 2;
     break;
    }
   default:
    {
     HEAP32[i48 >> 2] = i3;
     _fprintf(gb + 8728 | 0, gb + 36150 | 0, i48);
     _exit(1);
    }
   }
   HEAPF32[i4 + 4 >> 2] = 0.0;
   HEAPF32[i4 + 8 >> 2] = 0.0;
   HEAP32[i4 + 1036 >> 2] = 0;
   HEAPF32[i4 + 1040 >> 2] = 0.0;
   HEAPF32[i4 + 1044 >> 2] = 1.0;
   i71 = i18 + 96 | 0;
   HEAP32[i71 >> 2] = i4;
   HEAPF32[i1 >> 2] = 9.999999747378752e-05;
   HEAPF32[i2 >> 2] = .009999999776482582;
   HEAP32[i18 + 124 >> 2] = 0;
   HEAP32[i18 + 136 >> 2] = 0;
   HEAP32[i18 + 156 >> 2] = 0;
   HEAP32[i18 + 132 >> 2] = 0;
   HEAP32[i18 + 144 >> 2] = 0;
   _flexframesync_set_header_len(i18, 14);
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 48;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 2;
   HEAP32[i1 + 8 >> 2] = 4;
   i69 = i1 + 236 | 0;
   HEAP32[i69 >> 2] = 0;
   HEAP32[i69 + 4 >> 2] = 0;
   HEAP32[i69 + 8 >> 2] = 0;
   HEAP32[i69 + 12 >> 2] = 0;
   HEAP32[i69 >> 2] = fb + 1;
   HEAP32[i1 + 240 >> 2] = fb + 2;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   HEAP32[i18 + 164 >> 2] = i1;
   i1 = i18 + 184 | 0;
   HEAP32[i1 >> 2] = 64;
   i69 = _malloc(36) | 0;
   i68 = _malloc(252) | 0;
   HEAP32[i68 >> 2] = 48;
   HEAP32[i68 + 76 >> 2] = 0;
   HEAP32[i68 + 80 >> 2] = 0;
   HEAP32[i68 + 4 >> 2] = 2;
   HEAP32[i68 + 8 >> 2] = 4;
   i70 = i68 + 236 | 0;
   HEAP32[i70 >> 2] = 0;
   HEAP32[i70 + 4 >> 2] = 0;
   HEAP32[i70 + 8 >> 2] = 0;
   HEAP32[i70 + 12 >> 2] = 0;
   HEAP32[i70 >> 2] = fb + 1;
   HEAP32[i68 + 240 >> 2] = fb + 2;
   HEAPF32[i68 + 84 >> 2] = 1.0;
   HEAPF32[i68 + 88 >> 2] = 0.0;
   HEAP32[i68 + 92 >> 2] = 1065353216;
   HEAPF32[i68 + 96 >> 2] = 0.0;
   HEAP32[i69 >> 2] = i68;
   HEAP32[i69 + 8 >> 2] = 2;
   HEAP32[i69 + 12 >> 2] = 1;
   i68 = _packetizer_create(1, 1, 1, 1) | 0;
   HEAP32[i69 + 4 >> 2] = i68;
   i68 = HEAP32[i68 + 4 >> 2] | 0;
   HEAP32[i69 + 24 >> 2] = i68;
   i70 = i68 << 3;
   HEAP32[i69 + 28 >> 2] = i70;
   HEAP32[i69 + 16 >> 2] = _malloc(((i70 | 0) / 2 | 0) << 1) | 0;
   HEAP32[i69 + 32 >> 2] = i68 << 1;
   HEAP32[i69 + 20 >> 2] = _malloc(i70) | 0;
   i70 = i18 + 176 | 0;
   HEAP32[i70 >> 2] = i69;
   _qpacketmodem_configure(i69, HEAP32[i1 >> 2] | 0, 5, 1, 7, 48);
   i70 = HEAP32[(HEAP32[i70 >> 2] | 0) + 32 >> 2] | 0;
   HEAP32[i18 + 172 >> 2] = i70;
   HEAP32[i18 + 168 >> 2] = _malloc(i70 << 3) | 0;
   HEAP32[i18 + 180 >> 2] = _malloc(HEAP32[i1 >> 2] | 0) | 0;
   i1 = i18 + 48 | 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   i1 = i18 + 204 | 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   i70 = HEAP32[i5 >> 2] | 0;
   HEAPF32[i70 + 4 >> 2] = 0.0;
   HEAPF32[i70 + 8 >> 2] = 0.0;
   HEAP32[i70 + 1036 >> 2] = 0;
   HEAPF32[i70 + 1040 >> 2] = 0.0;
   HEAPF32[i70 + 1044 >> 2] = 1.0;
   i71 = HEAP32[i71 >> 2] | 0;
   HEAPF32[i71 + 4 >> 2] = 0.0;
   HEAPF32[i71 + 8 >> 2] = 0.0;
   HEAP32[i71 + 1036 >> 2] = 0;
   HEAPF32[i71 + 1040 >> 2] = 0.0;
   HEAPF32[i71 + 1044 >> 2] = 1.0;
   i71 = HEAP32[(HEAP32[i8 >> 2] | 0) + 16 >> 2] | 0;
   HEAP32[i71 + 24 >> 2] = 0;
   _memset(HEAP32[i71 >> 2] | 0, 0, HEAP32[i71 + 20 >> 2] << 3 | 0) | 0;
   HEAP32[i18 + 200 >> 2] = 0;
   HEAP32[i18 + 192 >> 2] = 0;
   HEAP32[i18 + 196 >> 2] = 0;
   HEAPF32[i18 + 8 >> 2] = 0.0;
   _flexframesync_set_header_len(i18, 0);
   if (HEAP8[i73 + 56 >> 0] | 0 ? (i49 = i18 + 208 | 0, (HEAP32[i49 >> 2] | 0) == 0) : 0) {
    i71 = _malloc(28) | 0;
    HEAP32[i71 + 4 >> 2] = 2e3;
    HEAP32[i71 + 8 >> 2] = 11;
    HEAP32[i71 + 12 >> 2] = 2048;
    HEAP32[i71 + 16 >> 2] = 2047;
    HEAP32[i71 + 20 >> 2] = 4047;
    i70 = _malloc(32376) | 0;
    HEAP32[i71 >> 2] = i70;
    HEAP32[i71 + 24 >> 2] = 0;
    _memset(i70 | 0, 0, 32376) | 0;
    HEAP32[i18 + 216 >> 2] = i71;
    HEAP32[i1 >> 2] = 1;
    HEAP32[i49 >> 2] = 1;
   }
   HEAP32[i75 + 80 >> 2] = _malloc(2048) | 0;
   HEAP32[i75 + 84 >> 2] = 256;
   HEAP32[i75 + 60 >> 2] = i18;
   break;
  }
 case 2:
  {
   i3 = _gmskframesync_create(i75) | 0;
   HEAP32[i3 + 144 >> 2] = 0;
   i1 = i3 + 164 | 0;
   HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, 5) | 0;
   i1 = i3 + 168 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if (i2 | 0) _packetizer_destroy(i2);
   i69 = _packetizer_create(5, 6, 6, 1) | 0;
   HEAP32[i1 >> 2] = i69;
   i69 = HEAP32[i69 + 4 >> 2] | 0;
   i70 = i3 + 148 | 0;
   HEAP32[i70 >> 2] = i69;
   i71 = i3 + 160 | 0;
   HEAP32[i71 >> 2] = _realloc(HEAP32[i71 >> 2] | 0, i69) | 0;
   i70 = HEAP32[i70 >> 2] << 3;
   HEAP32[i3 + 152 >> 2] = i70;
   i71 = i3 + 156 | 0;
   HEAP32[i71 >> 2] = _realloc(HEAP32[i71 >> 2] | 0, i70) | 0;
   if (HEAP8[i73 + 56 >> 0] | 0) {
    i1 = i3 + 236 | 0;
    if (!(HEAP32[i1 >> 2] | 0)) {
     i71 = _malloc(28) | 0;
     HEAP32[i71 + 4 >> 2] = 2e3;
     HEAP32[i71 + 8 >> 2] = 11;
     HEAP32[i71 + 12 >> 2] = 2048;
     HEAP32[i71 + 16 >> 2] = 2047;
     HEAP32[i71 + 20 >> 2] = 4047;
     i70 = _malloc(32376) | 0;
     HEAP32[i71 >> 2] = i70;
     HEAP32[i71 + 24 >> 2] = 0;
     _memset(i70 | 0, 0, 32376) | 0;
     HEAP32[i3 + 240 >> 2] = i71;
     i71 = _malloc(28) | 0;
     HEAP32[i71 + 4 >> 2] = 2e3;
     HEAP32[i71 + 8 >> 2] = 11;
     HEAP32[i71 + 12 >> 2] = 2048;
     HEAP32[i71 + 16 >> 2] = 2047;
     HEAP32[i71 + 20 >> 2] = 4047;
     i70 = _malloc(16188) | 0;
     HEAP32[i71 >> 2] = i70;
     HEAP32[i71 + 24 >> 2] = 0;
     _memset(i70 | 0, 0, 16188) | 0;
     HEAP32[i3 + 244 >> 2] = i71;
     i71 = _malloc(28) | 0;
     HEAP32[i71 + 4 >> 2] = 2e3;
     HEAP32[i71 + 8 >> 2] = 11;
     HEAP32[i71 + 12 >> 2] = 2048;
     HEAP32[i71 + 16 >> 2] = 2047;
     HEAP32[i71 + 20 >> 2] = 4047;
     i70 = _malloc(16188) | 0;
     HEAP32[i71 >> 2] = i70;
     HEAP32[i71 + 24 >> 2] = 0;
     _memset(i70 | 0, 0, 16188) | 0;
     HEAP32[i3 + 248 >> 2] = i71;
     i71 = _malloc(28) | 0;
     HEAP32[i71 + 4 >> 2] = 2e3;
     HEAP32[i71 + 8 >> 2] = 11;
     HEAP32[i71 + 12 >> 2] = 2048;
     HEAP32[i71 + 16 >> 2] = 2047;
     HEAP32[i71 + 20 >> 2] = 4047;
     i70 = _malloc(16188) | 0;
     HEAP32[i71 >> 2] = i70;
     HEAP32[i71 + 24 >> 2] = 0;
     _memset(i70 | 0, 0, 16188) | 0;
     HEAP32[i3 + 252 >> 2] = i71;
    }
    HEAP32[i3 + 232 >> 2] = 1;
    HEAP32[i1 >> 2] = 1;
   }
   HEAP32[i75 + 80 >> 2] = _malloc(2048) | 0;
   HEAP32[i75 + 84 >> 2] = 256;
   HEAP32[i75 + 60 >> 2] = i3;
   break;
  }
 default:
  {}
 }
 i4 = i73 + 20 | 0;
 i1 = _malloc(24) | 0;
 HEAP32[i1 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i1 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 HEAP32[i1 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
 HEAP32[i1 + 12 >> 2] = HEAP32[i4 + 12 >> 2];
 i5 = _malloc(1060) | 0;
 HEAP32[i5 >> 2] = 0;
 i2 = i5 + 12 | 0;
 i3 = 0;
 do {
  HEAPF32[i2 + (i3 << 2) >> 2] = +Math_sin(+(+(i3 >>> 0) * 6.283185307179586 * .00390625));
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 256);
 HEAPF32[i5 + 1052 >> 2] = .10000000149011612;
 HEAPF32[i5 + 1056 >> 2] = .3162277638912201;
 i2 = HEAP32[i5 >> 2] | 0;
 switch (i2 | 0) {
 case 0:
  {
   HEAP32[i5 + 1048 >> 2] = fb + 1;
   break;
  }
 case 1:
  {
   HEAP32[i5 + 1048 >> 2] = fb + 2;
   break;
  }
 default:
  {
   HEAP32[i72 >> 2] = i2;
   _fprintf(gb + 8728 | 0, gb + 36150 | 0, i72);
   _exit(1);
  }
 }
 HEAP32[i5 + 1036 >> 2] = 0;
 HEAPF32[i5 + 1040 >> 2] = 0.0;
 HEAPF32[i5 + 1044 >> 2] = 1.0;
 HEAP32[i1 + 16 >> 2] = i5;
 HEAPF32[i5 + 4 >> 2] = 0.0;
 HEAP32[i5 + 8 >> 2] = HEAP32[i73 + 32 >> 2];
 i2 = HEAP32[i4 >> 2] | 0;
 if (i2 >>> 0 > 1) HEAP32[i1 + 20 >> 2] = _firdecim_crcf_create_kaiser(i2, HEAP32[i73 + 24 >> 2] | 0) | 0; else {
  HEAP32[i1 >> 2] = 1;
  HEAP32[i1 + 4 >> 2] = 0;
  HEAP32[i1 + 20 >> 2] = 0;
 }
 i2 = i75 + 64 | 0;
 HEAP32[i2 >> 2] = i1;
 HEAP32[i75 + 88 >> 2] = 0;
 i3 = i75 + 92 | 0;
 HEAPF32[i3 >> 2] = 1.0;
 i5 = i75 + 100 | 0;
 HEAP32[i5 >> 2] = 0;
 i4 = i75 + 96 | 0;
 HEAP32[i4 >> 2] = 0;
 if (d74 != 44100.0) {
  d79 = 44100.0 / d74;
  HEAP32[i4 >> 2] = _resamp_rrrf_create(d79, HEAP32[i73 + 36 >> 2] | 0, +HEAPF32[i73 + 40 >> 2], +HEAPF32[i73 + 44 >> 2], HEAP32[i73 + 48 >> 2] | 0) | 0;
  HEAPF32[i3 >> 2] = d79;
  i1 = HEAP32[i2 >> 2] | 0;
 }
 HEAP32[i5 >> 2] = _malloc(Math_imul(HEAP32[i75 + 84 >> 2] << 2, HEAP32[i1 >> 2] | 0) | 0) | 0;
 HEAP32[i75 + 104 >> 2] = 0;
 HEAP32[i75 + 108 >> 2] = 0;
 STACKTOP = i76;
 return i75 | 0;
}

function _gmskframesync_execute(i93, i94, i92) {
 i93 = i93 | 0;
 i94 = i94 | 0;
 i92 = i92 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, d18 = 0.0, d19 = 0.0, d20 = 0.0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, i74 = 0, i75 = 0, i76 = 0, i77 = 0, i78 = 0, i79 = 0, i80 = 0, i81 = 0, i82 = 0, i83 = 0, i84 = 0, i85 = 0, i86 = 0, i87 = 0, i88 = 0, i89 = 0, i90 = 0, i91 = 0, i95 = 0, i96 = 0, i97 = 0, i98 = 0, i99 = 0, i100 = 0, i101 = 0, i102 = 0, i103 = 0, i104 = 0, i105 = 0, i106 = 0, i107 = 0;
 i98 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i29 = i98 + 16 | 0;
 i96 = i98 + 8 | 0;
 i97 = i98;
 if (!i92) {
  STACKTOP = i98;
  return;
 }
 i31 = i93 + 232 | 0;
 i42 = i93 + 216 | 0;
 i53 = i97 + 4 | 0;
 i64 = i93 + 124 | 0;
 i75 = i93 + 108 | 0;
 i87 = i93 + 112 | 0;
 i89 = i93 + 116 | 0;
 i90 = i93 + 120 | 0;
 i91 = i93 + 240 | 0;
 i32 = i93 + 76 | 0;
 i33 = i93 + 80 | 0;
 i34 = i93 + 4 | 0;
 i35 = i93 + 8 | 0;
 i36 = i93 + 84 | 0;
 i37 = i93 + 92 | 0;
 i38 = i93 + 96 | 0;
 i39 = i93 + 100 | 0;
 i40 = i93 + 128 | 0;
 i41 = i93 + 132 | 0;
 i43 = i93 + 68 | 0;
 i44 = i29 + 4 | 0;
 i45 = i93 + 72 | 0;
 i46 = i93 + 64 | 0;
 i47 = i29 + 4 | 0;
 i48 = i29 + 4 | 0;
 i49 = i29 + 4 | 0;
 i50 = i29 + 4 | 0;
 i51 = i93 + 224 | 0;
 i52 = i93 + 156 | 0;
 i54 = i93 + 152 | 0;
 i55 = i93 + 160 | 0;
 i56 = i93 + 148 | 0;
 i57 = i93 + 168 | 0;
 i58 = i93 + 164 | 0;
 i59 = i93 + 172 | 0;
 i60 = i93 + 16 | 0;
 i30 = i93 + 88 | 0;
 i61 = i93 + 24 | 0;
 i62 = i93 + 28 | 0;
 i63 = i93 + 36 | 0;
 i65 = i93 + 40 | 0;
 i66 = i93 + 56 | 0;
 i67 = i93 + 60 | 0;
 i68 = i93 + 20 | 0;
 i69 = i93 + 144 | 0;
 i70 = i93 + 196 | 0;
 i71 = i93 + 180 | 0;
 i72 = i93 + 184 | 0;
 i73 = i93 + 188 | 0;
 i74 = i93 + 208 | 0;
 i76 = i93 + 192 | 0;
 i77 = i93 + 200 | 0;
 i78 = i93 + 204 | 0;
 i79 = i29 + 4 | 0;
 i80 = i29 + 4 | 0;
 i81 = i93 + 176 | 0;
 i82 = i93 + 228 | 0;
 i83 = i93 + 212 | 0;
 i84 = i93 + 44 | 0;
 i86 = i93 + 48 | 0;
 i88 = i93 + 52 | 0;
 i95 = 0;
 L4 : while (1) {
  _iirfilt_crcf_execute(HEAP32[i93 >> 2] | 0, +HEAPF32[i94 + (i95 << 3) >> 2], +HEAPF32[i94 + (i95 << 3) + 4 >> 2], i97);
  if (HEAP32[i31 >> 2] | 0) {
   i4 = HEAP32[i91 >> 2] | 0;
   i12 = HEAP32[i97 >> 2] | 0;
   i13 = HEAP32[i53 >> 2] | 0;
   i5 = i4 + 24 | 0;
   i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
   HEAP32[i5 >> 2] = i2;
   if (!i2) {
    i2 = HEAP32[i4 >> 2] | 0;
    i11 = i4 + 4 | 0;
    _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
    i2 = HEAP32[i5 >> 2] | 0;
   } else i11 = i4 + 4 | 0;
   i27 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
   i26 = HEAP32[i4 >> 2] | 0;
   HEAP32[i26 + (i27 << 3) >> 2] = i12;
   HEAP32[i26 + (i27 << 3) + 4 >> 2] = i13;
  }
  L13 : do switch (HEAP32[i42 >> 2] | 0) {
  case 0:
   {
    i12 = HEAP32[i97 >> 2] | 0;
    i13 = HEAP32[i53 >> 2] | 0;
    i4 = HEAP32[i64 >> 2] | 0;
    i5 = i4 + 24 | 0;
    i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
    HEAP32[i5 >> 2] = i2;
    if (!i2) {
     i2 = HEAP32[i4 >> 2] | 0;
     i11 = i4 + 4 | 0;
     _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
     i2 = HEAP32[i5 >> 2] | 0;
    } else i11 = i4 + 4 | 0;
    i27 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
    i14 = HEAP32[i4 >> 2] | 0;
    HEAP32[i14 + (i27 << 3) >> 2] = i12;
    HEAP32[i14 + (i27 << 3) + 4 >> 2] = i13;
    i27 = HEAP32[i75 >> 2] | 0;
    i14 = i27 + 16 | 0;
    i4 = HEAP32[i14 >> 2] | 0;
    i5 = i4 + 24 | 0;
    i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
    HEAP32[i5 >> 2] = i2;
    if (!i2) {
     i2 = HEAP32[i4 >> 2] | 0;
     i11 = i4 + 4 | 0;
     _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i11 >> 2] << 3) + -8 | 0) | 0;
     i2 = HEAP32[i5 >> 2] | 0;
    } else i11 = i4 + 4 | 0;
    i26 = i2 + -1 + (HEAP32[i11 >> 2] | 0) | 0;
    i25 = HEAP32[i4 >> 2] | 0;
    HEAP32[i25 + (i26 << 3) >> 2] = i12;
    HEAP32[i25 + (i26 << 3) + 4 >> 2] = i13;
    d8 = (HEAP32[tempDoublePtr >> 2] = i12, +HEAPF32[tempDoublePtr >> 2]);
    d6 = (HEAP32[tempDoublePtr >> 2] = i13, +HEAPF32[tempDoublePtr >> 2]);
    d7 = -d6;
    d3 = d8 * d8 - d6 * d7;
    d20 = d8 * d6 + d8 * d7;
    if ((d3 != d3 | 0.0 != 0.0) & (d20 != d20 | 0.0 != 0.0)) {
     ___mulsc3(i29, d8, d6, d8, d7);
     d3 = +HEAPF32[i29 >> 2];
    }
    i25 = HEAP32[i27 + 60 >> 2] | 0;
    i21 = i25 + 8 | 0;
    i26 = HEAP32[i21 >> 2] | 0;
    i2 = (HEAP32[i25 >> 2] | 0) + (i26 << 2) | 0;
    d20 = +HEAPF32[i2 >> 2];
    HEAPF32[i2 >> 2] = d3;
    HEAP32[i21 >> 2] = ((i26 + 1 | 0) >>> 0) % ((HEAP32[i25 + 4 >> 2] | 0) >>> 0) | 0;
    i21 = i27 + 64 | 0;
    d20 = d3 + +HEAPF32[i21 >> 2] - d20;
    HEAPF32[i21 >> 2] = d20;
    i21 = i27 + 12 | 0;
    i25 = i27 + 68 | 0;
    HEAPF32[i25 >> 2] = d20 * +HEAPF32[i21 >> 2];
    i26 = i27 + 76 | 0;
    i2 = HEAP32[i26 >> 2] | 0;
    if (i2 | 0) {
     HEAP32[i26 >> 2] = i2 + -1;
     break L13;
    }
    i24 = i27 + 44 | 0;
    i23 = i27 + 48 | 0;
    i17 = i27 + 24 | 0;
    _memmove(HEAP32[i24 >> 2] | 0, HEAP32[i23 >> 2] | 0, HEAP32[i17 >> 2] << 2 | 0) | 0;
    i22 = i27 + 40 | 0;
    _memmove(HEAP32[i23 >> 2] | 0, HEAP32[i22 >> 2] | 0, HEAP32[i17 >> 2] << 2 | 0) | 0;
    i12 = HEAP32[i14 >> 2] | 0;
    i12 = (HEAP32[i12 >> 2] | 0) + (HEAP32[i12 + 24 >> 2] << 3) | 0;
    if (!(HEAP32[i17 >> 2] | 0)) {
     i2 = i27 + 52 | 0;
     i14 = HEAP32[i22 >> 2] | 0;
     i13 = 0;
    } else {
     i15 = i27 + 20 | 0;
     i2 = i27 + 52 | 0;
     i16 = 0;
     d20 = 0.0;
     while (1) {
      i5 = HEAP32[(HEAP32[i15 >> 2] | 0) + (i16 << 2) >> 2] | 0;
      i4 = HEAP32[i5 >> 2] | 0;
      i5 = HEAP32[i5 + 4 >> 2] | 0;
      if (!i5) {
       d6 = 0.0;
       d3 = 0.0;
      } else {
       i11 = 0;
       d6 = 0.0;
       d3 = 0.0;
       do {
        d9 = +HEAPF32[i4 + (i11 << 3) >> 2];
        d10 = +HEAPF32[i4 + (i11 << 3) + 4 >> 2];
        d18 = +HEAPF32[i12 + (i11 << 3) >> 2];
        d19 = +HEAPF32[i12 + (i11 << 3) + 4 >> 2];
        d7 = d9 * d18 - d10 * d19;
        d8 = d10 * d18 + d9 * d19;
        if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
         ___mulsc3(i29, d9, d10, d18, d19);
         d7 = +HEAPF32[i29 >> 2];
         d8 = +HEAPF32[i48 >> 2];
        }
        d6 = d6 + d7;
        d3 = d3 + d8;
        i11 = i11 + 1 | 0;
       } while ((i11 | 0) != (i5 | 0));
      }
      d6 = +Math_abs(+d6);
      i14 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
      d6 = +Math_abs(+d3);
      i5 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
      i13 = i14 >>> 0 < i5 >>> 0;
      i4 = i13 ? i5 : i14;
      i5 = i13 ? i14 : i5;
      d6 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
      d3 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
      do if ((i5 | 0) != 2139095040) {
       if (i4 >>> 0 > 2139095039 | (i5 | 0) == 0 | (i4 - i5 | 0) >>> 0 > 209715199) {
        d3 = d6 + d3;
        break;
       }
       if (i4 >>> 0 <= 1568669695) if (i5 >>> 0 < 562036736) {
        d3 = d3 * 1237940039285380274899124.0e3;
        d6 = d6 * 1237940039285380274899124.0e3;
        d7 = 8.077935669463161e-28;
       } else d7 = 1.0; else {
        d3 = d3 * 8.077935669463161e-28;
        d6 = d6 * 8.077935669463161e-28;
        d7 = 1237940039285380274899124.0e3;
       }
       d19 = d6;
       d3 = d7 * +Math_sqrt(+(d19 * d19 + d3 * d3));
      } while (0);
      d3 = d3 * +HEAPF32[i21 >> 2] / +Math_sqrt(+(+HEAPF32[i25 >> 2]));
      i14 = HEAP32[i22 >> 2] | 0;
      HEAPF32[i14 + (i16 << 2) >> 2] = d3;
      if (d3 > d20) HEAP32[i2 >> 2] = i16; else d3 = d20;
      i16 = i16 + 1 | 0;
      i13 = HEAP32[i17 >> 2] | 0;
      if (i16 >>> 0 >= i13 >>> 0) break; else d20 = d3;
     }
    }
    i4 = HEAP32[i2 >> 2] | 0;
    d6 = +HEAPF32[i14 + (i4 << 2) >> 2];
    i12 = i27 + 72 | 0;
    switch (HEAP32[i12 >> 2] | 0) {
    case 0:
     {
      if (!(d6 > +HEAPF32[i27 + 8 >> 2])) break L13;
      HEAP32[i27 + 56 >> 2] = i4;
      HEAP32[i12 >> 2] = 1;
      break L13;
     }
    case 1:
     break;
    default:
     {
      i28 = 45;
      break L4;
     }
    }
    i5 = i27 + 56 | 0;
    i11 = HEAP32[i5 >> 2] | 0;
    i2 = HEAP32[i23 >> 2] | 0;
    d3 = +HEAPF32[i2 + (i11 << 2) >> 2];
    if (d6 > d3) {
     HEAP32[i5 >> 2] = i4;
     break L13;
    }
    if ((i13 | 0) == 1) {
     HEAPF32[i89 >> 2] = 0.0;
     d3 = 0.0;
    } else {
     d19 = +HEAPF32[(HEAP32[i24 >> 2] | 0) + (i11 << 2) >> 2];
     d10 = +HEAPF32[((i11 | 0) == 0 ? i2 + 4 | 0 : i2 + (i11 + -1 << 2) | 0) >> 2];
     d18 = +HEAPF32[i2 + (((i11 | 0) == (i13 + -1 | 0) ? -1 : 1) + i11 << 2) >> 2];
     d20 = +HEAPF32[i14 + (i11 << 2) >> 2];
     d3 = d3 * 2.0;
     HEAPF32[i89 >> 2] = +HEAPF32[(HEAP32[i27 + 36 >> 2] | 0) + (i11 << 2) >> 2] - (d18 - d10) * (+HEAPF32[i27 + 28 >> 2] * .5) / (d10 + d18 - d3);
     d3 = (d20 - d19) * .5 / (d19 + d20 - d3);
     d3 = d3 < -.49900001287460327 ? -.49900001287460327 : d3;
     d3 = d3 > .49900001287460327 ? .49900001287460327 : d3;
    }
    HEAPF32[i87 >> 2] = d3;
    HEAPF32[i90 >> 2] = +Math_sqrt(+(+HEAPF32[i25 >> 2]));
    HEAP32[i12 >> 2] = 0;
    HEAP32[i26 >> 2] = (HEAP32[i27 + 4 >> 2] | 0) >>> 2;
    i16 = HEAP32[(HEAP32[i32 >> 2] | 0) + 16 >> 2] | 0;
    HEAP32[i16 + 24 >> 2] = 0;
    _memset(HEAP32[i16 >> 2] | 0, 0, HEAP32[i16 + 20 >> 2] << 2 | 0) | 0;
    i16 = HEAP32[(HEAP32[i33 >> 2] | 0) + 16 >> 2] | 0;
    HEAP32[i16 + 24 >> 2] = 0;
    _memset(HEAP32[i16 >> 2] | 0, 0, HEAP32[i16 + 20 >> 2] << 2 | 0) | 0;
    i16 = HEAP32[i64 >> 2] | 0;
    i16 = (HEAP32[i16 >> 2] | 0) + (HEAP32[i16 + 24 >> 2] << 3) | 0;
    d3 = +HEAPF32[i87 >> 2];
    if (!(d3 < .5 & d3 > -.5)) {
     i28 = 58;
     break L4;
    }
    i11 = HEAP32[i34 >> 2] | 0;
    i12 = HEAP32[i35 >> 2] | 0;
    i4 = Math_imul(i11 << 1, i12) | 0;
    i5 = HEAP32[i36 >> 2] | 0;
    d6 = +(i5 >>> 0);
    d3 = -(d3 * d6);
    HEAPF32[i37 >> 2] = d3;
    i2 = ~~+_roundf(+d3);
    HEAP32[i38 >> 2] = i2;
    i4 = i4 + -1 | 0;
    if ((i2 | 0) < 0) {
     do {
      i2 = i2 + i5 | 0;
      d3 = d6 + d3;
      i4 = i4 + -1 | 0;
     } while ((i2 | 0) < 0);
     HEAP32[i38 >> 2] = i2;
     HEAPF32[i37 >> 2] = d3;
    }
    HEAP32[i39 >> 2] = 0;
    HEAP32[(HEAP32[i40 >> 2] | 0) + 8 >> 2] = HEAP32[i89 >> 2];
    i14 = Math_imul(i12 + (HEAP32[i41 >> 2] | 0) | 0, i11) | 0;
    if (i14 | 0) {
     i15 = 0;
     do {
      if (i15 >>> 0 < i4 >>> 0) {
       i27 = HEAP32[i40 >> 2] | 0;
       d3 = +HEAPF32[i16 + (i15 << 3) >> 2];
       d6 = +HEAPF32[i16 + (i15 << 3) + 4 >> 2];
       mftCall_vi(HEAP32[i27 + 1048 >> 2] | 0, i27 | 0);
       d8 = +HEAPF32[i27 + 1040 >> 2];
       d7 = +HEAPF32[i27 + 1044 >> 2] - d8 * 0.0;
       d8 = -d8;
       d9 = d3 * d7 - d6 * d8;
       d10 = d3 * d8 + d6 * d7;
       if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
        ___mulsc3(i29, d3, d6, d7, d8);
        d9 = +HEAPF32[i29 >> 2];
        d10 = +HEAPF32[i47 >> 2];
       }
       i27 = HEAP32[i40 >> 2] | 0;
       i2 = i27 + 4 | 0;
       d3 = +HEAPF32[i27 + 8 >> 2] + +HEAPF32[i2 >> 2];
       HEAPF32[i2 >> 2] = d3;
       do if (d3 > 3.141592653589793) HEAPF32[i2 >> 2] = d3 + -6.283185307179586; else {
        if (!(d3 < -3.141592653589793)) break;
        HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
       } while (0);
       d7 = +HEAPF32[i46 >> 2];
       d8 = -+HEAPF32[i43 >> 2];
       d3 = d9 * d7 - d10 * d8;
       d6 = d10 * d7 + d9 * d8;
       if ((d3 != d3 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
        ___mulsc3(i29, d7, d8, d9, d10);
        d6 = +HEAPF32[i44 >> 2];
        d3 = +HEAPF32[i29 >> 2];
       }
       d3 = +Math_atan2(+d6, +d3);
       d3 = d3 * +((HEAP32[i34 >> 2] | 0) >>> 0);
       HEAPF32[i45 >> 2] = d3;
       HEAPF32[i46 >> 2] = d9;
       HEAPF32[i43 >> 2] = d10;
       i5 = HEAP32[(HEAP32[i32 >> 2] | 0) + 16 >> 2] | 0;
       i11 = i5 + 24 | 0;
       i2 = HEAP32[i5 + 16 >> 2] & (HEAP32[i11 >> 2] | 0) + 1;
       HEAP32[i11 >> 2] = i2;
       if (!i2) {
        i2 = HEAP32[i5 >> 2] | 0;
        i12 = i5 + 4 | 0;
        _memmove(i2 | 0, i2 + (HEAP32[i5 + 12 >> 2] << 2) | 0, (HEAP32[i12 >> 2] << 2) + -4 | 0) | 0;
        i2 = HEAP32[i11 >> 2] | 0;
       } else i12 = i5 + 4 | 0;
       HEAPF32[(HEAP32[i5 >> 2] | 0) + (i2 + -1 + (HEAP32[i12 >> 2] | 0) << 2) >> 2] = d3;
       i13 = HEAP32[i45 >> 2] | 0;
       i5 = HEAP32[(HEAP32[i33 >> 2] | 0) + 16 >> 2] | 0;
       i11 = i5 + 24 | 0;
       i2 = HEAP32[i5 + 16 >> 2] & (HEAP32[i11 >> 2] | 0) + 1;
       HEAP32[i11 >> 2] = i2;
       if (!i2) {
        i2 = HEAP32[i5 >> 2] | 0;
        i12 = i5 + 4 | 0;
        _memmove(i2 | 0, i2 + (HEAP32[i5 + 12 >> 2] << 2) | 0, (HEAP32[i12 >> 2] << 2) + -4 | 0) | 0;
        i2 = HEAP32[i11 >> 2] | 0;
       } else i12 = i5 + 4 | 0;
       HEAP32[(HEAP32[i5 >> 2] | 0) + (i2 + -1 + (HEAP32[i12 >> 2] | 0) << 2) >> 2] = i13;
      } else _gmskframesync_execute_rxpreamble(i93, +HEAPF32[i16 + (i15 << 3) >> 2], +HEAPF32[i16 + (i15 << 3) + 4 >> 2]);
      i15 = i15 + 1 | 0;
     } while ((i15 | 0) != (i14 | 0));
    }
    HEAP32[i42 >> 2] = 1;
    break;
   }
  case 1:
   {
    _gmskframesync_execute_rxpreamble(i93, +HEAPF32[i97 >> 2], +HEAPF32[i53 >> 2]);
    break;
   }
  case 2:
   {
    d3 = +HEAPF32[i97 >> 2];
    d6 = +HEAPF32[i53 >> 2];
    i27 = HEAP32[i40 >> 2] | 0;
    mftCall_vi(HEAP32[i27 + 1048 >> 2] | 0, i27 | 0);
    d8 = +HEAPF32[i27 + 1040 >> 2];
    d7 = +HEAPF32[i27 + 1044 >> 2] - d8 * 0.0;
    d8 = -d8;
    d9 = d3 * d7 - d6 * d8;
    d10 = d3 * d8 + d6 * d7;
    if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
     ___mulsc3(i29, d3, d6, d7, d8);
     d9 = +HEAPF32[i29 >> 2];
     d10 = +HEAPF32[i49 >> 2];
    }
    i27 = HEAP32[i40 >> 2] | 0;
    i2 = i27 + 4 | 0;
    d3 = +HEAPF32[i27 + 8 >> 2] + +HEAPF32[i2 >> 2];
    HEAPF32[i2 >> 2] = d3;
    if (!(d3 > 3.141592653589793)) {
     if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
    } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
    d7 = +HEAPF32[i46 >> 2];
    d8 = -+HEAPF32[i43 >> 2];
    d3 = d9 * d7 - d10 * d8;
    d6 = d10 * d7 + d9 * d8;
    if ((d3 != d3 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
     ___mulsc3(i29, d7, d8, d9, d10);
     d6 = +HEAPF32[i50 >> 2];
     d3 = +HEAPF32[i29 >> 2];
    }
    d20 = +Math_atan2(+d6, +d3);
    d20 = d20 * +((HEAP32[i34 >> 2] | 0) >>> 0);
    HEAPF32[i45 >> 2] = d20;
    HEAPF32[i46 >> 2] = d9;
    HEAPF32[i43 >> 2] = d10;
    HEAPF32[i96 >> 2] = 0.0;
    L113 : do if (_gmskframesync_update_symsync(i93, d20, i96) | 0 ? (HEAP8[(HEAP32[i52 >> 2] | 0) + (HEAP32[i51 >> 2] | 0) >> 0] = +HEAPF32[i96 >> 2] > 0.0 & 1, i85 = (HEAP32[i51 >> 2] | 0) + 1 | 0, HEAP32[i51 >> 2] = i85, (i85 | 0) == (HEAP32[i54 >> 2] | 0)) : 0) {
     i11 = HEAP32[i52 >> 2] | 0;
     i12 = HEAP32[i55 >> 2] | 0;
     if (((((i85 | 0) % 8 | 0 | 0) > 0 & 1) + ((i85 | 0) / 8 | 0) | 0) >>> 0 > (HEAP32[i56 >> 2] | 0) >>> 0) {
      i28 = 95;
      break L4;
     }
     L117 : do if (!i85) i2 = 0; else {
      i13 = 0;
      i2 = 0;
      L118 : while (1) {
       i4 = 0;
       i5 = i2;
       while (1) {
        i4 = HEAPU8[i11 + i5 >> 0] & 1 | i4 & 254;
        i5 = i5 + 1 | 0;
        if (!(i5 & 7)) break;
        if (i5 >>> 0 >= i85 >>> 0) break L118; else i4 = i4 << 1;
       }
       i2 = i13 + 1 | 0;
       HEAP8[i12 + i13 >> 0] = i4;
       if (i5 >>> 0 < i85 >>> 0) {
        i13 = i2;
        i2 = i5;
       } else break L117;
      }
      HEAP8[i12 + i13 >> 0] = i4 & 127;
      i2 = i13 + 1 | 0;
     } while (0);
     if ((i2 | 0) != (HEAP32[i56 >> 2] | 0)) {
      i28 = 113;
      break L4;
     }
     _scramble_data(HEAP32[i55 >> 2] | 0, i2);
     i2 = _packetizer_decode(HEAP32[i57 >> 2] | 0, HEAP32[i55 >> 2] | 0, HEAP32[i58 >> 2] | 0) | 0;
     HEAP32[i59 >> 2] = i2;
     do if (!i2) i28 = 176; else {
      i4 = HEAP32[i69 >> 2] | 0;
      i5 = HEAP32[i58 >> 2] | 0;
      if ((HEAP8[i5 + i4 >> 0] | 0) != 3) {
       i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i2) {
        i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
        i2 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i2 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i2;
         i28 = 121;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i2 | 32;
         break;
        }
       } else {
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        i28 = 121;
       } while (0);
       do if ((i28 | 0) == 121) {
        if ((i2 - i4 | 0) >>> 0 < 64) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25173 | 0, 64) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25173 | 0, 64) | 0) >>> 0 < 64) break;
         i2 = 0;
         i5 = gb + 25173 + 64 | 0;
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 64;
         i5 = gb + 25173 | 0;
        }
        _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       HEAP32[i59 >> 2] = 0;
       i28 = 176;
       break;
      }
      i14 = HEAPU8[i5 + (i4 + 1) >> 0] << 8 | HEAPU8[i5 + (i4 + 2) >> 0];
      i12 = HEAPU8[i5 + (i4 + 3) >> 0] | 0;
      i11 = i12 >>> 5;
      i12 = i12 & 31;
      i13 = HEAPU8[i5 + (i4 + 4) >> 0] & 31;
      if ((i11 | 0) == 7) {
       i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i2) {
        i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
        i2 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i2 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i2;
         i28 = 134;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i2 | 32;
         break;
        }
       } else {
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        i28 = 134;
       } while (0);
       do if ((i28 | 0) == 134) {
        i28 = 0;
        if ((i2 - i4 | 0) >>> 0 < 70) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25238 | 0, 70) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25238 | 0, 70) | 0) >>> 0 < 70) break;
         i2 = 0;
         i5 = gb + 25238 + 70 | 0;
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 70;
         i5 = gb + 25238 | 0;
        }
        _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       HEAP32[i59 >> 2] = 0;
       i2 = 0;
       i11 = 0;
      }
      if (i12 >>> 0 > 27) {
       i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i2) {
        i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
        i2 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i2 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i2;
         i28 = 147;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i2 | 32;
         break;
        }
       } else {
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        i28 = 147;
       } while (0);
       do if ((i28 | 0) == 147) {
        i28 = 0;
        if ((i2 - i4 | 0) >>> 0 < 78) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25309 | 0, 78) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25309 | 0, 78) | 0) >>> 0 < 78) break;
         i2 = 0;
         i5 = gb + 25309 + 78 | 0;
         i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 78;
         i5 = gb + 25309 | 0;
        }
        _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       HEAP32[i59 >> 2] = 0;
       i2 = 0;
       i5 = 0;
      } else i5 = i12;
      if (i13 >>> 0 <= 27) {
       if (!i2) {
        i28 = 176;
        break;
       }
       HEAP32[i70 >> 2] = i14;
       HEAP32[i71 >> 2] = i11;
       HEAP32[i72 >> 2] = i5;
       HEAP32[i73 >> 2] = i13;
       i2 = HEAP32[i74 >> 2] | 0;
       L189 : do if (!i2) i2 = _packetizer_create(i14, i11, i5, i13) | 0; else {
        do if ((HEAP32[i2 >> 2] | 0) == (i14 | 0)) {
         if ((HEAP32[i2 + 8 >> 2] | 0) != (i11 | 0)) break;
         i4 = HEAP32[i2 + 16 >> 2] | 0;
         if ((HEAP32[i4 + 8 >> 2] | 0) != (i5 | 0)) break;
         if ((HEAP32[i4 + 28 >> 2] | 0) == (i13 | 0)) break L189;
        } while (0);
        _packetizer_destroy(i2);
        i2 = _packetizer_create(i14, i11, i5, i13) | 0;
       } while (0);
       HEAP32[i74 >> 2] = i2;
       i27 = HEAP32[i2 + 4 >> 2] | 0;
       HEAP32[i76 >> 2] = i27;
       HEAP32[i77 >> 2] = _realloc(HEAP32[i77 >> 2] | 0, i27) | 0;
       HEAP32[i78 >> 2] = _realloc(HEAP32[i78 >> 2] | 0, HEAP32[i70 >> 2] | 0) | 0;
       if (!(HEAP32[i59 >> 2] | 0)) {
        i28 = 176;
        break;
       } else break;
      }
      i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
      do if (!i2) {
       i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
       HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
       i2 = HEAP32[gb + 8728 >> 2] | 0;
       if (!(i2 & 8)) {
        HEAP32[gb + 8728 + 8 >> 2] = 0;
        HEAP32[gb + 8728 + 4 >> 2] = 0;
        i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
        HEAP32[gb + 8728 + 28 >> 2] = i4;
        HEAP32[gb + 8728 + 20 >> 2] = i4;
        i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
        HEAP32[gb + 8728 + 16 >> 2] = i2;
        i28 = 160;
        break;
       } else {
        HEAP32[gb + 8728 >> 2] = i2 | 32;
        break;
       }
      } else {
       i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       i28 = 160;
      } while (0);
      do if ((i28 | 0) == 160) {
       if ((i2 - i4 | 0) >>> 0 < 78) {
        mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25388 | 0, 78) | 0;
        break;
       }
       if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
        if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25388 | 0, 78) | 0) >>> 0 < 78) break;
        i2 = 0;
        i5 = gb + 25388 + 78 | 0;
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       } else {
        i2 = 78;
        i5 = gb + 25388 | 0;
       }
       _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
       HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
      } while (0);
      HEAP32[i59 >> 2] = 0;
      i28 = 176;
     } while (0);
     do if ((i28 | 0) == 176) {
      i28 = 0;
      i5 = HEAP32[i60 >> 2] | 0;
      if (i5 | 0) {
       d3 = +HEAPF32[i90 >> 2];
       i2 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
       i4 = (i2 | 0) < 0;
       do if (i2 >>> 0 < 8388608 | i4) {
        d20 = +Math_abs(+d3);
        if (!((HEAPF32[tempDoublePtr >> 2] = d20, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
         d3 = -1.0 / (d3 * d3);
         break;
        }
        if (i4) {
         d3 = (d3 - d3) / 0.0;
         break;
        } else {
         i2 = (HEAPF32[tempDoublePtr >> 2] = d3 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
         i4 = -152;
         i28 = 185;
         break;
        }
       } else if (i2 >>> 0 <= 2139095039) if ((i2 | 0) == 1065353216) d3 = 0.0; else {
        i4 = -127;
        i28 = 185;
       } while (0);
       if ((i28 | 0) == 185) {
        i28 = 0;
        i27 = i2 + 4913933 | 0;
        d9 = (HEAP32[tempDoublePtr >> 2] = (i27 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
        d10 = d9 / (d9 + 2.0);
        d19 = d10 * d10;
        d3 = d19 * d19;
        d18 = d9 * (d9 * .5);
        d20 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d9 - d18, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
        d3 = d9 - d20 - d18 + d10 * (d18 + (d19 * (d3 * .2849878668785095 + .6666666269302368) + d3 * (d3 * .24279078841209412 + .40000972151756287)));
        d19 = +((i27 >>> 23) + i4 | 0);
        d3 = d19 * .3010292053222656 + (d20 * .434326171875 + (d3 * .434326171875 + (d19 * 7.903415166765626e-07 - (d20 + d3) * 3.168997136526741e-05)));
       }
       HEAPF32[i62 >> 2] = d3 * 20.0;
       HEAPF32[i61 >> 2] = 0.0;
       HEAP32[i63 >> 2] = 0;
       SIMD_Int32x4_store(HEAPU8, i65, SIMD_Int32x4(0, 0, 1, 0));
       HEAP32[i66 >> 2] = 0;
       HEAP32[i67 >> 2] = 0;
       i2 = HEAP32[i58 >> 2] | 0;
       i4 = HEAP32[i68 >> 2] | 0;
       i13 = i29;
       i14 = i61;
       i15 = i13 + 40 | 0;
       do {
        HEAP32[i13 >> 2] = HEAP32[i14 >> 2];
        i13 = i13 + 4 | 0;
        i14 = i14 + 4 | 0;
       } while ((i13 | 0) < (i15 | 0));
       mftCall_iiiiiiii(i5 | 0, i2 | 0, 0, 0, 0, 0, i29 | 0, i4 | 0) | 0;
       HEAP32[i42 >> 2] = 0;
       HEAP32[i42 + 4 >> 2] = 0;
       HEAP32[i42 + 8 >> 2] = 0;
       HEAP32[i42 + 12 >> 2] = 0;
       i26 = HEAP32[i64 >> 2] | 0;
       HEAP32[i26 + 24 >> 2] = 0;
       _memset(HEAP32[i26 >> 2] | 0, 0, HEAP32[i26 + 20 >> 2] << 3 | 0) | 0;
       i26 = HEAP32[i75 >> 2] | 0;
       i27 = HEAP32[i26 + 16 >> 2] | 0;
       HEAP32[i27 + 24 >> 2] = 0;
       _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 3 | 0) | 0;
       i27 = HEAP32[i26 + 60 >> 2] | 0;
       HEAP32[i27 + 8 >> 2] = 0;
       _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 4 >> 2] << 2 | 0) | 0;
       HEAP32[i26 + 76 >> 2] = HEAP32[i26 + 4 >> 2];
       HEAP32[i26 + 72 >> 2] = 0;
       HEAP32[i26 + 52 >> 2] = 0;
       HEAP32[i26 + 56 >> 2] = 0;
       HEAPF32[i26 + 64 >> 2] = 0.0;
       i27 = i26 + 24 | 0;
       _memset(HEAP32[i26 + 44 >> 2] | 0, 0, HEAP32[i27 >> 2] << 2 | 0) | 0;
       _memset(HEAP32[i26 + 48 >> 2] | 0, 0, HEAP32[i27 >> 2] << 2 | 0) | 0;
       i27 = HEAP32[i40 >> 2] | 0;
       HEAPF32[i27 + 4 >> 2] = 0.0;
       HEAPF32[i27 + 8 >> 2] = 0.0;
       HEAP32[i27 + 1036 >> 2] = 0;
       HEAPF32[i27 + 1040 >> 2] = 0.0;
       HEAPF32[i27 + 1044 >> 2] = 1.0;
       HEAPF32[i46 >> 2] = 0.0;
       HEAPF32[i43 >> 2] = 0.0;
       HEAPF32[i45 >> 2] = 0.0;
       i27 = HEAP32[(HEAP32[i32 >> 2] | 0) + 16 >> 2] | 0;
       HEAP32[i27 + 24 >> 2] = 0;
       _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 2 | 0) | 0;
       i27 = HEAP32[(HEAP32[i33 >> 2] | 0) + 16 >> 2] | 0;
       HEAP32[i27 + 24 >> 2] = 0;
       _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 2 | 0) | 0;
       HEAPF32[i30 >> 2] = 0.0;
       if (HEAP32[i59 >> 2] | 0) break;
      };
      HEAP32[i42 >> 2] = 0;
      HEAP32[i42 + 4 >> 2] = 0;
      HEAP32[i42 + 8 >> 2] = 0;
      HEAP32[i42 + 12 >> 2] = 0;
      i26 = HEAP32[i64 >> 2] | 0;
      HEAP32[i26 + 24 >> 2] = 0;
      _memset(HEAP32[i26 >> 2] | 0, 0, HEAP32[i26 + 20 >> 2] << 3 | 0) | 0;
      i26 = HEAP32[i75 >> 2] | 0;
      i27 = HEAP32[i26 + 16 >> 2] | 0;
      HEAP32[i27 + 24 >> 2] = 0;
      _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 3 | 0) | 0;
      i27 = HEAP32[i26 + 60 >> 2] | 0;
      HEAP32[i27 + 8 >> 2] = 0;
      _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 4 >> 2] << 2 | 0) | 0;
      HEAP32[i26 + 76 >> 2] = HEAP32[i26 + 4 >> 2];
      HEAP32[i26 + 72 >> 2] = 0;
      HEAP32[i26 + 52 >> 2] = 0;
      HEAP32[i26 + 56 >> 2] = 0;
      HEAPF32[i26 + 64 >> 2] = 0.0;
      i27 = i26 + 24 | 0;
      _memset(HEAP32[i26 + 44 >> 2] | 0, 0, HEAP32[i27 >> 2] << 2 | 0) | 0;
      _memset(HEAP32[i26 + 48 >> 2] | 0, 0, HEAP32[i27 >> 2] << 2 | 0) | 0;
      i27 = HEAP32[i40 >> 2] | 0;
      HEAPF32[i27 + 4 >> 2] = 0.0;
      HEAPF32[i27 + 8 >> 2] = 0.0;
      HEAP32[i27 + 1036 >> 2] = 0;
      HEAPF32[i27 + 1040 >> 2] = 0.0;
      HEAPF32[i27 + 1044 >> 2] = 1.0;
      HEAPF32[i46 >> 2] = 0.0;
      HEAPF32[i43 >> 2] = 0.0;
      HEAPF32[i45 >> 2] = 0.0;
      i27 = HEAP32[(HEAP32[i32 >> 2] | 0) + 16 >> 2] | 0;
      HEAP32[i27 + 24 >> 2] = 0;
      _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 2 | 0) | 0;
      i27 = HEAP32[(HEAP32[i33 >> 2] | 0) + 16 >> 2] | 0;
      HEAP32[i27 + 24 >> 2] = 0;
      _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 2 | 0) | 0;
      HEAPF32[i30 >> 2] = 0.0;
      break L113;
     } while (0);
     HEAP32[i42 >> 2] = 3;
    } while (0);
    break;
   }
  case 3:
   {
    d8 = +HEAPF32[i97 >> 2];
    d9 = +HEAPF32[i53 >> 2];
    i27 = HEAP32[i40 >> 2] | 0;
    mftCall_vi(HEAP32[i27 + 1048 >> 2] | 0, i27 | 0);
    d6 = +HEAPF32[i27 + 1040 >> 2];
    d3 = +HEAPF32[i27 + 1044 >> 2] - d6 * 0.0;
    d6 = -d6;
    d7 = d8 * d3 - d9 * d6;
    d10 = d8 * d6 + d9 * d3;
    if ((d7 != d7 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
     ___mulsc3(i29, d8, d9, d3, d6);
     d7 = +HEAPF32[i29 >> 2];
     d10 = +HEAPF32[i79 >> 2];
    }
    i27 = HEAP32[i40 >> 2] | 0;
    i2 = i27 + 4 | 0;
    d3 = +HEAPF32[i27 + 8 >> 2] + +HEAPF32[i2 >> 2];
    HEAPF32[i2 >> 2] = d3;
    if (!(d3 > 3.141592653589793)) {
     if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
    } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
    d8 = +HEAPF32[i46 >> 2];
    d9 = -+HEAPF32[i43 >> 2];
    d3 = d7 * d8 - d10 * d9;
    d6 = d10 * d8 + d7 * d9;
    if ((d3 != d3 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
     ___mulsc3(i29, d8, d9, d7, d10);
     d6 = +HEAPF32[i80 >> 2];
     d3 = +HEAPF32[i29 >> 2];
    }
    d20 = +Math_atan2(+d6, +d3);
    d20 = d20 * +((HEAP32[i34 >> 2] | 0) >>> 0);
    HEAPF32[i45 >> 2] = d20;
    HEAPF32[i46 >> 2] = d7;
    HEAPF32[i43 >> 2] = d10;
    HEAPF32[i96 >> 2] = 0.0;
    if (_gmskframesync_update_symsync(i93, d20, i96) | 0 ? (i27 = (HEAPU8[i81 >> 0] << 1 | +HEAPF32[i96 >> 2] > 0.0) & 255, HEAP8[i81 >> 0] = i27, HEAP8[(HEAP32[i77 >> 2] | 0) + ((HEAP32[i82 >> 2] | 0) >>> 3) >> 0] = i27, i27 = (HEAP32[i82 >> 2] | 0) + 1 | 0, HEAP32[i82 >> 2] = i27, (i27 | 0) == (HEAP32[i76 >> 2] << 3 | 0)) : 0) {
     i16 = _packetizer_decode(HEAP32[i74 >> 2] | 0, HEAP32[i77 >> 2] | 0, HEAP32[i78 >> 2] | 0) | 0;
     HEAP32[i83 >> 2] = i16;
     i17 = HEAP32[i60 >> 2] | 0;
     if (i17 | 0) {
      d3 = +HEAPF32[i90 >> 2];
      i2 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
      i4 = (i2 | 0) < 0;
      do if (i2 >>> 0 < 8388608 | i4) {
       d20 = +Math_abs(+d3);
       if (!((HEAPF32[tempDoublePtr >> 2] = d20, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
        d3 = -1.0 / (d3 * d3);
        break;
       }
       if (i4) {
        d3 = (d3 - d3) / 0.0;
        break;
       } else {
        i2 = (HEAPF32[tempDoublePtr >> 2] = d3 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
        i4 = -152;
        i28 = 209;
        break;
       }
      } else if (i2 >>> 0 <= 2139095039) if ((i2 | 0) == 1065353216) d3 = 0.0; else {
       i4 = -127;
       i28 = 209;
      } while (0);
      if ((i28 | 0) == 209) {
       i28 = 0;
       i27 = i2 + 4913933 | 0;
       d9 = (HEAP32[tempDoublePtr >> 2] = (i27 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
       d10 = d9 / (d9 + 2.0);
       d19 = d10 * d10;
       d3 = d19 * d19;
       d18 = d9 * (d9 * .5);
       d20 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d9 - d18, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
       d3 = d9 - d20 - d18 + d10 * (d18 + (d19 * (d3 * .2849878668785095 + .6666666269302368) + d3 * (d3 * .24279078841209412 + .40000972151756287)));
       d19 = +((i27 >>> 23) + i4 | 0);
       d3 = d19 * .3010292053222656 + (d20 * .434326171875 + (d3 * .434326171875 + (d19 * 7.903415166765626e-07 - (d20 + d3) * 3.168997136526741e-05)));
      }
      HEAPF32[i62 >> 2] = d3 * 20.0;
      HEAPF32[i61 >> 2] = 0.0;
      HEAP32[i63 >> 2] = 0;
      HEAP32[i65 >> 2] = 0;
      HEAP32[i84 >> 2] = 0;
      HEAP32[i86 >> 2] = 1;
      HEAP32[i88 >> 2] = HEAP32[i71 >> 2];
      HEAP32[i66 >> 2] = HEAP32[i72 >> 2];
      HEAP32[i67 >> 2] = HEAP32[i73 >> 2];
      i2 = HEAP32[i58 >> 2] | 0;
      i4 = HEAP32[i59 >> 2] | 0;
      i5 = HEAP32[i78 >> 2] | 0;
      i11 = HEAP32[i70 >> 2] | 0;
      i12 = HEAP32[i68 >> 2] | 0;
      i13 = i29;
      i14 = i61;
      i15 = i13 + 40 | 0;
      do {
       HEAP32[i13 >> 2] = HEAP32[i14 >> 2];
       i13 = i13 + 4 | 0;
       i14 = i14 + 4 | 0;
      } while ((i13 | 0) < (i15 | 0));
      mftCall_iiiiiiii(i17 | 0, i2 | 0, i4 | 0, i5 | 0, i11 | 0, i16 | 0, i29 | 0, i12 | 0) | 0;
     };
     HEAP32[i42 >> 2] = 0;
     HEAP32[i42 + 4 >> 2] = 0;
     HEAP32[i42 + 8 >> 2] = 0;
     HEAP32[i42 + 12 >> 2] = 0;
     i26 = HEAP32[i64 >> 2] | 0;
     HEAP32[i26 + 24 >> 2] = 0;
     _memset(HEAP32[i26 >> 2] | 0, 0, HEAP32[i26 + 20 >> 2] << 3 | 0) | 0;
     i26 = HEAP32[i75 >> 2] | 0;
     i27 = HEAP32[i26 + 16 >> 2] | 0;
     HEAP32[i27 + 24 >> 2] = 0;
     _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 3 | 0) | 0;
     i27 = HEAP32[i26 + 60 >> 2] | 0;
     HEAP32[i27 + 8 >> 2] = 0;
     _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 4 >> 2] << 2 | 0) | 0;
     HEAP32[i26 + 76 >> 2] = HEAP32[i26 + 4 >> 2];
     HEAP32[i26 + 72 >> 2] = 0;
     HEAP32[i26 + 52 >> 2] = 0;
     HEAP32[i26 + 56 >> 2] = 0;
     HEAPF32[i26 + 64 >> 2] = 0.0;
     i27 = i26 + 24 | 0;
     _memset(HEAP32[i26 + 44 >> 2] | 0, 0, HEAP32[i27 >> 2] << 2 | 0) | 0;
     _memset(HEAP32[i26 + 48 >> 2] | 0, 0, HEAP32[i27 >> 2] << 2 | 0) | 0;
     i27 = HEAP32[i40 >> 2] | 0;
     HEAPF32[i27 + 4 >> 2] = 0.0;
     HEAPF32[i27 + 8 >> 2] = 0.0;
     HEAP32[i27 + 1036 >> 2] = 0;
     HEAPF32[i27 + 1040 >> 2] = 0.0;
     HEAPF32[i27 + 1044 >> 2] = 1.0;
     HEAPF32[i46 >> 2] = 0.0;
     HEAPF32[i43 >> 2] = 0.0;
     HEAPF32[i45 >> 2] = 0.0;
     i27 = HEAP32[(HEAP32[i32 >> 2] | 0) + 16 >> 2] | 0;
     HEAP32[i27 + 24 >> 2] = 0;
     _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 2 | 0) | 0;
     i27 = HEAP32[(HEAP32[i33 >> 2] | 0) + 16 >> 2] | 0;
     HEAP32[i27 + 24 >> 2] = 0;
     _memset(HEAP32[i27 >> 2] | 0, 0, HEAP32[i27 + 20 >> 2] << 2 | 0) | 0;
     HEAPF32[i30 >> 2] = 0.0;
    }
    break;
   }
  default:
   {}
  } while (0);
  i95 = i95 + 1 | 0;
  if ((i95 | 0) == (i92 | 0)) {
   i28 = 214;
   break;
  }
 }
 if ((i28 | 0) == 45) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i99 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i99;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i99 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i99 - i1 | 0) >>> 0 < 69) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37545 | 0, 69) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37545 | 0, 69) | 0) >>> 0 < 69) _exit(1); else {
   i102 = 0;
   i104 = gb + 37545 + 69 | 0;
   i106 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i102 = 69;
   i104 = gb + 37545 | 0;
   i106 = i1;
  } while (0);
  _memcpy(i106 | 0, i104 | 0, i102 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i102;
  _exit(1);
 } else if ((i28 | 0) == 58) ___assert_fail(gb + 24985 | 0, gb + 25027 | 0, 496, gb + 25059 | 0); else if ((i28 | 0) == 95) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i101 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i101;
    HEAP32[gb + 8728 + 20 >> 2] = i101;
    i100 = i101 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i100;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(-1);
  } else {
   i100 = i1;
   i101 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i100 - i101 | 0) >>> 0 < 38) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36869 | 0, 38) | 0;
   _exit(-1);
  }
  i1 = i101;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36869 | 0, 38) | 0) >>> 0 < 38) _exit(-1); else {
   i103 = 0;
   i105 = gb + 36869 + 38 | 0;
   i107 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i103 = 38;
   i105 = gb + 36869 | 0;
   i107 = i1;
  } while (0);
  _memcpy(i107 | 0, i105 | 0, i103 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i103;
  _exit(-1);
 } else if ((i28 | 0) == 113) ___assert_fail(gb + 26736 | 0, gb + 25027 | 0, 757, gb + 25145 | 0); else if ((i28 | 0) == 214) {
  STACKTOP = i98;
  return;
 }
}

function _quiet_encoder_create(i91, d92) {
 i91 = i91 | 0;
 d92 = +d92;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, I474 = SIMD_Int32x4(0, 0, 0, 0), i75 = 0, i76 = 0, i77 = 0, i78 = 0, i79 = 0, i80 = 0, i81 = 0, i82 = 0, i83 = 0, i84 = 0, i85 = 0, i86 = 0, i87 = 0, i88 = 0, i89 = 0, i90 = 0, i93 = 0, d94 = 0.0;
 i93 = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 i85 = i93 + 152 | 0;
 i53 = i93 + 144 | 0;
 i32 = i93 + 136 | 0;
 i86 = i93 + 16 | 0;
 i89 = i93;
 if (!i91) {
  i91 = 0;
  STACKTOP = i93;
  return i91 | 0;
 }
 i90 = _malloc(156) | 0;
 i13 = i90;
 i14 = i91;
 i15 = i13 + 96 | 0;
 do {
  HEAP32[i13 >> 2] = HEAP32[i14 >> 2];
  i13 = i13 + 4 | 0;
  i14 = i14 + 4 | 0;
 } while ((i13 | 0) < (i15 | 0));
 L4 : do switch (HEAP32[i90 + 60 >> 2] | 0) {
 case 0:
  {
   I474 = SIMD_Int32x4_load(HEAPU8, i91 + 64 | 0);
   i13 = HEAP32[i91 >> 2] | 0;
   i79 = _malloc(i13) | 0;
   _ofdmframe_init_default_sctype(i13, i79);
   i13 = (HEAP32[i91 >> 2] | 0) >>> 1;
   i15 = i13;
   while (1) if (!(HEAP8[i79 + i15 >> 0] | 0)) i15 = i15 + -1 | 0; else break;
   while (1) {
    i14 = i79 + i13 | 0;
    if (!(HEAP8[i14 >> 0] | 0)) i13 = i13 + 1 | 0; else break;
   }
   i13 = HEAP32[i91 + 16 >> 2] | 0;
   if (i13 | 0) {
    i69 = i13 >>> 0 > 1 ? i13 : 1;
    _memset(i79 + (i15 + 1 - i69) | 0, 0, i69 | 0) | 0;
   }
   i13 = HEAP32[i91 + 12 >> 2] | 0;
   if (i13 | 0) _memset(i14 | 0, 0, (i13 >>> 0 > 1 ? i13 : 1) | 0) | 0;
   i16 = HEAP32[i91 >> 2] | 0;
   i69 = i91 + 4 | 0;
   i14 = HEAP32[i69 >> 2] | 0;
   i15 = HEAP32[i91 + 8 >> 2] | 0;
   if (i16 >>> 0 < 2) {
    i13 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i13) {
     i13 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i13 + 255 | i13;
     i13 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i13 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i18 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i18;
      HEAP32[gb + 8728 + 20 >> 2] = i18;
      i17 = i18 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i17;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i13 | 32;
     _exit(1);
    } else {
     i17 = i13;
     i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i17 - i18 | 0) >>> 0 < 75) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26016 | 0, 75) | 0;
     _exit(1);
    }
    i13 = i18;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26016 | 0, 75) | 0) >>> 0 < 75) _exit(1); else {
     i19 = 0;
     i20 = gb + 26016 + 75 | 0;
     i21 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i19 = 75;
     i20 = gb + 26016 | 0;
     i21 = i13;
    } while (0);
    _memcpy(i21 | 0, i20 | 0, i19 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i19;
    _exit(1);
   }
   if (i16 & 1 | 0) {
    i13 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i13) {
     i13 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i13 + 255 | i13;
     i13 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i13 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i11 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i11;
      HEAP32[gb + 8728 + 20 >> 2] = i11;
      i22 = i11 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i22;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i13 | 32;
     _exit(1);
    } else {
     i22 = i13;
     i11 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i22 - i11 | 0) >>> 0 < 69) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26092 | 0, 69) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26092 | 0, 69) | 0) >>> 0 < 69) _exit(1); else {
     i23 = 0;
     i24 = gb + 26092 + 69 | 0;
     i25 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i23 = 69;
     i24 = gb + 26092 | 0;
     i25 = i11;
    } while (0);
    _memcpy(i25 | 0, i24 | 0, i23 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i23;
    _exit(1);
   }
   i25 = _malloc(156) | 0;
   HEAP32[i25 >> 2] = i16;
   i23 = i25 + 4 | 0;
   HEAP32[i23 >> 2] = i14;
   i24 = i25 + 8 | 0;
   HEAP32[i24 >> 2] = i15;
   HEAP32[i25 + 36 >> 2] = _malloc(i16 << 3) | 0;
   i11 = _malloc(i16) | 0;
   i22 = i25 + 12 | 0;
   HEAP32[i22 >> 2] = i11;
   if (!i79) {
    _ofdmframe_init_default_sctype(i16, i11);
    i11 = HEAP32[i22 >> 2] | 0;
    i16 = HEAP32[i25 >> 2] | 0;
    i15 = i25 + 16 | 0;
    i14 = i25 + 20 | 0;
    i13 = i25 + 24 | 0;
    if (!i16) {
     i26 = i15;
     i27 = i14;
     i28 = i13;
     i49 = i11;
     i29 = 0;
     i30 = 0;
     i31 = 0;
    } else i87 = 40;
   } else {
    _memcpy(i11 | 0, i79 | 0, i16 | 0) | 0;
    i13 = i25 + 24 | 0;
    i14 = i25 + 20 | 0;
    i15 = i25 + 16 | 0;
    i87 = 40;
   }
   do if ((i87 | 0) == 40) {
    i18 = 0;
    i19 = 0;
    i20 = 0;
    i21 = 0;
    L67 : while (1) {
     i17 = HEAP8[i11 + i21 >> 0] | 0;
     switch (i17 << 24 >> 24) {
     case 0:
      {
       i19 = i19 + 1 | 0;
       break;
      }
     case 1:
      {
       i20 = i20 + 1 | 0;
       break;
      }
     case 2:
      {
       i18 = i18 + 1 | 0;
       break;
      }
     default:
      {
       i87 = 45;
       break L67;
      }
     }
     i21 = i21 + 1 | 0;
     if (i21 >>> 0 >= i16 >>> 0) {
      i87 = 47;
      break;
     }
    }
    if ((i87 | 0) == 45) {
     HEAP32[i32 >> 2] = i17 & 255;
     _fprintf(gb + 8728 | 0, gb + 32703 | 0, i32);
     _exit(1);
    } else if ((i87 | 0) == 47) {
     i26 = i15;
     i27 = i14;
     i28 = i13;
     i49 = HEAP32[i22 >> 2] | 0;
     i29 = i18;
     i30 = i19;
     i31 = i20;
     break;
    }
   } while (0);
   HEAP32[i26 >> 2] = i30;
   HEAP32[i27 >> 2] = i31;
   HEAP32[i28 >> 2] = i29;
   i11 = HEAP32[i25 >> 2] | 0;
   i14 = HEAP32[i23 >> 2] | 0;
   i15 = HEAP32[i24 >> 2] | 0;
   if (i11 >>> 0 < 2) {
    i13 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i13) {
     i13 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i13 + 255 | i13;
     i13 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i13 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i12 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i12;
      HEAP32[gb + 8728 + 20 >> 2] = i12;
      i33 = i12 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i33;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i13 | 32;
     _exit(1);
    } else {
     i33 = i13;
     i12 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i33 - i12 | 0) >>> 0 < 71) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32769 | 0, 71) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32769 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
     i34 = 0;
     i35 = gb + 32769 + 71 | 0;
     i36 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i34 = 71;
     i35 = gb + 32769 | 0;
     i36 = i12;
    } while (0);
    _memcpy(i36 | 0, i35 | 0, i34 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i34;
    _exit(1);
   }
   if (i11 & 1 | 0) {
    i12 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i12) {
     i12 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i12 + 255 | i12;
     i12 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i12 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i10 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i10;
      HEAP32[gb + 8728 + 20 >> 2] = i10;
      i37 = i10 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i37;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i12 | 32;
     _exit(1);
    } else {
     i37 = i12;
     i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i37 - i10 | 0) >>> 0 < 65) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32841 | 0, 65) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32841 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
     i38 = 0;
     i39 = gb + 32841 + 65 | 0;
     i40 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i38 = 65;
     i39 = gb + 32841 | 0;
     i40 = i10;
    } while (0);
    _memcpy(i40 | 0, i39 | 0, i38 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i38;
    _exit(1);
   }
   if (i14 >>> 0 > i11 >>> 0) {
    i10 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i10) {
     i10 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i10 + 255 | i10;
     i10 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i10 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i9 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i9;
      HEAP32[gb + 8728 + 20 >> 2] = i9;
      i41 = i9 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i41;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i10 | 32;
     _exit(1);
    } else {
     i41 = i10;
     i9 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i41 - i9 | 0) >>> 0 < 72) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32907 | 0, 72) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32907 | 0, 72) | 0) >>> 0 < 72) _exit(1); else {
     i42 = 0;
     i43 = gb + 32907 + 72 | 0;
     i44 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i42 = 72;
     i43 = gb + 32907 | 0;
     i44 = i9;
    } while (0);
    _memcpy(i44 | 0, i43 | 0, i42 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i42;
    _exit(1);
   }
   if (i15 >>> 0 > i14 >>> 0) {
    i9 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i9) {
     i9 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i9 + 255 | i9;
     i9 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i9 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i8 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i8;
      HEAP32[gb + 8728 + 20 >> 2] = i8;
      i45 = i8 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i45;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i9 | 32;
     _exit(1);
    } else {
     i45 = i9;
     i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i45 - i8 | 0) >>> 0 < 71) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32980 | 0, 71) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32980 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
     i46 = 0;
     i47 = gb + 32980 + 71 | 0;
     i48 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i46 = 71;
     i47 = gb + 32980 | 0;
     i48 = i8;
    } while (0);
    _memcpy(i48 | 0, i47 | 0, i46 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i46;
    _exit(1);
   }
   i20 = _malloc(80) | 0;
   HEAP32[i20 >> 2] = i11;
   HEAP32[i20 + 4 >> 2] = i14;
   i19 = i20 + 12 | 0;
   HEAP32[i19 >> 2] = i15;
   i10 = _malloc(i11) | 0;
   i18 = i20 + 8 | 0;
   HEAP32[i18 >> 2] = i10;
   if (!i49) {
    _ofdmframe_init_default_sctype(i11, i10);
    i11 = HEAP32[i20 >> 2] | 0;
    i10 = i20 + 24 | 0;
    i9 = i20 + 28 | 0;
    i8 = i20 + 32 | 0;
    if (!i11) {
     i50 = i10;
     i67 = i9;
     i68 = i8;
     i58 = 0;
     i51 = 0;
     i52 = 0;
    } else {
     i17 = i10;
     i10 = HEAP32[i18 >> 2] | 0;
     i87 = 103;
    }
   } else {
    _memcpy(i10 | 0, i49 | 0, i11 | 0) | 0;
    i8 = i20 + 32 | 0;
    i9 = i20 + 28 | 0;
    i17 = i20 + 24 | 0;
    i87 = 103;
   }
   L169 : do if ((i87 | 0) == 103) {
    i15 = 0;
    i13 = 0;
    i14 = 0;
    i16 = 0;
    L171 : while (1) {
     i12 = HEAP8[i10 + i16 >> 0] | 0;
     switch (i12 << 24 >> 24) {
     case 0:
      {
       i12 = i15;
       i13 = i13 + 1 | 0;
       break;
      }
     case 1:
      {
       i12 = i15;
       i14 = i14 + 1 | 0;
       break;
      }
     case 2:
      {
       i12 = i15 + 1 | 0;
       break;
      }
     default:
      break L171;
     }
     i16 = i16 + 1 | 0;
     if (i16 >>> 0 >= i11 >>> 0) {
      i50 = i17;
      i67 = i9;
      i68 = i8;
      i58 = i12;
      i51 = i13;
      i52 = i14;
      break L169;
     } else i15 = i12;
    }
    HEAP32[i53 >> 2] = i12 & 255;
    _fprintf(gb + 8728 | 0, gb + 32703 | 0, i53);
    _exit(1);
   } while (0);
   HEAP32[i50 >> 2] = i51;
   HEAP32[i67 >> 2] = i52;
   HEAP32[i68 >> 2] = i58;
   i9 = HEAP32[i67 >> 2] | 0;
   if ((i9 | 0) == (0 - i58 | 0)) {
    i8 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i8) {
     i8 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i8 + 255 | i8;
     i8 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i8 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i7 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i7;
      HEAP32[gb + 8728 + 20 >> 2] = i7;
      i54 = i7 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i54;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i8 | 32;
     _exit(1);
    } else {
     i54 = i8;
     i7 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i54 - i7 | 0) >>> 0 < 72) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33052 | 0, 72) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33052 | 0, 72) | 0) >>> 0 < 72) _exit(1); else {
     i55 = 0;
     i56 = gb + 33052 + 72 | 0;
     i57 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i55 = 72;
     i56 = gb + 33052 | 0;
     i57 = i7;
    } while (0);
    _memcpy(i57 | 0, i56 | 0, i55 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i55;
    _exit(1);
   }
   if (!i58) {
    i7 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i7) {
     i7 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i7 + 255 | i7;
     i7 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i7 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i6 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i6;
      HEAP32[gb + 8728 + 20 >> 2] = i6;
      i59 = i6 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i59;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i7 | 32;
     _exit(1);
    } else {
     i59 = i7;
     i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i59 - i6 | 0) >>> 0 < 70) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33125 | 0, 70) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33125 | 0, 70) | 0) >>> 0 < 70) _exit(1); else {
     i60 = 0;
     i61 = gb + 33125 + 70 | 0;
     i62 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i60 = 70;
     i61 = gb + 33125 | 0;
     i62 = i6;
    } while (0);
    _memcpy(i62 | 0, i61 | 0, i60 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i60;
    _exit(1);
   }
   if (i9 >>> 0 < 2) {
    i6 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i6) {
     i6 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i6 + 255 | i6;
     i6 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i6 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i5 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i5;
      HEAP32[gb + 8728 + 20 >> 2] = i5;
      i63 = i5 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i63;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i6 | 32;
     _exit(1);
    } else {
     i63 = i6;
     i5 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i63 - i5 | 0) >>> 0 < 71) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33196 | 0, 71) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33196 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
     i64 = 0;
     i65 = gb + 33196 + 71 | 0;
     i66 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i64 = 71;
     i65 = gb + 33196 | 0;
     i66 = i5;
    } while (0);
    _memcpy(i66 | 0, i65 | 0, i64 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i64;
    _exit(1);
   }
   i65 = HEAP32[i20 >> 2] | 0;
   i64 = i65 << 3;
   i63 = _malloc(i64) | 0;
   HEAP32[i20 + 52 >> 2] = i63;
   i64 = _malloc(i64) | 0;
   HEAP32[i20 + 56 >> 2] = i64;
   HEAP32[i20 + 48 >> 2] = _fft_create_plan(i65, i63, i64, -1, 0) | 0;
   i64 = HEAP32[i20 >> 2] | 0;
   i63 = i64 << 3;
   i65 = _malloc(i63) | 0;
   HEAP32[i20 + 60 >> 2] = i65;
   i66 = _malloc(i63) | 0;
   HEAP32[i20 + 64 >> 2] = i66;
   i6 = i20 + 68 | 0;
   HEAP32[i6 >> 2] = _malloc(i63) | 0;
   i5 = i20 + 72 | 0;
   HEAP32[i5 >> 2] = _malloc(i63) | 0;
   _ofdmframe_init_S0(HEAP32[i18 >> 2] | 0, i64, i65, i66, i20 + 36 | 0);
   _ofdmframe_init_S1(HEAP32[i18 >> 2] | 0, HEAP32[i20 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i5 >> 2] | 0, i20 + 40 | 0);
   i5 = HEAP32[i19 >> 2] | 0;
   i6 = _malloc(i5 << 2) | 0;
   HEAP32[i20 + 16 >> 2] = i6;
   HEAP32[i20 + 20 >> 2] = _malloc(i5 << 3) | 0;
   if (i5 | 0) {
    d3 = +(i5 >>> 0);
    i7 = 0;
    do {
     d94 = +Math_sin(+((+(i7 >>> 0) + .5) / d3 * 1.5707963267948966));
     HEAPF32[i6 + (i7 << 2) >> 2] = d94 * d94;
     i7 = i7 + 1 | 0;
    } while ((i7 | 0) != (i5 | 0));
   }
   HEAPF32[i20 + 44 >> 2] = 1.0 / +Math_sqrt(+(+(((HEAP32[i68 >> 2] | 0) + (HEAP32[i67 >> 2] | 0) | 0) >>> 0)));
   i6 = _malloc(24) | 0;
   HEAP32[i6 >> 2] = HEAP32[gb + 6864 + 192 >> 2];
   HEAP32[i6 + 4 >> 2] = HEAP32[gb + 6864 + 192 + 4 >> 2];
   HEAP32[i6 + 8 >> 2] = HEAP32[gb + 6864 + 192 + 8 >> 2];
   HEAP32[i6 + 12 >> 2] = HEAP32[gb + 6864 + 192 + 12 >> 2];
   HEAP32[i6 + 16 >> 2] = HEAP32[gb + 6864 + 192 + 16 >> 2];
   HEAP32[i6 + 20 >> 2] = HEAP32[gb + 6864 + 192 + 20 >> 2];
   HEAP32[i20 + 76 >> 2] = i6;
   i6 = i25 + 40 | 0;
   HEAP32[i6 >> 2] = i20;
   i68 = i25 + 52 | 0;
   HEAP32[i68 >> 2] = 0;
   HEAP32[i68 + 4 >> 2] = 0;
   HEAP32[i68 + 8 >> 2] = 0;
   HEAP32[i68 + 12 >> 2] = 0;
   HEAP32[i68 + 16 >> 2] = 0;
   _ofdmflexframegen_set_header_len(i25, 8);
   HEAP32[i25 + 92 >> 2] = 1;
   i68 = _packetizer_create(1, 1, 1, 1) | 0;
   HEAP32[i25 + 88 >> 2] = i68;
   i68 = HEAP32[i68 + 4 >> 2] | 0;
   HEAP32[i25 + 108 >> 2] = i68;
   HEAP32[i25 + 100 >> 2] = _malloc(i68) | 0;
   HEAP32[i25 + 112 >> 2] = 1;
   HEAP32[i25 + 104 >> 2] = _malloc(4) | 0;
   i68 = _malloc(252) | 0;
   HEAP32[i68 >> 2] = 48;
   HEAP32[i68 + 76 >> 2] = 0;
   HEAP32[i68 + 80 >> 2] = 0;
   HEAP32[i68 + 4 >> 2] = 2;
   HEAP32[i68 + 8 >> 2] = 4;
   i67 = i68 + 236 | 0;
   HEAP32[i67 >> 2] = 0;
   HEAP32[i67 + 4 >> 2] = 0;
   HEAP32[i67 + 8 >> 2] = 0;
   HEAP32[i67 + 12 >> 2] = 0;
   HEAP32[i67 >> 2] = fb + 1;
   HEAP32[i68 + 240 >> 2] = fb + 2;
   HEAPF32[i68 + 84 >> 2] = 1.0;
   HEAPF32[i68 + 88 >> 2] = 0.0;
   HEAP32[i68 + 92 >> 2] = 1065353216;
   HEAPF32[i68 + 96 >> 2] = 0.0;
   HEAP32[i25 + 96 >> 2] = i68;
   if (((SIMD_Int32x4_extractLane(I474, 0) | 0) + -1 | 0) >>> 0 > 5) {
    i5 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i5) {
     i5 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i5 + 255 | i5;
     i5 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i5 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i4;
      HEAP32[gb + 8728 + 20 >> 2] = i4;
      i70 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i70;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i5 | 32;
     _exit(1);
    } else {
     i70 = i5;
     i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i70 - i4 | 0) >>> 0 < 67) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26162 | 0, 67) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26162 | 0, 67) | 0) >>> 0 < 67) _exit(1); else {
     i71 = 0;
     i72 = gb + 26162 + 67 | 0;
     i73 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i71 = 67;
     i72 = gb + 26162 | 0;
     i73 = i4;
    } while (0);
    _memcpy(i73 | 0, i72 | 0, i71 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i71;
    _exit(1);
   }
   i73 = (SIMD_Int32x4_extractLane(I474, 1) | 0) == 0;
   if (i73 | (SIMD_Int32x4_extractLane(I474, 2) | 0) == 0) {
    i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i4) {
     i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
     i4 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i4 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i75 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i75;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i4 | 32;
     _exit(1);
    } else {
     i75 = i4;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i75 - i2 | 0) >>> 0 < 67) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26230 | 0, 67) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26230 | 0, 67) | 0) >>> 0 < 67) _exit(1); else {
     i76 = 0;
     i77 = gb + 26230 + 67 | 0;
     i78 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i76 = 67;
     i77 = gb + 26230 | 0;
     i78 = i2;
    } while (0);
    _memcpy(i78 | 0, i77 | 0, i76 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i76;
    _exit(1);
   }
   if (SIMD_Int32x4_extractLane(I474, 3) | 0) {
    i1 = i25 + 140 | 0;
    SIMD_Int32x4_store(HEAPU8, i1, I474);
    _ofdmflexframegen_reconfigure(i25);
    i1 = i25 + 116 | 0;
    HEAP32[i1 >> 2] = 0;
    HEAP32[i1 + 4 >> 2] = 0;
    HEAP32[i1 + 8 >> 2] = 0;
    HEAP32[i1 + 12 >> 2] = 0;
    HEAP32[i1 + 16 >> 2] = 0;
    HEAP32[i1 + 20 >> 2] = 0;
    i1 = HEAP32[i6 >> 2] | 0;
    i4 = HEAP32[i1 + 76 >> 2] | 0;
    HEAP32[i4 + 16 >> 2] = HEAP32[i4 + 8 >> 2];
    i4 = i1 + 12 | 0;
    if (HEAP32[i4 >> 2] | 0) {
     i1 = i1 + 20 | 0;
     i2 = 0;
     do {
      i84 = HEAP32[i1 >> 2] | 0;
      HEAPF32[i84 + (i2 << 3) >> 2] = 0.0;
      HEAPF32[i84 + (i2 << 3) + 4 >> 2] = 0.0;
      i2 = i2 + 1 | 0;
     } while (i2 >>> 0 < (HEAP32[i4 >> 2] | 0) >>> 0);
    }
    _ofdmflexframegen_set_header_len(i25, 0);
    i83 = (HEAP32[i69 >> 2] | 0) + (HEAP32[i91 >> 2] | 0) | 0;
    HEAP32[i90 + 108 >> 2] = _malloc(i83 << 3) | 0;
    i84 = i90 + 112 | 0;
    HEAP32[i84 >> 2] = i83;
    _free(i79);
    HEAP32[i90 + 96 >> 2] = i25;
    break L4;
   }
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i80 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i80;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i80 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i80 - i1 | 0) >>> 0 < 74) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26298 | 0, 74) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26298 | 0, 74) | 0) >>> 0 < 74) _exit(1); else {
    i81 = 0;
    i82 = gb + 26298 + 74 | 0;
    i83 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i81 = 74;
    i82 = gb + 26298 | 0;
    i83 = i1;
   } while (0);
   _memcpy(i83 | 0, i82 | 0, i81 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i81;
   _exit(1);
   break;
  }
 case 1:
  {
   i12 = i89;
   SIMD_Int32x4_store(HEAPU8, i12, SIMD_Int32x4_load(HEAPU8, i91 + 64 | 0));
   i12 = _malloc(124) | 0;
   HEAP32[i12 >> 2] = 2;
   HEAP32[i12 + 4 >> 2] = 7;
   HEAPF32[i12 + 8 >> 2] = .25;
   i5 = _llvm_stacksave() | 0;
   _liquid_firdes_prototype(7, 2, 7, .25, i86);
   i1 = _malloc(20) | 0;
   HEAP32[i1 + 12 >> 2] = 2;
   HEAP32[i1 + 8 >> 2] = 15;
   HEAP32[i1 + 4 >> 2] = 30;
   i2 = _malloc(120) | 0;
   HEAP32[i1 >> 2] = i2;
   i4 = 0;
   do {
    if (i4 >>> 0 < 29) d3 = +HEAPF32[i86 + (i4 << 2) >> 2]; else d3 = 0.0;
    HEAPF32[i2 + (i4 << 2) >> 2] = d3;
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != 30);
   HEAP32[i1 + 16 >> 2] = _firpfb_crcf_create(2, i2, 30) | 0;
   _llvm_stackrestore(i5 | 0);
   HEAP32[i12 + 12 >> 2] = i1;
   i2 = _malloc(512) | 0;
   HEAP32[i12 + 48 >> 2] = i2;
   i4 = _malloc(24) | 0;
   i5 = i4 + 4 | 0;
   i6 = i4 + 12 | 0;
   i7 = i4;
   SIMD_Int32x4_store(HEAPU8, i7, SIMD_Int32x4(7, 68, 64, 127));
   i7 = i4 + 16 | 0;
   HEAP32[i7 >> 2] = 64;
   i8 = i4 + 20 | 0;
   HEAP32[i8 >> 2] = 0;
   i9 = 68;
   i10 = 64;
   i11 = 127;
   i1 = 0;
   while (1) {
    i83 = i9 & i10;
    i83 = (HEAPU8[(i83 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i83 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i83 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i83 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    i82 = (i83 | i10 << 1) & i11;
    i84 = i82 & i9;
    i84 = (HEAPU8[(i84 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i84 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i84 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i84 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    HEAP32[i8 >> 2] = i84;
    HEAP32[i7 >> 2] = (i84 | i82 << 1) & i11;
    i84 = (i84 | 0) != 0;
    HEAPF32[i2 + (i1 << 3) >> 2] = (i83 | 0 ? .7071067811865476 : -.7071067811865476) + (i84 ? 0.0 : -0.0);
    HEAPF32[i2 + (i1 << 3) + 4 >> 2] = i84 ? .7071067690849304 : -.7071067690849304;
    i1 = i1 + 1 | 0;
    if ((i1 | 0) == 64) break;
    i9 = HEAP32[i5 >> 2] | 0;
    i10 = HEAP32[i7 >> 2] | 0;
    i11 = HEAP32[i6 >> 2] | 0;
   }
   _free(i4);
   i83 = i12 + 104 | 0;
   HEAP32[i83 >> 2] = 0;
   HEAP32[i83 + 4 >> 2] = 0;
   HEAP32[i83 + 8 >> 2] = 0;
   HEAP32[i83 + 12 >> 2] = 0;
   HEAP32[i83 + 16 >> 2] = 0;
   HEAP32[i12 + 52 >> 2] = 0;
   HEAP32[i12 + 72 >> 2] = 0;
   HEAP32[i12 + 84 >> 2] = 0;
   HEAP32[i12 + 64 >> 2] = 0;
   HEAP32[i12 + 76 >> 2] = 0;
   _flexframegen_set_header_len(i12, 14);
   i83 = _malloc(36) | 0;
   i81 = _malloc(252) | 0;
   HEAP32[i81 >> 2] = 48;
   HEAP32[i81 + 76 >> 2] = 0;
   HEAP32[i81 + 80 >> 2] = 0;
   HEAP32[i81 + 4 >> 2] = 2;
   HEAP32[i81 + 8 >> 2] = 4;
   i82 = i81 + 236 | 0;
   HEAP32[i82 >> 2] = 0;
   HEAP32[i82 + 4 >> 2] = 0;
   HEAP32[i82 + 8 >> 2] = 0;
   HEAP32[i82 + 12 >> 2] = 0;
   HEAP32[i82 >> 2] = fb + 1;
   HEAP32[i81 + 240 >> 2] = fb + 2;
   HEAPF32[i81 + 84 >> 2] = 1.0;
   HEAPF32[i81 + 88 >> 2] = 0.0;
   HEAP32[i81 + 92 >> 2] = 1065353216;
   HEAPF32[i81 + 96 >> 2] = 0.0;
   HEAP32[i83 >> 2] = i81;
   HEAP32[i83 + 8 >> 2] = 2;
   HEAP32[i83 + 12 >> 2] = 1;
   i81 = _packetizer_create(1, 1, 1, 1) | 0;
   HEAP32[i83 + 4 >> 2] = i81;
   i81 = HEAP32[i81 + 4 >> 2] | 0;
   HEAP32[i83 + 24 >> 2] = i81;
   i82 = i81 << 3;
   HEAP32[i83 + 28 >> 2] = i82;
   i84 = i83 + 32 | 0;
   HEAP32[i83 + 16 >> 2] = _malloc(((i82 | 0) / 2 | 0) << 1) | 0;
   HEAP32[i84 >> 2] = i81 << 1;
   HEAP32[i83 + 20 >> 2] = _malloc(i82) | 0;
   HEAP32[i12 + 92 >> 2] = i83;
   HEAP32[i12 + 88 >> 2] = 64;
   i84 = HEAP32[i84 >> 2] | 0;
   HEAP32[i12 + 96 >> 2] = i84;
   HEAP32[i12 + 100 >> 2] = _malloc(i84 << 3) | 0;
   _flexframegen_setprops(i12, i89);
   _flexframegen_set_header_len(i12, 0);
   HEAP32[i90 + 108 >> 2] = 0;
   i84 = i90 + 112 | 0;
   HEAP32[i84 >> 2] = 0;
   HEAP32[i90 + 96 >> 2] = i12;
   HEAP32[i90 + 100 >> 2] = 0;
   break;
  }
 case 2:
  {
   i83 = _malloc(100) | 0;
   HEAP32[i83 + 4 >> 2] = 2;
   HEAP32[i83 + 8 >> 2] = 3;
   HEAPF32[i83 + 12 >> 2] = .5;
   HEAP32[i83 + 16 >> 2] = 63;
   i82 = i83 + 24 | 0;
   HEAP32[i82 >> 2] = 0;
   HEAP32[i83 + 28 >> 2] = 6;
   i79 = _malloc(32) | 0;
   HEAP32[i79 >> 2] = 2;
   HEAP32[i79 + 4 >> 2] = 3;
   HEAPF32[i79 + 8 >> 2] = .5;
   HEAPF32[i79 + 28 >> 2] = .5;
   HEAP32[i79 + 12 >> 2] = 13;
   i81 = _malloc(52) | 0;
   HEAP32[i79 + 16 >> 2] = i81;
   _liquid_firdes_gmsktx(2, 3, .5, i81);
   i81 = _llvm_stacksave() | 0;
   _liquid_firdes_prototype(11, 2, 3, .5, i86);
   i80 = _malloc(20) | 0;
   HEAP32[i80 + 12 >> 2] = 2;
   HEAP32[i80 + 8 >> 2] = 7;
   HEAP32[i80 + 4 >> 2] = 14;
   i78 = _malloc(56) | 0;
   HEAP32[i80 >> 2] = i78;
   i84 = i78;
   SIMD_Int32x4_store(HEAPU8, i84, SIMD_Int32x4_load(HEAPU8, i86));
   i84 = i78 + 16 | 0;
   SIMD_Int32x4_store(HEAPU8, i84, SIMD_Int32x4_load(HEAPU8, i86 + 16 | 0));
   i84 = i78 + 32 | 0;
   SIMD_Int32x4_store(HEAPU8, i84, SIMD_Int32x4_load(HEAPU8, i86 + 32 | 0));
   HEAP32[i78 + 48 >> 2] = HEAP32[i86 + 48 >> 2];
   HEAPF32[i78 + 52 >> 2] = 0.0;
   i84 = i80 + 16 | 0;
   HEAP32[i84 >> 2] = _firpfb_rrrf_create(2, i78, 14) | 0;
   _llvm_stackrestore(i81 | 0);
   i81 = i79 + 20 | 0;
   HEAP32[i81 >> 2] = i80;
   i80 = i79 + 24 | 0;
   HEAPF32[i80 >> 2] = 0.0;
   i84 = HEAP32[(HEAP32[i84 >> 2] | 0) + 16 >> 2] | 0;
   HEAP32[i84 + 24 >> 2] = 0;
   _memset(HEAP32[i84 >> 2] | 0, 0, HEAP32[i84 + 20 >> 2] << 2 | 0) | 0;
   HEAP32[i83 >> 2] = i79;
   i79 = _malloc(24) | 0;
   i84 = i79;
   SIMD_Int32x4_store(HEAPU8, i84, SIMD_Int32x4(6, 54, 32, 63));
   HEAP32[i79 + 16 >> 2] = 32;
   HEAP32[i79 + 20 >> 2] = 0;
   i84 = i83 + 32 | 0;
   HEAP32[i84 >> 2] = i79;
   HEAPF32[i80 >> 2] = 0.0;
   i81 = HEAP32[(HEAP32[(HEAP32[i81 >> 2] | 0) + 16 >> 2] | 0) + 16 >> 2] | 0;
   HEAP32[i81 + 24 >> 2] = 0;
   _memset(HEAP32[i81 >> 2] | 0, 0, HEAP32[i81 + 20 >> 2] << 2 | 0) | 0;
   i84 = HEAP32[i84 >> 2] | 0;
   HEAP32[i84 + 16 >> 2] = HEAP32[i84 + 8 >> 2];
   i84 = i83 + 84 | 0;
   SIMD_Int32x4_store(HEAPU8, i84, SIMD_Int32x4_splat(0));
   HEAP32[i83 + 44 >> 2] = 0;
   HEAP32[i83 + 48 >> 2] = 0;
   HEAP32[i83 + 52 >> 2] = 0;
   _gmskframegen_set_header_len(i83, 8);
   HEAP32[i83 + 72 >> 2] = 0;
   HEAP32[i83 + 60 >> 2] = 6;
   HEAP32[i83 + 64 >> 2] = 1;
   HEAP32[i83 + 68 >> 2] = 1;
   i84 = _packetizer_create(0, 6, 1, 1) | 0;
   HEAP32[i83 + 56 >> 2] = i84;
   i84 = HEAP32[i84 + 4 >> 2] | 0;
   HEAP32[i83 + 76 >> 2] = i84;
   HEAP32[i82 >> 2] = i84 << 3;
   HEAP32[i83 + 80 >> 2] = _malloc(i84) | 0;
   _gmskframegen_set_header_len(i83, 0);
   HEAP32[i90 + 108 >> 2] = 0;
   i84 = i90 + 112 | 0;
   HEAP32[i84 >> 2] = 0;
   HEAP32[i90 + 96 >> 2] = i83;
   HEAP32[i90 + 100 >> 2] = 2;
   break;
  }
 default:
  i84 = i90 + 112 | 0;
 } while (0);
 i4 = i91 + 20 | 0;
 i9 = _malloc(36) | 0;
 HEAP32[i9 >> 2] = HEAP32[i4 >> 2];
 HEAP32[i9 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
 HEAP32[i9 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
 HEAP32[i9 + 12 >> 2] = HEAP32[i4 + 12 >> 2];
 HEAP32[i9 + 16 >> 2] = HEAP32[i4 + 16 >> 2];
 HEAP32[i9 + 20 >> 2] = HEAP32[i4 + 20 >> 2];
 i5 = _malloc(1060) | 0;
 HEAP32[i5 >> 2] = 0;
 i1 = i5 + 12 | 0;
 i2 = 0;
 do {
  HEAPF32[i1 + (i2 << 2) >> 2] = +Math_sin(+(+(i2 >>> 0) * 6.283185307179586 * .00390625));
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 256);
 HEAPF32[i5 + 1052 >> 2] = .10000000149011612;
 HEAPF32[i5 + 1056 >> 2] = .3162277638912201;
 i1 = HEAP32[i5 >> 2] | 0;
 switch (i1 | 0) {
 case 0:
  {
   HEAP32[i5 + 1048 >> 2] = fb + 1;
   break;
  }
 case 1:
  {
   HEAP32[i5 + 1048 >> 2] = fb + 2;
   break;
  }
 default:
  {
   HEAP32[i85 >> 2] = i1;
   _fprintf(gb + 8728 | 0, gb + 36150 | 0, i85);
   _exit(1);
  }
 }
 HEAP32[i5 + 1036 >> 2] = 0;
 HEAPF32[i5 + 1040 >> 2] = 0.0;
 HEAPF32[i5 + 1044 >> 2] = 1.0;
 HEAP32[i9 + 24 >> 2] = i5;
 HEAPF32[i5 + 4 >> 2] = 0.0;
 HEAP32[i5 + 8 >> 2] = HEAP32[i91 + 32 >> 2];
 i1 = HEAP32[i4 >> 2] | 0;
 if (i1 >>> 0 > 1) HEAP32[i9 + 28 >> 2] = _firinterp_crcf_create_kaiser(i1, HEAP32[i91 + 24 >> 2] | 0) | 0; else {
  HEAP32[i9 >> 2] = 1;
  HEAP32[i9 + 4 >> 2] = 0;
  HEAP32[i9 + 28 >> 2] = 0;
 }
 d3 = +HEAPF32[i91 + 40 >> 2];
 if (d3 != 0.0) {
  HEAPF32[i86 >> 2] = 1.0;
  HEAPF32[i86 + 4 >> 2] = -1.0;
  HEAPF32[i89 >> 2] = 1.0;
  HEAPF32[i89 + 4 >> 2] = d3 + -1.0;
  i8 = _malloc(36) | 0;
  HEAP32[i8 + 16 >> 2] = 2;
  i6 = i8 + 20 | 0;
  HEAP32[i6 >> 2] = 2;
  i7 = i8 + 12 | 0;
  HEAP32[i7 >> 2] = 2;
  HEAP32[i8 + 24 >> 2] = 0;
  i1 = _malloc(8) | 0;
  HEAP32[i8 >> 2] = i1;
  i2 = i8 + 4 | 0;
  HEAP32[i2 >> 2] = _malloc(8) | 0;
  d3 = 1.0;
  i5 = 0;
  while (1) {
   HEAPF32[i1 + (i5 << 2) >> 2] = d3;
   i4 = i5 + 1 | 0;
   if ((i5 | 0) == 1) break;
   d3 = +HEAPF32[i86 + (i4 << 2) >> 2];
   i5 = i4;
  }
  i5 = HEAP32[i2 >> 2] | 0;
  i4 = HEAP32[i6 >> 2] | 0;
  i2 = i4 >>> 0 > 1 ? i4 : 1;
  if ((i2 >>> 0 >= 4 ? (i88 = i2 & -4, (i88 | 0) != 0) : 0) ? (i86 = i2 + -1 | 0, !(i5 >>> 0 <= (i89 + (i86 << 2) | 0) >>> 0 & (i5 + (i86 << 2) | 0) >>> 0 >= i89 >>> 0)) : 0) {
   i1 = 0;
   do {
    SIMD_Float32x4_store(HEAPU8, i5 + (i1 << 2) | 0, SIMD_Float32x4_div(SIMD_Float32x4_load(HEAPU8, i89 + (i1 << 2) | 0), SIMD_Float32x4_splat(Math_fround(1.0))));
    i1 = i1 + 4 | 0;
   } while ((i1 | 0) != (i88 | 0));
   if ((i2 | 0) != (i88 | 0)) {
    i1 = i88;
    i87 = 222;
   }
  } else {
   i1 = 0;
   i87 = 222;
  }
  if ((i87 | 0) == 222) while (1) {
   HEAP32[i5 + (i1 << 2) >> 2] = HEAP32[i89 + (i1 << 2) >> 2];
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= i4 >>> 0) break; else i87 = 222;
  }
  i4 = _malloc(16) | 0;
  HEAP32[i8 + 8 >> 2] = i4;
  i1 = HEAP32[i7 >> 2] | 0;
  i2 = 0;
  do {
   HEAPF32[i4 + (i2 << 3) >> 2] = 0.0;
   HEAPF32[i4 + (i2 << 3) + 4 >> 2] = 0.0;
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < i1 >>> 0);
  HEAP32[i9 + 32 >> 2] = i8;
 } else HEAP32[i9 + 32 >> 2] = 0;
 HEAP32[i90 + 104 >> 2] = i9;
 i1 = Math_imul(HEAP32[i9 >> 2] | 0, HEAP32[i84 >> 2] | 0) | 0;
 HEAP32[i90 + 120 >> 2] = i1;
 HEAP32[i90 + 116 >> 2] = _malloc(i1 << 2) | 0;
 i1 = i90 + 124 | 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 HEAP8[i90 + 140 >> 0] = 1;
 HEAP8[i90 + 92 >> 0] = 0;
 i1 = i90 + 148 | 0;
 HEAPF32[i1 >> 2] = 1.0;
 i2 = i90 + 152 | 0;
 HEAP32[i2 >> 2] = 0;
 if (!(d92 != 44100.0)) {
  i91 = i90;
  STACKTOP = i93;
  return i91 | 0;
 }
 d94 = d92 / 44100.0;
 HEAP32[i2 >> 2] = _resamp_rrrf_create(d94, HEAP32[i91 + 44 >> 2] | 0, +HEAPF32[i91 + 48 >> 2], +HEAPF32[i91 + 52 >> 2], HEAP32[i91 + 56 >> 2] | 0) | 0;
 HEAPF32[i1 >> 2] = d94;
 i91 = i90;
 STACKTOP = i93;
 return i91 | 0;
}

function _malloc(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0;
 do if (i1 >>> 0 < 245) {
  i14 = i1 >>> 0 < 11 ? 16 : i1 + 11 & -8;
  i1 = i14 >>> 3;
  i9 = HEAP32[gb + 41408 >> 2] | 0;
  i2 = i9 >>> i1;
  if (i2 & 3 | 0) {
   i2 = (i2 & 1 ^ 1) + i1 | 0;
   i3 = gb + 41408 + 40 + (i2 << 1 << 2) | 0;
   i4 = i3 + 8 | 0;
   i5 = HEAP32[i4 >> 2] | 0;
   i6 = i5 + 8 | 0;
   i7 = HEAP32[i6 >> 2] | 0;
   do if ((i3 | 0) != (i7 | 0)) {
    if (i7 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i7 + 12 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i5 | 0)) {
     HEAP32[i1 >> 2] = i3;
     HEAP32[i4 >> 2] = i7;
     break;
    } else _abort();
   } else HEAP32[gb + 41408 >> 2] = i9 & ~(1 << i2); while (0);
   i32 = i2 << 3;
   HEAP32[i5 + 4 >> 2] = i32 | 3;
   i32 = i5 + i32 + 4 | 0;
   HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
   i32 = i6;
   return i32 | 0;
  }
  i7 = HEAP32[gb + 41408 + 8 >> 2] | 0;
  if (i14 >>> 0 > i7 >>> 0) {
   if (i2 | 0) {
    i3 = 2 << i1;
    i3 = i2 << i1 & (i3 | 0 - i3);
    i3 = (i3 & 0 - i3) + -1 | 0;
    i8 = i3 >>> 12 & 16;
    i3 = i3 >>> i8;
    i5 = i3 >>> 5 & 8;
    i3 = i3 >>> i5;
    i6 = i3 >>> 2 & 4;
    i3 = i3 >>> i6;
    i4 = i3 >>> 1 & 2;
    i3 = i3 >>> i4;
    i2 = i3 >>> 1 & 1;
    i2 = (i5 | i8 | i6 | i4 | i2) + (i3 >>> i2) | 0;
    i3 = gb + 41408 + 40 + (i2 << 1 << 2) | 0;
    i4 = i3 + 8 | 0;
    i6 = HEAP32[i4 >> 2] | 0;
    i8 = i6 + 8 | 0;
    i5 = HEAP32[i8 >> 2] | 0;
    do if ((i3 | 0) != (i5 | 0)) {
     if (i5 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
     i1 = i5 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i6 | 0)) {
      HEAP32[i1 >> 2] = i3;
      HEAP32[i4 >> 2] = i5;
      i10 = HEAP32[gb + 41408 + 8 >> 2] | 0;
      break;
     } else _abort();
    } else {
     HEAP32[gb + 41408 >> 2] = i9 & ~(1 << i2);
     i10 = i7;
    } while (0);
    i7 = (i2 << 3) - i14 | 0;
    HEAP32[i6 + 4 >> 2] = i14 | 3;
    i4 = i6 + i14 | 0;
    HEAP32[i4 + 4 >> 2] = i7 | 1;
    HEAP32[i4 + i7 >> 2] = i7;
    if (i10 | 0) {
     i5 = HEAP32[gb + 41408 + 20 >> 2] | 0;
     i2 = i10 >>> 3;
     i3 = gb + 41408 + 40 + (i2 << 1 << 2) | 0;
     i1 = HEAP32[gb + 41408 >> 2] | 0;
     i2 = 1 << i2;
     if (i1 & i2) {
      i1 = i3 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
       i11 = i1;
       i12 = i2;
      }
     } else {
      HEAP32[gb + 41408 >> 2] = i1 | i2;
      i11 = i3 + 8 | 0;
      i12 = i3;
     }
     HEAP32[i11 >> 2] = i5;
     HEAP32[i12 + 12 >> 2] = i5;
     HEAP32[i5 + 8 >> 2] = i12;
     HEAP32[i5 + 12 >> 2] = i3;
    }
    HEAP32[gb + 41408 + 8 >> 2] = i7;
    HEAP32[gb + 41408 + 20 >> 2] = i4;
    i32 = i8;
    return i32 | 0;
   }
   i1 = HEAP32[gb + 41408 + 4 >> 2] | 0;
   if (i1) {
    i8 = (i1 & 0 - i1) + -1 | 0;
    i31 = i8 >>> 12 & 16;
    i8 = i8 >>> i31;
    i30 = i8 >>> 5 & 8;
    i8 = i8 >>> i30;
    i32 = i8 >>> 2 & 4;
    i8 = i8 >>> i32;
    i2 = i8 >>> 1 & 2;
    i8 = i8 >>> i2;
    i9 = i8 >>> 1 & 1;
    i9 = HEAP32[gb + 41408 + 304 + ((i30 | i31 | i32 | i2 | i9) + (i8 >>> i9) << 2) >> 2] | 0;
    i8 = (HEAP32[i9 + 4 >> 2] & -8) - i14 | 0;
    i2 = i9;
    while (1) {
     i1 = HEAP32[i2 + 16 >> 2] | 0;
     if (!i1) {
      i1 = HEAP32[i2 + 20 >> 2] | 0;
      if (!i1) break;
     }
     i2 = (HEAP32[i1 + 4 >> 2] & -8) - i14 | 0;
     i32 = i2 >>> 0 < i8 >>> 0;
     i8 = i32 ? i2 : i8;
     i2 = i1;
     i9 = i32 ? i1 : i9;
    }
    i5 = HEAP32[gb + 41408 + 16 >> 2] | 0;
    if (i9 >>> 0 < i5 >>> 0) _abort();
    i7 = i9 + i14 | 0;
    if (i9 >>> 0 >= i7 >>> 0) _abort();
    i6 = HEAP32[i9 + 24 >> 2] | 0;
    i3 = HEAP32[i9 + 12 >> 2] | 0;
    do if ((i3 | 0) == (i9 | 0)) {
     i2 = i9 + 20 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i2 = i9 + 16 | 0;
      i1 = HEAP32[i2 >> 2] | 0;
      if (!i1) {
       i13 = 0;
       break;
      }
     }
     while (1) {
      i3 = i1 + 20 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (i4 | 0) {
       i1 = i4;
       i2 = i3;
       continue;
      }
      i3 = i1 + 16 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (!i4) break; else {
       i1 = i4;
       i2 = i3;
      }
     }
     if (i2 >>> 0 < i5 >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = 0;
      i13 = i1;
      break;
     }
    } else {
     i4 = HEAP32[i9 + 8 >> 2] | 0;
     if (i4 >>> 0 < i5 >>> 0) _abort();
     i1 = i4 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) != (i9 | 0)) _abort();
     i2 = i3 + 8 | 0;
     if ((HEAP32[i2 >> 2] | 0) == (i9 | 0)) {
      HEAP32[i1 >> 2] = i3;
      HEAP32[i2 >> 2] = i4;
      i13 = i3;
      break;
     } else _abort();
    } while (0);
    do if (i6 | 0) {
     i1 = HEAP32[i9 + 28 >> 2] | 0;
     i2 = gb + 41408 + 304 + (i1 << 2) | 0;
     if ((i9 | 0) == (HEAP32[i2 >> 2] | 0)) {
      HEAP32[i2 >> 2] = i13;
      if (!i13) {
       HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
       break;
      }
     } else {
      if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
      i1 = i6 + 16 | 0;
      if ((HEAP32[i1 >> 2] | 0) == (i9 | 0)) HEAP32[i1 >> 2] = i13; else HEAP32[i6 + 20 >> 2] = i13;
      if (!i13) break;
     }
     i2 = HEAP32[gb + 41408 + 16 >> 2] | 0;
     if (i13 >>> 0 < i2 >>> 0) _abort();
     HEAP32[i13 + 24 >> 2] = i6;
     i1 = HEAP32[i9 + 16 >> 2] | 0;
     do if (i1 | 0) if (i1 >>> 0 < i2 >>> 0) _abort(); else {
      HEAP32[i13 + 16 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i13;
      break;
     } while (0);
     i1 = HEAP32[i9 + 20 >> 2] | 0;
     if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i13 + 20 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i13;
      break;
     }
    } while (0);
    if (i8 >>> 0 < 16) {
     i32 = i8 + i14 | 0;
     HEAP32[i9 + 4 >> 2] = i32 | 3;
     i32 = i9 + i32 + 4 | 0;
     HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
    } else {
     HEAP32[i9 + 4 >> 2] = i14 | 3;
     HEAP32[i7 + 4 >> 2] = i8 | 1;
     HEAP32[i7 + i8 >> 2] = i8;
     i1 = HEAP32[gb + 41408 + 8 >> 2] | 0;
     if (i1 | 0) {
      i4 = HEAP32[gb + 41408 + 20 >> 2] | 0;
      i2 = i1 >>> 3;
      i3 = gb + 41408 + 40 + (i2 << 1 << 2) | 0;
      i1 = HEAP32[gb + 41408 >> 2] | 0;
      i2 = 1 << i2;
      if (i1 & i2) {
       i1 = i3 + 8 | 0;
       i2 = HEAP32[i1 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
        i15 = i1;
        i16 = i2;
       }
      } else {
       HEAP32[gb + 41408 >> 2] = i1 | i2;
       i15 = i3 + 8 | 0;
       i16 = i3;
      }
      HEAP32[i15 >> 2] = i4;
      HEAP32[i16 + 12 >> 2] = i4;
      HEAP32[i4 + 8 >> 2] = i16;
      HEAP32[i4 + 12 >> 2] = i3;
     }
     HEAP32[gb + 41408 + 8 >> 2] = i8;
     HEAP32[gb + 41408 + 20 >> 2] = i7;
    }
    i32 = i9 + 8 | 0;
    return i32 | 0;
   }
  }
 } else if (i1 >>> 0 <= 4294967231) {
  i1 = i1 + 11 | 0;
  i14 = i1 & -8;
  i10 = HEAP32[gb + 41408 + 4 >> 2] | 0;
  if (i10) {
   i3 = 0 - i14 | 0;
   i1 = i1 >>> 8;
   if (i1) if (i14 >>> 0 > 16777215) i9 = 31; else {
    i16 = (i1 + 1048320 | 0) >>> 16 & 8;
    i25 = i1 << i16;
    i15 = (i25 + 520192 | 0) >>> 16 & 4;
    i25 = i25 << i15;
    i9 = (i25 + 245760 | 0) >>> 16 & 2;
    i9 = 14 - (i15 | i16 | i9) + (i25 << i9 >>> 15) | 0;
    i9 = i14 >>> (i9 + 7 | 0) & 1 | i9 << 1;
   } else i9 = 0;
   i2 = HEAP32[gb + 41408 + 304 + (i9 << 2) >> 2] | 0;
   L123 : do if (!i2) {
    i1 = 0;
    i2 = 0;
    i25 = 86;
   } else {
    i5 = i3;
    i1 = 0;
    i7 = i14 << ((i9 | 0) == 31 ? 0 : 25 - (i9 >>> 1) | 0);
    i8 = i2;
    i2 = 0;
    while (1) {
     i4 = HEAP32[i8 + 4 >> 2] & -8;
     i3 = i4 - i14 | 0;
     if (i3 >>> 0 < i5 >>> 0) if ((i4 | 0) == (i14 | 0)) {
      i1 = i8;
      i2 = i8;
      i25 = 90;
      break L123;
     } else i2 = i8; else i3 = i5;
     i4 = HEAP32[i8 + 20 >> 2] | 0;
     i8 = HEAP32[i8 + 16 + (i7 >>> 31 << 2) >> 2] | 0;
     i1 = (i4 | 0) == 0 | (i4 | 0) == (i8 | 0) ? i1 : i4;
     i4 = (i8 | 0) == 0;
     if (i4) {
      i25 = 86;
      break;
     } else {
      i5 = i3;
      i7 = i7 << (i4 & 1 ^ 1);
     }
    }
   } while (0);
   if ((i25 | 0) == 86) {
    if ((i1 | 0) == 0 & (i2 | 0) == 0) {
     i1 = 2 << i9;
     i1 = (i1 | 0 - i1) & i10;
     if (!i1) break;
     i16 = (i1 & 0 - i1) + -1 | 0;
     i12 = i16 >>> 12 & 16;
     i16 = i16 >>> i12;
     i11 = i16 >>> 5 & 8;
     i16 = i16 >>> i11;
     i13 = i16 >>> 2 & 4;
     i16 = i16 >>> i13;
     i15 = i16 >>> 1 & 2;
     i16 = i16 >>> i15;
     i1 = i16 >>> 1 & 1;
     i1 = HEAP32[gb + 41408 + 304 + ((i11 | i12 | i13 | i15 | i1) + (i16 >>> i1) << 2) >> 2] | 0;
    }
    if (!i1) {
     i8 = i3;
     i9 = i2;
    } else i25 = 90;
   }
   if ((i25 | 0) == 90) while (1) {
    i25 = 0;
    i16 = (HEAP32[i1 + 4 >> 2] & -8) - i14 | 0;
    i4 = i16 >>> 0 < i3 >>> 0;
    i3 = i4 ? i16 : i3;
    i2 = i4 ? i1 : i2;
    i4 = HEAP32[i1 + 16 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i25 = 90;
     continue;
    }
    i1 = HEAP32[i1 + 20 >> 2] | 0;
    if (!i1) {
     i8 = i3;
     i9 = i2;
     break;
    } else i25 = 90;
   }
   if ((i9 | 0) != 0 ? i8 >>> 0 < ((HEAP32[gb + 41408 + 8 >> 2] | 0) - i14 | 0) >>> 0 : 0) {
    i5 = HEAP32[gb + 41408 + 16 >> 2] | 0;
    if (i9 >>> 0 < i5 >>> 0) _abort();
    i7 = i9 + i14 | 0;
    if (i9 >>> 0 >= i7 >>> 0) _abort();
    i6 = HEAP32[i9 + 24 >> 2] | 0;
    i3 = HEAP32[i9 + 12 >> 2] | 0;
    do if ((i3 | 0) == (i9 | 0)) {
     i2 = i9 + 20 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i2 = i9 + 16 | 0;
      i1 = HEAP32[i2 >> 2] | 0;
      if (!i1) {
       i18 = 0;
       break;
      }
     }
     while (1) {
      i3 = i1 + 20 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (i4 | 0) {
       i1 = i4;
       i2 = i3;
       continue;
      }
      i3 = i1 + 16 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (!i4) break; else {
       i1 = i4;
       i2 = i3;
      }
     }
     if (i2 >>> 0 < i5 >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = 0;
      i18 = i1;
      break;
     }
    } else {
     i4 = HEAP32[i9 + 8 >> 2] | 0;
     if (i4 >>> 0 < i5 >>> 0) _abort();
     i1 = i4 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) != (i9 | 0)) _abort();
     i2 = i3 + 8 | 0;
     if ((HEAP32[i2 >> 2] | 0) == (i9 | 0)) {
      HEAP32[i1 >> 2] = i3;
      HEAP32[i2 >> 2] = i4;
      i18 = i3;
      break;
     } else _abort();
    } while (0);
    do if (i6 | 0) {
     i1 = HEAP32[i9 + 28 >> 2] | 0;
     i2 = gb + 41408 + 304 + (i1 << 2) | 0;
     if ((i9 | 0) == (HEAP32[i2 >> 2] | 0)) {
      HEAP32[i2 >> 2] = i18;
      if (!i18) {
       HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
       break;
      }
     } else {
      if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
      i1 = i6 + 16 | 0;
      if ((HEAP32[i1 >> 2] | 0) == (i9 | 0)) HEAP32[i1 >> 2] = i18; else HEAP32[i6 + 20 >> 2] = i18;
      if (!i18) break;
     }
     i2 = HEAP32[gb + 41408 + 16 >> 2] | 0;
     if (i18 >>> 0 < i2 >>> 0) _abort();
     HEAP32[i18 + 24 >> 2] = i6;
     i1 = HEAP32[i9 + 16 >> 2] | 0;
     do if (i1 | 0) if (i1 >>> 0 < i2 >>> 0) _abort(); else {
      HEAP32[i18 + 16 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i18;
      break;
     } while (0);
     i1 = HEAP32[i9 + 20 >> 2] | 0;
     if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i18 + 20 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i18;
      break;
     }
    } while (0);
    do if (i8 >>> 0 >= 16) {
     HEAP32[i9 + 4 >> 2] = i14 | 3;
     HEAP32[i7 + 4 >> 2] = i8 | 1;
     HEAP32[i7 + i8 >> 2] = i8;
     i1 = i8 >>> 3;
     if (i8 >>> 0 < 256) {
      i3 = gb + 41408 + 40 + (i1 << 1 << 2) | 0;
      i2 = HEAP32[gb + 41408 >> 2] | 0;
      i1 = 1 << i1;
      if (i2 & i1) {
       i1 = i3 + 8 | 0;
       i2 = HEAP32[i1 >> 2] | 0;
       if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
        i19 = i1;
        i21 = i2;
       }
      } else {
       HEAP32[gb + 41408 >> 2] = i2 | i1;
       i19 = i3 + 8 | 0;
       i21 = i3;
      }
      HEAP32[i19 >> 2] = i7;
      HEAP32[i21 + 12 >> 2] = i7;
      HEAP32[i7 + 8 >> 2] = i21;
      HEAP32[i7 + 12 >> 2] = i3;
      break;
     }
     i1 = i8 >>> 8;
     if (i1) if (i8 >>> 0 > 16777215) i3 = 31; else {
      i31 = (i1 + 1048320 | 0) >>> 16 & 8;
      i32 = i1 << i31;
      i30 = (i32 + 520192 | 0) >>> 16 & 4;
      i32 = i32 << i30;
      i3 = (i32 + 245760 | 0) >>> 16 & 2;
      i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
      i3 = i8 >>> (i3 + 7 | 0) & 1 | i3 << 1;
     } else i3 = 0;
     i4 = gb + 41408 + 304 + (i3 << 2) | 0;
     HEAP32[i7 + 28 >> 2] = i3;
     i1 = i7 + 16 | 0;
     HEAP32[i1 + 4 >> 2] = 0;
     HEAP32[i1 >> 2] = 0;
     i1 = HEAP32[gb + 41408 + 4 >> 2] | 0;
     i2 = 1 << i3;
     if (!(i1 & i2)) {
      HEAP32[gb + 41408 + 4 >> 2] = i1 | i2;
      HEAP32[i4 >> 2] = i7;
      HEAP32[i7 + 24 >> 2] = i4;
      HEAP32[i7 + 12 >> 2] = i7;
      HEAP32[i7 + 8 >> 2] = i7;
      break;
     }
     i3 = i8 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
     i4 = HEAP32[i4 >> 2] | 0;
     while (1) {
      if ((HEAP32[i4 + 4 >> 2] & -8 | 0) == (i8 | 0)) {
       i25 = 148;
       break;
      }
      i2 = i4 + 16 + (i3 >>> 31 << 2) | 0;
      i1 = HEAP32[i2 >> 2] | 0;
      if (!i1) {
       i25 = 145;
       break;
      } else {
       i3 = i3 << 1;
       i4 = i1;
      }
     }
     if ((i25 | 0) == 145) if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = i7;
      HEAP32[i7 + 24 >> 2] = i4;
      HEAP32[i7 + 12 >> 2] = i7;
      HEAP32[i7 + 8 >> 2] = i7;
      break;
     } else if ((i25 | 0) == 148) {
      i1 = i4 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      i32 = HEAP32[gb + 41408 + 16 >> 2] | 0;
      if (i2 >>> 0 >= i32 >>> 0 & i4 >>> 0 >= i32 >>> 0) {
       HEAP32[i2 + 12 >> 2] = i7;
       HEAP32[i1 >> 2] = i7;
       HEAP32[i7 + 8 >> 2] = i2;
       HEAP32[i7 + 12 >> 2] = i4;
       HEAP32[i7 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } else {
     i32 = i8 + i14 | 0;
     HEAP32[i9 + 4 >> 2] = i32 | 3;
     i32 = i9 + i32 + 4 | 0;
     HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
    } while (0);
    i32 = i9 + 8 | 0;
    return i32 | 0;
   }
  }
 } else i14 = -1; while (0);
 i3 = HEAP32[gb + 41408 + 8 >> 2] | 0;
 if (i3 >>> 0 >= i14 >>> 0) {
  i1 = i3 - i14 | 0;
  i2 = HEAP32[gb + 41408 + 20 >> 2] | 0;
  if (i1 >>> 0 > 15) {
   i32 = i2 + i14 | 0;
   HEAP32[gb + 41408 + 20 >> 2] = i32;
   HEAP32[gb + 41408 + 8 >> 2] = i1;
   HEAP32[i32 + 4 >> 2] = i1 | 1;
   HEAP32[i32 + i1 >> 2] = i1;
   HEAP32[i2 + 4 >> 2] = i14 | 3;
  } else {
   HEAP32[gb + 41408 + 8 >> 2] = 0;
   HEAP32[gb + 41408 + 20 >> 2] = 0;
   HEAP32[i2 + 4 >> 2] = i3 | 3;
   i32 = i2 + i3 + 4 | 0;
   HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
  }
  i32 = i2 + 8 | 0;
  return i32 | 0;
 }
 i1 = HEAP32[gb + 41408 + 12 >> 2] | 0;
 if (i1 >>> 0 > i14 >>> 0) {
  i30 = i1 - i14 | 0;
  HEAP32[gb + 41408 + 12 >> 2] = i30;
  i32 = HEAP32[gb + 41408 + 24 >> 2] | 0;
  i31 = i32 + i14 | 0;
  HEAP32[gb + 41408 + 24 >> 2] = i31;
  HEAP32[i31 + 4 >> 2] = i30 | 1;
  HEAP32[i32 + 4 >> 2] = i14 | 3;
  i32 = i32 + 8 | 0;
  return i32 | 0;
 }
 do if (!(HEAP32[gb + 41880 >> 2] | 0)) {
  i1 = _sysconf(30) | 0;
  if (!(i1 + -1 & i1)) {
   HEAP32[gb + 41880 + 8 >> 2] = i1;
   HEAP32[gb + 41880 + 4 >> 2] = i1;
   HEAP32[gb + 41880 + 12 >> 2] = -1;
   HEAP32[gb + 41880 + 16 >> 2] = -1;
   HEAP32[gb + 41880 + 20 >> 2] = 0;
   HEAP32[gb + 41408 + 444 >> 2] = 0;
   i21 = (_time(0) | 0) & -16 ^ 1431655768;
   HEAP32[gb + 41880 >> 2] = i21;
   break;
  } else _abort();
 } while (0);
 i7 = i14 + 48 | 0;
 i4 = HEAP32[gb + 41880 + 8 >> 2] | 0;
 i8 = i14 + 47 | 0;
 i3 = i4 + i8 | 0;
 i4 = 0 - i4 | 0;
 i9 = i3 & i4;
 if (i9 >>> 0 <= i14 >>> 0) {
  i32 = 0;
  return i32 | 0;
 }
 i1 = HEAP32[gb + 41408 + 440 >> 2] | 0;
 if (i1 | 0 ? (i19 = HEAP32[gb + 41408 + 432 >> 2] | 0, i21 = i19 + i9 | 0, i21 >>> 0 <= i19 >>> 0 | i21 >>> 0 > i1 >>> 0) : 0) {
  i32 = 0;
  return i32 | 0;
 }
 L257 : do if (!(HEAP32[gb + 41408 + 444 >> 2] & 4)) {
  i2 = HEAP32[gb + 41408 + 24 >> 2] | 0;
  L259 : do if (i2) {
   i5 = gb + 41408 + 448 | 0;
   while (1) {
    i1 = HEAP32[i5 >> 2] | 0;
    if (i1 >>> 0 <= i2 >>> 0 ? (i17 = i5 + 4 | 0, (i1 + (HEAP32[i17 >> 2] | 0) | 0) >>> 0 > i2 >>> 0) : 0) break;
    i1 = HEAP32[i5 + 8 >> 2] | 0;
    if (!i1) {
     i25 = 173;
     break L259;
    } else i5 = i1;
   }
   i1 = i3 - (HEAP32[gb + 41408 + 12 >> 2] | 0) & i4;
   if (i1 >>> 0 < 2147483647) {
    i2 = _sbrk(i1 | 0) | 0;
    if ((i2 | 0) == ((HEAP32[i5 >> 2] | 0) + (HEAP32[i17 >> 2] | 0) | 0)) {
     if ((i2 | 0) != (-1 | 0)) {
      i7 = i2;
      i6 = i1;
      i25 = 193;
      break L257;
     }
    } else i25 = 183;
   }
  } else i25 = 173; while (0);
  do if ((i25 | 0) == 173 ? (i20 = _sbrk(0) | 0, (i20 | 0) != (-1 | 0)) : 0) {
   i1 = i20;
   i2 = HEAP32[gb + 41880 + 4 >> 2] | 0;
   i3 = i2 + -1 | 0;
   if (!(i3 & i1)) i1 = i9; else i1 = i9 - i1 + (i3 + i1 & 0 - i2) | 0;
   i2 = HEAP32[gb + 41408 + 432 >> 2] | 0;
   i3 = i2 + i1 | 0;
   if (i1 >>> 0 > i14 >>> 0 & i1 >>> 0 < 2147483647) {
    i21 = HEAP32[gb + 41408 + 440 >> 2] | 0;
    if (i21 | 0 ? i3 >>> 0 <= i2 >>> 0 | i3 >>> 0 > i21 >>> 0 : 0) break;
    i2 = _sbrk(i1 | 0) | 0;
    if ((i2 | 0) == (i20 | 0)) {
     i7 = i20;
     i6 = i1;
     i25 = 193;
     break L257;
    } else i25 = 183;
   }
  } while (0);
  L279 : do if ((i25 | 0) == 183) {
   i3 = 0 - i1 | 0;
   do if (i7 >>> 0 > i1 >>> 0 & (i1 >>> 0 < 2147483647 & (i2 | 0) != (-1 | 0)) ? (i22 = HEAP32[gb + 41880 + 8 >> 2] | 0, i22 = i8 - i1 + i22 & 0 - i22, i22 >>> 0 < 2147483647) : 0) if ((_sbrk(i22 | 0) | 0) == (-1 | 0)) {
    _sbrk(i3 | 0) | 0;
    break L279;
   } else {
    i1 = i22 + i1 | 0;
    break;
   } while (0);
   if ((i2 | 0) != (-1 | 0)) {
    i7 = i2;
    i6 = i1;
    i25 = 193;
    break L257;
   }
  } while (0);
  HEAP32[gb + 41408 + 444 >> 2] = HEAP32[gb + 41408 + 444 >> 2] | 4;
  i25 = 190;
 } else i25 = 190; while (0);
 if ((((i25 | 0) == 190 ? i9 >>> 0 < 2147483647 : 0) ? (i23 = _sbrk(i9 | 0) | 0, i24 = _sbrk(0) | 0, i23 >>> 0 < i24 >>> 0 & ((i23 | 0) != (-1 | 0) & (i24 | 0) != (-1 | 0))) : 0) ? (i6 = i24 - i23 | 0, i6 >>> 0 > (i14 + 40 | 0) >>> 0) : 0) {
  i7 = i23;
  i25 = 193;
 }
 if ((i25 | 0) == 193) {
  i1 = (HEAP32[gb + 41408 + 432 >> 2] | 0) + i6 | 0;
  HEAP32[gb + 41408 + 432 >> 2] = i1;
  if (i1 >>> 0 > (HEAP32[gb + 41408 + 436 >> 2] | 0) >>> 0) HEAP32[gb + 41408 + 436 >> 2] = i1;
  i10 = HEAP32[gb + 41408 + 24 >> 2] | 0;
  do if (i10) {
   i5 = gb + 41408 + 448 | 0;
   while (1) {
    i1 = HEAP32[i5 >> 2] | 0;
    i2 = i5 + 4 | 0;
    i3 = HEAP32[i2 >> 2] | 0;
    if ((i7 | 0) == (i1 + i3 | 0)) {
     i25 = 203;
     break;
    }
    i4 = HEAP32[i5 + 8 >> 2] | 0;
    if (!i4) break; else i5 = i4;
   }
   if (((i25 | 0) == 203 ? (HEAP32[i5 + 12 >> 2] & 8 | 0) == 0 : 0) ? i10 >>> 0 < i7 >>> 0 & i10 >>> 0 >= i1 >>> 0 : 0) {
    HEAP32[i2 >> 2] = i3 + i6;
    i32 = i10 + 8 | 0;
    i32 = (i32 & 7 | 0) == 0 ? 0 : 0 - i32 & 7;
    i31 = i10 + i32 | 0;
    i32 = (HEAP32[gb + 41408 + 12 >> 2] | 0) + (i6 - i32) | 0;
    HEAP32[gb + 41408 + 24 >> 2] = i31;
    HEAP32[gb + 41408 + 12 >> 2] = i32;
    HEAP32[i31 + 4 >> 2] = i32 | 1;
    HEAP32[i31 + i32 + 4 >> 2] = 40;
    HEAP32[gb + 41408 + 28 >> 2] = HEAP32[gb + 41880 + 16 >> 2];
    break;
   }
   i1 = HEAP32[gb + 41408 + 16 >> 2] | 0;
   if (i7 >>> 0 < i1 >>> 0) {
    HEAP32[gb + 41408 + 16 >> 2] = i7;
    i8 = i7;
   } else i8 = i1;
   i2 = i7 + i6 | 0;
   i1 = gb + 41408 + 448 | 0;
   while (1) {
    if ((HEAP32[i1 >> 2] | 0) == (i2 | 0)) {
     i25 = 211;
     break;
    }
    i1 = HEAP32[i1 + 8 >> 2] | 0;
    if (!i1) {
     i2 = gb + 41408 + 448 | 0;
     break;
    }
   }
   if ((i25 | 0) == 211) if (!(HEAP32[i1 + 12 >> 2] & 8)) {
    HEAP32[i1 >> 2] = i7;
    i12 = i1 + 4 | 0;
    HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + i6;
    i12 = i7 + 8 | 0;
    i12 = i7 + ((i12 & 7 | 0) == 0 ? 0 : 0 - i12 & 7) | 0;
    i1 = i2 + 8 | 0;
    i1 = i2 + ((i1 & 7 | 0) == 0 ? 0 : 0 - i1 & 7) | 0;
    i11 = i12 + i14 | 0;
    i9 = i1 - i12 - i14 | 0;
    HEAP32[i12 + 4 >> 2] = i14 | 3;
    do if ((i1 | 0) != (i10 | 0)) {
     if ((i1 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
      i32 = (HEAP32[gb + 41408 + 8 >> 2] | 0) + i9 | 0;
      HEAP32[gb + 41408 + 8 >> 2] = i32;
      HEAP32[gb + 41408 + 20 >> 2] = i11;
      HEAP32[i11 + 4 >> 2] = i32 | 1;
      HEAP32[i11 + i32 >> 2] = i32;
      break;
     }
     i2 = HEAP32[i1 + 4 >> 2] | 0;
     if ((i2 & 3 | 0) == 1) {
      i7 = i2 & -8;
      i5 = i2 >>> 3;
      L331 : do if (i2 >>> 0 >= 256) {
       i6 = HEAP32[i1 + 24 >> 2] | 0;
       i4 = HEAP32[i1 + 12 >> 2] | 0;
       do if ((i4 | 0) == (i1 | 0)) {
        i4 = i1 + 16 | 0;
        i3 = i4 + 4 | 0;
        i2 = HEAP32[i3 >> 2] | 0;
        if (!i2) {
         i2 = HEAP32[i4 >> 2] | 0;
         if (!i2) {
          i30 = 0;
          break;
         } else i3 = i4;
        }
        while (1) {
         i4 = i2 + 20 | 0;
         i5 = HEAP32[i4 >> 2] | 0;
         if (i5 | 0) {
          i2 = i5;
          i3 = i4;
          continue;
         }
         i4 = i2 + 16 | 0;
         i5 = HEAP32[i4 >> 2] | 0;
         if (!i5) break; else {
          i2 = i5;
          i3 = i4;
         }
        }
        if (i3 >>> 0 < i8 >>> 0) _abort(); else {
         HEAP32[i3 >> 2] = 0;
         i30 = i2;
         break;
        }
       } else {
        i5 = HEAP32[i1 + 8 >> 2] | 0;
        if (i5 >>> 0 < i8 >>> 0) _abort();
        i2 = i5 + 12 | 0;
        if ((HEAP32[i2 >> 2] | 0) != (i1 | 0)) _abort();
        i3 = i4 + 8 | 0;
        if ((HEAP32[i3 >> 2] | 0) == (i1 | 0)) {
         HEAP32[i2 >> 2] = i4;
         HEAP32[i3 >> 2] = i5;
         i30 = i4;
         break;
        } else _abort();
       } while (0);
       if (!i6) break;
       i2 = HEAP32[i1 + 28 >> 2] | 0;
       i3 = gb + 41408 + 304 + (i2 << 2) | 0;
       do if ((i1 | 0) != (HEAP32[i3 >> 2] | 0)) {
        if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
        i2 = i6 + 16 | 0;
        if ((HEAP32[i2 >> 2] | 0) == (i1 | 0)) HEAP32[i2 >> 2] = i30; else HEAP32[i6 + 20 >> 2] = i30;
        if (!i30) break L331;
       } else {
        HEAP32[i3 >> 2] = i30;
        if (i30 | 0) break;
        HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i2);
        break L331;
       } while (0);
       i4 = HEAP32[gb + 41408 + 16 >> 2] | 0;
       if (i30 >>> 0 < i4 >>> 0) _abort();
       HEAP32[i30 + 24 >> 2] = i6;
       i2 = i1 + 16 | 0;
       i3 = HEAP32[i2 >> 2] | 0;
       do if (i3 | 0) if (i3 >>> 0 < i4 >>> 0) _abort(); else {
        HEAP32[i30 + 16 >> 2] = i3;
        HEAP32[i3 + 24 >> 2] = i30;
        break;
       } while (0);
       i2 = HEAP32[i2 + 4 >> 2] | 0;
       if (!i2) break;
       if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
        HEAP32[i30 + 20 >> 2] = i2;
        HEAP32[i2 + 24 >> 2] = i30;
        break;
       }
      } else {
       i3 = HEAP32[i1 + 8 >> 2] | 0;
       i4 = HEAP32[i1 + 12 >> 2] | 0;
       i2 = gb + 41408 + 40 + (i5 << 1 << 2) | 0;
       do if ((i3 | 0) != (i2 | 0)) {
        if (i3 >>> 0 < i8 >>> 0) _abort();
        if ((HEAP32[i3 + 12 >> 2] | 0) == (i1 | 0)) break;
        _abort();
       } while (0);
       if ((i4 | 0) == (i3 | 0)) {
        HEAP32[gb + 41408 >> 2] = HEAP32[gb + 41408 >> 2] & ~(1 << i5);
        break;
       }
       do if ((i4 | 0) == (i2 | 0)) i27 = i4 + 8 | 0; else {
        if (i4 >>> 0 < i8 >>> 0) _abort();
        i2 = i4 + 8 | 0;
        if ((HEAP32[i2 >> 2] | 0) == (i1 | 0)) {
         i27 = i2;
         break;
        }
        _abort();
       } while (0);
       HEAP32[i3 + 12 >> 2] = i4;
       HEAP32[i27 >> 2] = i3;
      } while (0);
      i1 = i1 + i7 | 0;
      i5 = i7 + i9 | 0;
     } else i5 = i9;
     i1 = i1 + 4 | 0;
     HEAP32[i1 >> 2] = HEAP32[i1 >> 2] & -2;
     HEAP32[i11 + 4 >> 2] = i5 | 1;
     HEAP32[i11 + i5 >> 2] = i5;
     i1 = i5 >>> 3;
     if (i5 >>> 0 < 256) {
      i3 = gb + 41408 + 40 + (i1 << 1 << 2) | 0;
      i2 = HEAP32[gb + 41408 >> 2] | 0;
      i1 = 1 << i1;
      do if (!(i2 & i1)) {
       HEAP32[gb + 41408 >> 2] = i2 | i1;
       i31 = i3 + 8 | 0;
       i32 = i3;
      } else {
       i1 = i3 + 8 | 0;
       i2 = HEAP32[i1 >> 2] | 0;
       if (i2 >>> 0 >= (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) {
        i31 = i1;
        i32 = i2;
        break;
       }
       _abort();
      } while (0);
      HEAP32[i31 >> 2] = i11;
      HEAP32[i32 + 12 >> 2] = i11;
      HEAP32[i11 + 8 >> 2] = i32;
      HEAP32[i11 + 12 >> 2] = i3;
      break;
     }
     i1 = i5 >>> 8;
     do if (!i1) i3 = 0; else {
      if (i5 >>> 0 > 16777215) {
       i3 = 31;
       break;
      }
      i31 = (i1 + 1048320 | 0) >>> 16 & 8;
      i32 = i1 << i31;
      i30 = (i32 + 520192 | 0) >>> 16 & 4;
      i32 = i32 << i30;
      i3 = (i32 + 245760 | 0) >>> 16 & 2;
      i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
      i3 = i5 >>> (i3 + 7 | 0) & 1 | i3 << 1;
     } while (0);
     i4 = gb + 41408 + 304 + (i3 << 2) | 0;
     HEAP32[i11 + 28 >> 2] = i3;
     i1 = i11 + 16 | 0;
     HEAP32[i1 + 4 >> 2] = 0;
     HEAP32[i1 >> 2] = 0;
     i1 = HEAP32[gb + 41408 + 4 >> 2] | 0;
     i2 = 1 << i3;
     if (!(i1 & i2)) {
      HEAP32[gb + 41408 + 4 >> 2] = i1 | i2;
      HEAP32[i4 >> 2] = i11;
      HEAP32[i11 + 24 >> 2] = i4;
      HEAP32[i11 + 12 >> 2] = i11;
      HEAP32[i11 + 8 >> 2] = i11;
      break;
     }
     i3 = i5 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
     i4 = HEAP32[i4 >> 2] | 0;
     while (1) {
      if ((HEAP32[i4 + 4 >> 2] & -8 | 0) == (i5 | 0)) {
       i25 = 281;
       break;
      }
      i2 = i4 + 16 + (i3 >>> 31 << 2) | 0;
      i1 = HEAP32[i2 >> 2] | 0;
      if (!i1) {
       i25 = 278;
       break;
      } else {
       i3 = i3 << 1;
       i4 = i1;
      }
     }
     if ((i25 | 0) == 278) if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = i11;
      HEAP32[i11 + 24 >> 2] = i4;
      HEAP32[i11 + 12 >> 2] = i11;
      HEAP32[i11 + 8 >> 2] = i11;
      break;
     } else if ((i25 | 0) == 281) {
      i1 = i4 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      i32 = HEAP32[gb + 41408 + 16 >> 2] | 0;
      if (i2 >>> 0 >= i32 >>> 0 & i4 >>> 0 >= i32 >>> 0) {
       HEAP32[i2 + 12 >> 2] = i11;
       HEAP32[i1 >> 2] = i11;
       HEAP32[i11 + 8 >> 2] = i2;
       HEAP32[i11 + 12 >> 2] = i4;
       HEAP32[i11 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } else {
     i32 = (HEAP32[gb + 41408 + 12 >> 2] | 0) + i9 | 0;
     HEAP32[gb + 41408 + 12 >> 2] = i32;
     HEAP32[gb + 41408 + 24 >> 2] = i11;
     HEAP32[i11 + 4 >> 2] = i32 | 1;
    } while (0);
    i32 = i12 + 8 | 0;
    return i32 | 0;
   } else i2 = gb + 41408 + 448 | 0;
   while (1) {
    i1 = HEAP32[i2 >> 2] | 0;
    if (i1 >>> 0 <= i10 >>> 0 ? (i26 = i1 + (HEAP32[i2 + 4 >> 2] | 0) | 0, i26 >>> 0 > i10 >>> 0) : 0) break;
    i2 = HEAP32[i2 + 8 >> 2] | 0;
   }
   i5 = i26 + -47 | 0;
   i2 = i5 + 8 | 0;
   i2 = i5 + ((i2 & 7 | 0) == 0 ? 0 : 0 - i2 & 7) | 0;
   i5 = i10 + 16 | 0;
   i2 = i2 >>> 0 < i5 >>> 0 ? i10 : i2;
   i1 = i2 + 8 | 0;
   i3 = i7 + 8 | 0;
   i3 = (i3 & 7 | 0) == 0 ? 0 : 0 - i3 & 7;
   i32 = i7 + i3 | 0;
   i3 = i6 + -40 - i3 | 0;
   HEAP32[gb + 41408 + 24 >> 2] = i32;
   HEAP32[gb + 41408 + 12 >> 2] = i3;
   HEAP32[i32 + 4 >> 2] = i3 | 1;
   HEAP32[i32 + i3 + 4 >> 2] = 40;
   HEAP32[gb + 41408 + 28 >> 2] = HEAP32[gb + 41880 + 16 >> 2];
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 27;
   HEAP32[i1 >> 2] = HEAP32[gb + 41408 + 448 >> 2];
   HEAP32[i1 + 4 >> 2] = HEAP32[gb + 41408 + 448 + 4 >> 2];
   HEAP32[i1 + 8 >> 2] = HEAP32[gb + 41408 + 448 + 8 >> 2];
   HEAP32[i1 + 12 >> 2] = HEAP32[gb + 41408 + 448 + 12 >> 2];
   HEAP32[gb + 41408 + 448 >> 2] = i7;
   HEAP32[gb + 41408 + 452 >> 2] = i6;
   HEAP32[gb + 41408 + 460 >> 2] = 0;
   HEAP32[gb + 41408 + 456 >> 2] = i1;
   i1 = i2 + 24 | 0;
   do {
    i1 = i1 + 4 | 0;
    HEAP32[i1 >> 2] = 7;
   } while ((i1 + 4 | 0) >>> 0 < i26 >>> 0);
   if ((i2 | 0) != (i10 | 0)) {
    i6 = i2 - i10 | 0;
    HEAP32[i3 >> 2] = HEAP32[i3 >> 2] & -2;
    HEAP32[i10 + 4 >> 2] = i6 | 1;
    HEAP32[i2 >> 2] = i6;
    i1 = i6 >>> 3;
    if (i6 >>> 0 < 256) {
     i3 = gb + 41408 + 40 + (i1 << 1 << 2) | 0;
     i2 = HEAP32[gb + 41408 >> 2] | 0;
     i1 = 1 << i1;
     if (i2 & i1) {
      i1 = i3 + 8 | 0;
      i2 = HEAP32[i1 >> 2] | 0;
      if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
       i28 = i1;
       i29 = i2;
      }
     } else {
      HEAP32[gb + 41408 >> 2] = i2 | i1;
      i28 = i3 + 8 | 0;
      i29 = i3;
     }
     HEAP32[i28 >> 2] = i10;
     HEAP32[i29 + 12 >> 2] = i10;
     HEAP32[i10 + 8 >> 2] = i29;
     HEAP32[i10 + 12 >> 2] = i3;
     break;
    }
    i1 = i6 >>> 8;
    if (i1) if (i6 >>> 0 > 16777215) i3 = 31; else {
     i31 = (i1 + 1048320 | 0) >>> 16 & 8;
     i32 = i1 << i31;
     i30 = (i32 + 520192 | 0) >>> 16 & 4;
     i32 = i32 << i30;
     i3 = (i32 + 245760 | 0) >>> 16 & 2;
     i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
     i3 = i6 >>> (i3 + 7 | 0) & 1 | i3 << 1;
    } else i3 = 0;
    i4 = gb + 41408 + 304 + (i3 << 2) | 0;
    HEAP32[i10 + 28 >> 2] = i3;
    HEAP32[i10 + 20 >> 2] = 0;
    HEAP32[i5 >> 2] = 0;
    i1 = HEAP32[gb + 41408 + 4 >> 2] | 0;
    i2 = 1 << i3;
    if (!(i1 & i2)) {
     HEAP32[gb + 41408 + 4 >> 2] = i1 | i2;
     HEAP32[i4 >> 2] = i10;
     HEAP32[i10 + 24 >> 2] = i4;
     HEAP32[i10 + 12 >> 2] = i10;
     HEAP32[i10 + 8 >> 2] = i10;
     break;
    }
    i3 = i6 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
    i4 = HEAP32[i4 >> 2] | 0;
    while (1) {
     if ((HEAP32[i4 + 4 >> 2] & -8 | 0) == (i6 | 0)) {
      i25 = 307;
      break;
     }
     i2 = i4 + 16 + (i3 >>> 31 << 2) | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i25 = 304;
      break;
     } else {
      i3 = i3 << 1;
      i4 = i1;
     }
    }
    if ((i25 | 0) == 304) if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i2 >> 2] = i10;
     HEAP32[i10 + 24 >> 2] = i4;
     HEAP32[i10 + 12 >> 2] = i10;
     HEAP32[i10 + 8 >> 2] = i10;
     break;
    } else if ((i25 | 0) == 307) {
     i1 = i4 + 8 | 0;
     i2 = HEAP32[i1 >> 2] | 0;
     i32 = HEAP32[gb + 41408 + 16 >> 2] | 0;
     if (i2 >>> 0 >= i32 >>> 0 & i4 >>> 0 >= i32 >>> 0) {
      HEAP32[i2 + 12 >> 2] = i10;
      HEAP32[i1 >> 2] = i10;
      HEAP32[i10 + 8 >> 2] = i2;
      HEAP32[i10 + 12 >> 2] = i4;
      HEAP32[i10 + 24 >> 2] = 0;
      break;
     } else _abort();
    }
   }
  } else {
   i32 = HEAP32[gb + 41408 + 16 >> 2] | 0;
   if ((i32 | 0) == 0 | i7 >>> 0 < i32 >>> 0) HEAP32[gb + 41408 + 16 >> 2] = i7;
   HEAP32[gb + 41408 + 448 >> 2] = i7;
   HEAP32[gb + 41408 + 452 >> 2] = i6;
   HEAP32[gb + 41408 + 460 >> 2] = 0;
   HEAP32[gb + 41408 + 36 >> 2] = HEAP32[gb + 41880 >> 2];
   HEAP32[gb + 41408 + 32 >> 2] = -1;
   i1 = 0;
   do {
    i32 = gb + 41408 + 40 + (i1 << 1 << 2) | 0;
    HEAP32[i32 + 12 >> 2] = i32;
    HEAP32[i32 + 8 >> 2] = i32;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != 32);
   i32 = i7 + 8 | 0;
   i32 = (i32 & 7 | 0) == 0 ? 0 : 0 - i32 & 7;
   i31 = i7 + i32 | 0;
   i32 = i6 + -40 - i32 | 0;
   HEAP32[gb + 41408 + 24 >> 2] = i31;
   HEAP32[gb + 41408 + 12 >> 2] = i32;
   HEAP32[i31 + 4 >> 2] = i32 | 1;
   HEAP32[i31 + i32 + 4 >> 2] = 40;
   HEAP32[gb + 41408 + 28 >> 2] = HEAP32[gb + 41880 + 16 >> 2];
  } while (0);
  i1 = HEAP32[gb + 41408 + 12 >> 2] | 0;
  if (i1 >>> 0 > i14 >>> 0) {
   i30 = i1 - i14 | 0;
   HEAP32[gb + 41408 + 12 >> 2] = i30;
   i32 = HEAP32[gb + 41408 + 24 >> 2] | 0;
   i31 = i32 + i14 | 0;
   HEAP32[gb + 41408 + 24 >> 2] = i31;
   HEAP32[i31 + 4 >> 2] = i30 | 1;
   HEAP32[i32 + 4 >> 2] = i14 | 3;
   i32 = i32 + 8 | 0;
   return i32 | 0;
  }
 }
 if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
 HEAP32[i1 >> 2] = 12;
 i32 = 0;
 return i32 | 0;
}

function _modem_create(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i11;
 do switch (i2 | 0) {
 case 1:
  {
   i10 = _modem_create_psk(1) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 2:
  {
   i10 = _modem_create_psk(2) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 3:
  {
   i10 = _modem_create_psk(3) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 4:
  {
   i10 = _modem_create_psk(4) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 5:
  {
   i10 = _modem_create_psk(5) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 6:
  {
   i10 = _modem_create_psk(6) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 7:
  {
   i10 = _modem_create_psk(7) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 8:
  {
   i10 = _modem_create_psk(8) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 9:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 9;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 1;
   HEAP32[i10 + 8 >> 2] = 2;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAPF32[i10 + 12 >> 2] = 1.5707963705062866;
   HEAP32[i9 >> 2] = fb + 5;
   HEAP32[i10 + 240 >> 2] = fb + 6;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   i9 = i10 + 96 | 0;
   SIMD_Float32x4_store(HEAPU8, i9, SIMD_Float32x4(Math_fround(0.0), Math_fround(1.5707963705062866), Math_fround(0.0), Math_fround(1.5707963705062866)));
   HEAPF32[i10 + 104 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 10:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 10;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 2;
   HEAP32[i10 + 8 >> 2] = 4;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAPF32[i10 + 12 >> 2] = .7853981852531433;
   HEAPF32[i10 + 16 >> 2] = 1.5707963705062866;
   HEAP32[i9 >> 2] = fb + 5;
   HEAP32[i10 + 240 >> 2] = fb + 6;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   i9 = i10 + 96 | 0;
   SIMD_Float32x4_store(HEAPU8, i9, SIMD_Float32x4(Math_fround(0.0), Math_fround(2.356194496154785), Math_fround(0.0), Math_fround(.7853981852531433)));
   STACKTOP = i11;
   return i10 | 0;
  }
 case 11:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 11;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 3;
   HEAP32[i10 + 8 >> 2] = 8;
   i8 = i10 + 236 | 0;
   HEAP32[i8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 12 >> 2] = 0;
   HEAPF32[i10 + 108 >> 2] = .39269909262657166;
   i9 = i10 + 104 | 0;
   HEAPF32[i9 >> 2] = 0.0;
   HEAPF32[i10 + 12 >> 2] = .39269909262657166;
   HEAPF32[i10 + 16 >> 2] = .7853981852531433;
   HEAPF32[i10 + 20 >> 2] = 1.5707963705062866;
   HEAPF32[i10 + 100 >> 2] = 2.7488934993743896;
   HEAP32[i8 >> 2] = fb + 5;
   HEAP32[i10 + 240 >> 2] = fb + 6;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   HEAPF32[i10 + 96 >> 2] = 0.0;
   HEAPF32[i9 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 12:
  {
   i2 = _malloc(252) | 0;
   HEAP32[i2 >> 2] = 12;
   HEAP32[i2 + 76 >> 2] = 0;
   HEAP32[i2 + 80 >> 2] = 0;
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 4;
   i4 = i2 + 8 | 0;
   HEAP32[i4 >> 2] = 16;
   i6 = i2 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i2 + 100 | 0;
   i8 = i2 + 108 | 0;
   HEAPF32[i8 >> 2] = .19634954631328583;
   i9 = i2 + 104 | 0;
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2 + 12 | 0;
   HEAPF32[i10 >> 2] = .19634954631328583;
   HEAPF32[i2 + 16 >> 2] = .39269909262657166;
   HEAPF32[i2 + 20 >> 2] = .7853981852531433;
   d5 = .19634954631328583;
   i1 = 3;
   while (1) {
    HEAPF32[i10 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    if (i1 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) break;
    d5 = +HEAPF32[i8 >> 2];
   }
   i10 = ((HEAP32[i2 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i7 >> 2] = (1.0 - 1.0 / +((HEAP32[i4 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i6 >> 2] = fb + 5;
   HEAP32[i2 + 240 >> 2] = fb + 6;
   HEAPF32[i2 + 84 >> 2] = 1.0;
   HEAPF32[i2 + 88 >> 2] = 0.0;
   HEAP32[i2 + 92 >> 2] = 1065353216;
   HEAPF32[i2 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i2;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 13:
  {
   i2 = _malloc(252) | 0;
   HEAP32[i2 >> 2] = 13;
   HEAP32[i2 + 76 >> 2] = 0;
   HEAP32[i2 + 80 >> 2] = 0;
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 5;
   i4 = i2 + 8 | 0;
   HEAP32[i4 >> 2] = 32;
   i6 = i2 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i2 + 100 | 0;
   i8 = i2 + 108 | 0;
   HEAPF32[i8 >> 2] = .09817477315664291;
   i9 = i2 + 104 | 0;
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2 + 12 | 0;
   HEAPF32[i10 >> 2] = .09817477315664291;
   HEAPF32[i2 + 16 >> 2] = .19634954631328583;
   HEAPF32[i2 + 20 >> 2] = .39269909262657166;
   d5 = .09817477315664291;
   i1 = 3;
   while (1) {
    HEAPF32[i10 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    if (i1 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) break;
    d5 = +HEAPF32[i8 >> 2];
   }
   i10 = ((HEAP32[i2 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i7 >> 2] = (1.0 - 1.0 / +((HEAP32[i4 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i6 >> 2] = fb + 5;
   HEAP32[i2 + 240 >> 2] = fb + 6;
   HEAPF32[i2 + 84 >> 2] = 1.0;
   HEAPF32[i2 + 88 >> 2] = 0.0;
   HEAP32[i2 + 92 >> 2] = 1065353216;
   HEAPF32[i2 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i2;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 14:
  {
   i2 = _malloc(252) | 0;
   HEAP32[i2 >> 2] = 14;
   HEAP32[i2 + 76 >> 2] = 0;
   HEAP32[i2 + 80 >> 2] = 0;
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 6;
   i4 = i2 + 8 | 0;
   HEAP32[i4 >> 2] = 64;
   i6 = i2 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i2 + 100 | 0;
   i8 = i2 + 108 | 0;
   HEAPF32[i8 >> 2] = .04908738657832146;
   i9 = i2 + 104 | 0;
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2 + 12 | 0;
   HEAPF32[i10 >> 2] = .04908738657832146;
   HEAPF32[i2 + 16 >> 2] = .09817477315664291;
   HEAPF32[i2 + 20 >> 2] = .19634954631328583;
   d5 = .04908738657832146;
   i1 = 3;
   while (1) {
    HEAPF32[i10 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    if (i1 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) break;
    d5 = +HEAPF32[i8 >> 2];
   }
   i10 = ((HEAP32[i2 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i7 >> 2] = (1.0 - 1.0 / +((HEAP32[i4 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i6 >> 2] = fb + 5;
   HEAP32[i2 + 240 >> 2] = fb + 6;
   HEAPF32[i2 + 84 >> 2] = 1.0;
   HEAPF32[i2 + 88 >> 2] = 0.0;
   HEAP32[i2 + 92 >> 2] = 1065353216;
   HEAPF32[i2 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i2;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 15:
  {
   i2 = _malloc(252) | 0;
   HEAP32[i2 >> 2] = 15;
   HEAP32[i2 + 76 >> 2] = 0;
   HEAP32[i2 + 80 >> 2] = 0;
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 7;
   i4 = i2 + 8 | 0;
   HEAP32[i4 >> 2] = 128;
   i6 = i2 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i2 + 100 | 0;
   i8 = i2 + 108 | 0;
   HEAPF32[i8 >> 2] = .02454369328916073;
   i9 = i2 + 104 | 0;
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2 + 12 | 0;
   HEAPF32[i10 >> 2] = .02454369328916073;
   HEAPF32[i2 + 16 >> 2] = .04908738657832146;
   HEAPF32[i2 + 20 >> 2] = .09817477315664291;
   d5 = .02454369328916073;
   i1 = 3;
   while (1) {
    HEAPF32[i10 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    if (i1 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) break;
    d5 = +HEAPF32[i8 >> 2];
   }
   i10 = ((HEAP32[i2 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i7 >> 2] = (1.0 - 1.0 / +((HEAP32[i4 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i6 >> 2] = fb + 5;
   HEAP32[i2 + 240 >> 2] = fb + 6;
   HEAPF32[i2 + 84 >> 2] = 1.0;
   HEAPF32[i2 + 88 >> 2] = 0.0;
   HEAP32[i2 + 92 >> 2] = 1065353216;
   HEAPF32[i2 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i2;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 16:
  {
   i2 = _malloc(252) | 0;
   HEAP32[i2 >> 2] = 16;
   HEAP32[i2 + 76 >> 2] = 0;
   HEAP32[i2 + 80 >> 2] = 0;
   i3 = i2 + 4 | 0;
   HEAP32[i3 >> 2] = 8;
   i4 = i2 + 8 | 0;
   HEAP32[i4 >> 2] = 256;
   i6 = i2 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i2 + 100 | 0;
   i8 = i2 + 108 | 0;
   HEAPF32[i8 >> 2] = .012271846644580364;
   i9 = i2 + 104 | 0;
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2 + 12 | 0;
   HEAPF32[i10 >> 2] = .012271846644580364;
   HEAPF32[i2 + 16 >> 2] = .02454369328916073;
   HEAPF32[i2 + 20 >> 2] = .04908738657832146;
   d5 = .012271846644580364;
   i1 = 3;
   while (1) {
    HEAPF32[i10 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    if (i1 >>> 0 >= (HEAP32[i3 >> 2] | 0) >>> 0) break;
    d5 = +HEAPF32[i8 >> 2];
   }
   i10 = ((HEAP32[i2 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i7 >> 2] = (1.0 - 1.0 / +((HEAP32[i4 >> 2] | 0) >>> 0)) * 3.141592653589793;
   HEAP32[i6 >> 2] = fb + 5;
   HEAP32[i2 + 240 >> 2] = fb + 6;
   HEAPF32[i2 + 84 >> 2] = 1.0;
   HEAPF32[i2 + 88 >> 2] = 0.0;
   HEAP32[i2 + 92 >> 2] = 1065353216;
   HEAPF32[i2 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i2;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i9 >> 2] = 0.0;
   i10 = i2;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 17:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 1;
   HEAP32[i10 + 8 >> 2] = 2;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAPF32[i10 + 100 >> 2] = 1.0;
   HEAP32[i10 >> 2] = 17;
   HEAPF32[i10 + 12 >> 2] = 1.0;
   HEAP32[i9 >> 2] = fb + 7;
   HEAP32[i10 + 240 >> 2] = fb + 8;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   HEAPF32[i10 + 96 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 18:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 2;
   HEAP32[i1 + 8 >> 2] = 4;
   i10 = i1 + 236 | 0;
   HEAP32[i10 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 0;
   HEAP32[i10 + 8 >> 2] = 0;
   HEAP32[i10 + 12 >> 2] = 0;
   HEAPF32[i1 + 100 >> 2] = .4472135901451111;
   HEAP32[i1 >> 2] = 18;
   HEAPF32[i1 + 12 >> 2] = .4472135901451111;
   HEAPF32[i1 + 16 >> 2] = .8944271802902222;
   HEAP32[i10 >> 2] = fb + 7;
   HEAP32[i1 + 240 >> 2] = fb + 8;
   _modem_demodsoft_gentab(i1, 2);
   i10 = ((HEAP32[i1 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i1;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 19:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 3;
   HEAP32[i1 + 8 >> 2] = 8;
   i10 = i1 + 236 | 0;
   HEAP32[i10 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 0;
   HEAP32[i10 + 8 >> 2] = 0;
   HEAP32[i10 + 12 >> 2] = 0;
   HEAPF32[i1 + 100 >> 2] = .2182178944349289;
   HEAP32[i1 >> 2] = 19;
   HEAPF32[i1 + 12 >> 2] = .2182178944349289;
   HEAPF32[i1 + 16 >> 2] = .4364357888698578;
   HEAPF32[i1 + 20 >> 2] = .8728715777397156;
   HEAP32[i10 >> 2] = fb + 7;
   HEAP32[i1 + 240 >> 2] = fb + 8;
   _modem_demodsoft_gentab(i1, 2);
   i10 = ((HEAP32[i1 >> 2] | 0) + -9 | 0) >>> 0 < 8;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   if (!i10) {
    i10 = i1;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i1 + 104 >> 2] = 0.0;
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 20:
  {
   i3 = _malloc(252) | 0;
   HEAP32[i3 + 76 >> 2] = 0;
   HEAP32[i3 + 80 >> 2] = 0;
   i4 = i3 + 4 | 0;
   HEAP32[i4 >> 2] = 4;
   HEAP32[i3 + 8 >> 2] = 16;
   i6 = i3 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i3 + 100 | 0;
   HEAPF32[i7 >> 2] = .10846523195505142;
   HEAP32[i3 >> 2] = 20;
   i8 = i3 + 12 | 0;
   HEAPF32[i8 >> 2] = .10846523195505142;
   HEAPF32[i3 + 16 >> 2] = .21693046391010284;
   HEAPF32[i3 + 20 >> 2] = .4338609278202057;
   d5 = .10846523195505142;
   i1 = 3;
   while (1) {
    HEAPF32[i8 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 >= i2 >>> 0) break;
    d5 = +HEAPF32[i7 >> 2];
   }
   HEAP32[i6 >> 2] = fb + 7;
   HEAP32[i3 + 240 >> 2] = fb + 8;
   if ((i2 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i3, 2);
   HEAPF32[i3 + 84 >> 2] = 1.0;
   HEAPF32[i3 + 88 >> 2] = 0.0;
   HEAP32[i3 + 92 >> 2] = 1065353216;
   HEAPF32[i3 + 96 >> 2] = 0.0;
   if (((HEAP32[i3 >> 2] | 0) + -9 | 0) >>> 0 >= 8) {
    i10 = i3;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i3 + 104 >> 2] = 0.0;
   i10 = i3;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 21:
  {
   i3 = _malloc(252) | 0;
   HEAP32[i3 + 76 >> 2] = 0;
   HEAP32[i3 + 80 >> 2] = 0;
   i4 = i3 + 4 | 0;
   HEAP32[i4 >> 2] = 5;
   HEAP32[i3 + 8 >> 2] = 32;
   i6 = i3 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i3 + 100 | 0;
   HEAPF32[i7 >> 2] = .05415303632616997;
   HEAP32[i3 >> 2] = 21;
   i8 = i3 + 12 | 0;
   HEAPF32[i8 >> 2] = .05415303632616997;
   HEAPF32[i3 + 16 >> 2] = .10830607265233994;
   HEAPF32[i3 + 20 >> 2] = .21661214530467987;
   d5 = .05415303632616997;
   i1 = 3;
   while (1) {
    HEAPF32[i8 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 >= i2 >>> 0) break;
    d5 = +HEAPF32[i7 >> 2];
   }
   HEAP32[i6 >> 2] = fb + 7;
   HEAP32[i3 + 240 >> 2] = fb + 8;
   if ((i2 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i3, 2);
   HEAPF32[i3 + 84 >> 2] = 1.0;
   HEAPF32[i3 + 88 >> 2] = 0.0;
   HEAP32[i3 + 92 >> 2] = 1065353216;
   HEAPF32[i3 + 96 >> 2] = 0.0;
   if (((HEAP32[i3 >> 2] | 0) + -9 | 0) >>> 0 >= 8) {
    i10 = i3;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i3 + 104 >> 2] = 0.0;
   i10 = i3;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 22:
  {
   i3 = _malloc(252) | 0;
   HEAP32[i3 + 76 >> 2] = 0;
   HEAP32[i3 + 80 >> 2] = 0;
   i4 = i3 + 4 | 0;
   HEAP32[i4 >> 2] = 6;
   HEAP32[i3 + 8 >> 2] = 64;
   i6 = i3 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i3 + 100 | 0;
   HEAPF32[i7 >> 2] = .02706659771502018;
   HEAP32[i3 >> 2] = 22;
   i8 = i3 + 12 | 0;
   HEAPF32[i8 >> 2] = .02706659771502018;
   HEAPF32[i3 + 16 >> 2] = .05413319543004036;
   HEAPF32[i3 + 20 >> 2] = .10826639086008072;
   d5 = .02706659771502018;
   i1 = 3;
   while (1) {
    HEAPF32[i8 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 >= i2 >>> 0) break;
    d5 = +HEAPF32[i7 >> 2];
   }
   HEAP32[i6 >> 2] = fb + 7;
   HEAP32[i3 + 240 >> 2] = fb + 8;
   if ((i2 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i3, 2);
   HEAPF32[i3 + 84 >> 2] = 1.0;
   HEAPF32[i3 + 88 >> 2] = 0.0;
   HEAP32[i3 + 92 >> 2] = 1065353216;
   HEAPF32[i3 + 96 >> 2] = 0.0;
   if (((HEAP32[i3 >> 2] | 0) + -9 | 0) >>> 0 >= 8) {
    i10 = i3;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i3 + 104 >> 2] = 0.0;
   i10 = i3;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 23:
  {
   i3 = _malloc(252) | 0;
   HEAP32[i3 + 76 >> 2] = 0;
   HEAP32[i3 + 80 >> 2] = 0;
   i4 = i3 + 4 | 0;
   HEAP32[i4 >> 2] = 7;
   HEAP32[i3 + 8 >> 2] = 128;
   i6 = i3 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i3 + 100 | 0;
   HEAPF32[i7 >> 2] = .013532060198485851;
   HEAP32[i3 >> 2] = 23;
   i8 = i3 + 12 | 0;
   HEAPF32[i8 >> 2] = .013532060198485851;
   HEAPF32[i3 + 16 >> 2] = .027064120396971703;
   HEAPF32[i3 + 20 >> 2] = .054128240793943405;
   d5 = .013532060198485851;
   i1 = 3;
   while (1) {
    HEAPF32[i8 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 >= i2 >>> 0) break;
    d5 = +HEAPF32[i7 >> 2];
   }
   HEAP32[i6 >> 2] = fb + 7;
   HEAP32[i3 + 240 >> 2] = fb + 8;
   if ((i2 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i3, 2);
   HEAPF32[i3 + 84 >> 2] = 1.0;
   HEAPF32[i3 + 88 >> 2] = 0.0;
   HEAP32[i3 + 92 >> 2] = 1065353216;
   HEAPF32[i3 + 96 >> 2] = 0.0;
   if (((HEAP32[i3 >> 2] | 0) + -9 | 0) >>> 0 >= 8) {
    i10 = i3;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i3 + 104 >> 2] = 0.0;
   i10 = i3;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 24:
  {
   i3 = _malloc(252) | 0;
   HEAP32[i3 + 76 >> 2] = 0;
   HEAP32[i3 + 80 >> 2] = 0;
   i4 = i3 + 4 | 0;
   HEAP32[i4 >> 2] = 8;
   HEAP32[i3 + 8 >> 2] = 256;
   i6 = i3 + 236 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   i7 = i3 + 100 | 0;
   HEAPF32[i7 >> 2] = .006765875034034252;
   HEAP32[i3 >> 2] = 24;
   i8 = i3 + 12 | 0;
   HEAPF32[i8 >> 2] = .006765875034034252;
   HEAPF32[i3 + 16 >> 2] = .013531750068068504;
   HEAPF32[i3 + 20 >> 2] = .02706350013613701;
   d5 = .006765875034034252;
   i1 = 3;
   while (1) {
    HEAPF32[i8 + (i1 << 2) >> 2] = d5 * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
    i2 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 >= i2 >>> 0) break;
    d5 = +HEAPF32[i7 >> 2];
   }
   HEAP32[i6 >> 2] = fb + 7;
   HEAP32[i3 + 240 >> 2] = fb + 8;
   if ((i2 + -2 | 0) >>> 0 < 6) _modem_demodsoft_gentab(i3, 2);
   HEAPF32[i3 + 84 >> 2] = 1.0;
   HEAPF32[i3 + 88 >> 2] = 0.0;
   HEAP32[i3 + 92 >> 2] = 1065353216;
   HEAPF32[i3 + 96 >> 2] = 0.0;
   if (((HEAP32[i3 >> 2] | 0) + -9 | 0) >>> 0 >= 8) {
    i10 = i3;
    STACKTOP = i11;
    return i10 | 0;
   }
   HEAPF32[i3 + 104 >> 2] = 0.0;
   i10 = i3;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 25:
  {
   i10 = _modem_create_qam(2) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 26:
  {
   i10 = _modem_create_qam(3) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 27:
  {
   i10 = _modem_create_qam(4) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 28:
  {
   i10 = _modem_create_qam(5) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 29:
  {
   i10 = _modem_create_qam(6) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 30:
  {
   i10 = _modem_create_qam(7) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 31:
  {
   i10 = _modem_create_qam(8) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 32:
  {
   i10 = _modem_create_qam(9) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 33:
  {
   i10 = _modem_create_qam(10) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 34:
  {
   i10 = _modem_create_qam(11) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 35:
  {
   i10 = _modem_create_qam(12) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 36:
  {
   i10 = _modem_create_qam(13) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 37:
  {
   i10 = _modem_create_qam(14) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 38:
  {
   i10 = _modem_create_qam(15) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 39:
  {
   i10 = _modem_create_qam(16) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 40:
  {
   i10 = _modem_create_apsk(2) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 41:
  {
   i10 = _modem_create_apsk(3) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 42:
  {
   i10 = _modem_create_apsk(4) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 43:
  {
   i10 = _modem_create_apsk(5) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 44:
  {
   i10 = _modem_create_apsk(6) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 45:
  {
   i10 = _modem_create_apsk(7) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 46:
  {
   i10 = _modem_create_apsk(8) | 0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 47:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 47;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 1;
   HEAP32[i10 + 8 >> 2] = 2;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 >> 2] = fb + 3;
   HEAP32[i10 + 240 >> 2] = fb + 4;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   HEAPF32[i10 + 96 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 48:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 48;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 2;
   HEAP32[i10 + 8 >> 2] = 4;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 >> 2] = fb + 1;
   HEAP32[i10 + 240 >> 2] = fb + 2;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   HEAPF32[i10 + 96 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 49:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 49;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 1;
   HEAP32[i10 + 8 >> 2] = 2;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 >> 2] = fb + 9;
   HEAP32[i10 + 240 >> 2] = fb + 10;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   HEAPF32[i10 + 96 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 50:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 50;
   HEAP32[i1 + 76 >> 2] = 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 5;
   HEAP32[i1 + 8 >> 2] = 32;
   i2 = i1 + 236 | 0;
   HEAP32[i2 >> 2] = 0;
   HEAP32[i2 + 4 >> 2] = 0;
   HEAP32[i2 + 8 >> 2] = 0;
   HEAP32[i2 + 12 >> 2] = 0;
   i6 = _malloc(64) | 0;
   HEAP32[i1 + 100 >> 2] = i6;
   i3 = gb + 1936 | 0;
   i7 = i6 + 64 | 0;
   do {
    HEAP32[i6 >> 2] = HEAP32[i3 >> 2];
    i6 = i6 + 4 | 0;
    i3 = i3 + 4 | 0;
   } while ((i6 | 0) < (i7 | 0));
   HEAP32[i2 >> 2] = fb + 11;
   HEAP32[i1 + 240 >> 2] = fb + 12;
   HEAPF32[i1 + 84 >> 2] = 1.0;
   HEAPF32[i1 + 88 >> 2] = 0.0;
   HEAP32[i1 + 92 >> 2] = 1065353216;
   HEAPF32[i1 + 96 >> 2] = 0.0;
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 51:
  {
   i10 = _malloc(252) | 0;
   HEAP32[i10 >> 2] = 51;
   HEAP32[i10 + 76 >> 2] = 0;
   HEAP32[i10 + 80 >> 2] = 0;
   HEAP32[i10 + 4 >> 2] = 7;
   HEAP32[i10 + 8 >> 2] = 128;
   i9 = i10 + 236 | 0;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 8 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   i8 = _malloc(256) | 0;
   HEAP32[i10 + 100 >> 2] = i8;
   _memcpy(i8 | 0, gb + 2e3 | 0, 256) | 0;
   HEAP32[i9 >> 2] = fb + 13;
   HEAP32[i10 + 240 >> 2] = fb + 14;
   HEAPF32[i10 + 84 >> 2] = 1.0;
   HEAPF32[i10 + 88 >> 2] = 0.0;
   HEAP32[i10 + 92 >> 2] = 1065353216;
   HEAPF32[i10 + 96 >> 2] = 0.0;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 52:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 4;
   HEAP32[i1 + 8 >> 2] = 16;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(128) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) {
    i6 = i4;
    i7 = i6 + 128 | 0;
    do {
     HEAP8[i6 >> 0] = 0;
     i6 = i6 + 1 | 0;
    } while ((i6 | 0) < (i7 | 0));
   }
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 2256 | 0, 16);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 53:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 4;
   HEAP32[i1 + 8 >> 2] = 16;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(128) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) {
    i6 = i4;
    i7 = i6 + 128 | 0;
    do {
     HEAP8[i6 >> 0] = 0;
     i6 = i6 + 1 | 0;
    } while ((i6 | 0) < (i7 | 0));
   }
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 2896 | 0, 16);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 54:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 5;
   HEAP32[i1 + 8 >> 2] = 32;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(256) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) _memset(i4 | 0, 0, 256) | 0;
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 3024 | 0, 32);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 55:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 6;
   HEAP32[i1 + 8 >> 2] = 64;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(512) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) _memset(i4 | 0, 0, 512) | 0;
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 3280 | 0, 64);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 56:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 7;
   HEAP32[i1 + 8 >> 2] = 128;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(1024) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) _memset(i4 | 0, 0, 1024) | 0;
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 3792 | 0, 128);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 57:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 8;
   HEAP32[i1 + 8 >> 2] = 256;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(2048) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) _memset(i4 | 0, 0, 2048) | 0;
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 4816 | 0, 256);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 58:
  {
   i1 = _malloc(252) | 0;
   HEAP32[i1 >> 2] = 59;
   i2 = i1 + 76 | 0;
   HEAP32[i1 + 80 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 6;
   HEAP32[i1 + 8 >> 2] = 64;
   i3 = i1 + 236 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   i4 = _malloc(512) | 0;
   if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) _memset(i4 | 0, 0, 512) | 0;
   HEAP32[i2 >> 2] = i4;
   HEAP32[i3 >> 2] = fb + 15;
   HEAP32[i1 + 240 >> 2] = fb + 16;
   _modem_arb_init(i1, gb + 2384 | 0, 64);
   i10 = i1;
   STACKTOP = i11;
   return i10 | 0;
  }
 case 59:
  {
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i4 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i4;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i4 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i4 - i1 | 0) >>> 0 < 105) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29484 | 0, 105) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29484 | 0, 105) | 0) >>> 0 < 105) _exit(1); else {
    i6 = 0;
    i7 = gb + 29484 + 105 | 0;
    i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i6 = 105;
    i7 = gb + 29484 | 0;
    i8 = i1;
   } while (0);
   _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
   _exit(1);
   break;
  }
 default:
  {
   HEAP32[i3 >> 2] = i2;
   _fprintf(gb + 8728 | 0, gb + 29590 | 0, i3);
   _exit(1);
  }
 } while (0);
 return 0;
}

function _quiet_encoder_emit(i56, i1, i57) {
 i56 = i56 | 0;
 i1 = i1 | 0;
 i57 = i57 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, d23 = 0.0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, i74 = 0, i75 = 0, d76 = 0.0, d77 = 0.0, d78 = 0.0, i79 = 0, i80 = 0;
 i60 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i58 = i60 + 4 | 0;
 i59 = i60;
 if ((i56 | 0) == 0 | (i57 | 0) == 0) {
  i75 = 0;
  STACKTOP = i60;
  return i75 | 0;
 }
 i36 = i56 + 124 | 0;
 i42 = i56 + 128 | 0;
 i43 = i56 + 60 | 0;
 i46 = i56 + 92 | 0;
 i47 = i56 + 136 | 0;
 i50 = i56 + 140 | 0;
 i54 = i56 + 104 | 0;
 i55 = i56 + 116 | 0;
 i26 = i56 + 152 | 0;
 i27 = i56 + 44 | 0;
 i28 = i56 + 80 | 0;
 i29 = i56 + 132 | 0;
 i30 = i56 + 96 | 0;
 i31 = i56 + 96 | 0;
 i32 = i56 + 100 | 0;
 i33 = i56 + 64 | 0;
 i34 = i56 + 68 | 0;
 i35 = i56 + 72 | 0;
 i37 = i56 + 148 | 0;
 i38 = i56 + 120 | 0;
 i39 = i56 + 108 | 0;
 i40 = i56 + 4 | 0;
 i41 = i56 + 112 | 0;
 i25 = i1;
 i2 = HEAP32[i36 >> 2] | 0;
 i1 = 0;
 L4 : while (1) {
  i24 = i57 - i1 | 0;
  i22 = (i1 | 0) != 0;
  d23 = +(i24 >>> 0);
  L6 : do if (!i2) while (1) {
   HEAP32[i42 >> 2] = 0;
   i5 = HEAP32[i43 >> 2] | 0;
   switch (i5 | 0) {
   case 0:
    {
     i6 = HEAP32[i30 >> 2] | 0;
     i2 = i6 + 124 | 0;
     i14 = i6;
     i21 = 12;
     break;
    }
   case 1:
    {
     i6 = HEAP32[i31 >> 2] | 0;
     i2 = i6 + 112 | 0;
     i14 = i6;
     i21 = 12;
     break;
    }
   case 2:
    {
     i6 = HEAP32[i30 >> 2] | 0;
     i2 = i6 + 88 | 0;
     i14 = i6;
     i21 = 12;
     break;
    }
   default:
    i21 = 13;
   }
   if ((i21 | 0) == 12) {
    i21 = 0;
    if (!(HEAP32[i2 >> 2] | 0)) i21 = 13; else {
     i4 = ~~+Math_ceil(+(d23 / +HEAPF32[i37 >> 2])) >>> 0;
     i2 = HEAP32[i54 >> 2] | 0;
     if (!i2) {
      i2 = 0;
      i3 = 0;
     } else {
      i3 = HEAP32[i2 >> 2] | 0;
      i2 = (i4 >>> 0) / (i3 >>> 0) | 0;
     }
     i2 = (((i4 >>> 0) % (i3 >>> 0) | 0 | 0) != 0 & 1) + i2 | 0;
     L19 : do switch (i5 | 0) {
     case 0:
      {
       i12 = HEAP32[i39 >> 2] | 0;
       L21 : do if (HEAP32[i14 + 124 >> 2] | 0) {
        i13 = i14 + 116 | 0;
        HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + 1;
        i11 = i14 + 120 | 0;
        switch (HEAP32[i11 >> 2] | 0) {
        case 0:
         {
          i7 = HEAP32[i14 + 40 >> 2] | 0;
          i3 = HEAP32[i7 >> 2] | 0;
          i5 = i7 + 4 | 0;
          i2 = HEAP32[i5 >> 2] | 0;
          if ((i2 | 0) != (0 - i3 | 0)) {
           i6 = i7 + 64 | 0;
           i4 = 0;
           do {
            i19 = ((i3 - (i2 << 1) + i4 | 0) >>> 0) % (i3 >>> 0) | 0;
            i18 = HEAP32[i6 >> 2] | 0;
            i20 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
            HEAP32[i12 + (i4 << 3) >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
            HEAP32[i12 + (i4 << 3) + 4 >> 2] = i20;
            i4 = i4 + 1 | 0;
            i3 = HEAP32[i7 >> 2] | 0;
            i2 = HEAP32[i5 >> 2] | 0;
           } while (i4 >>> 0 < (i2 + i3 | 0) >>> 0);
          }
          i4 = i7 + 12 | 0;
          if (HEAP32[i4 >> 2] | 0) {
           i2 = i7 + 16 | 0;
           i3 = 0;
           do {
            d77 = +HEAPF32[(HEAP32[i2 >> 2] | 0) + (i3 << 2) >> 2];
            i19 = i12 + (i3 << 3) | 0;
            i20 = i12 + (i3 << 3) + 4 | 0;
            d76 = d77 * +HEAPF32[i20 >> 2];
            HEAPF32[i19 >> 2] = d77 * +HEAPF32[i19 >> 2];
            HEAPF32[i20 >> 2] = d76;
            i3 = i3 + 1 | 0;
           } while (i3 >>> 0 < (HEAP32[i4 >> 2] | 0) >>> 0);
          }
          HEAP32[i11 >> 2] = 1;
          break;
         }
        case 1:
         {
          i6 = HEAP32[i14 + 40 >> 2] | 0;
          i2 = HEAP32[i6 >> 2] | 0;
          i7 = i6 + 4 | 0;
          i3 = HEAP32[i7 >> 2] | 0;
          i5 = i6 + 64 | 0;
          if ((i3 | 0) != (0 - i2 | 0)) {
           i4 = 0;
           do {
            i19 = ((i2 - i3 + i4 | 0) >>> 0) % (i2 >>> 0) | 0;
            i18 = HEAP32[i5 >> 2] | 0;
            i20 = HEAP32[i18 + (i19 << 3) + 4 >> 2] | 0;
            HEAP32[i12 + (i4 << 3) >> 2] = HEAP32[i18 + (i19 << 3) >> 2];
            HEAP32[i12 + (i4 << 3) + 4 >> 2] = i20;
            i4 = i4 + 1 | 0;
            i2 = HEAP32[i6 >> 2] | 0;
            i3 = HEAP32[i7 >> 2] | 0;
           } while (i4 >>> 0 < (i3 + i2 | 0) >>> 0);
          }
          _memmove(HEAP32[i6 + 20 >> 2] | 0, HEAP32[i5 >> 2] | 0, HEAP32[i6 + 12 >> 2] << 3 | 0) | 0;
          HEAP32[i11 >> 2] = 2;
          break;
         }
        case 2:
         {
          i2 = HEAP32[i14 + 40 >> 2] | 0;
          i7 = i2 + 56 | 0;
          _memmove(HEAP32[i7 >> 2] | 0, HEAP32[i2 + 72 >> 2] | 0, HEAP32[i2 >> 2] << 3 | 0) | 0;
          i5 = i2 + 4 | 0;
          i20 = HEAP32[i5 >> 2] | 0;
          _memmove(i12 | 0, (HEAP32[i7 >> 2] | 0) + ((HEAP32[i2 >> 2] | 0) - i20 << 3) | 0, i20 << 3 | 0) | 0;
          _memmove(i12 + (HEAP32[i5 >> 2] << 3) | 0, HEAP32[i7 >> 2] | 0, HEAP32[i2 >> 2] << 3 | 0) | 0;
          i5 = i2 + 12 | 0;
          if (!(HEAP32[i5 >> 2] | 0)) {
           i3 = 0;
           i2 = i2 + 20 | 0;
          } else {
           i6 = i2 + 16 | 0;
           i2 = i2 + 20 | 0;
           i4 = 0;
           do {
            d77 = +HEAPF32[(HEAP32[i6 >> 2] | 0) + (i4 << 2) >> 2];
            i20 = i12 + (i4 << 3) | 0;
            i3 = i12 + (i4 << 3) + 4 | 0;
            d78 = d77 * +HEAPF32[i20 >> 2];
            d77 = d77 * +HEAPF32[i3 >> 2];
            HEAPF32[i20 >> 2] = d78;
            HEAPF32[i3 >> 2] = d77;
            i19 = HEAP32[i2 >> 2] | 0;
            d76 = +HEAPF32[(HEAP32[i6 >> 2] | 0) + ((HEAP32[i5 >> 2] | 0) + ~i4 << 2) >> 2];
            d77 = d77 + +HEAPF32[i19 + (i4 << 3) + 4 >> 2] * d76;
            HEAPF32[i20 >> 2] = d78 + +HEAPF32[i19 + (i4 << 3) >> 2] * d76;
            HEAPF32[i3 >> 2] = d77;
            i4 = i4 + 1 | 0;
            i3 = HEAP32[i5 >> 2] | 0;
           } while (i4 >>> 0 < i3 >>> 0);
           i3 = i3 << 3;
          }
          _memmove(HEAP32[i2 >> 2] | 0, HEAP32[i7 >> 2] | 0, i3 | 0) | 0;
          HEAP32[i13 >> 2] = 0;
          HEAP32[i11 >> 2] = 3;
          break;
         }
        case 3:
         {
          if (!(HEAP32[i14 >> 2] | 0)) i2 = i14 + 36 | 0; else {
           i3 = i14 + 12 | 0;
           i4 = i14 + 132 | 0;
           i5 = i14 + 84 | 0;
           i6 = i14 + 52 | 0;
           i7 = i14 + 68 | 0;
           i2 = i14 + 36 | 0;
           i10 = 0;
           do {
            do if ((HEAP8[(HEAP32[i3 >> 2] | 0) + i10 >> 0] | 0) == 2) {
             i8 = HEAP32[i4 >> 2] | 0;
             i9 = HEAP32[i6 >> 2] | 0;
             if (i8 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0) {
              HEAP32[i4 >> 2] = i8 + 1;
              _modem_modulate(i9, HEAPU8[(HEAP32[i7 >> 2] | 0) + i8 >> 0] | 0, (HEAP32[i2 >> 2] | 0) + (i10 << 3) | 0);
              break;
             } else {
              i19 = gb + 41248 | 0;
              i19 = ___muldi3(HEAP32[i19 >> 2] | 0, HEAP32[i19 + 4 >> 2] | 0, 1284865837, 1481765933) | 0;
              i19 = _i64Add(i19 | 0, getTempRet0() | 0, 1, 0) | 0;
              i20 = getTempRet0() | 0;
              i18 = gb + 41248 | 0;
              HEAP32[i18 >> 2] = i19;
              HEAP32[i18 + 4 >> 2] = i20;
              i20 = _bitshift64Lshr(i19 | 0, i20 | 0, 33) | 0;
              getTempRet0() | 0;
              _modem_modulate(i9, (i20 >>> 0) % ((HEAP32[i9 + 8 >> 2] | 0) >>> 0) | 0, (HEAP32[i2 >> 2] | 0) + (i10 << 3) | 0);
              break;
             }
            } else {
             i20 = HEAP32[i2 >> 2] | 0;
             HEAPF32[i20 + (i10 << 3) >> 2] = 0.0;
             HEAPF32[i20 + (i10 << 3) + 4 >> 2] = 0.0;
            } while (0);
            i10 = i10 + 1 | 0;
           } while (i10 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0);
          }
          _ofdmframegen_writesymbol(HEAP32[i14 + 40 >> 2] | 0, HEAP32[i2 >> 2] | 0, i12);
          if ((HEAP32[i13 >> 2] | 0) == (HEAP32[i14 + 44 >> 2] | 0)) {
           HEAP32[i13 >> 2] = 0;
           HEAP32[i11 >> 2] = 4;
          }
          break;
         }
        case 4:
         {
          if (!(HEAP32[i14 >> 2] | 0)) i2 = i14 + 36 | 0; else {
           i3 = i14 + 12 | 0;
           i4 = i14 + 136 | 0;
           i5 = i14 + 112 | 0;
           i6 = i14 + 96 | 0;
           i7 = i14 + 104 | 0;
           i2 = i14 + 36 | 0;
           i10 = 0;
           do {
            do if ((HEAP8[(HEAP32[i3 >> 2] | 0) + i10 >> 0] | 0) == 2) {
             i8 = HEAP32[i4 >> 2] | 0;
             i9 = HEAP32[i6 >> 2] | 0;
             if (i8 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0) {
              HEAP32[i4 >> 2] = i8 + 1;
              _modem_modulate(i9, HEAP32[(HEAP32[i7 >> 2] | 0) + (i8 << 2) >> 2] | 0, (HEAP32[i2 >> 2] | 0) + (i10 << 3) | 0);
              break;
             } else {
              i19 = gb + 41248 | 0;
              i19 = ___muldi3(HEAP32[i19 >> 2] | 0, HEAP32[i19 + 4 >> 2] | 0, 1284865837, 1481765933) | 0;
              i19 = _i64Add(i19 | 0, getTempRet0() | 0, 1, 0) | 0;
              i20 = getTempRet0() | 0;
              i18 = gb + 41248 | 0;
              HEAP32[i18 >> 2] = i19;
              HEAP32[i18 + 4 >> 2] = i20;
              i20 = _bitshift64Lshr(i19 | 0, i20 | 0, 33) | 0;
              getTempRet0() | 0;
              _modem_modulate(i9, (i20 >>> 0) % ((HEAP32[i9 + 8 >> 2] | 0) >>> 0) | 0, (HEAP32[i2 >> 2] | 0) + (i10 << 3) | 0);
              break;
             }
            } else {
             i20 = HEAP32[i2 >> 2] | 0;
             HEAPF32[i20 + (i10 << 3) >> 2] = 0.0;
             HEAPF32[i20 + (i10 << 3) + 4 >> 2] = 0.0;
            } while (0);
            i10 = i10 + 1 | 0;
           } while (i10 >>> 0 < (HEAP32[i14 >> 2] | 0) >>> 0);
          }
          _ofdmframegen_writesymbol(HEAP32[i14 + 40 >> 2] | 0, HEAP32[i2 >> 2] | 0, i12);
          if ((HEAP32[i13 >> 2] | 0) == (HEAP32[i14 + 48 >> 2] | 0)) HEAP32[i14 + 128 >> 2] = 1;
          break;
         }
        default:
         {
          i21 = 83;
          break L4;
         }
        }
        if (HEAP32[i14 + 128 >> 2] | 0 ? (HEAP32[i13 >> 2] = 0, HEAP32[i13 + 4 >> 2] = 0, HEAP32[i13 + 8 >> 2] = 0, HEAP32[i13 + 12 >> 2] = 0, HEAP32[i13 + 16 >> 2] = 0, HEAP32[i13 + 20 >> 2] = 0, i44 = HEAP32[i14 + 40 >> 2] | 0, i45 = HEAP32[i44 + 76 >> 2] | 0, HEAP32[i45 + 16 >> 2] = HEAP32[i45 + 8 >> 2], i45 = i44 + 12 | 0, HEAP32[i45 >> 2] | 0) : 0) {
         i2 = i44 + 20 | 0;
         i3 = 0;
         do {
          i20 = HEAP32[i2 >> 2] | 0;
          HEAPF32[i20 + (i3 << 3) >> 2] = 0.0;
          HEAPF32[i20 + (i3 << 3) + 4 >> 2] = 0.0;
          i3 = i3 + 1 | 0;
         } while (i3 >>> 0 < (HEAP32[i45 >> 2] | 0) >>> 0);
        }
       } else {
        i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
        do if (!i2) {
         i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
         HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
         i2 = HEAP32[gb + 8728 >> 2] | 0;
         if (!(i2 & 8)) {
          HEAP32[gb + 8728 + 8 >> 2] = 0;
          HEAP32[gb + 8728 + 4 >> 2] = 0;
          i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
          HEAP32[gb + 8728 + 28 >> 2] = i3;
          HEAP32[gb + 8728 + 20 >> 2] = i3;
          i2 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
          HEAP32[gb + 8728 + 16 >> 2] = i2;
          break;
         } else {
          HEAP32[gb + 8728 >> 2] = i2 | 32;
          break L21;
         }
        } else i3 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
        if ((i2 - i3 | 0) >>> 0 < 61) {
         mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26373 | 0, 61) | 0;
         break;
        }
        if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
         if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26373 | 0, 61) | 0) >>> 0 < 61) break;
         i2 = 0;
         i4 = gb + 26373 + 61 | 0;
         i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
        } else {
         i2 = 61;
         i4 = gb + 26373 | 0;
        }
        _memcpy(i3 | 0, i4 | 0, i2 | 0) | 0;
        HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
       } while (0);
       i2 = (HEAP32[i40 >> 2] | 0) + (HEAP32[i56 >> 2] | 0) | 0;
       break;
      }
     case 1:
      {
       i20 = HEAP32[i32 >> 2] | 0;
       i2 = i20 >>> 0 < i2 >>> 0 ? i20 : i2;
       if (i2 >>> 0 > (HEAP32[i41 >> 2] | 0) >>> 0) {
        i19 = _realloc(HEAP32[i39 >> 2] | 0, i2 << 3) | 0;
        HEAP32[i39 >> 2] = i19;
        HEAP32[i41 >> 2] = i2;
        i6 = HEAP32[i31 >> 2] | 0;
       } else i19 = HEAP32[i39 >> 2] | 0;
       if (i2 | 0) {
        i5 = i6 + 108 | 0;
        i7 = i6 + 12 | 0;
        i8 = i6 + 16 | 0;
        i9 = i6 + 112 | 0;
        i10 = i6 + 120 | 0;
        i11 = i6 + 104 | 0;
        i12 = i6 + 48 | 0;
        i13 = i6 + 84 | 0;
        i14 = i6 + 80 | 0;
        i15 = i6 + 100 | 0;
        i16 = i6 + 96 | 0;
        i17 = i6 + 4 | 0;
        i18 = i6 + 116 | 0;
        i3 = HEAP32[i5 >> 2] | 0;
        i20 = 0;
        do {
         if (!i3) {
          L110 : do if (!(HEAP32[i9 >> 2] | 0)) {
           i4 = 0;
           i3 = 0;
          } else switch (HEAP32[i10 >> 2] | 0) {
          case 0:
           {
            i3 = HEAP32[i11 >> 2] | 0;
            i79 = i3 + 1 | 0;
            HEAP32[i11 >> 2] = i79;
            i80 = HEAP32[i12 >> 2] | 0;
            i4 = HEAP32[i80 + (i3 << 3) >> 2] | 0;
            i3 = HEAP32[i80 + (i3 << 3) + 4 >> 2] | 0;
            if ((i79 | 0) != 64) break L110;
            HEAP32[i11 >> 2] = 0;
            HEAP32[i10 >> 2] = 1;
            break L110;
           }
          case 1:
           {
            i3 = HEAP32[i11 >> 2] | 0;
            i80 = i3 + 1 | 0;
            HEAP32[i11 >> 2] = i80;
            i79 = HEAP32[i13 >> 2] | 0;
            i4 = HEAP32[i79 + (i3 << 3) >> 2] | 0;
            i3 = HEAP32[i79 + (i3 << 3) + 4 >> 2] | 0;
            if ((i80 | 0) != (HEAP32[i14 >> 2] | 0)) break L110;
            HEAP32[i11 >> 2] = 0;
            HEAP32[i10 >> 2] = 2;
            break L110;
           }
          case 2:
           {
            i3 = HEAP32[i11 >> 2] | 0;
            i80 = i3 + 1 | 0;
            HEAP32[i11 >> 2] = i80;
            i79 = HEAP32[i15 >> 2] | 0;
            i4 = HEAP32[i79 + (i3 << 3) >> 2] | 0;
            i3 = HEAP32[i79 + (i3 << 3) + 4 >> 2] | 0;
            if ((i80 | 0) != (HEAP32[i16 >> 2] | 0)) break L110;
            HEAP32[i11 >> 2] = 0;
            HEAP32[i10 >> 2] = 3;
            break L110;
           }
          case 3:
           {
            i80 = (HEAP32[i11 >> 2] | 0) + 1 | 0;
            HEAP32[i11 >> 2] = i80;
            if ((i80 | 0) != (HEAP32[i17 >> 2] << 1 | 0)) {
             i4 = 0;
             i3 = 0;
             break L110;
            }
            HEAP32[i11 >> 2] = 0;
            HEAP32[i18 >> 2] = 1;
            HEAP32[i9 >> 2] = 0;
            i4 = 0;
            i3 = 0;
            break L110;
           }
          default:
           {
            i21 = 116;
            break L4;
           }
          } while (0);
          d78 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
          _firinterp_crcf_execute(HEAP32[i7 >> 2] | 0, d78, (HEAP32[tempDoublePtr >> 2] = i3, +HEAPF32[tempDoublePtr >> 2]), i8);
          i3 = HEAP32[i5 >> 2] | 0;
         }
         i80 = HEAP32[i6 + 16 + (i3 << 3) + 4 >> 2] | 0;
         HEAP32[i19 + (i20 << 3) >> 2] = HEAP32[i6 + 16 + (i3 << 3) >> 2];
         HEAP32[i19 + (i20 << 3) + 4 >> 2] = i80;
         i3 = (((HEAP32[i5 >> 2] | 0) + 1 | 0) >>> 0) % ((HEAP32[i6 >> 2] | 0) >>> 0) | 0;
         HEAP32[i5 >> 2] = i3;
         i20 = i20 + 1 | 0;
        } while ((i20 | 0) != (i2 | 0));
       }
       HEAP32[i32 >> 2] = (HEAP32[i32 >> 2] | 0) - i2;
       break;
      }
     case 2:
      {
       i80 = HEAP32[i32 >> 2] | 0;
       i13 = (i2 >>> 0) % (i80 >>> 0) | 0;
       i13 = ((i13 | 0) == 0 ? 0 : i80 - i13 | 0) + i2 | 0;
       if (i13 >>> 0 > (HEAP32[i41 >> 2] | 0) >>> 0) {
        HEAP32[i39 >> 2] = _realloc(HEAP32[i39 >> 2] | 0, i13 << 3) | 0;
        HEAP32[i41 >> 2] = i13;
       }
       if (!i13) i2 = 0; else {
        i2 = 0;
        while (1) {
         i11 = HEAP32[i30 >> 2] | 0;
         i10 = (HEAP32[i39 >> 2] | 0) + (i2 << 3) | 0;
         i12 = i11 + 84 | 0;
         switch (HEAP32[i12 >> 2] | 0) {
         case 0:
          {
           i8 = i11 + 32 | 0;
           i7 = HEAP32[i8 >> 2] | 0;
           i3 = i7 + 16 | 0;
           i5 = HEAP32[i3 >> 2] | 0;
           i9 = HEAP32[i7 + 4 >> 2] & i5;
           i9 = (HEAPU8[(i9 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i9 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i9 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i9 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
           HEAP32[i7 + 20 >> 2] = i9;
           HEAP32[i3 >> 2] = (i9 | i5 << 1) & HEAP32[i7 + 12 >> 2];
           _gmskmod_modulate(HEAP32[i11 >> 2] | 0, i9, i10);
           i9 = i11 + 96 | 0;
           i3 = HEAP32[i9 >> 2] | 0;
           i7 = i11 + 8 | 0;
           i5 = HEAP32[i7 >> 2] | 0;
           L132 : do if (i3 >>> 0 < i5 >>> 0 ? (i48 = i11 + 4 | 0, i49 = HEAP32[i48 >> 2] | 0, (i49 | 0) != 0) : 0) {
            i4 = i49;
            i6 = 0;
            while (1) {
             d77 = .53836 - +Math_cos(+(+(((Math_imul(i4, i3) | 0) + i6 | 0) >>> 0) * 6.283185307179586 / +(((Math_imul(i5 << 1, i4) | 0) + -1 | 0) >>> 0))) * .46164;
             i3 = i10 + (i6 << 3) | 0;
             i4 = i10 + (i6 << 3) + 4 | 0;
             d78 = +HEAPF32[i4 >> 2] * d77;
             HEAPF32[i3 >> 2] = +HEAPF32[i3 >> 2] * d77;
             HEAPF32[i4 >> 2] = d78;
             i6 = i6 + 1 | 0;
             i4 = HEAP32[i48 >> 2] | 0;
             i3 = HEAP32[i9 >> 2] | 0;
             if (i6 >>> 0 >= i4 >>> 0) break L132;
             i5 = HEAP32[i7 >> 2] | 0;
            }
           } while (0);
           i80 = i3 + 1 | 0;
           HEAP32[i9 >> 2] = i80;
           if ((i80 | 0) == (HEAP32[i11 + 16 >> 2] | 0)) {
            i80 = HEAP32[i8 >> 2] | 0;
            HEAP32[i80 + 16 >> 2] = HEAP32[i80 + 8 >> 2];
            HEAP32[i9 >> 2] = 0;
            HEAP32[i12 >> 2] = 1;
           }
           break;
          }
         case 1:
          {
           i3 = i11 + 96 | 0;
           i80 = HEAP32[i3 >> 2] | 0;
           _gmskmod_modulate(HEAP32[i11 >> 2] | 0, (HEAPU8[(HEAP32[i11 + 48 >> 2] | 0) + ((i80 | 0) / 8 | 0) >> 0] | 0) >>> (7 - ((i80 | 0) % 8 | 0) | 0) & 1, i10);
           i80 = (HEAP32[i3 >> 2] | 0) + 1 | 0;
           HEAP32[i3 >> 2] = i80;
           if ((i80 | 0) == (HEAP32[i11 + 20 >> 2] | 0)) {
            HEAP32[i3 >> 2] = 0;
            HEAP32[i12 >> 2] = 2;
           }
           break;
          }
         case 2:
          {
           i3 = i11 + 96 | 0;
           i80 = HEAP32[i3 >> 2] | 0;
           _gmskmod_modulate(HEAP32[i11 >> 2] | 0, (HEAPU8[(HEAP32[i11 + 80 >> 2] | 0) + ((i80 | 0) / 8 | 0) >> 0] | 0) >>> (7 - ((i80 | 0) % 8 | 0) | 0) & 1, i10);
           i80 = (HEAP32[i3 >> 2] | 0) + 1 | 0;
           HEAP32[i3 >> 2] = i80;
           if ((i80 | 0) == (HEAP32[i11 + 24 >> 2] | 0)) {
            HEAP32[i3 >> 2] = 0;
            HEAP32[i12 >> 2] = 3;
           }
           break;
          }
         case 3:
          {
           i3 = gb + 41248 | 0;
           i3 = _i64Add(___muldi3(HEAP32[i3 >> 2] | 0, HEAP32[i3 + 4 >> 2] | 0, 1284865837, 1481765933) | 0, getTempRet0() | 0, 1, 0) | 0;
           i8 = getTempRet0() | 0;
           i7 = gb + 41248 | 0;
           HEAP32[i7 >> 2] = i3;
           HEAP32[i7 + 4 >> 2] = i8;
           i8 = _bitshift64Lshr(i3 | 0, i8 | 0, 33) | 0;
           getTempRet0() | 0;
           _gmskmod_modulate(HEAP32[i11 >> 2] | 0, i8 & 1, i10);
           i8 = i11 + 96 | 0;
           i3 = HEAP32[i8 >> 2] | 0;
           i7 = i11 + 8 | 0;
           i4 = HEAP32[i7 >> 2] | 0;
           if (i3 >>> 0 >= i4 >>> 0 ? (i51 = i11 + 4 | 0, i52 = HEAP32[i51 >> 2] | 0, (i52 | 0) != 0) : 0) {
            i6 = i52;
            i5 = 0;
            while (1) {
             d77 = .53836 - +Math_cos(+(+(((Math_imul(i6, i3) | 0) + i5 | 0) >>> 0) * 6.283185307179586 / +(((Math_imul(i4 << 1, i6) | 0) + -1 | 0) >>> 0))) * .46164;
             i80 = i10 + (i5 << 3) | 0;
             i3 = i10 + (i5 << 3) + 4 | 0;
             d78 = +HEAPF32[i3 >> 2] * d77;
             HEAPF32[i80 >> 2] = +HEAPF32[i80 >> 2] * d77;
             HEAPF32[i3 >> 2] = d78;
             i5 = i5 + 1 | 0;
             i3 = HEAP32[i51 >> 2] | 0;
             if (i5 >>> 0 >= i3 >>> 0) break;
             i6 = i3;
             i3 = HEAP32[i8 >> 2] | 0;
             i4 = HEAP32[i7 >> 2] | 0;
            }
            i3 = HEAP32[i8 >> 2] | 0;
           }
           i80 = i3 + 1 | 0;
           HEAP32[i8 >> 2] = i80;
           if ((i80 | 0) == (HEAP32[i11 + 28 >> 2] | 0)) {
            HEAP32[i8 >> 2] = 0;
            HEAP32[i11 + 92 >> 2] = 1;
           }
           break;
          }
         default:
          {
           i21 = 152;
           break L4;
          }
         }
         if (HEAP32[i11 + 92 >> 2] | 0) break;
         i2 = (HEAP32[i32 >> 2] | 0) + i2 | 0;
         if (i2 >>> 0 >= i13 >>> 0) break L19;
        }
        i80 = HEAP32[i11 >> 2] | 0;
        HEAPF32[i80 + 24 >> 2] = 0.0;
        i80 = HEAP32[(HEAP32[(HEAP32[i80 + 20 >> 2] | 0) + 16 >> 2] | 0) + 16 >> 2] | 0;
        HEAP32[i80 + 24 >> 2] = 0;
        _memset(HEAP32[i80 >> 2] | 0, 0, HEAP32[i80 + 20 >> 2] << 2 | 0) | 0;
        i80 = HEAP32[i11 + 32 >> 2] | 0;
        HEAP32[i80 + 16 >> 2] = HEAP32[i80 + 8 >> 2];
        SIMD_Int32x4_store(HEAPU8, i12, SIMD_Int32x4_splat(0));
       }
       break;
      }
     default:
      i2 = 0;
     } while (0);
     i3 = HEAP32[i54 >> 2] | 0;
     if ((i3 | 0) != 0 ? (i53 = Math_imul(HEAP32[i3 >> 2] | 0, i2) | 0, i53 >>> 0 > (HEAP32[i38 >> 2] | 0) >>> 0) : 0) {
      i4 = _realloc(HEAP32[i55 >> 2] | 0, i53 << 2) | 0;
      HEAP32[i55 >> 2] = i4;
      HEAP32[i38 >> 2] = i53;
      i3 = HEAP32[i54 >> 2] | 0;
     } else i4 = HEAP32[i55 >> 2] | 0;
     i2 = _modulator_emit(i3, HEAP32[i39 >> 2] | 0, i2, i4) | 0;
     HEAP32[i36 >> 2] = i2;
     HEAP8[i50 >> 0] = 0;
    }
   }
   do if ((i21 | 0) == 13) {
    i2 = (HEAP8[i46 >> 0] | 0) != 0;
    i5 = HEAP32[i47 >> 2] | 0;
    i3 = (i5 | 0) == 0;
    if (i3 | i22 & i2) {
     if (HEAP8[i50 >> 0] | 0) {
      i21 = 15;
      break L4;
     }
     i2 = _modulator_flush(HEAP32[i54 >> 2] | 0, HEAP32[i55 >> 2] | 0) | 0;
     HEAP32[i36 >> 2] = i2;
     if (HEAP32[i26 >> 2] | 0) {
      i3 = HEAP32[i27 >> 2] | 0;
      if (!i3) i3 = 0; else _memset((HEAP32[i55 >> 2] | 0) + (i2 << 2) | 0, 0, i3 << 2 | 0) | 0;
      i2 = i3 + i2 | 0;
      HEAP32[i36 >> 2] = i2;
     }
     HEAP8[i50 >> 0] = 1;
     break;
    }
    i3 = HEAP32[i28 >> 2] | 0;
    i3 = i3 >>> 0 < i5 >>> 0 ? i3 : i5;
    i4 = HEAP32[i29 >> 2] | 0;
    HEAP32[i29 >> 2] = i4 + i3;
    HEAP32[i47 >> 2] = i5 - i3;
    i2 = _malloc(1) | 0;
    if (i2 | 0 ? HEAP32[i2 + -4 >> 2] & 3 | 0 : 0) HEAP8[i2 >> 0] = 0;
    switch (HEAP32[i43 >> 2] | 0) {
    case 0:
     {
      _ofdmflexframegen_assemble(HEAP32[i30 >> 2] | 0, i2, i4, i3);
      break;
     }
    case 1:
     {
      _flexframegen_assemble(HEAP32[i31 >> 2] | 0, i2, i4, i3);
      HEAP32[i32 >> 2] = _flexframegen_getframelen(HEAP32[i31 >> 2] | 0) | 0;
      break;
     }
    case 2:
     {
      _gmskframegen_assemble(HEAP32[i30 >> 2] | 0, i2, i4, i3, HEAP32[i33 >> 2] | 0, HEAP32[i34 >> 2] | 0, HEAP32[i35 >> 2] | 0);
      break;
     }
    default:
     {}
    }
    _free(i2);
    i2 = HEAP32[i36 >> 2] | 0;
   } while (0);
   if (i2 | 0) break L6;
  } while (0);
  i3 = HEAP32[i26 >> 2] | 0;
  if (!i3) {
   i3 = i24 >>> 0 < i2 >>> 0 ? i24 : i2;
   _memmove(i25 | 0, (HEAP32[i55 >> 2] | 0) + (HEAP32[i42 >> 2] << 2) | 0, i3 << 2 | 0) | 0;
   HEAP32[i42 >> 2] = (HEAP32[i42 >> 2] | 0) + i3;
   i2 = (HEAP32[i36 >> 2] | 0) - i3 | 0;
   HEAP32[i36 >> 2] = i2;
  } else {
   _resamp_rrrf_execute_output_block(i3, (HEAP32[i55 >> 2] | 0) + (HEAP32[i42 >> 2] << 2) | 0, i2, i58, i25, i24, i59);
   i3 = HEAP32[i59 >> 2] | 0;
   i2 = HEAP32[i58 >> 2] | 0;
   HEAP32[i42 >> 2] = (HEAP32[i42 >> 2] | 0) + i2;
   i2 = (HEAP32[i36 >> 2] | 0) - i2 | 0;
   HEAP32[i36 >> 2] = i2;
  }
  i1 = i3 + i1 | 0;
  if (i1 >>> 0 < i57 >>> 0) i25 = i25 + (i3 << 2) | 0; else {
   i21 = 175;
   break;
  }
 }
 if ((i21 | 0) == 15) {
  if (i3 | i22 & i2 ^ 1) {
   i80 = i1;
   STACKTOP = i60;
   return i80 | 0;
  }
  if ((i1 | 0) == (i57 | 0)) {
   i80 = i57;
   STACKTOP = i60;
   return i80 | 0;
  }
  _memset(i25 | 0, 0, i24 << 2 | 0) | 0;
  i80 = i57;
  STACKTOP = i60;
  return i80 | 0;
 } else if ((i21 | 0) == 83) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i64 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i64;
    HEAP32[gb + 8728 + 20 >> 2] = i64;
    i61 = i64 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i61;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i61 = i1;
   i64 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i61 - i64 | 0) >>> 0 < 74) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26435 | 0, 74) | 0;
   _exit(1);
  }
  i1 = i64;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26435 | 0, 74) | 0) >>> 0 < 74) _exit(1); else {
   i69 = 0;
   i72 = gb + 26435 + 74 | 0;
   i73 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i69 = 74;
   i72 = gb + 26435 | 0;
   i73 = i1;
  } while (0);
  _memcpy(i73 | 0, i72 | 0, i69 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i69;
  _exit(1);
 } else if ((i21 | 0) == 116) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i65 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i65;
    HEAP32[gb + 8728 + 20 >> 2] = i65;
    i63 = i65 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i63;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i63 = i1;
   i65 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i63 - i65 | 0) >>> 0 < 74) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23420 | 0, 74) | 0;
   _exit(1);
  }
  i1 = i65;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23420 | 0, 74) | 0) >>> 0 < 74) _exit(1); else {
   i67 = 0;
   i71 = gb + 23420 + 74 | 0;
   i74 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i67 = 74;
   i71 = gb + 23420 | 0;
   i74 = i1;
  } while (0);
  _memcpy(i74 | 0, i71 | 0, i67 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i67;
  _exit(1);
 } else if ((i21 | 0) == 152) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i66 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i66;
    HEAP32[gb + 8728 + 20 >> 2] = i66;
    i62 = i66 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i62;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i62 = i1;
   i66 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i62 - i66 | 0) >>> 0 < 70) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24914 | 0, 70) | 0;
   _exit(1);
  }
  i1 = i66;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24914 | 0, 70) | 0) >>> 0 < 70) _exit(1); else {
   i68 = 0;
   i70 = gb + 24914 + 70 | 0;
   i75 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i68 = 70;
   i70 = gb + 24914 | 0;
   i75 = i1;
  } while (0);
  _memcpy(i75 | 0, i70 | 0, i68 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i68;
  _exit(1);
 } else if ((i21 | 0) == 175) {
  STACKTOP = i60;
  return i1 | 0;
 }
 return 0;
}

function _liquid_firdes_prototype(i19, i93, i97, d98, i101) {
 i19 = i19 | 0;
 i93 = i93 | 0;
 i97 = i97 | 0;
 d98 = +d98;
 i101 = i101 | 0;
 var i1 = 0, i2 = 0, F43 = SIMD_Float32x4(0, 0, 0, 0), d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, d13 = 0.0, d14 = 0.0, d15 = 0.0, d16 = 0.0, d17 = 0.0, i18 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, i74 = 0, i75 = 0, i76 = 0, i77 = 0, i78 = 0, i79 = 0, i80 = 0, i81 = 0, i82 = 0, i83 = 0, i84 = 0, i85 = 0, i86 = 0, i87 = 0, i88 = 0, i89 = 0, i90 = 0, i91 = 0, i92 = 0, i94 = 0, i95 = 0, i96 = 0, d99 = 0.0, i100 = 0, i102 = 0;
 i102 = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 i24 = i102 + 32 | 0;
 i91 = i102 + 24 | 0;
 i84 = i102 + 16 | 0;
 i23 = i102 + 8 | 0;
 i18 = i102;
 i20 = i102 + 72 | 0;
 i21 = i102 + 60 | 0;
 i25 = i102 + 48 | 0;
 i26 = i102 + 36 | 0;
 i96 = Math_imul(i93 << 1, i97) | 0;
 i100 = i96 | 1;
 d99 = +(i93 >>> 0);
 d5 = .5 / d99;
 d6 = d98 / d99;
 d7 = d6 * 14.260000228881836;
 d10 = +(i100 >>> 0);
 if (d6 > .5 | d6 <= 0.0) {
  HEAPF64[i18 >> 3] = d6;
  _fprintf(gb + 8728 | 0, gb + 20455 | 0, i18);
  _exit(1);
 } else {
  d8 = .009999999776482582;
  d9 = 200.0;
  i22 = 0;
 }
 while (1) {
  d4 = (d8 + d9) * .5;
  if (d4 <= 0.0) {
   i92 = 4;
   break;
  }
  i18 = (d4 + -7.949999809265137) / d7 < d10;
  i22 = i22 + 1 | 0;
  if (i22 >>> 0 >= 20) break; else {
   d8 = i18 ? d4 : d8;
   d9 = i18 ? d9 : d4;
  }
 }
 if ((i92 | 0) == 4) {
  HEAPF64[i23 >> 3] = d4;
  _fprintf(gb + 8728 | 0, gb + 20392 | 0, i23);
  _exit(1);
 }
 HEAPF32[i20 >> 2] = 0.0;
 d17 = d6 * .5;
 HEAPF32[i20 + 4 >> 2] = d5 - d17;
 HEAPF32[i20 + 8 >> 2] = d5;
 HEAPF32[i20 + 12 >> 2] = d5;
 HEAPF32[i20 + 16 >> 2] = d5 + d17;
 HEAPF32[i20 + 20 >> 2] = .5;
 HEAPF32[i21 >> 2] = d99;
 HEAPF32[i21 + 4 >> 2] = d99 * .5;
 HEAPF32[i21 + 8 >> 2] = 0.0;
 HEAP32[i25 >> 2] = HEAP32[gb + 468 >> 2];
 HEAP32[i25 + 4 >> 2] = HEAP32[gb + 468 + 4 >> 2];
 HEAP32[i25 + 8 >> 2] = HEAP32[gb + 468 + 8 >> 2];
 HEAP32[i26 >> 2] = 0;
 HEAP32[i26 + 4 >> 2] = 0;
 HEAP32[i26 + 8 >> 2] = 0;
 do switch (i19 | 0) {
 case 1:
  {
   _liquid_firdes_kaiser(i100, d5, d4, i101);
   STACKTOP = i102;
   return;
  }
 case 2:
  {
   i100 = _firdespm_create(i100, i20, i21, i25, i26) | 0;
   _firdespm_execute(i100, i101);
   _firdespm_destroy(i100);
   STACKTOP = i102;
   return;
  }
 case 3:
  {
   if (!i93) {
    i18 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i18) {
     i18 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i18 + 255 | i18;
     i18 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i18 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i12 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i12;
      HEAP32[gb + 8728 + 20 >> 2] = i12;
      i28 = i12 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i28;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i18 | 32;
     _exit(1);
    } else {
     i28 = i18;
     i12 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i28 - i12 | 0) >>> 0 < 54) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22058 | 0, 54) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22058 | 0, 54) | 0) >>> 0 < 54) _exit(1); else {
     i34 = 0;
     i38 = gb + 22058 + 54 | 0;
     i45 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i34 = 54;
     i38 = gb + 22058 | 0;
     i45 = i12;
    } while (0);
    _memcpy(i45 | 0, i38 | 0, i34 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i34;
    _exit(1);
   }
   if (!i97) {
    i12 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i12) {
     i12 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i12 + 255 | i12;
     i12 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i12 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i47 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i47;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i12 | 32;
     _exit(1);
    } else {
     i47 = i12;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i47 - i2 | 0) >>> 0 < 54) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22113 | 0, 54) | 0;
     _exit(1);
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22113 | 0, 54) | 0) >>> 0 < 54) _exit(1); else {
     i53 = 0;
     i57 = gb + 22113 + 54 | 0;
     i64 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i53 = 54;
     i57 = gb + 22113 | 0;
     i64 = i2;
    } while (0);
    _memcpy(i64 | 0, i57 | 0, i53 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i53;
    _exit(1);
   }
   if (!(d98 < 0.0 | d98 > 1.0)) {
    d8 = +(i97 >>> 0);
    d11 = d98;
    d9 = d98 * 4.0 * d98;
    d10 = 3.141592653589793 / (d11 * 2.0);
    d11 = d11 * 3.141592653589793;
    i1 = 0;
    do {
     d4 = +(i1 >>> 0) / d99 - d8;
     d6 = 1.0 - d4 * (d9 * d4);
     if (+Math_abs(+d6) < 1.0000000474974513e-03) d4 = +Math_sin(+d10) * d98 * .5; else {
      d7 = d4;
      d5 = d7 * 3.141592653589793;
      if (+Math_abs(+d4) < .009999999776482582) d4 = +Math_cos(+(d5 * .5)) * +Math_cos(+(d5 * .25)) * +Math_cos(+(d5 * .125)); else d4 = +Math_sin(+d5) / d5;
      d4 = d4 * +Math_cos(+(d11 * d7)) / d6;
     }
     HEAPF32[i101 + (i1 << 2) >> 2] = d4;
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i100 | 0));
    STACKTOP = i102;
    return;
   }
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i65 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i65;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i65 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i65 - i1 | 0) >>> 0 < 51) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22168 | 0, 51) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22168 | 0, 51) | 0) >>> 0 < 51) _exit(1); else {
    i72 = 0;
    i76 = gb + 22168 + 51 | 0;
    i80 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i72 = 51;
    i76 = gb + 22168 | 0;
    i80 = i1;
   } while (0);
   _memcpy(i80 | 0, i76 | 0, i72 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i72;
   _exit(1);
   break;
  }
 case 4:
  {
   _liquid_firdes_fnyquist(4, 0, i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 5:
  {
   _liquid_firdes_fnyquist(5, 0, i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 6:
  {
   _liquid_firdes_fnyquist(6, 0, i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 7:
  {
   if (i93 >>> 0 < 2) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i31 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i31;
      HEAP32[gb + 8728 + 20 >> 2] = i31;
      i29 = i31 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i29;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i29 = i1;
     i31 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i29 - i31 | 0) >>> 0 < 54) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22677 | 0, 54) | 0;
     _exit(1);
    }
    i1 = i31;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22677 | 0, 54) | 0) >>> 0 < 54) _exit(1); else {
     i36 = 0;
     i40 = gb + 22677 + 54 | 0;
     i42 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i36 = 54;
     i40 = gb + 22677 | 0;
     i42 = i1;
    } while (0);
    _memcpy(i42 | 0, i40 | 0, i36 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i36;
    _exit(1);
   }
   if (!i97) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i50 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i50;
      HEAP32[gb + 8728 + 20 >> 2] = i50;
      i48 = i50 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i48;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i48 = i1;
     i50 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i48 - i50 | 0) >>> 0 < 54) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22732 | 0, 54) | 0;
     _exit(1);
    }
    i1 = i50;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22732 | 0, 54) | 0) >>> 0 < 54) _exit(1); else {
     i54 = 0;
     i58 = gb + 22732 + 54 | 0;
     i61 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i54 = 54;
     i58 = gb + 22732 | 0;
     i61 = i1;
    } while (0);
    _memcpy(i61 | 0, i58 | 0, i54 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i54;
    _exit(1);
   }
   if (d98 <= 0.0 | d98 >= 1.0) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i69 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i69;
      HEAP32[gb + 8728 + 20 >> 2] = i69;
      i67 = i69 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i67;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i67 = i1;
     i69 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i67 - i69 | 0) >>> 0 < 55) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22787 | 0, 55) | 0;
     _exit(1);
    }
    i1 = i69;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22787 | 0, 55) | 0) >>> 0 < 55) _exit(1); else {
     i73 = 0;
     i77 = gb + 22787 + 55 | 0;
     i81 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i73 = 55;
     i77 = gb + 22787 | 0;
     i81 = i1;
    } while (0);
    _memcpy(i81 | 0, i77 | 0, i73 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i73;
    _exit(1);
   } else {
    d17 = +(i97 >>> 0);
    d4 = +Math_log(+d98);
    d4 = +Math_log(+d17) * .067663 + .762886 + d4 * .06551499664783478 + d4 * (+Math_log(+(1.0 - +Math_pow(+d17, -1.600000023841858) * .088)) * d4);
    if (d4 <= 0.0 | d4 >= 1.0) d4 = +_rkaiser_approximate_rho(i97, d98);
    d5 = d4 * d98 / d99;
    d6 = d5 * 14.260000228881836;
    if (d5 > .5 | d5 <= 0.0) {
     HEAPF64[i84 >> 3] = d5;
     _fprintf(gb + 8728 | 0, gb + 20455 | 0, i84);
     _exit(1);
    } else {
     d11 = .009999999776482582;
     d13 = 200.0;
     i90 = 0;
    }
    while (1) {
     d5 = (d11 + d13) * .5;
     if (d5 <= 0.0) {
      i92 = 103;
      break;
     }
     i1 = (d5 + -7.949999809265137) / d6 < d10;
     i90 = i90 + 1 | 0;
     if (i90 >>> 0 >= 20) break; else {
      d11 = i1 ? d5 : d11;
      d13 = i1 ? d13 : d5;
     }
    }
    if ((i92 | 0) == 103) {
     HEAPF64[i91 >> 3] = d5;
     _fprintf(gb + 8728 | 0, gb + 20392 | 0, i91);
     _exit(1);
    }
    _liquid_firdes_kaiser(i100, ((1.0 - d4) * d98 + 1.0) * .5 / d99, d5, i101);
    d4 = 0.0;
    i1 = 0;
    do {
     d98 = +HEAPF32[i101 + (i1 << 2) >> 2];
     d4 = d4 + d98 * d98;
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i100 | 0));
    d4 = +Math_sqrt(+(d99 / d4));
    if (i96 >>> 0 >= 4 ? (i94 = i96 & -4, (i94 | 0) != 0) : 0) {
     F43 = SIMD_Float32x4_splat(Math_fround(d4));
     i1 = 0;
     do {
      i97 = i101 + (i1 << 2) | 0;
      i96 = i97;
      SIMD_Float32x4_store(HEAPU8, i96, SIMD_Float32x4_mul(F43, SIMD_Float32x4_load(HEAPU8, i97)));
      i1 = i1 + 4 | 0;
     } while ((i1 | 0) != (i94 | 0));
     i1 = i94;
    } else i1 = 0;
    do {
     i97 = i101 + (i1 << 2) | 0;
     HEAPF32[i97 >> 2] = d4 * +HEAPF32[i97 >> 2];
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i100 | 0));
    STACKTOP = i102;
    return;
   }
   break;
  }
 case 8:
  {
   if (i93 >>> 0 < 2) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i32 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i32;
      HEAP32[gb + 8728 + 20 >> 2] = i32;
      i30 = i32 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i30;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i30 = i1;
     i32 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i30 - i32 | 0) >>> 0 < 53) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22220 | 0, 53) | 0;
     _exit(1);
    }
    i1 = i32;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22220 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
     i35 = 0;
     i39 = gb + 22220 + 53 | 0;
     i43 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i35 = 53;
     i39 = gb + 22220 | 0;
     i43 = i1;
    } while (0);
    _memcpy(i43 | 0, i39 | 0, i35 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i35;
    _exit(1);
   }
   if (!i97) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i51 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i51;
      HEAP32[gb + 8728 + 20 >> 2] = i51;
      i49 = i51 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i49;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i49 = i1;
     i51 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i49 - i51 | 0) >>> 0 < 53) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22274 | 0, 53) | 0;
     _exit(1);
    }
    i1 = i51;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22274 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
     i55 = 0;
     i59 = gb + 22274 + 53 | 0;
     i62 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i55 = 53;
     i59 = gb + 22274 | 0;
     i62 = i1;
    } while (0);
    _memcpy(i62 | 0, i59 | 0, i55 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i55;
    _exit(1);
   }
   if (d98 <= 0.0 | d98 >= 1.0) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i70 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i70;
      HEAP32[gb + 8728 + 20 >> 2] = i70;
      i68 = i70 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i68;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i68 = i1;
     i70 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i68 - i70 | 0) >>> 0 < 54) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22328 | 0, 54) | 0;
     _exit(1);
    }
    i1 = i70;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22328 | 0, 54) | 0) >>> 0 < 54) _exit(1); else {
     i74 = 0;
     i78 = gb + 22328 + 54 | 0;
     i82 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i74 = 54;
     i78 = gb + 22328 | 0;
     i82 = i1;
    } while (0);
    _memcpy(i82 | 0, i78 | 0, i74 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i74;
    _exit(1);
   }
   if (!(d98 < 0.0 | d98 > 1.0)) {
    d6 = +_rkaiser_approximate_rho(i97, d98);
    d4 = .20000000298023224;
    i1 = 0;
    d5 = d6;
    d8 = 0.0;
    while (1) {
     d16 = d6 - d4;
     d17 = d4 + d6;
     d16 = !(d16 <= 0.0) ? d16 : .009999999776482582;
     d17 = !(d17 >= 1.0) ? d17 : .9900000095367432;
     d13 = +_liquid_firdes_rkaiser_internal_isi(i93, i97, d98, d16, i101);
     d14 = +_liquid_firdes_rkaiser_internal_isi(i93, i97, d98, d6, i101);
     d15 = +_liquid_firdes_rkaiser_internal_isi(i93, i97, d98, d17, i101);
     i94 = (i1 | 0) == 0 | d14 < d8;
     d8 = i94 ? d14 : d8;
     d5 = i94 ? d6 : d5;
     d9 = d6 * d6;
     d10 = d17 * d17;
     d11 = d16 * d16;
     d7 = d6;
     d6 = ((d11 - d9) * d15 + (d13 * (d9 - d10) + d14 * (d10 - d11))) * .5 / (d13 * (d6 - d17) + (d17 - d16) * d14 + (d16 - d6) * d15);
     if (d6 < d16 | d6 > d17) break;
     if (i1 >>> 0 > 3 ? +Math_abs(+(d6 - d7)) < 9.999999974752427e-07 : 0) break;
     i1 = i1 + 1 | 0;
     if (i1 >>> 0 >= 14) break; else d4 = d4 * .5;
    }
    +_liquid_firdes_rkaiser_internal_isi(i93, i97, d98, d5, i101);
    d4 = 0.0;
    i1 = 0;
    do {
     d98 = +HEAPF32[i101 + (i1 << 2) >> 2];
     d4 = d4 + d98 * d98;
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i100 | 0));
    d4 = +Math_sqrt(+(d99 / d4));
    if (i96 >>> 0 >= 4 ? (i95 = i96 & -4, (i95 | 0) != 0) : 0) {
     F43 = SIMD_Float32x4_splat(Math_fround(d4));
     i1 = 0;
     do {
      i97 = i101 + (i1 << 2) | 0;
      i96 = i97;
      SIMD_Float32x4_store(HEAPU8, i96, SIMD_Float32x4_mul(F43, SIMD_Float32x4_load(HEAPU8, i97)));
      i1 = i1 + 4 | 0;
     } while ((i1 | 0) != (i95 | 0));
     i1 = i95;
    } else i1 = 0;
    do {
     i97 = i101 + (i1 << 2) | 0;
     HEAPF32[i97 >> 2] = d4 * +HEAPF32[i97 >> 2];
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i100 | 0));
    STACKTOP = i102;
    return;
   }
   i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i86 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i86;
     HEAP32[gb + 8728 + 20 >> 2] = i86;
     i85 = i86 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i85;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i1 | 32;
    _exit(1);
   } else {
    i85 = i1;
    i86 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i85 - i86 | 0) >>> 0 < 64) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22383 | 0, 64) | 0;
    _exit(1);
   }
   i1 = i86;
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22383 | 0, 64) | 0) >>> 0 < 64) _exit(1); else {
    i87 = 0;
    i88 = gb + 22383 + 64 | 0;
    i89 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i87 = 64;
    i88 = gb + 22383 | 0;
    i89 = i1;
   } while (0);
   _memcpy(i89 | 0, i88 | 0, i87 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i87;
   _exit(1);
   break;
  }
 case 9:
  {
   if (!i93) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i33 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i33;
      HEAP32[gb + 8728 + 20 >> 2] = i33;
      i27 = i33 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i27;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i27 = i1;
     i33 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i27 - i33 | 0) >>> 0 < 55) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22843 | 0, 55) | 0;
     _exit(1);
    }
    i1 = i33;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22843 | 0, 55) | 0) >>> 0 < 55) _exit(1); else {
     i37 = 0;
     i41 = gb + 22843 + 55 | 0;
     i44 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i37 = 55;
     i41 = gb + 22843 | 0;
     i44 = i1;
    } while (0);
    _memcpy(i44 | 0, i41 | 0, i37 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i37;
    _exit(1);
   }
   if (!i97) {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i52 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i52;
      HEAP32[gb + 8728 + 20 >> 2] = i52;
      i46 = i52 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i46;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     _exit(1);
    } else {
     i46 = i1;
     i52 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    } while (0);
    if ((i46 - i52 | 0) >>> 0 < 55) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22899 | 0, 55) | 0;
     _exit(1);
    }
    i1 = i52;
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22899 | 0, 55) | 0) >>> 0 < 55) _exit(1); else {
     i56 = 0;
     i60 = gb + 22899 + 55 | 0;
     i63 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i56 = 55;
     i60 = gb + 22899 | 0;
     i63 = i1;
    } while (0);
    _memcpy(i63 | 0, i60 | 0, i56 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i56;
    _exit(1);
   }
   if (!(d98 < 0.0 | d98 > 1.0)) {
    d9 = +(i97 >>> 0);
    d10 = (d98 + 1.0) * 3.141592653589793;
    d15 = 1.0 - d98;
    d11 = d15 * 3.141592653589793;
    d13 = d98 * 4.0;
    d14 = d13;
    d15 = d15 + d14 / 3.141592653589793;
    d16 = d98 * 16.0 * d98;
    d17 = .7853981633974483 / d98;
    d4 = d98 / 1.4142135381698608;
    i1 = 0;
    do {
     d5 = +(i1 >>> 0) / d99 - d9;
     d7 = d5;
     d6 = +Math_cos(+(d10 * d7));
     d7 = +Math_sin(+(d11 * d7));
     do if (!(+Math_abs(+d5) < 1.0e-05)) {
      d8 = 1.0 - d5 * (d16 * d5);
      if (d8 * d8 < 1.0e-05) {
       HEAPF32[i101 + (i1 << 2) >> 2] = d4 * (+Math_sin(+d17) * 1.6366198062896729 + +Math_cos(+d17) * .36338022351264954);
       break;
      } else {
       HEAPF32[i101 + (i1 << 2) >> 2] = (d6 + d7 * (1.0 / (d13 * d5))) * (d14 / (d8 * 3.141592653589793));
       break;
      }
     } else HEAPF32[i101 + (i1 << 2) >> 2] = d15; while (0);
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i100 | 0));
    STACKTOP = i102;
    return;
   }
   i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i71 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i71;
     HEAP32[gb + 8728 + 20 >> 2] = i71;
     i66 = i71 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i66;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i1 | 32;
    _exit(1);
   } else {
    i66 = i1;
    i71 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i66 - i71 | 0) >>> 0 < 52) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22955 | 0, 52) | 0;
    _exit(1);
   }
   i1 = i71;
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22955 | 0, 52) | 0) >>> 0 < 52) _exit(1); else {
    i75 = 0;
    i79 = gb + 22955 + 52 | 0;
    i83 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i75 = 52;
    i79 = gb + 22955 | 0;
    i83 = i1;
   } while (0);
   _memcpy(i83 | 0, i79 | 0, i75 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i75;
   _exit(1);
   break;
  }
 case 10:
  {
   _liquid_firdes_hM3(i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 11:
  {
   _liquid_firdes_gmsktx(i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 12:
  {
   _liquid_firdes_gmskrx(i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 13:
  {
   _liquid_firdes_fnyquist(4, 1, i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 14:
  {
   _liquid_firdes_fnyquist(5, 1, i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 case 15:
  {
   _liquid_firdes_fnyquist(6, 1, i93, i97, d98, i101);
   STACKTOP = i102;
   return;
  }
 default:
  {
   HEAP32[i24 >> 2] = i19;
   _fprintf(gb + 8728 | 0, gb + 20672 | 0, i24);
   _exit(1);
  }
 } while (0);
}

function _printf_core(i48, i2, i51, i52, i53) {
 i48 = i48 | 0;
 i2 = i2 | 0;
 i51 = i51 | 0;
 i52 = i52 | 0;
 i53 = i53 | 0;
 var i1 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i49 = 0, i50 = 0, i54 = 0;
 i54 = STACKTOP;
 STACKTOP = STACKTOP + 624 | 0;
 i45 = i54 + 24 | 0;
 i47 = i54 + 16 | 0;
 i46 = i54 + 588 | 0;
 i42 = i54 + 576 | 0;
 i44 = i54;
 i37 = i54 + 536 | 0;
 i50 = i54 + 8 | 0;
 i49 = i54 + 528 | 0;
 i27 = (i48 | 0) != 0;
 i28 = i37 + 40 | 0;
 i36 = i28;
 i37 = i37 + 39 | 0;
 i38 = i50 + 4 | 0;
 i39 = i46;
 i40 = 0 - i39 | 0;
 i41 = i42 + 12 | 0;
 i42 = i42 + 11 | 0;
 i43 = i41;
 i29 = i43 - i39 | 0;
 i30 = -2 - i39 | 0;
 i31 = i43 + 2 | 0;
 i32 = i45 + 288 | 0;
 i33 = i46 + 9 | 0;
 i34 = i33;
 i35 = i46 + 8 | 0;
 i1 = 0;
 i3 = 0;
 i7 = 0;
 i13 = i2;
 L1 : while (1) {
  do if ((i1 | 0) > -1) {
   if ((i3 | 0) <= (2147483647 - i1 | 0)) {
    i1 = i3 + i1 | 0;
    break;
   }
   if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
   HEAP32[i1 >> 2] = 75;
   i1 = -1;
  } while (0);
  i2 = HEAP8[i13 >> 0] | 0;
  if (!(i2 << 24 >> 24)) {
   i26 = 254;
   break;
  } else i3 = i13;
  L12 : while (1) {
   switch (i2 << 24 >> 24) {
   case 37:
    {
     i2 = i3;
     i26 = 11;
     break L12;
    }
   case 0:
    {
     i2 = i3;
     break L12;
    }
   default:
    {}
   }
   i25 = i3 + 1 | 0;
   i2 = HEAP8[i25 >> 0] | 0;
   i3 = i25;
  }
  L15 : do if ((i26 | 0) == 11) while (1) {
   i26 = 0;
   if ((HEAP8[i2 + 1 >> 0] | 0) != 37) break L15;
   i3 = i3 + 1 | 0;
   i2 = i2 + 2 | 0;
   if ((HEAP8[i2 >> 0] | 0) == 37) i26 = 11; else break;
  } while (0);
  i11 = i3 - i13 | 0;
  if (i27 ? (HEAP32[i48 >> 2] & 32 | 0) == 0 : 0) ___fwritex(i13, i11, i48);
  if ((i3 | 0) != (i13 | 0)) {
   i3 = i11;
   i13 = i2;
   continue;
  }
  i6 = i2 + 1 | 0;
  i3 = HEAP8[i6 >> 0] | 0;
  i4 = (i3 << 24 >> 24) + -48 | 0;
  if (i4 >>> 0 < 10) {
   i25 = (HEAP8[i2 + 2 >> 0] | 0) == 36;
   i6 = i25 ? i2 + 3 | 0 : i6;
   i3 = HEAP8[i6 >> 0] | 0;
   i9 = i25 ? i4 : -1;
   i7 = i25 ? 1 : i7;
  } else i9 = -1;
  i2 = i3 << 24 >> 24;
  L28 : do if ((i2 & -32 | 0) == 32) {
   i4 = 0;
   do {
    if (!(1 << i2 + -32 & 75913)) break L28;
    i4 = 1 << (i3 << 24 >> 24) + -32 | i4;
    i6 = i6 + 1 | 0;
    i3 = HEAP8[i6 >> 0] | 0;
    i2 = i3 << 24 >> 24;
   } while ((i2 & -32 | 0) == 32);
  } else i4 = 0; while (0);
  do if (i3 << 24 >> 24 == 42) {
   i3 = i6 + 1 | 0;
   i2 = (HEAP8[i3 >> 0] | 0) + -48 | 0;
   if (i2 >>> 0 < 10 ? (HEAP8[i6 + 2 >> 0] | 0) == 36 : 0) {
    HEAP32[i53 + (i2 << 2) >> 2] = 10;
    i2 = 1;
    i6 = i6 + 3 | 0;
    i3 = HEAP32[i52 + ((HEAP8[i3 >> 0] | 0) + -48 << 3) >> 2] | 0;
   } else {
    if (i7 | 0) {
     i1 = -1;
     break L1;
    }
    if (!i27) {
     i10 = i4;
     i25 = 0;
     i6 = i3;
     i24 = 0;
     break;
    }
    i2 = (HEAP32[i51 >> 2] | 0) + (4 - 1) & ~(4 - 1);
    i25 = HEAP32[i2 >> 2] | 0;
    HEAP32[i51 >> 2] = i2 + 4;
    i2 = 0;
    i6 = i3;
    i3 = i25;
   }
   if ((i3 | 0) < 0) {
    i10 = i4 | 8192;
    i25 = i2;
    i24 = 0 - i3 | 0;
   } else {
    i10 = i4;
    i25 = i2;
    i24 = i3;
   }
  } else {
   i2 = (i3 << 24 >> 24) + -48 | 0;
   if (i2 >>> 0 < 10) {
    i3 = 0;
    do {
     i3 = (i3 * 10 | 0) + i2 | 0;
     i6 = i6 + 1 | 0;
     i2 = (HEAP8[i6 >> 0] | 0) + -48 | 0;
    } while (i2 >>> 0 < 10);
    if ((i3 | 0) < 0) {
     i1 = -1;
     break L1;
    } else {
     i10 = i4;
     i25 = i7;
     i24 = i3;
    }
   } else {
    i10 = i4;
    i25 = i7;
    i24 = 0;
   }
  } while (0);
  L49 : do if ((HEAP8[i6 >> 0] | 0) == 46) {
   i2 = i6 + 1 | 0;
   i3 = HEAP8[i2 >> 0] | 0;
   if (i3 << 24 >> 24 != 42) {
    i4 = (i3 << 24 >> 24) + -48 | 0;
    if (i4 >>> 0 < 10) i3 = 0; else {
     i7 = 0;
     break;
    }
    while (1) {
     i3 = (i3 * 10 | 0) + i4 | 0;
     i2 = i2 + 1 | 0;
     i4 = (HEAP8[i2 >> 0] | 0) + -48 | 0;
     if (i4 >>> 0 >= 10) {
      i7 = i3;
      break L49;
     }
    }
   }
   i2 = i6 + 2 | 0;
   i3 = (HEAP8[i2 >> 0] | 0) + -48 | 0;
   if (i3 >>> 0 < 10 ? (HEAP8[i6 + 3 >> 0] | 0) == 36 : 0) {
    HEAP32[i53 + (i3 << 2) >> 2] = 10;
    i7 = HEAP32[i52 + ((HEAP8[i2 >> 0] | 0) + -48 << 3) >> 2] | 0;
    i2 = i6 + 4 | 0;
    break;
   }
   if (i25 | 0) {
    i1 = -1;
    break L1;
   }
   if (i27) {
    i23 = (HEAP32[i51 >> 2] | 0) + (4 - 1) & ~(4 - 1);
    i7 = HEAP32[i23 >> 2] | 0;
    HEAP32[i51 >> 2] = i23 + 4;
   } else i7 = 0;
  } else {
   i7 = -1;
   i2 = i6;
  } while (0);
  i8 = 0;
  while (1) {
   i3 = (HEAP8[i2 >> 0] | 0) + -65 | 0;
   if (i3 >>> 0 > 57) {
    i1 = -1;
    break L1;
   }
   i23 = i2 + 1 | 0;
   i3 = HEAP8[gb + 38800 + (i8 * 58 | 0) + i3 >> 0] | 0;
   i4 = i3 & 255;
   if ((i4 + -1 | 0) >>> 0 < 8) {
    i2 = i23;
    i8 = i4;
   } else break;
  }
  if (!(i3 << 24 >> 24)) {
   i1 = -1;
   break;
  }
  i6 = (i9 | 0) > -1;
  do if (i3 << 24 >> 24 == 19) if (i6) {
   i1 = -1;
   break L1;
  } else i26 = 54; else {
   if (i6) {
    HEAP32[i53 + (i9 << 2) >> 2] = i4;
    i21 = i52 + (i9 << 3) | 0;
    i22 = HEAP32[i21 + 4 >> 2] | 0;
    i26 = i44;
    HEAP32[i26 >> 2] = HEAP32[i21 >> 2];
    HEAP32[i26 + 4 >> 2] = i22;
    i26 = 54;
    break;
   }
   if (!i27) {
    i1 = 0;
    break L1;
   }
   _pop_arg(i44, i4, i51);
  } while (0);
  if ((i26 | 0) == 54 ? (i26 = 0, !i27) : 0) {
   i3 = i11;
   i7 = i25;
   i13 = i23;
   continue;
  }
  i9 = HEAP8[i2 >> 0] | 0;
  i9 = (i8 | 0) != 0 & (i9 & 15 | 0) == 3 ? i9 & -33 : i9;
  i4 = i10 & -65537;
  i22 = (i10 & 8192 | 0) == 0 ? i10 : i4;
  L78 : do switch (i9 | 0) {
  case 110:
   switch (i8 | 0) {
   case 0:
    {
     HEAP32[HEAP32[i44 >> 2] >> 2] = i1;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   case 1:
    {
     HEAP32[HEAP32[i44 >> 2] >> 2] = i1;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   case 2:
    {
     i3 = HEAP32[i44 >> 2] | 0;
     HEAP32[i3 >> 2] = i1;
     HEAP32[i3 + 4 >> 2] = ((i1 | 0) < 0) << 31 >> 31;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   case 3:
    {
     HEAP16[HEAP32[i44 >> 2] >> 1] = i1;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   case 4:
    {
     HEAP8[HEAP32[i44 >> 2] >> 0] = i1;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   case 6:
    {
     HEAP32[HEAP32[i44 >> 2] >> 2] = i1;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   case 7:
    {
     i3 = HEAP32[i44 >> 2] | 0;
     HEAP32[i3 >> 2] = i1;
     HEAP32[i3 + 4 >> 2] = ((i1 | 0) < 0) << 31 >> 31;
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   default:
    {
     i3 = i11;
     i7 = i25;
     i13 = i23;
     continue L1;
    }
   }
  case 112:
   {
    i8 = i22 | 8;
    i7 = i7 >>> 0 > 8 ? i7 : 8;
    i9 = 120;
    i26 = 66;
    break;
   }
  case 88:
  case 120:
   {
    i8 = i22;
    i26 = 66;
    break;
   }
  case 111:
   {
    i4 = i44;
    i3 = HEAP32[i4 >> 2] | 0;
    i4 = HEAP32[i4 + 4 >> 2] | 0;
    if ((i3 | 0) == 0 & (i4 | 0) == 0) i2 = i28; else {
     i2 = i28;
     do {
      i2 = i2 + -1 | 0;
      HEAP8[i2 >> 0] = i3 & 7 | 48;
      i3 = _bitshift64Lshr(i3 | 0, i4 | 0, 3) | 0;
      i4 = getTempRet0() | 0;
     } while (!((i3 | 0) == 0 & (i4 | 0) == 0));
    }
    if (!(i22 & 8)) {
     i3 = i22;
     i8 = 0;
     i6 = gb + 39280 | 0;
     i26 = 79;
    } else {
     i8 = i36 - i2 | 0;
     i3 = i22;
     i7 = (i7 | 0) > (i8 | 0) ? i7 : i8 + 1 | 0;
     i8 = 0;
     i6 = gb + 39280 | 0;
     i26 = 79;
    }
    break;
   }
  case 105:
  case 100:
   {
    i3 = i44;
    i2 = HEAP32[i3 >> 2] | 0;
    i3 = HEAP32[i3 + 4 >> 2] | 0;
    if ((i3 | 0) < 0) {
     i2 = _i64Subtract(0, 0, i2 | 0, i3 | 0) | 0;
     i3 = getTempRet0() | 0;
     i4 = i44;
     HEAP32[i4 >> 2] = i2;
     HEAP32[i4 + 4 >> 2] = i3;
     i4 = 1;
     i6 = gb + 39280 | 0;
     i26 = 78;
     break L78;
    }
    if (!(i22 & 2048)) {
     i6 = i22 & 1;
     i4 = i6;
     i6 = (i6 | 0) == 0 ? gb + 39280 | 0 : gb + 39280 + 2 | 0;
     i26 = 78;
    } else {
     i4 = 1;
     i6 = gb + 39280 + 1 | 0;
     i26 = 78;
    }
    break;
   }
  case 117:
   {
    i3 = i44;
    i2 = HEAP32[i3 >> 2] | 0;
    i3 = HEAP32[i3 + 4 >> 2] | 0;
    i4 = 0;
    i6 = gb + 39280 | 0;
    i26 = 78;
    break;
   }
  case 99:
   {
    HEAP8[i37 >> 0] = HEAP32[i44 >> 2];
    i2 = i37;
    i9 = 1;
    i11 = 0;
    i10 = gb + 39280 | 0;
    i3 = i28;
    break;
   }
  case 109:
   {
    if (!(HEAP32[gb + 41360 >> 2] | 0)) i2 = gb + 41404 | 0; else i2 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
    i3 = HEAP32[i2 >> 2] | 0;
    i2 = 0;
    while (1) {
     if ((HEAPU8[gb + 39290 + i2 >> 0] | 0) == (i3 | 0)) {
      i26 = 85;
      break;
     }
     i2 = i2 + 1 | 0;
     if ((i2 | 0) == 87) {
      i3 = 87;
      i2 = gb + 39378 | 0;
      break;
     }
    }
    if ((i26 | 0) == 85) if (!i2) {
     i3 = gb + 39378 | 0;
     i26 = 92;
     break L78;
    } else {
     i3 = i2;
     i2 = gb + 39378 | 0;
    }
    do {
     do {
      i26 = i2;
      i2 = i2 + 1 | 0;
     } while ((HEAP8[i26 >> 0] | 0) != 0);
     i3 = i3 + -1 | 0;
    } while ((i3 | 0) != 0);
    i3 = i2;
    i26 = 92;
    break;
   }
  case 115:
   {
    i3 = HEAP32[i44 >> 2] | 0;
    i3 = i3 | 0 ? i3 : gb + 41182 | 0;
    i26 = 92;
    break;
   }
  case 67:
   {
    HEAP32[i50 >> 2] = HEAP32[i44 >> 2];
    HEAP32[i38 >> 2] = 0;
    HEAP32[i44 >> 2] = i50;
    i2 = i50;
    i7 = -1;
    i26 = 96;
    break;
   }
  case 83:
   {
    i2 = HEAP32[i44 >> 2] | 0;
    if (!i7) {
     _pad(i48, 32, i24, 0, i22);
     i2 = 0;
     i26 = 107;
    } else i26 = 96;
    break;
   }
  case 65:
  case 71:
  case 70:
  case 69:
  case 97:
  case 103:
  case 102:
  case 101:
   {
    d5 = +HEAPF64[i44 >> 3];
    HEAP32[i47 >> 2] = 0;
    HEAPF64[tempDoublePtr >> 3] = d5;
    if ((HEAP32[tempDoublePtr + 4 >> 2] | 0) >= 0) if (!(i22 & 2048)) {
     i21 = i22 & 1;
     i20 = i21;
     i21 = (i21 | 0) == 0 ? gb + 41189 + 1 | 0 : gb + 41189 + 6 | 0;
    } else {
     i20 = 1;
     i21 = gb + 41189 + 3 | 0;
    } else {
     d5 = -d5;
     i20 = 1;
     i21 = gb + 41189 | 0;
    }
    HEAPF64[tempDoublePtr >> 3] = d5;
    i19 = HEAP32[tempDoublePtr + 4 >> 2] & 2146435072;
    do if (i19 >>> 0 < 2146435072 | (i19 | 0) == 2146435072 & 0 < 0) {
     d12 = +_frexp(d5, i47) * 2.0;
     i3 = d12 != 0.0;
     if (i3) HEAP32[i47 >> 2] = (HEAP32[i47 >> 2] | 0) + -1;
     i17 = i9 | 32;
     if ((i17 | 0) == 97) {
      i10 = i9 & 32;
      i13 = (i10 | 0) == 0 ? i21 : i21 + 9 | 0;
      i11 = i20 | 2;
      i2 = 12 - i7 | 0;
      do if (!(i7 >>> 0 > 11 | (i2 | 0) == 0)) {
       d5 = 8.0;
       do {
        i2 = i2 + -1 | 0;
        d5 = d5 * 16.0;
       } while ((i2 | 0) != 0);
       if ((HEAP8[i13 >> 0] | 0) == 45) {
        d5 = -(d5 + (-d12 - d5));
        break;
       } else {
        d5 = d12 + d5 - d5;
        break;
       }
      } else d5 = d12; while (0);
      i3 = HEAP32[i47 >> 2] | 0;
      i2 = (i3 | 0) < 0 ? 0 - i3 | 0 : i3;
      i2 = _fmt_u(i2, ((i2 | 0) < 0) << 31 >> 31, i41) | 0;
      if ((i2 | 0) == (i41 | 0)) {
       HEAP8[i42 >> 0] = 48;
       i2 = i42;
      }
      HEAP8[i2 + -1 >> 0] = (i3 >> 31 & 2) + 43;
      i8 = i2 + -2 | 0;
      HEAP8[i8 >> 0] = i9 + 15;
      i6 = (i7 | 0) < 1;
      i4 = (i22 & 8 | 0) == 0;
      i3 = i46;
      while (1) {
       i21 = ~~d5;
       i2 = i3 + 1 | 0;
       HEAP8[i3 >> 0] = HEAPU8[gb + 39264 + i21 >> 0] | i10;
       d5 = (d5 - +(i21 | 0)) * 16.0;
       do if ((i2 - i39 | 0) == 1) {
        if (i4 & (i6 & d5 == 0.0)) break;
        HEAP8[i2 >> 0] = 46;
        i2 = i3 + 2 | 0;
       } while (0);
       if (!(d5 != 0.0)) break; else i3 = i2;
      }
      i4 = i8;
      i7 = (i7 | 0) != 0 & (i30 + i2 | 0) < (i7 | 0) ? i31 + i7 - i4 | 0 : i29 - i4 + i2 | 0;
      i6 = i7 + i11 | 0;
      _pad(i48, 32, i24, i6, i22);
      if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i13, i11, i48);
      _pad(i48, 48, i24, i6, i22 ^ 65536);
      i3 = i2 - i39 | 0;
      if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i46, i3, i48);
      i2 = i43 - i4 | 0;
      _pad(i48, 48, i7 - (i3 + i2) | 0, 0, 0);
      if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i8, i2, i48);
      _pad(i48, 32, i24, i6, i22 ^ 8192);
      i2 = (i6 | 0) < (i24 | 0) ? i24 : i6;
      break;
     }
     i2 = (i7 | 0) < 0 ? 6 : i7;
     if (i3) {
      i3 = (HEAP32[i47 >> 2] | 0) + -28 | 0;
      HEAP32[i47 >> 2] = i3;
      d5 = d12 * 268435456.0;
     } else {
      d5 = d12;
      i3 = HEAP32[i47 >> 2] | 0;
     }
     i19 = (i3 | 0) < 0 ? i45 : i32;
     i18 = i19;
     i4 = i19;
     do {
      i16 = ~~d5 >>> 0;
      HEAP32[i4 >> 2] = i16;
      i4 = i4 + 4 | 0;
      d5 = (d5 - +(i16 >>> 0)) * 1.0e9;
     } while (d5 != 0.0);
     i3 = HEAP32[i47 >> 2] | 0;
     if ((i3 | 0) > 0) {
      i6 = i19;
      i7 = i4;
      while (1) {
       i8 = (i3 | 0) > 29 ? 29 : i3;
       i3 = i7 + -4 | 0;
       do if (i3 >>> 0 >= i6 >>> 0) {
        i4 = 0;
        do {
         i15 = _bitshift64Shl(HEAP32[i3 >> 2] | 0, 0, i8 | 0) | 0;
         i15 = _i64Add(i15 | 0, getTempRet0() | 0, i4 | 0, 0) | 0;
         i16 = getTempRet0() | 0;
         i14 = ___uremdi3(i15 | 0, i16 | 0, 1e9, 0) | 0;
         getTempRet0() | 0;
         HEAP32[i3 >> 2] = i14;
         i4 = ___udivdi3(i15 | 0, i16 | 0, 1e9, 0) | 0;
         getTempRet0() | 0;
         i3 = i3 + -4 | 0;
        } while (i3 >>> 0 >= i6 >>> 0);
        if (!i4) break;
        i6 = i6 + -4 | 0;
        HEAP32[i6 >> 2] = i4;
       } while (0);
       i4 = i7;
       while (1) {
        if (i4 >>> 0 <= i6 >>> 0) break;
        i3 = i4 + -4 | 0;
        if (!(HEAP32[i3 >> 2] | 0)) i4 = i3; else break;
       }
       i3 = (HEAP32[i47 >> 2] | 0) - i8 | 0;
       HEAP32[i47 >> 2] = i3;
       if ((i3 | 0) > 0) i7 = i4; else break;
      }
     } else i6 = i19;
     if ((i3 | 0) < 0) {
      i13 = ((i2 + 25 | 0) / 9 | 0) + 1 | 0;
      i14 = (i17 | 0) == 102;
      do {
       i11 = 0 - i3 | 0;
       i11 = (i11 | 0) > 9 ? 9 : i11;
       do if (i6 >>> 0 < i4 >>> 0) {
        i3 = (1 << i11) + -1 | 0;
        i7 = 1e9 >>> i11;
        i10 = 0;
        i8 = i6;
        do {
         i16 = HEAP32[i8 >> 2] | 0;
         HEAP32[i8 >> 2] = (i16 >>> i11) + i10;
         i10 = Math_imul(i16 & i3, i7) | 0;
         i8 = i8 + 4 | 0;
        } while (i8 >>> 0 < i4 >>> 0);
        i3 = (HEAP32[i6 >> 2] | 0) == 0 ? i6 + 4 | 0 : i6;
        if (!i10) {
         i6 = i3;
         i3 = i4;
         break;
        }
        HEAP32[i4 >> 2] = i10;
        i6 = i3;
        i3 = i4 + 4 | 0;
       } else {
        i6 = (HEAP32[i6 >> 2] | 0) == 0 ? i6 + 4 | 0 : i6;
        i3 = i4;
       } while (0);
       i4 = i14 ? i19 : i6;
       i4 = (i3 - i4 >> 2 | 0) > (i13 | 0) ? i4 + (i13 << 2) | 0 : i3;
       i3 = (HEAP32[i47 >> 2] | 0) + i11 | 0;
       HEAP32[i47 >> 2] = i3;
      } while ((i3 | 0) < 0);
      i13 = i6;
      i14 = i4;
     } else {
      i13 = i6;
      i14 = i4;
     }
     do if (i13 >>> 0 < i14 >>> 0) {
      i3 = (i18 - i13 >> 2) * 9 | 0;
      i6 = HEAP32[i13 >> 2] | 0;
      if (i6 >>> 0 < 10) break; else i4 = 10;
      do {
       i4 = i4 * 10 | 0;
       i3 = i3 + 1 | 0;
      } while (i6 >>> 0 >= i4 >>> 0);
     } else i3 = 0; while (0);
     i15 = (i17 | 0) == 103;
     i16 = (i2 | 0) != 0;
     i4 = i2 - ((i17 | 0) != 102 ? i3 : 0) + ((i16 & i15) << 31 >> 31) | 0;
     if ((i4 | 0) < (((i14 - i18 >> 2) * 9 | 0) + -9 | 0)) {
      i7 = i4 + 9216 | 0;
      i4 = i19 + 4 + (((i7 | 0) / 9 | 0) + -1024 << 2) | 0;
      i7 = ((i7 | 0) % 9 | 0) + 1 | 0;
      if ((i7 | 0) < 9) {
       i6 = 10;
       do {
        i6 = i6 * 10 | 0;
        i7 = i7 + 1 | 0;
       } while ((i7 | 0) != 9);
      } else i6 = 10;
      i10 = HEAP32[i4 >> 2] | 0;
      i11 = (i10 >>> 0) % (i6 >>> 0) | 0;
      i7 = (i4 + 4 | 0) == (i14 | 0);
      do if (i7 & (i11 | 0) == 0) i6 = i13; else {
       d12 = (((i10 >>> 0) / (i6 >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0;
       i8 = (i6 | 0) / 2 | 0;
       if (i11 >>> 0 < i8 >>> 0) d5 = .5; else d5 = i7 & (i11 | 0) == (i8 | 0) ? 1.0 : 1.5;
       do if (i20) {
        if ((HEAP8[i21 >> 0] | 0) != 45) break;
        d12 = -d12;
        d5 = -d5;
       } while (0);
       i7 = i10 - i11 | 0;
       HEAP32[i4 >> 2] = i7;
       if (!(d12 + d5 != d12)) {
        i6 = i13;
        break;
       }
       i17 = i7 + i6 | 0;
       HEAP32[i4 >> 2] = i17;
       if (i17 >>> 0 > 999999999) {
        i3 = i13;
        while (1) {
         i6 = i4 + -4 | 0;
         HEAP32[i4 >> 2] = 0;
         if (i6 >>> 0 < i3 >>> 0) {
          i3 = i3 + -4 | 0;
          HEAP32[i3 >> 2] = 0;
         }
         i17 = (HEAP32[i6 >> 2] | 0) + 1 | 0;
         HEAP32[i6 >> 2] = i17;
         if (i17 >>> 0 > 999999999) i4 = i6; else {
          i8 = i3;
          i4 = i6;
          break;
         }
        }
       } else i8 = i13;
       i3 = (i18 - i8 >> 2) * 9 | 0;
       i7 = HEAP32[i8 >> 2] | 0;
       if (i7 >>> 0 < 10) {
        i6 = i8;
        break;
       } else i6 = 10;
       do {
        i6 = i6 * 10 | 0;
        i3 = i3 + 1 | 0;
       } while (i7 >>> 0 >= i6 >>> 0);
       i6 = i8;
      } while (0);
      i4 = i4 + 4 | 0;
      i13 = i6;
      i4 = i14 >>> 0 > i4 >>> 0 ? i4 : i14;
     } else i4 = i14;
     i11 = 0 - i3 | 0;
     i17 = i4;
     while (1) {
      if (i17 >>> 0 <= i13 >>> 0) {
       i14 = 0;
       break;
      }
      i4 = i17 + -4 | 0;
      if (!(HEAP32[i4 >> 2] | 0)) i17 = i4; else {
       i14 = 1;
       break;
      }
     }
     do if (i15) {
      i2 = (i16 & 1 ^ 1) + i2 | 0;
      if ((i2 | 0) > (i3 | 0) & (i3 | 0) > -5) {
       i9 = i9 + -1 | 0;
       i2 = i2 + -1 - i3 | 0;
      } else {
       i9 = i9 + -2 | 0;
       i2 = i2 + -1 | 0;
      }
      i4 = i22 & 8;
      if (i4 | 0) break;
      do if (i14) {
       i4 = HEAP32[i17 + -4 >> 2] | 0;
       if (!i4) {
        i6 = 9;
        break;
       }
       if (!((i4 >>> 0) % 10 | 0)) {
        i7 = 10;
        i6 = 0;
       } else {
        i6 = 0;
        break;
       }
       do {
        i7 = i7 * 10 | 0;
        i6 = i6 + 1 | 0;
       } while (!((i4 >>> 0) % (i7 >>> 0) | 0 | 0));
      } else i6 = 9; while (0);
      i4 = ((i17 - i18 >> 2) * 9 | 0) + -9 | 0;
      if ((i9 | 32 | 0) == 102) {
       i4 = i4 - i6 | 0;
       i4 = (i4 | 0) < 0 ? 0 : i4;
       i2 = (i2 | 0) < (i4 | 0) ? i2 : i4;
       i4 = 0;
       break;
      } else {
       i4 = i4 + i3 - i6 | 0;
       i4 = (i4 | 0) < 0 ? 0 : i4;
       i2 = (i2 | 0) < (i4 | 0) ? i2 : i4;
       i4 = 0;
       break;
      }
     } else i4 = i22 & 8; while (0);
     i10 = i2 | i4;
     i7 = (i10 | 0) != 0 & 1;
     i8 = (i9 | 32 | 0) == 102;
     if (i8) {
      i3 = (i3 | 0) > 0 ? i3 : 0;
      i9 = 0;
     } else {
      i6 = (i3 | 0) < 0 ? i11 : i3;
      i6 = _fmt_u(i6, ((i6 | 0) < 0) << 31 >> 31, i41) | 0;
      if ((i43 - i6 | 0) < 2) do {
       i6 = i6 + -1 | 0;
       HEAP8[i6 >> 0] = 48;
      } while ((i43 - i6 | 0) < 2);
      HEAP8[i6 + -1 >> 0] = (i3 >> 31 & 2) + 43;
      i18 = i6 + -2 | 0;
      HEAP8[i18 >> 0] = i9;
      i3 = i43 - i18 | 0;
      i9 = i18;
     }
     i11 = i20 + 1 + i2 + i7 + i3 | 0;
     _pad(i48, 32, i24, i11, i22);
     if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i21, i20, i48);
     _pad(i48, 48, i24, i11, i22 ^ 65536);
     do if (i8) {
      i6 = i13 >>> 0 > i19 >>> 0 ? i19 : i13;
      i4 = i6;
      do {
       i3 = _fmt_u(HEAP32[i4 >> 2] | 0, 0, i33) | 0;
       do if ((i4 | 0) == (i6 | 0)) {
        if ((i3 | 0) != (i33 | 0)) break;
        HEAP8[i35 >> 0] = 48;
        i3 = i35;
       } else {
        if (i3 >>> 0 <= i46 >>> 0) break;
        _memset(i46 | 0, 48, i3 - i39 | 0) | 0;
        do i3 = i3 + -1 | 0; while (i3 >>> 0 > i46 >>> 0);
       } while (0);
       if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i3, i34 - i3 | 0, i48);
       i4 = i4 + 4 | 0;
      } while (i4 >>> 0 <= i19 >>> 0);
      do if (i10 | 0) {
       if (HEAP32[i48 >> 2] & 32 | 0) break;
       ___fwritex(gb + 41242 | 0, 1, i48);
      } while (0);
      if ((i2 | 0) > 0 & i4 >>> 0 < i17 >>> 0) while (1) {
       i3 = _fmt_u(HEAP32[i4 >> 2] | 0, 0, i33) | 0;
       if (i3 >>> 0 > i46 >>> 0) {
        _memset(i46 | 0, 48, i3 - i39 | 0) | 0;
        do i3 = i3 + -1 | 0; while (i3 >>> 0 > i46 >>> 0);
       }
       if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i3, (i2 | 0) > 9 ? 9 : i2, i48);
       i4 = i4 + 4 | 0;
       i3 = i2 + -9 | 0;
       if (!((i2 | 0) > 9 & i4 >>> 0 < i17 >>> 0)) {
        i2 = i3;
        break;
       } else i2 = i3;
      }
      _pad(i48, 48, i2 + 9 | 0, 9, 0);
     } else {
      i8 = i14 ? i17 : i13 + 4 | 0;
      if ((i2 | 0) > -1) {
       i7 = (i4 | 0) == 0;
       i6 = i13;
       do {
        i3 = _fmt_u(HEAP32[i6 >> 2] | 0, 0, i33) | 0;
        if ((i3 | 0) == (i33 | 0)) {
         HEAP8[i35 >> 0] = 48;
         i3 = i35;
        }
        do if ((i6 | 0) == (i13 | 0)) {
         i4 = i3 + 1 | 0;
         if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i3, 1, i48);
         if (i7 & (i2 | 0) < 1) {
          i3 = i4;
          break;
         }
         if (HEAP32[i48 >> 2] & 32 | 0) {
          i3 = i4;
          break;
         }
         ___fwritex(gb + 41242 | 0, 1, i48);
         i3 = i4;
        } else {
         if (i3 >>> 0 <= i46 >>> 0) break;
         _memset(i46 | 0, 48, i3 + i40 | 0) | 0;
         do i3 = i3 + -1 | 0; while (i3 >>> 0 > i46 >>> 0);
        } while (0);
        i4 = i34 - i3 | 0;
        if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i3, (i2 | 0) > (i4 | 0) ? i4 : i2, i48);
        i2 = i2 - i4 | 0;
        i6 = i6 + 4 | 0;
       } while (i6 >>> 0 < i8 >>> 0 & (i2 | 0) > -1);
      }
      _pad(i48, 48, i2 + 18 | 0, 18, 0);
      if (HEAP32[i48 >> 2] & 32 | 0) break;
      ___fwritex(i9, i43 - i9 | 0, i48);
     } while (0);
     _pad(i48, 32, i24, i11, i22 ^ 8192);
     i2 = (i11 | 0) < (i24 | 0) ? i24 : i11;
    } else {
     i7 = (i9 & 32 | 0) != 0;
     i6 = d5 != d5 | 0.0 != 0.0;
     i3 = i6 ? 0 : i20;
     i7 = i6 ? (i7 ? gb + 41229 | 0 : gb + 41216 | 0) : i7 ? gb + 41208 | 0 : gb + 41212 | 0;
     i6 = i3 + 3 | 0;
     _pad(i48, 32, i24, i6, i4);
     i2 = HEAP32[i48 >> 2] | 0;
     if (!(i2 & 32)) {
      ___fwritex(i21, i3, i48);
      i2 = HEAP32[i48 >> 2] | 0;
     }
     if (!(i2 & 32)) ___fwritex(i7, 3, i48);
     _pad(i48, 32, i24, i6, i22 ^ 8192);
     i2 = (i6 | 0) < (i24 | 0) ? i24 : i6;
    } while (0);
    i3 = i2;
    i7 = i25;
    i13 = i23;
    continue L1;
   }
  default:
   {
    i2 = i13;
    i4 = i22;
    i9 = i7;
    i11 = 0;
    i10 = gb + 39280 | 0;
    i3 = i28;
   }
  } while (0);
  L327 : do if ((i26 | 0) == 66) {
   i4 = i44;
   i3 = HEAP32[i4 >> 2] | 0;
   i4 = HEAP32[i4 + 4 >> 2] | 0;
   i6 = i9 & 32;
   if (!((i3 | 0) == 0 & (i4 | 0) == 0)) {
    i2 = i28;
    do {
     i2 = i2 + -1 | 0;
     HEAP8[i2 >> 0] = HEAPU8[(i3 & 15) + (gb + 39264) >> 0] | i6;
     i3 = _bitshift64Lshr(i3 | 0, i4 | 0, 4) | 0;
     i4 = getTempRet0() | 0;
    } while (!((i3 | 0) == 0 & (i4 | 0) == 0));
    i26 = i44;
    if ((i8 & 8 | 0) == 0 | (HEAP32[i26 >> 2] | 0) == 0 & (HEAP32[i26 + 4 >> 2] | 0) == 0) {
     i3 = i8;
     i8 = 0;
     i6 = gb + 39280 | 0;
     i26 = 79;
    } else {
     i3 = i8;
     i8 = 2;
     i6 = (i9 >> 4) + (gb + 39280) | 0;
     i26 = 79;
    }
   } else {
    i2 = i28;
    i3 = i8;
    i8 = 0;
    i6 = gb + 39280 | 0;
    i26 = 79;
   }
  } else if ((i26 | 0) == 78) {
   i2 = _fmt_u(i2, i3, i28) | 0;
   i3 = i22;
   i8 = i4;
   i26 = 79;
  } else if ((i26 | 0) == 92) {
   i26 = 0;
   i22 = _memchr(i3, 0, i7) | 0;
   i21 = (i22 | 0) == 0;
   i2 = i3;
   i9 = i21 ? i7 : i22 - i3 | 0;
   i11 = 0;
   i10 = gb + 39280 | 0;
   i3 = i21 ? i3 + i7 | 0 : i22;
  } else if ((i26 | 0) == 96) {
   i26 = 0;
   i4 = 0;
   i3 = 0;
   i8 = i2;
   while (1) {
    i6 = HEAP32[i8 >> 2] | 0;
    if (!i6) break;
    i3 = _wcrtomb(i49, i6) | 0;
    if ((i3 | 0) < 0 | i3 >>> 0 > (i7 - i4 | 0) >>> 0) break;
    i4 = i3 + i4 | 0;
    if (i7 >>> 0 > i4 >>> 0) i8 = i8 + 4 | 0; else break;
   }
   if ((i3 | 0) < 0) {
    i1 = -1;
    break L1;
   }
   _pad(i48, 32, i24, i4, i22);
   if (!i4) {
    i2 = 0;
    i26 = 107;
   } else {
    i6 = 0;
    while (1) {
     i3 = HEAP32[i2 >> 2] | 0;
     if (!i3) {
      i2 = i4;
      i26 = 107;
      break L327;
     }
     i3 = _wcrtomb(i49, i3) | 0;
     i6 = i3 + i6 | 0;
     if ((i6 | 0) > (i4 | 0)) {
      i2 = i4;
      i26 = 107;
      break L327;
     }
     if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i49, i3, i48);
     if (i6 >>> 0 >= i4 >>> 0) {
      i2 = i4;
      i26 = 107;
      break;
     } else i2 = i2 + 4 | 0;
    }
   }
  } while (0);
  if ((i26 | 0) == 107) {
   i26 = 0;
   _pad(i48, 32, i24, i2, i22 ^ 8192);
   i3 = (i24 | 0) > (i2 | 0) ? i24 : i2;
   i7 = i25;
   i13 = i23;
   continue;
  }
  if ((i26 | 0) == 79) {
   i26 = 0;
   i4 = (i7 | 0) > -1 ? i3 & -65537 : i3;
   i3 = i44;
   i3 = (HEAP32[i3 >> 2] | 0) != 0 | (HEAP32[i3 + 4 >> 2] | 0) != 0;
   if ((i7 | 0) != 0 | i3) {
    i9 = (i3 & 1 ^ 1) + (i36 - i2) | 0;
    i9 = (i7 | 0) > (i9 | 0) ? i7 : i9;
    i11 = i8;
    i10 = i6;
    i3 = i28;
   } else {
    i2 = i28;
    i9 = 0;
    i11 = i8;
    i10 = i6;
    i3 = i28;
   }
  }
  i8 = i3 - i2 | 0;
  i6 = (i9 | 0) < (i8 | 0) ? i8 : i9;
  i7 = i11 + i6 | 0;
  i3 = (i24 | 0) < (i7 | 0) ? i7 : i24;
  _pad(i48, 32, i3, i7, i4);
  if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i10, i11, i48);
  _pad(i48, 48, i3, i7, i4 ^ 65536);
  _pad(i48, 48, i6, i8, 0);
  if (!(HEAP32[i48 >> 2] & 32)) ___fwritex(i2, i8, i48);
  _pad(i48, 32, i3, i7, i4 ^ 8192);
  i7 = i25;
  i13 = i23;
 }
 L361 : do if ((i26 | 0) == 254) if (!i48) if (!i7) i1 = 0; else {
  i1 = 1;
  while (1) {
   i2 = HEAP32[i53 + (i1 << 2) >> 2] | 0;
   if (!i2) break;
   _pop_arg(i52 + (i1 << 3) | 0, i2, i51);
   i1 = i1 + 1 | 0;
   if ((i1 | 0) >= 10) {
    i1 = 1;
    break L361;
   }
  }
  while (1) {
   i1 = i1 + 1 | 0;
   if ((i1 | 0) >= 10) {
    i1 = 1;
    break L361;
   }
   if (HEAP32[i53 + (i1 << 2) >> 2] | 0) {
    i1 = -1;
    break;
   }
  }
 } while (0);
 STACKTOP = i54;
 return i1 | 0;
}
function _quiet_encoder_profile_str(i1, i3) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 var d2 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + 304 | 0;
 i12 = i21 + 32 | 0;
 i11 = i21 + 24 | 0;
 i10 = i21 + 16 | 0;
 i9 = i21 + 8 | 0;
 i4 = i21;
 i18 = i21 + 288 | 0;
 i19 = _json_loads(i1, i21 + 36 | 0) | 0;
 if (!i19) {
  i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
   HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8840 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8840 + 8 >> 2] = 0;
    HEAP32[gb + 8840 + 4 >> 2] = 0;
    i3 = HEAP32[gb + 8840 + 44 >> 2] | 0;
    HEAP32[gb + 8840 + 28 >> 2] = i3;
    HEAP32[gb + 8840 + 20 >> 2] = i3;
    i1 = i3 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8840 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8840 >> 2] = i1 | 32;
   i20 = 0;
   STACKTOP = i21;
   return i20 | 0;
  } else i3 = HEAP32[gb + 8840 + 20 >> 2] | 0; while (0);
  if ((i1 - i3 | 0) >>> 0 < 23) {
   if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 10300 | 0, 23) | 0) >>> 0 < 23) {
    i20 = 0;
    STACKTOP = i21;
    return i20 | 0;
   }
  } else {
   i1 = gb + 10300 | 0;
   i5 = i3 + 23 | 0;
   do {
    HEAP8[i3 >> 0] = HEAP8[i1 >> 0] | 0;
    i3 = i3 + 1 | 0;
    i1 = i1 + 1 | 0;
   } while ((i3 | 0) < (i5 | 0));
   HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 23;
  }
  i4 = HEAP8[gb + 8840 + 75 >> 0] | 0;
  if (i4 << 24 >> 24 != 10) {
   i1 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   if (i1 >>> 0 < i3 >>> 0) {
    HEAP32[gb + 8840 + 20 >> 2] = i1 + 1;
    HEAP8[i1 >> 0] = 10;
    i20 = 0;
    STACKTOP = i21;
    return i20 | 0;
   }
  } else i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
  HEAP8[i18 >> 0] = 10;
  do if (!i3) {
   i4 = HEAP16[gb + 8840 + 74 >> 1] | 0;
   i1 = (i4 & 65535) << 24 >> 24;
   HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8840 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8840 + 8 >> 2] = 0;
    HEAP32[gb + 8840 + 4 >> 2] = 0;
    i5 = HEAP32[gb + 8840 + 44 >> 2] | 0;
    HEAP32[gb + 8840 + 28 >> 2] = i5;
    HEAP32[gb + 8840 + 20 >> 2] = i5;
    i3 = i5 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8840 + 16 >> 2] = i3;
    i1 = (i4 & 65535) >>> 8 & 255;
    i20 = 19;
    break;
   } else {
    HEAP32[gb + 8840 >> 2] = i1 | 32;
    break;
   }
  } else {
   i5 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   i1 = i4;
   i20 = 19;
  } while (0);
  do if ((i20 | 0) == 19) if (i5 >>> 0 >= i3 >>> 0 | i1 << 24 >> 24 == 10) {
   mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i18 | 0, 1) | 0;
   break;
  } else {
   HEAP32[gb + 8840 + 20 >> 2] = i5 + 1;
   HEAP8[i5 >> 0] = 10;
   break;
  } while (0);
  i20 = 0;
  STACKTOP = i21;
  return i20 | 0;
 }
 L36 : do if (((i3 | 0) != 0 ? (HEAP32[i19 >> 2] | 0) == 0 : 0) ? (i15 = _hashtable_get(i19 + 8 | 0, i3) | 0, (i15 | 0) != 0) : 0) {
  i4 = _malloc(96) | 0;
  if (!i4) {
   i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
    HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8840 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8840 + 8 >> 2] = 0;
     HEAP32[gb + 8840 + 4 >> 2] = 0;
     i3 = HEAP32[gb + 8840 + 44 >> 2] | 0;
     HEAP32[gb + 8840 + 28 >> 2] = i3;
     HEAP32[gb + 8840 + 20 >> 2] = i3;
     i1 = i3 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8840 + 16 >> 2] = i1;
     break;
    } else {
     HEAP32[gb + 8840 >> 2] = i1 | 32;
     i4 = 0;
     break L36;
    }
   } else i3 = HEAP32[gb + 8840 + 20 >> 2] | 0; while (0);
   if ((i1 - i3 | 0) >>> 0 < 36) {
    if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 9878 | 0, 36) | 0) >>> 0 < 36) {
     i4 = 0;
     break;
    }
   } else {
    i1 = gb + 9878 | 0;
    i5 = i3 + 36 | 0;
    do {
     HEAP8[i3 >> 0] = HEAP8[i1 >> 0] | 0;
     i3 = i3 + 1 | 0;
     i1 = i1 + 1 | 0;
    } while ((i3 | 0) < (i5 | 0));
    HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 36;
   }
   i3 = HEAP8[gb + 8840 + 75 >> 0] | 0;
   if (i3 << 24 >> 24 != 10) {
    i4 = HEAP32[gb + 8840 + 20 >> 2] | 0;
    i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
    if (i4 >>> 0 < i1 >>> 0) {
     HEAP32[gb + 8840 + 20 >> 2] = i4 + 1;
     HEAP8[i4 >> 0] = 10;
     i4 = 0;
     break;
    }
   } else i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   HEAP8[i18 >> 0] = 10;
   do if (!i1) {
    i3 = HEAP16[gb + 8840 + 74 >> 1] | 0;
    i1 = (i3 & 65535) << 24 >> 24;
    HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8840 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8840 + 8 >> 2] = 0;
     HEAP32[gb + 8840 + 4 >> 2] = 0;
     i4 = HEAP32[gb + 8840 + 44 >> 2] | 0;
     HEAP32[gb + 8840 + 28 >> 2] = i4;
     HEAP32[gb + 8840 + 20 >> 2] = i4;
     i1 = i4 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8840 + 16 >> 2] = i1;
     i3 = (i3 & 65535) >>> 8 & 255;
     i20 = 47;
     break;
    } else {
     HEAP32[gb + 8840 >> 2] = i1 | 32;
     break;
    }
   } else {
    i4 = HEAP32[gb + 8840 + 20 >> 2] | 0;
    i20 = 47;
   } while (0);
   do if ((i20 | 0) == 47) if (i4 >>> 0 >= i1 >>> 0 | i3 << 24 >> 24 == 10) {
    mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i18 | 0, 1) | 0;
    break;
   } else {
    HEAP32[gb + 8840 + 20 >> 2] = i4 + 1;
    HEAP8[i4 >> 0] = 10;
    break;
   } while (0);
   i4 = 0;
   break;
  }
  if (HEAP32[i4 + -4 >> 2] & 3 | 0) {
   i3 = i4;
   i5 = i3 + 96 | 0;
   do {
    HEAP8[i3 >> 0] = 0;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) < (i5 | 0));
  }
  do if (!(HEAP32[i15 >> 2] | 0)) {
   i13 = i15 + 8 | 0;
   i1 = _hashtable_get(i13, gb + 9915 | 0) | 0;
   if (i1 | 0) {
    if ((HEAP32[i1 >> 2] | 0) == 2) i8 = HEAP32[i1 + 8 >> 2] | 0; else i8 = 0;
    i7 = HEAP8[i8 >> 0] | 0;
    switch (i7 << 24 >> 24) {
    case 117:
     {
      i1 = i8;
      i3 = gb + 29657 | 0;
      do {
       i1 = i1 + 1 | 0;
       i3 = i3 + 1 | 0;
       i5 = HEAP8[i1 >> 0] | 0;
       i6 = HEAP8[i3 >> 0] | 0;
      } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
      if (i5 << 24 >> 24 == i6 << 24 >> 24) i1 = 0; else switch (i7 << 24 >> 24) {
      case 110:
       {
        i1 = i8;
        i3 = gb + 10724 | 0;
        i20 = 59;
        break;
       }
      case 99:
       {
        i1 = i8;
        i3 = gb + 10361 | 0;
        i20 = 62;
        break;
       }
      default:
       i20 = 72;
      }
      break;
     }
    case 110:
     {
      i1 = i8;
      i3 = gb + 10724 | 0;
      i20 = 59;
      break;
     }
    case 99:
     {
      i1 = i8;
      i3 = gb + 10361 | 0;
      i20 = 62;
      break;
     }
    default:
     i20 = 72;
    }
    if ((i20 | 0) == 59) {
     while (1) {
      i20 = 0;
      i1 = i1 + 1 | 0;
      i3 = i3 + 1 | 0;
      i5 = HEAP8[i1 >> 0] | 0;
      i6 = HEAP8[i3 >> 0] | 0;
      if (i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24) break; else i20 = 59;
     }
     if (i5 << 24 >> 24 != i6 << 24 >> 24) if (i7 << 24 >> 24 == 99) {
      i1 = i8;
      i3 = gb + 10361 | 0;
      i20 = 62;
     } else i20 = 72; else i1 = 1;
    }
    if ((i20 | 0) == 62) {
     while (1) {
      i20 = 0;
      i1 = i1 + 1 | 0;
      i3 = i3 + 1 | 0;
      i5 = HEAP8[i1 >> 0] | 0;
      i6 = HEAP8[i3 >> 0] | 0;
      if (i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24) break; else i20 = 62;
     }
     if (i5 << 24 >> 24 != i6 << 24 >> 24) {
      i1 = i8;
      i3 = gb + 10370 | 0;
      do {
       i1 = i1 + 1 | 0;
       i3 = i3 + 1 | 0;
       i5 = HEAP8[i1 >> 0] | 0;
       i6 = HEAP8[i3 >> 0] | 0;
      } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
      if (i5 << 24 >> 24 != i6 << 24 >> 24) {
       i1 = i8;
       i3 = gb + 10375 | 0;
       do {
        i1 = i1 + 1 | 0;
        i3 = i3 + 1 | 0;
        i5 = HEAP8[i1 >> 0] | 0;
        i6 = HEAP8[i3 >> 0] | 0;
       } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
       if (i5 << 24 >> 24 != i6 << 24 >> 24) {
        i1 = i8;
        i3 = gb + 10381 | 0;
        do {
         i1 = i1 + 1 | 0;
         i3 = i3 + 1 | 0;
         i5 = HEAP8[i1 >> 0] | 0;
         i6 = HEAP8[i3 >> 0] | 0;
        } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
        if (i5 << 24 >> 24 != i6 << 24 >> 24) {
         i1 = i8;
         i3 = gb + 10387 | 0;
         do {
          i1 = i1 + 1 | 0;
          i3 = i3 + 1 | 0;
          i5 = HEAP8[i1 >> 0] | 0;
          i6 = HEAP8[i3 >> 0] | 0;
         } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
         if (i5 << 24 >> 24 == i6 << 24 >> 24) i1 = 6; else i20 = 72;
        } else i1 = 5;
       } else i1 = 4;
      } else i1 = 3;
     } else i1 = 2;
    }
    if ((i20 | 0) == 72) {
     HEAP32[i9 >> 2] = i8;
     _fprintf(gb + 8728 | 0, gb + 10393 | 0, i9);
     i1 = 0;
    }
    HEAP32[i4 + 64 >> 2] = i1;
   }
   if (!(HEAP32[i15 >> 2] | 0)) {
    i1 = _hashtable_get(i13, gb + 9931 | 0) | 0;
    if (i1 | 0) {
     if ((HEAP32[i1 >> 2] | 0) == 2) i9 = HEAP32[i1 + 8 >> 2] | 0; else i9 = 0;
     i8 = HEAP8[i9 >> 0] | 0;
     L117 : do if (!(i8 << 24 >> 24)) {
      i1 = 0;
      while (1) {
       if (!(HEAP8[HEAP32[gb + 0 + (i1 << 3) >> 2] >> 0] | 0)) break L117;
       i1 = i1 + 1 | 0;
       if (i1 >>> 0 >= 28) {
        i20 = 85;
        break;
       }
      }
     } else {
      i1 = 0;
      while (1) {
       i5 = HEAP32[gb + 0 + (i1 << 3) >> 2] | 0;
       i3 = HEAP8[i5 >> 0] | 0;
       if (i8 << 24 >> 24 == i3 << 24 >> 24) {
        i7 = i9;
        do {
         i7 = i7 + 1 | 0;
         i5 = i5 + 1 | 0;
         i6 = HEAP8[i7 >> 0] | 0;
         i3 = HEAP8[i5 >> 0] | 0;
        } while (!(i6 << 24 >> 24 == 0 ? 1 : i6 << 24 >> 24 != i3 << 24 >> 24));
        i5 = i6;
       } else i5 = i8;
       if (i5 << 24 >> 24 == i3 << 24 >> 24) break L117;
       i1 = i1 + 1 | 0;
       if (i1 >>> 0 >= 28) {
        i20 = 85;
        break;
       }
      }
     } while (0);
     if ((i20 | 0) == 85) {
      HEAP32[i10 >> 2] = i9;
      _fprintf(gb + 8728 | 0, gb + 11549 | 0, i10);
      i1 = 0;
     }
     HEAP32[i4 + 68 >> 2] = i1;
    }
    if (!(HEAP32[i15 >> 2] | 0)) {
     i1 = _hashtable_get(i13, gb + 9948 | 0) | 0;
     if (i1 | 0) {
      if ((HEAP32[i1 >> 2] | 0) == 2) i9 = HEAP32[i1 + 8 >> 2] | 0; else i9 = 0;
      i8 = HEAP8[i9 >> 0] | 0;
      L138 : do if (!(i8 << 24 >> 24)) {
       i1 = 0;
       while (1) {
        if (!(HEAP8[HEAP32[gb + 0 + (i1 << 3) >> 2] >> 0] | 0)) break L138;
        i1 = i1 + 1 | 0;
        if (i1 >>> 0 >= 28) {
         i20 = 98;
         break;
        }
       }
      } else {
       i1 = 0;
       while (1) {
        i5 = HEAP32[gb + 0 + (i1 << 3) >> 2] | 0;
        i3 = HEAP8[i5 >> 0] | 0;
        if (i8 << 24 >> 24 == i3 << 24 >> 24) {
         i7 = i9;
         do {
          i7 = i7 + 1 | 0;
          i5 = i5 + 1 | 0;
          i6 = HEAP8[i7 >> 0] | 0;
          i3 = HEAP8[i5 >> 0] | 0;
         } while (!(i6 << 24 >> 24 == 0 ? 1 : i6 << 24 >> 24 != i3 << 24 >> 24));
         i5 = i6;
        } else i5 = i8;
        if (i5 << 24 >> 24 == i3 << 24 >> 24) break L138;
        i1 = i1 + 1 | 0;
        if (i1 >>> 0 >= 28) {
         i20 = 98;
         break;
        }
       }
      } while (0);
      if ((i20 | 0) == 98) {
       HEAP32[i11 >> 2] = i9;
       _fprintf(gb + 8728 | 0, gb + 11549 | 0, i11);
       i1 = 0;
      }
      HEAP32[i4 + 72 >> 2] = i1;
     }
     if (!(HEAP32[i15 >> 2] | 0)) {
      i1 = _hashtable_get(i13, gb + 9965 | 0) | 0;
      L154 : do if (i1 | 0) {
       if ((HEAP32[i1 >> 2] | 0) == 2) i9 = HEAP32[i1 + 8 >> 2] | 0; else i9 = 0;
       do if ((HEAP8[i9 >> 0] | 0) == 103) {
        i1 = i9;
        i3 = gb + 9976 | 0;
        do {
         i1 = i1 + 1 | 0;
         i3 = i3 + 1 | 0;
         i5 = HEAP8[i1 >> 0] | 0;
         i6 = HEAP8[i3 >> 0] | 0;
        } while (!(i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 != i6 << 24 >> 24));
        i1 = i4 + 60 | 0;
        if (i5 << 24 >> 24 != i6 << 24 >> 24) break;
        HEAP32[i1 >> 2] = 2;
        break L154;
       } else i1 = i4 + 60 | 0; while (0);
       HEAP32[i1 >> 2] = 1;
       i8 = HEAP8[i9 >> 0] | 0;
       L166 : do if (!(i8 << 24 >> 24)) {
        i1 = 0;
        while (1) {
         if (!(HEAP8[HEAP32[gb + 508 + (i1 << 4) >> 2] >> 0] | 0)) break L166;
         i1 = i1 + 1 | 0;
         if (i1 >>> 0 >= 60) {
          i20 = 116;
          break;
         }
        }
       } else {
        i1 = 0;
        while (1) {
         i5 = HEAP32[gb + 508 + (i1 << 4) >> 2] | 0;
         i3 = HEAP8[i5 >> 0] | 0;
         if (i8 << 24 >> 24 == i3 << 24 >> 24) {
          i7 = i9;
          do {
           i7 = i7 + 1 | 0;
           i5 = i5 + 1 | 0;
           i6 = HEAP8[i7 >> 0] | 0;
           i3 = HEAP8[i5 >> 0] | 0;
          } while (!(i6 << 24 >> 24 == 0 ? 1 : i6 << 24 >> 24 != i3 << 24 >> 24));
          i5 = i6;
         } else i5 = i8;
         if (i5 << 24 >> 24 == i3 << 24 >> 24) break L166;
         i1 = i1 + 1 | 0;
         if (i1 >>> 0 >= 60) {
          i20 = 116;
          break;
         }
        }
       } while (0);
       if ((i20 | 0) == 116) {
        HEAP32[i12 >> 2] = i9;
        _fprintf(gb + 8728 | 0, gb + 31917 | 0, i12);
        i1 = 0;
       }
       HEAP32[i4 + 76 >> 2] = i1;
      } while (0);
      if (!(HEAP32[i15 >> 2] | 0)) {
       i1 = _hashtable_get(i13, gb + 9981 | 0) | 0;
       if (i1 | 0) {
        if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
        HEAP32[i4 + 80 >> 2] = i1;
       }
       if (!(HEAP32[i15 >> 2] | 0)) {
        i5 = _hashtable_get(i13, gb + 9994 | 0) | 0;
        do if (i5 | 0) {
         i1 = i4 + 60 | 0;
         if ((HEAP32[i1 >> 2] | 0) == 2) {
          i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
          do if (!i1) {
           i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
           HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
           i1 = HEAP32[gb + 8840 >> 2] | 0;
           if (!(i1 & 8)) {
            HEAP32[gb + 8840 + 8 >> 2] = 0;
            HEAP32[gb + 8840 + 4 >> 2] = 0;
            i3 = HEAP32[gb + 8840 + 44 >> 2] | 0;
            HEAP32[gb + 8840 + 28 >> 2] = i3;
            HEAP32[gb + 8840 + 20 >> 2] = i3;
            i1 = i3 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
            HEAP32[gb + 8840 + 16 >> 2] = i1;
            break;
           } else {
            HEAP32[gb + 8840 >> 2] = i1 | 32;
            i4 = 0;
            break L36;
           }
          } else i3 = HEAP32[gb + 8840 + 20 >> 2] | 0; while (0);
          if ((i1 - i3 | 0) >>> 0 < 46) {
           if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 9999 | 0, 46) | 0) >>> 0 < 46) {
            i4 = 0;
            break L36;
           }
          } else {
           i1 = gb + 9999 | 0;
           i5 = i3 + 46 | 0;
           do {
            HEAP8[i3 >> 0] = HEAP8[i1 >> 0] | 0;
            i3 = i3 + 1 | 0;
            i1 = i1 + 1 | 0;
           } while ((i3 | 0) < (i5 | 0));
           HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 46;
          }
          i4 = HEAP8[gb + 8840 + 75 >> 0] | 0;
          do if (i4 << 24 >> 24 == 10) i3 = HEAP32[gb + 8840 + 16 >> 2] | 0; else {
           i1 = HEAP32[gb + 8840 + 20 >> 2] | 0;
           i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
           if (i1 >>> 0 >= i3 >>> 0) break;
           HEAP32[gb + 8840 + 20 >> 2] = i1 + 1;
           HEAP8[i1 >> 0] = 10;
           i4 = 0;
           break L36;
          } while (0);
          HEAP8[i18 >> 0] = 10;
          do if (!i3) {
           i4 = HEAP16[gb + 8840 + 74 >> 1] | 0;
           i1 = (i4 & 65535) << 24 >> 24;
           HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
           i1 = HEAP32[gb + 8840 >> 2] | 0;
           if (!(i1 & 8)) {
            HEAP32[gb + 8840 + 8 >> 2] = 0;
            HEAP32[gb + 8840 + 4 >> 2] = 0;
            i5 = HEAP32[gb + 8840 + 44 >> 2] | 0;
            HEAP32[gb + 8840 + 28 >> 2] = i5;
            HEAP32[gb + 8840 + 20 >> 2] = i5;
            i3 = i5 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
            HEAP32[gb + 8840 + 16 >> 2] = i3;
            i1 = (i4 & 65535) >>> 8 & 255;
            i20 = 143;
            break;
           } else {
            HEAP32[gb + 8840 >> 2] = i1 | 32;
            break;
           }
          } else {
           i5 = HEAP32[gb + 8840 + 20 >> 2] | 0;
           i1 = i4;
           i20 = 143;
          } while (0);
          do if ((i20 | 0) == 143) if (i5 >>> 0 >= i3 >>> 0 | i1 << 24 >> 24 == 10) {
           mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i18 | 0, 1) | 0;
           break;
          } else {
           HEAP32[gb + 8840 + 20 >> 2] = i5 + 1;
           HEAP8[i5 >> 0] = 10;
           break;
          } while (0);
          i4 = 0;
          break L36;
         }
         HEAP32[i1 >> 2] = 0;
         if (HEAP32[i5 >> 2] | 0) break;
         i3 = i5 + 8 | 0;
         i1 = _hashtable_get(i3, gb + 10046 | 0) | 0;
         if (i1 | 0) {
          if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
          HEAP32[i4 >> 2] = i1;
         }
         if (HEAP32[i5 >> 2] | 0) break;
         i1 = _hashtable_get(i3, gb + 10062 | 0) | 0;
         if (i1 | 0) {
          if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
          HEAP32[i4 + 4 >> 2] = i1;
         }
         if (HEAP32[i5 >> 2] | 0) break;
         i1 = _hashtable_get(i3, gb + 10083 | 0) | 0;
         if (i1 | 0) {
          if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
          HEAP32[i4 + 8 >> 2] = i1;
         }
         if (HEAP32[i5 >> 2] | 0) break;
         i1 = _hashtable_get(i3, gb + 10096 | 0) | 0;
         if (i1 | 0) {
          if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
          HEAP32[i4 + 12 >> 2] = i1;
         }
         if (HEAP32[i5 >> 2] | 0) break;
         i1 = _hashtable_get(i3, gb + 10106 | 0) | 0;
         if (!i1) break;
         if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
         HEAP32[i4 + 16 >> 2] = i1;
        } while (0);
        if (HEAP32[i15 >> 2] | 0) {
         i20 = 204;
         break;
        }
        i3 = _hashtable_get(i13, gb + 10117 | 0) | 0;
        do if (i3 | 0) {
         if (HEAP32[i3 >> 2] | 0) break;
         i5 = i3 + 8 | 0;
         i1 = _hashtable_get(i5, gb + 10128 | 0) | 0;
         if (i1 | 0) {
          switch (HEAP32[i1 >> 2] | 0) {
          case 3:
           {
            i18 = i1 + 8 | 0;
            d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
            break;
           }
          case 4:
           {
            d2 = +HEAPF64[i1 + 8 >> 3];
            break;
           }
          default:
           d2 = 0.0;
          }
          HEAPF32[i4 + 32 >> 2] = d2 / 44100.0 * 3.141592653589793 * 2.0;
         }
         if (HEAP32[i3 >> 2] | 0) break;
         i1 = _hashtable_get(i5, gb + 10145 | 0) | 0;
         if (!i1) break;
         switch (HEAP32[i1 >> 2] | 0) {
         case 3:
          {
           i18 = i1 + 8 | 0;
           d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
           break;
          }
         case 4:
          {
           d2 = +HEAPF64[i1 + 8 >> 3];
           break;
          }
         default:
          d2 = 0.0;
         }
         HEAPF32[i4 + 36 >> 2] = d2;
        } while (0);
        if (HEAP32[i15 >> 2] | 0) {
         i20 = 204;
         break;
        }
        i3 = _hashtable_get(i13, gb + 10150 | 0) | 0;
        if (!i3) {
         i20 = 204;
         break;
        }
        if (HEAP32[i3 >> 2] | 0) break;
        i5 = i3 + 8 | 0;
        i1 = _hashtable_get(i5, gb + 10164 | 0) | 0;
        if (i1 | 0) {
         if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
         HEAP32[i4 + 20 >> 2] = i1;
        }
        if (HEAP32[i3 >> 2] | 0) break;
        i1 = _hashtable_get(i5, gb + 10183 | 0) | 0;
        if (i1 | 0) {
         if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
         HEAP32[i4 + 24 >> 2] = i1;
        }
        if (HEAP32[i3 >> 2] | 0) break;
        i1 = _hashtable_get(i5, gb + 10196 | 0) | 0;
        if (!i1) break;
        switch (HEAP32[i1 >> 2] | 0) {
        case 3:
         {
          i18 = i1 + 8 | 0;
          d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
          break;
         }
        case 4:
         {
          d2 = +HEAPF64[i1 + 8 >> 3];
          break;
         }
        default:
         d2 = 0.0;
        }
        HEAPF32[i4 + 28 >> 2] = d2;
       } else i20 = 204;
      } else i20 = 204;
     } else i20 = 204;
    } else i20 = 204;
   } else i20 = 204;
  } else i20 = 204; while (0);
  if ((i20 | 0) == 204) HEAP32[i4 + 20 >> 2] = 1;
  if (!(HEAP32[i15 >> 2] | 0)) {
   i3 = i15 + 8 | 0;
   i1 = _hashtable_get(i3, gb + 10213 | 0) | 0;
   if ((i1 | 0 ? (HEAP32[i1 >> 2] | 0) == 0 : 0) ? (i14 = _hashtable_get(i1 + 8 | 0, gb + 10229 | 0) | 0, i14 | 0) : 0) {
    switch (HEAP32[i14 >> 2] | 0) {
    case 3:
     {
      i18 = i14 + 8 | 0;
      d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
      break;
     }
    case 4:
     {
      d2 = +HEAPF64[i14 + 8 >> 3];
      break;
     }
    default:
     d2 = 0.0;
    }
    HEAPF32[i4 + 40 >> 2] = d2;
   }
   if (((HEAP32[i15 >> 2] | 0) == 0 ? (i16 = _hashtable_get(i3, gb + 10245 | 0) | 0, (i16 | 0) != 0) : 0) ? (HEAP32[i16 >> 2] | 0) == 0 : 0) {
    i3 = i16 + 8 | 0;
    i1 = _hashtable_get(i3, gb + 10255 | 0) | 0;
    if (i1 | 0) {
     if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
     HEAP32[i4 + 44 >> 2] = i1;
    }
    if (!(HEAP32[i16 >> 2] | 0)) {
     i1 = _hashtable_get(i3, gb + 10261 | 0) | 0;
     if (i1 | 0) {
      switch (HEAP32[i1 >> 2] | 0) {
      case 3:
       {
        i18 = i1 + 8 | 0;
        d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
        break;
       }
      case 4:
       {
        d2 = +HEAPF64[i1 + 8 >> 3];
        break;
       }
      default:
       d2 = 0.0;
      }
      HEAPF32[i4 + 48 >> 2] = d2;
     }
     if (!(HEAP32[i16 >> 2] | 0)) {
      i1 = _hashtable_get(i3, gb + 10271 | 0) | 0;
      if (i1 | 0) {
       switch (HEAP32[i1 >> 2] | 0) {
       case 3:
        {
         i18 = i1 + 8 | 0;
         d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
         break;
        }
       case 4:
        {
         d2 = +HEAPF64[i1 + 8 >> 3];
         break;
        }
       default:
        d2 = 0.0;
       }
       HEAPF32[i4 + 52 >> 2] = d2;
      }
      if ((HEAP32[i16 >> 2] | 0) == 0 ? (i17 = _hashtable_get(i3, gb + 10283 | 0) | 0, (i17 | 0) != 0) : 0) {
       switch (HEAP32[i17 >> 2] | 0) {
       case 3:
        {
         i18 = i17 + 8 | 0;
         d2 = +((HEAP32[i18 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i18 + 4 >> 2] | 0);
         break;
        }
       case 4:
        {
         d2 = +HEAPF64[i17 + 8 >> 3];
         break;
        }
       default:
        d2 = 0.0;
       }
       HEAP32[i4 + 56 >> 2] = ~~d2 >>> 0;
      }
     }
    }
   }
  }
 } else i20 = 26; while (0);
 if ((i20 | 0) == 26) {
  HEAP32[i4 >> 2] = i3;
  _printf(gb + 9849 | 0, i4);
  i4 = 0;
 }
 i1 = i19 + 4 | 0;
 i3 = HEAP32[i1 >> 2] | 0;
 if ((i3 | 0) == -1) {
  i20 = i4;
  STACKTOP = i21;
  return i20 | 0;
 }
 i20 = i3 + -1 | 0;
 HEAP32[i1 >> 2] = i20;
 if (i20 | 0) {
  i20 = i4;
  STACKTOP = i21;
  return i20 | 0;
 }
 _json_delete(i19);
 i20 = i4;
 STACKTOP = i21;
 return i20 | 0;
}

function _fft_execute_dft_16(i5) {
 i5 = i5 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i73 = 0, i74 = 0, i75 = 0, d76 = 0.0, d77 = 0.0, d78 = 0.0, d79 = 0.0, d80 = 0.0, d81 = 0.0, d82 = 0.0, d83 = 0.0, d84 = 0.0, d85 = 0.0, d86 = 0.0, d87 = 0.0, d88 = 0.0, d89 = 0.0, d90 = 0.0, i91 = 0, i92 = 0, i93 = 0, i94 = 0, i95 = 0, i96 = 0, i97 = 0, i98 = 0;
 i75 = STACKTOP;
 STACKTOP = STACKTOP + 432 | 0;
 i9 = i75 + 424 | 0;
 i11 = i75 + 416 | 0;
 i13 = i75 + 408 | 0;
 i15 = i75 + 400 | 0;
 i10 = i75 + 392 | 0;
 i12 = i75 + 384 | 0;
 i14 = i75 + 376 | 0;
 i16 = i75 + 368 | 0;
 i18 = i75 + 304 | 0;
 i20 = i75 + 288 | 0;
 i21 = i75 + 360 | 0;
 i23 = i75 + 352 | 0;
 i25 = i75 + 272 | 0;
 i27 = i75 + 256 | 0;
 i17 = i75 + 240 | 0;
 i19 = i75 + 224 | 0;
 i22 = i75 + 344 | 0;
 i24 = i75 + 336 | 0;
 i26 = i75 + 208 | 0;
 i28 = i75 + 192 | 0;
 i33 = i75 + 176 | 0;
 i39 = i75 + 160 | 0;
 i41 = i75 + 144 | 0;
 i47 = i75 + 328 | 0;
 i49 = i75 + 128 | 0;
 i55 = i75 + 112 | 0;
 i57 = i75 + 96 | 0;
 i34 = i75 + 80 | 0;
 i40 = i75 + 64 | 0;
 i42 = i75 + 48 | 0;
 i48 = i75 + 320 | 0;
 i50 = i75 + 32 | 0;
 i56 = i75 + 16 | 0;
 i58 = i75;
 i71 = HEAP32[i5 + 4 >> 2] | 0;
 i31 = HEAP32[i5 + 8 >> 2] | 0;
 i32 = (HEAP32[i5 + 12 >> 2] | 0) == 1;
 i98 = HEAP32[i71 + 4 >> 2] | 0;
 i5 = i31 + 4 | 0;
 HEAP32[i31 >> 2] = HEAP32[i71 >> 2];
 HEAP32[i5 >> 2] = i98;
 i98 = HEAP32[i71 + 68 >> 2] | 0;
 i35 = i31 + 8 | 0;
 i36 = i31 + 12 | 0;
 HEAP32[i35 >> 2] = HEAP32[i71 + 64 >> 2];
 HEAP32[i36 >> 2] = i98;
 i98 = HEAP32[i71 + 36 >> 2] | 0;
 i45 = i31 + 16 | 0;
 i46 = i31 + 20 | 0;
 HEAP32[i45 >> 2] = HEAP32[i71 + 32 >> 2];
 HEAP32[i46 >> 2] = i98;
 i98 = HEAP32[i71 + 100 >> 2] | 0;
 i53 = i31 + 24 | 0;
 i54 = i31 + 28 | 0;
 HEAP32[i53 >> 2] = HEAP32[i71 + 96 >> 2];
 HEAP32[i54 >> 2] = i98;
 i98 = HEAP32[i71 + 20 >> 2] | 0;
 i61 = i31 + 32 | 0;
 i62 = i31 + 36 | 0;
 HEAP32[i61 >> 2] = HEAP32[i71 + 16 >> 2];
 HEAP32[i62 >> 2] = i98;
 i98 = HEAP32[i71 + 84 >> 2] | 0;
 i65 = i31 + 40 | 0;
 i66 = i31 + 44 | 0;
 HEAP32[i65 >> 2] = HEAP32[i71 + 80 >> 2];
 HEAP32[i66 >> 2] = i98;
 i98 = HEAP32[i71 + 52 >> 2] | 0;
 i69 = i31 + 48 | 0;
 i70 = i31 + 52 | 0;
 HEAP32[i69 >> 2] = HEAP32[i71 + 48 >> 2];
 HEAP32[i70 >> 2] = i98;
 i98 = HEAP32[i71 + 116 >> 2] | 0;
 i73 = i31 + 56 | 0;
 i74 = i31 + 60 | 0;
 HEAP32[i73 >> 2] = HEAP32[i71 + 112 >> 2];
 HEAP32[i74 >> 2] = i98;
 i98 = HEAP32[i71 + 12 >> 2] | 0;
 i29 = i31 + 64 | 0;
 i30 = i31 + 68 | 0;
 HEAP32[i29 >> 2] = HEAP32[i71 + 8 >> 2];
 HEAP32[i30 >> 2] = i98;
 i98 = HEAP32[i71 + 76 >> 2] | 0;
 i37 = i31 + 72 | 0;
 i38 = i31 + 76 | 0;
 HEAP32[i37 >> 2] = HEAP32[i71 + 72 >> 2];
 HEAP32[i38 >> 2] = i98;
 i98 = HEAP32[i71 + 44 >> 2] | 0;
 i43 = i31 + 80 | 0;
 i44 = i31 + 84 | 0;
 HEAP32[i43 >> 2] = HEAP32[i71 + 40 >> 2];
 HEAP32[i44 >> 2] = i98;
 i98 = HEAP32[i71 + 104 >> 2] | 0;
 i97 = HEAP32[i71 + 108 >> 2] | 0;
 i51 = i31 + 88 | 0;
 i52 = i31 + 92 | 0;
 HEAP32[i51 >> 2] = i98;
 HEAP32[i52 >> 2] = i97;
 i94 = HEAP32[i71 + 24 >> 2] | 0;
 i93 = HEAP32[i71 + 28 >> 2] | 0;
 i59 = i31 + 96 | 0;
 i60 = i31 + 100 | 0;
 HEAP32[i59 >> 2] = i94;
 HEAP32[i60 >> 2] = i93;
 i96 = HEAP32[i71 + 88 >> 2] | 0;
 i95 = HEAP32[i71 + 92 >> 2] | 0;
 i63 = i31 + 104 | 0;
 i64 = i31 + 108 | 0;
 HEAP32[i63 >> 2] = i96;
 HEAP32[i64 >> 2] = i95;
 i92 = HEAP32[i71 + 56 >> 2] | 0;
 i91 = HEAP32[i71 + 60 >> 2] | 0;
 i67 = i31 + 112 | 0;
 i68 = i31 + 116 | 0;
 HEAP32[i67 >> 2] = i92;
 HEAP32[i68 >> 2] = i91;
 d90 = +HEAPF32[i71 + 120 >> 2];
 d89 = +HEAPF32[i71 + 124 >> 2];
 i71 = i31 + 120 | 0;
 i72 = i31 + 124 | 0;
 d1 = +HEAPF32[i35 >> 2];
 d2 = +HEAPF32[i36 >> 2];
 d88 = +HEAPF32[i31 >> 2];
 d86 = +HEAPF32[i5 >> 2];
 HEAPF32[i35 >> 2] = d88 - d1;
 HEAPF32[i36 >> 2] = d86 - d2;
 d88 = d1 + d88;
 d86 = d2 + d86;
 d2 = +HEAPF32[i53 >> 2];
 d1 = +HEAPF32[i54 >> 2];
 d87 = +HEAPF32[i45 >> 2];
 d85 = +HEAPF32[i46 >> 2];
 d6 = d87 - d2;
 d7 = d85 - d1;
 HEAPF32[i53 >> 2] = d6;
 HEAPF32[i54 >> 2] = d7;
 d87 = d2 + d87;
 d85 = d1 + d85;
 d1 = +HEAPF32[i65 >> 2];
 d2 = +HEAPF32[i66 >> 2];
 d84 = +HEAPF32[i61 >> 2];
 d82 = +HEAPF32[i62 >> 2];
 HEAPF32[i65 >> 2] = d84 - d1;
 HEAPF32[i66 >> 2] = d82 - d2;
 d84 = d1 + d84;
 d82 = d2 + d82;
 d2 = +HEAPF32[i73 >> 2];
 d1 = +HEAPF32[i74 >> 2];
 d83 = +HEAPF32[i69 >> 2];
 d81 = +HEAPF32[i70 >> 2];
 d4 = d83 - d2;
 d3 = d81 - d1;
 HEAPF32[i73 >> 2] = d4;
 HEAPF32[i74 >> 2] = d3;
 d83 = d2 + d83;
 d81 = d1 + d81;
 d1 = +HEAPF32[i37 >> 2];
 d2 = +HEAPF32[i38 >> 2];
 d80 = +HEAPF32[i29 >> 2];
 d78 = +HEAPF32[i30 >> 2];
 HEAPF32[i37 >> 2] = d80 - d1;
 HEAPF32[i38 >> 2] = d78 - d2;
 d80 = d1 + d80;
 d78 = d2 + d78;
 d2 = (HEAP32[tempDoublePtr >> 2] = i98, +HEAPF32[tempDoublePtr >> 2]);
 d1 = (HEAP32[tempDoublePtr >> 2] = i97, +HEAPF32[tempDoublePtr >> 2]);
 d79 = +HEAPF32[i43 >> 2];
 d77 = +HEAPF32[i44 >> 2];
 HEAPF32[i51 >> 2] = d79 - d2;
 HEAPF32[i52 >> 2] = d77 - d1;
 d79 = d2 + d79;
 d77 = d1 + d77;
 d1 = (HEAP32[tempDoublePtr >> 2] = i96, +HEAPF32[tempDoublePtr >> 2]);
 d2 = (HEAP32[tempDoublePtr >> 2] = i95, +HEAPF32[tempDoublePtr >> 2]);
 d76 = (HEAP32[tempDoublePtr >> 2] = i94, +HEAPF32[tempDoublePtr >> 2]);
 d8 = (HEAP32[tempDoublePtr >> 2] = i93, +HEAPF32[tempDoublePtr >> 2]);
 HEAPF32[i63 >> 2] = d76 - d1;
 HEAPF32[i64 >> 2] = d8 - d2;
 d76 = d1 + d76;
 d8 = d2 + d8;
 d2 = (HEAP32[tempDoublePtr >> 2] = i92, +HEAPF32[tempDoublePtr >> 2]);
 d1 = (HEAP32[tempDoublePtr >> 2] = i91, +HEAPF32[tempDoublePtr >> 2]);
 HEAPF32[i71 >> 2] = d2 - d90;
 HEAPF32[i72 >> 2] = d1 - d89;
 d2 = d90 + d2;
 d1 = d89 + d1;
 HEAPF32[i45 >> 2] = d88 - d87;
 HEAPF32[i46 >> 2] = d86 - d85;
 HEAPF32[i31 >> 2] = d88 + d87;
 HEAPF32[i5 >> 2] = d86 + d85;
 HEAPF32[i69 >> 2] = d84 - d83;
 HEAPF32[i70 >> 2] = d82 - d81;
 HEAPF32[i61 >> 2] = d84 + d83;
 HEAPF32[i62 >> 2] = d82 + d81;
 HEAPF32[i43 >> 2] = d80 - d79;
 HEAPF32[i44 >> 2] = d78 - d77;
 HEAPF32[i29 >> 2] = d80 + d79;
 HEAPF32[i30 >> 2] = d78 + d77;
 HEAPF32[i67 >> 2] = d76 - d2;
 HEAPF32[i68 >> 2] = d8 - d1;
 HEAPF32[i59 >> 2] = d76 + d2;
 HEAPF32[i60 >> 2] = d8 + d1;
 d1 = d6 * 0.0;
 if (i32) {
  d2 = d7 - d1;
  d1 = d7 * -0.0 - d6;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i9, -d6, -d7, 0.0, 1.0);
   d2 = +HEAPF32[i9 >> 2];
   d1 = +HEAPF32[i9 + 4 >> 2];
   d4 = +HEAPF32[i73 >> 2];
   d3 = +HEAPF32[i74 >> 2];
  }
  d89 = +HEAPF32[i35 >> 2];
  d90 = +HEAPF32[i36 >> 2];
  HEAPF32[i53 >> 2] = d89 - d2;
  HEAPF32[i54 >> 2] = d90 - d1;
  HEAPF32[i35 >> 2] = d2 + d89;
  HEAPF32[i36 >> 2] = d1 + d90;
  d2 = d3 - d4 * 0.0;
  d1 = d3 * -0.0 - d4;
  if ((d1 != d1 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___mulsc3(i11, -d4, -d3, 0.0, 1.0);
   d2 = +HEAPF32[i11 >> 2];
   d1 = +HEAPF32[i11 + 4 >> 2];
  }
  d4 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i73 >> 2] = d4 - d2;
  HEAPF32[i74 >> 2] = d3 - d1;
  HEAPF32[i65 >> 2] = d2 + d4;
  HEAPF32[i66 >> 2] = d1 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i13, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i13 >> 2];
   d1 = +HEAPF32[i13 + 4 >> 2];
  }
  d4 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i51 >> 2] = d4 - d2;
  HEAPF32[i52 >> 2] = d3 - d1;
  HEAPF32[i37 >> 2] = d2 + d4;
  HEAPF32[i38 >> 2] = d1 + d3;
  d2 = +HEAPF32[i71 >> 2];
  d3 = +HEAPF32[i72 >> 2];
  d4 = d3 - d2 * 0.0;
  d1 = d3 * -0.0 - d2;
  if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i15, -d2, -d3, 0.0, 1.0);
   d4 = +HEAPF32[i15 >> 2];
   d1 = +HEAPF32[i15 + 4 >> 2];
  }
  d90 = +HEAPF32[i63 >> 2];
  d3 = +HEAPF32[i64 >> 2];
  HEAPF32[i71 >> 2] = d90 - d4;
  HEAPF32[i72 >> 2] = d3 - d1;
  d3 = d1 + d3;
  d4 = d4 + d90;
 } else {
  d2 = d1 - d7;
  d1 = d6 + d7 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i10, d6, d7, 0.0, 1.0);
   d2 = +HEAPF32[i10 >> 2];
   d1 = +HEAPF32[i10 + 4 >> 2];
   d4 = +HEAPF32[i73 >> 2];
   d3 = +HEAPF32[i74 >> 2];
  }
  d89 = +HEAPF32[i35 >> 2];
  d90 = +HEAPF32[i36 >> 2];
  HEAPF32[i53 >> 2] = d89 - d2;
  HEAPF32[i54 >> 2] = d90 - d1;
  HEAPF32[i35 >> 2] = d2 + d89;
  HEAPF32[i36 >> 2] = d1 + d90;
  d2 = d4 * 0.0 - d3;
  d1 = d4 + d3 * 0.0;
  if ((d1 != d1 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___mulsc3(i12, d4, d3, 0.0, 1.0);
   d2 = +HEAPF32[i12 >> 2];
   d1 = +HEAPF32[i12 + 4 >> 2];
  }
  d4 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i73 >> 2] = d4 - d2;
  HEAPF32[i74 >> 2] = d3 - d1;
  HEAPF32[i65 >> 2] = d2 + d4;
  HEAPF32[i66 >> 2] = d1 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i14, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i14 >> 2];
   d1 = +HEAPF32[i14 + 4 >> 2];
  }
  d4 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i51 >> 2] = d4 - d2;
  HEAPF32[i52 >> 2] = d3 - d1;
  HEAPF32[i37 >> 2] = d2 + d4;
  HEAPF32[i38 >> 2] = d1 + d3;
  d2 = +HEAPF32[i71 >> 2];
  d3 = +HEAPF32[i72 >> 2];
  d4 = d2 * 0.0 - d3;
  d1 = d2 + d3 * 0.0;
  if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i16, d2, d3, 0.0, 1.0);
   d4 = +HEAPF32[i16 >> 2];
   d1 = +HEAPF32[i16 + 4 >> 2];
  }
  d90 = +HEAPF32[i63 >> 2];
  d3 = +HEAPF32[i64 >> 2];
  HEAPF32[i71 >> 2] = d90 - d4;
  HEAPF32[i72 >> 2] = d3 - d1;
  d3 = d1 + d3;
  d4 = d4 + d90;
 }
 HEAPF32[i63 >> 2] = d4;
 HEAPF32[i64 >> 2] = d3;
 d7 = +HEAPF32[i61 >> 2];
 d8 = +HEAPF32[i62 >> 2];
 d1 = +HEAPF32[i31 >> 2];
 d6 = +HEAPF32[i5 >> 2];
 HEAPF32[i61 >> 2] = d1 - d7;
 HEAPF32[i62 >> 2] = d6 - d8;
 HEAPF32[i31 >> 2] = d7 + d1;
 HEAPF32[i5 >> 2] = d8 + d6;
 d6 = +HEAPF32[i59 >> 2];
 d8 = +HEAPF32[i60 >> 2];
 d1 = +HEAPF32[i29 >> 2];
 d7 = +HEAPF32[i30 >> 2];
 HEAPF32[i59 >> 2] = d1 - d6;
 HEAPF32[i60 >> 2] = d7 - d8;
 HEAPF32[i29 >> 2] = d6 + d1;
 HEAPF32[i30 >> 2] = d8 + d7;
 d7 = +HEAPF32[i65 >> 2];
 d8 = +HEAPF32[i66 >> 2];
 d1 = d7 * .70710677;
 d6 = d8 * .70710677;
 if (i32) {
  d2 = d1 + d6;
  d1 = d6 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i18, d7, d8, .70710677, -.70710677);
   d2 = +HEAPF64[i18 >> 3];
   d1 = +HEAPF64[i18 + 8 >> 3];
   d4 = +HEAPF32[i63 >> 2];
   d3 = +HEAPF32[i64 >> 2];
  }
  d89 = d2;
  d90 = d1;
  d2 = +HEAPF32[i35 >> 2];
  d1 = +HEAPF32[i36 >> 2];
  HEAPF32[i65 >> 2] = d2 - d89;
  HEAPF32[i66 >> 2] = d1 - d90;
  HEAPF32[i35 >> 2] = d89 + d2;
  HEAPF32[i36 >> 2] = d90 + d1;
  d1 = d4 * .70710677;
  d90 = d3 * .70710677;
  d2 = d90 + d1;
  d1 = d90 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i20, d4, d3, .70710677, -.70710677);
   d2 = +HEAPF64[i20 >> 3];
   d1 = +HEAPF64[i20 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i63 >> 2] = d2 - d90;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i37 >> 2] = d90 + d2;
  HEAPF32[i38 >> 2] = d4 + d3;
  d3 = +HEAPF32[i69 >> 2];
  d4 = +HEAPF32[i70 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i21, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i21 >> 2];
   d1 = +HEAPF32[i21 + 4 >> 2];
  }
  d4 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i69 >> 2] = d4 - d2;
  HEAPF32[i70 >> 2] = d3 - d1;
  HEAPF32[i45 >> 2] = d2 + d4;
  HEAPF32[i46 >> 2] = d1 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i23, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i23 >> 2];
   d1 = +HEAPF32[i23 + 4 >> 2];
  }
  d4 = +HEAPF32[i43 >> 2];
  d3 = +HEAPF32[i44 >> 2];
  HEAPF32[i67 >> 2] = d4 - d2;
  HEAPF32[i68 >> 2] = d3 - d1;
  HEAPF32[i43 >> 2] = d2 + d4;
  HEAPF32[i44 >> 2] = d1 + d3;
  d3 = +HEAPF32[i73 >> 2];
  d4 = +HEAPF32[i74 >> 2];
  d90 = d3 * -.70710677;
  d1 = d4 * -.70710677;
  d2 = d90 - d1;
  d1 = d90 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i25, d3, d4, -.70710677, -.70710677);
   d2 = +HEAPF64[i25 >> 3];
   d1 = +HEAPF64[i25 + 8 >> 3];
  }
  d4 = d1;
  d90 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i73 >> 2] = d90 - d2;
  HEAPF32[i74 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d2 + d90;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d90 = d3 * -.70710677;
  d1 = d4 * -.70710677;
  d2 = d90 - d1;
  d1 = d90 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i27, d3, d4, -.70710677, -.70710677);
   d2 = +HEAPF64[i27 >> 3];
   d1 = +HEAPF64[i27 + 8 >> 3];
  }
  d90 = d2;
  d89 = d1;
  d2 = +HEAPF32[i51 >> 2];
  d1 = +HEAPF32[i52 >> 2];
  HEAPF32[i71 >> 2] = d2 - d90;
  HEAPF32[i72 >> 2] = d1 - d89;
  d1 = d89 + d1;
  d2 = d90 + d2;
 } else {
  d2 = d1 - d6;
  d1 = d1 + d6;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i17, d7, d8, .70710677, .70710677);
   d2 = +HEAPF64[i17 >> 3];
   d1 = +HEAPF64[i17 + 8 >> 3];
   d4 = +HEAPF32[i63 >> 2];
   d3 = +HEAPF32[i64 >> 2];
  }
  d89 = d2;
  d90 = d1;
  d2 = +HEAPF32[i35 >> 2];
  d1 = +HEAPF32[i36 >> 2];
  HEAPF32[i65 >> 2] = d2 - d89;
  HEAPF32[i66 >> 2] = d1 - d90;
  HEAPF32[i35 >> 2] = d89 + d2;
  HEAPF32[i36 >> 2] = d90 + d1;
  d1 = d4 * .70710677;
  d90 = d3 * .70710677;
  d2 = d1 - d90;
  d1 = d90 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i19, d4, d3, .70710677, .70710677);
   d2 = +HEAPF64[i19 >> 3];
   d1 = +HEAPF64[i19 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i37 >> 2];
  d3 = +HEAPF32[i38 >> 2];
  HEAPF32[i63 >> 2] = d2 - d90;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i37 >> 2] = d90 + d2;
  HEAPF32[i38 >> 2] = d4 + d3;
  d3 = +HEAPF32[i69 >> 2];
  d4 = +HEAPF32[i70 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i22, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i22 >> 2];
   d1 = +HEAPF32[i22 + 4 >> 2];
  }
  d4 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i69 >> 2] = d4 - d2;
  HEAPF32[i70 >> 2] = d3 - d1;
  HEAPF32[i45 >> 2] = d2 + d4;
  HEAPF32[i46 >> 2] = d1 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i24, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i24 >> 2];
   d1 = +HEAPF32[i24 + 4 >> 2];
  }
  d4 = +HEAPF32[i43 >> 2];
  d3 = +HEAPF32[i44 >> 2];
  HEAPF32[i67 >> 2] = d4 - d2;
  HEAPF32[i68 >> 2] = d3 - d1;
  HEAPF32[i43 >> 2] = d2 + d4;
  HEAPF32[i44 >> 2] = d1 + d3;
  d3 = +HEAPF32[i73 >> 2];
  d4 = +HEAPF32[i74 >> 2];
  d1 = d4 * .70710677;
  d2 = d3 * -.70710677 - d1;
  d1 = d3 * .70710677 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i26, d3, d4, -.70710677, .70710677);
   d2 = +HEAPF64[i26 >> 3];
   d1 = +HEAPF64[i26 + 8 >> 3];
  }
  d4 = d1;
  d1 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i73 >> 2] = d1 - d2;
  HEAPF32[i74 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d2 + d1;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d1 = d4 * .70710677;
  d2 = d3 * -.70710677 - d1;
  d1 = d3 * .70710677 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i28, d3, d4, -.70710677, .70710677);
   d2 = +HEAPF64[i28 >> 3];
   d1 = +HEAPF64[i28 + 8 >> 3];
  }
  d90 = d2;
  d89 = d1;
  d2 = +HEAPF32[i51 >> 2];
  d1 = +HEAPF32[i52 >> 2];
  HEAPF32[i71 >> 2] = d2 - d90;
  HEAPF32[i72 >> 2] = d1 - d89;
  d1 = d89 + d1;
  d2 = d90 + d2;
 }
 HEAPF32[i51 >> 2] = d2;
 HEAPF32[i52 >> 2] = d1;
 d2 = +HEAPF32[i29 >> 2];
 d7 = +HEAPF32[i30 >> 2];
 d1 = +HEAPF32[i31 >> 2];
 d6 = +HEAPF32[i5 >> 2];
 HEAPF32[i29 >> 2] = d1 - d2;
 HEAPF32[i30 >> 2] = d6 - d7;
 HEAPF32[i31 >> 2] = d2 + d1;
 HEAPF32[i5 >> 2] = d7 + d6;
 d6 = +HEAPF32[i37 >> 2];
 d7 = +HEAPF32[i38 >> 2];
 d1 = d6 * .9238795;
 d2 = d7 * .38268346;
 d3 = d6 * .38268346;
 d4 = d7 * .9238795;
 if (i32) {
  d2 = d1 + d2;
  d1 = d4 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i33, d6, d7, .9238795, -.38268346);
   d2 = +HEAPF64[i33 >> 3];
   d1 = +HEAPF64[i33 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d1 = +HEAPF32[i35 >> 2];
  d3 = +HEAPF32[i36 >> 2];
  HEAPF32[i37 >> 2] = d1 - d90;
  HEAPF32[i38 >> 2] = d3 - d4;
  HEAPF32[i35 >> 2] = d90 + d1;
  HEAPF32[i36 >> 2] = d4 + d3;
  d3 = +HEAPF32[i43 >> 2];
  d4 = +HEAPF32[i44 >> 2];
  d1 = d3 * .70710677;
  d90 = d4 * .70710677;
  d2 = d1 + d90;
  d1 = d90 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i39, d3, d4, .70710677, -.70710677);
   d2 = +HEAPF64[i39 >> 3];
   d1 = +HEAPF64[i39 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i43 >> 2] = d2 - d90;
  HEAPF32[i44 >> 2] = d3 - d4;
  HEAPF32[i45 >> 2] = d90 + d2;
  HEAPF32[i46 >> 2] = d4 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d3 * .38268343 + d4 * .9238795;
  d1 = d4 * .38268343 - d3 * .9238795;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i41, d3, d4, .38268343, -.9238795);
   d2 = +HEAPF64[i41 >> 3];
   d1 = +HEAPF64[i41 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i51 >> 2] = d2 - d90;
  HEAPF32[i52 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d90 + d2;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i59 >> 2];
  d4 = +HEAPF32[i60 >> 2];
  d2 = d4 - d3 * 0.0;
  d1 = d4 * -0.0 - d3;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i47, -d3, -d4, 0.0, 1.0);
   d2 = +HEAPF32[i47 >> 2];
   d1 = +HEAPF32[i47 + 4 >> 2];
  }
  d4 = +HEAPF32[i61 >> 2];
  d3 = +HEAPF32[i62 >> 2];
  HEAPF32[i59 >> 2] = d4 - d2;
  HEAPF32[i60 >> 2] = d3 - d1;
  HEAPF32[i61 >> 2] = d2 + d4;
  HEAPF32[i62 >> 2] = d1 + d3;
  d3 = +HEAPF32[i63 >> 2];
  d4 = +HEAPF32[i64 >> 2];
  d2 = d4 * .92387956 - d3 * .3826834;
  d1 = d4 * -.3826834 - d3 * .92387956;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i49, d3, d4, -.3826834, -.92387956);
   d2 = +HEAPF64[i49 >> 3];
   d1 = +HEAPF64[i49 + 8 >> 3];
  }
  d4 = d1;
  d90 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i63 >> 2] = d90 - d2;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i65 >> 2] = d2 + d90;
  HEAPF32[i66 >> 2] = d4 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d90 = d3 * -.70710677;
  d1 = d4 * -.70710677;
  d2 = d90 - d1;
  d1 = d90 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i55, d3, d4, -.70710677, -.70710677);
   d2 = +HEAPF64[i55 >> 3];
   d1 = +HEAPF64[i55 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i69 >> 2];
  d3 = +HEAPF32[i70 >> 2];
  HEAPF32[i67 >> 2] = d2 - d90;
  HEAPF32[i68 >> 2] = d3 - d4;
  HEAPF32[i69 >> 2] = d90 + d2;
  HEAPF32[i70 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d2 = d4 * .38268349 - d3 * .9238795;
  d1 = d4 * -.9238795 - d3 * .38268349;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i57, d3, d4, -.9238795, -.38268349);
   d2 = +HEAPF64[i57 >> 3];
   d1 = +HEAPF64[i57 + 8 >> 3];
  }
  d88 = d2;
  d87 = d1;
  d89 = +HEAPF32[i73 >> 2];
  d90 = +HEAPF32[i74 >> 2];
  HEAPF32[i71 >> 2] = d89 - d88;
  HEAPF32[i72 >> 2] = d90 - d87;
  d90 = d87 + d90;
  d89 = d88 + d89;
  HEAPF32[i73 >> 2] = d89;
  HEAPF32[i74 >> 2] = d90;
  STACKTOP = i75;
  return;
 } else {
  d2 = d1 - d2;
  d1 = d3 + d4;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i34, d6, d7, .9238795, .38268346);
   d2 = +HEAPF64[i34 >> 3];
   d1 = +HEAPF64[i34 + 8 >> 3];
  }
  d4 = d1;
  d90 = +HEAPF32[i35 >> 2];
  d3 = +HEAPF32[i36 >> 2];
  HEAPF32[i37 >> 2] = d90 - d2;
  HEAPF32[i38 >> 2] = d3 - d4;
  HEAPF32[i35 >> 2] = d2 + d90;
  HEAPF32[i36 >> 2] = d4 + d3;
  d3 = +HEAPF32[i43 >> 2];
  d4 = +HEAPF32[i44 >> 2];
  d90 = d3 * .70710677;
  d1 = d4 * .70710677;
  d2 = d90 - d1;
  d1 = d90 + d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i40, d3, d4, .70710677, .70710677);
   d2 = +HEAPF64[i40 >> 3];
   d1 = +HEAPF64[i40 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i45 >> 2];
  d3 = +HEAPF32[i46 >> 2];
  HEAPF32[i43 >> 2] = d2 - d90;
  HEAPF32[i44 >> 2] = d3 - d4;
  HEAPF32[i45 >> 2] = d90 + d2;
  HEAPF32[i46 >> 2] = d4 + d3;
  d3 = +HEAPF32[i51 >> 2];
  d4 = +HEAPF32[i52 >> 2];
  d2 = d3 * .38268343 - d4 * .9238795;
  d1 = d3 * .9238795 + d4 * .38268343;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i42, d3, d4, .38268343, .9238795);
   d2 = +HEAPF64[i42 >> 3];
   d1 = +HEAPF64[i42 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i53 >> 2];
  d3 = +HEAPF32[i54 >> 2];
  HEAPF32[i51 >> 2] = d2 - d90;
  HEAPF32[i52 >> 2] = d3 - d4;
  HEAPF32[i53 >> 2] = d90 + d2;
  HEAPF32[i54 >> 2] = d4 + d3;
  d3 = +HEAPF32[i59 >> 2];
  d4 = +HEAPF32[i60 >> 2];
  d2 = d3 * 0.0 - d4;
  d1 = d3 + d4 * 0.0;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___mulsc3(i48, d3, d4, 0.0, 1.0);
   d2 = +HEAPF32[i48 >> 2];
   d1 = +HEAPF32[i48 + 4 >> 2];
  }
  d4 = +HEAPF32[i61 >> 2];
  d3 = +HEAPF32[i62 >> 2];
  HEAPF32[i59 >> 2] = d4 - d2;
  HEAPF32[i60 >> 2] = d3 - d1;
  HEAPF32[i61 >> 2] = d2 + d4;
  HEAPF32[i62 >> 2] = d1 + d3;
  d3 = +HEAPF32[i63 >> 2];
  d4 = +HEAPF32[i64 >> 2];
  d2 = d3 * -.3826834 - d4 * .92387956;
  d1 = d3 * .92387956 - d4 * .3826834;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i50, d3, d4, -.3826834, .92387956);
   d2 = +HEAPF64[i50 >> 3];
   d1 = +HEAPF64[i50 + 8 >> 3];
  }
  d4 = d1;
  d1 = +HEAPF32[i65 >> 2];
  d3 = +HEAPF32[i66 >> 2];
  HEAPF32[i63 >> 2] = d1 - d2;
  HEAPF32[i64 >> 2] = d3 - d4;
  HEAPF32[i65 >> 2] = d2 + d1;
  HEAPF32[i66 >> 2] = d4 + d3;
  d3 = +HEAPF32[i67 >> 2];
  d4 = +HEAPF32[i68 >> 2];
  d1 = d4 * .70710677;
  d2 = d3 * -.70710677 - d1;
  d1 = d3 * .70710677 - d1;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i56, d3, d4, -.70710677, .70710677);
   d2 = +HEAPF64[i56 >> 3];
   d1 = +HEAPF64[i56 + 8 >> 3];
  }
  d90 = d2;
  d4 = d1;
  d2 = +HEAPF32[i69 >> 2];
  d3 = +HEAPF32[i70 >> 2];
  HEAPF32[i67 >> 2] = d2 - d90;
  HEAPF32[i68 >> 2] = d3 - d4;
  HEAPF32[i69 >> 2] = d90 + d2;
  HEAPF32[i70 >> 2] = d4 + d3;
  d3 = +HEAPF32[i71 >> 2];
  d4 = +HEAPF32[i72 >> 2];
  d2 = d3 * -.9238795 - d4 * .38268349;
  d1 = d3 * .38268349 - d4 * .9238795;
  if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
   ___muldc3(i58, d3, d4, -.9238795, .38268349);
   d2 = +HEAPF64[i58 >> 3];
   d1 = +HEAPF64[i58 + 8 >> 3];
  }
  d88 = d2;
  d87 = d1;
  d89 = +HEAPF32[i73 >> 2];
  d90 = +HEAPF32[i74 >> 2];
  HEAPF32[i71 >> 2] = d89 - d88;
  HEAPF32[i72 >> 2] = d90 - d87;
  d90 = d87 + d90;
  d89 = d88 + d89;
  HEAPF32[i73 >> 2] = d89;
  HEAPF32[i74 >> 2] = d90;
  STACKTOP = i75;
  return;
 }
}

function _ofdmflexframesync_internal_callback(i18, i5, i4, i36) {
 i18 = i18 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 i36 = i36 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, d15 = 0.0, i16 = 0, i17 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, d31 = 0.0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i37 = 0, i38 = 0, i39 = 0, d40 = 0.0, d41 = 0.0;
 i37 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i34 = i37 + 16 | 0;
 i16 = i37 + 8 | 0;
 i17 = i37;
 i35 = i36 + 188 | 0;
 HEAP32[i35 >> 2] = (HEAP32[i35 >> 2] | 0) + 1;
 i28 = i36 + 192 | 0;
 switch (HEAP32[i28 >> 2] | 0) {
 case 0:
  {
   i1 = HEAP32[i36 >> 2] | 0;
   if (!i1) {
    STACKTOP = i37;
    return 0;
   }
   i8 = i36 + 12 | 0;
   i9 = i36 + 36 | 0;
   i6 = i36 + 196 | 0;
   i10 = i36 + 52 | 0;
   i32 = i36 + 180 | 0;
   i27 = i36 + 68 | 0;
   i7 = i16 + 4 | 0;
   i5 = 0;
   while (1) {
    if ((HEAP8[(HEAP32[i8 >> 2] | 0) + i5 >> 0] | 0) == 2) {
     i11 = HEAP32[i9 >> 2] | 0;
     i38 = HEAP32[i18 + (i5 << 3) + 4 >> 2] | 0;
     i4 = HEAP32[i11 + 240 >> 2] | 0;
     HEAP32[i16 >> 2] = HEAP32[i18 + (i5 << 3) >> 2];
     HEAP32[i7 >> 2] = i38;
     HEAP32[i34 >> 2] = HEAP32[i16 >> 2];
     HEAP32[i34 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
     mftCall_viii(i4 | 0, i11 | 0, i34 | 0, i17 | 0);
     HEAP8[(HEAP32[i10 >> 2] | 0) + (HEAP32[i6 >> 2] | 0) >> 0] = HEAP32[i17 >> 2];
     i11 = (HEAP32[i6 >> 2] | 0) + 1 | 0;
     HEAP32[i6 >> 2] = i11;
     i4 = HEAP32[i9 >> 2] | 0;
     d3 = +Math_abs(+(+HEAPF32[i4 + 92 >> 2] - +HEAPF32[i4 + 84 >> 2]));
     i38 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     d3 = +Math_abs(+(+HEAPF32[i4 + 96 >> 2] - +HEAPF32[i4 + 88 >> 2]));
     i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     i39 = i38 >>> 0 < i4 >>> 0;
     i1 = i39 ? i4 : i38;
     i4 = i39 ? i38 : i4;
     d3 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]);
     d2 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) != 2139095040) {
      if (i1 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i1 - i4 | 0) >>> 0 > 209715199) {
       d2 = d3 + d2;
       break;
      }
      if (i1 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
       d2 = d2 * 1237940039285380274899124.0e3;
       d3 = d3 * 1237940039285380274899124.0e3;
       d15 = 8.077935669463161e-28;
      } else d15 = 1.0; else {
       d2 = d2 * 8.077935669463161e-28;
       d3 = d3 * 8.077935669463161e-28;
       d15 = 1237940039285380274899124.0e3;
      }
      d2 = d15 * +Math_sqrt(+(d3 * d3 + d2 * d2));
     } while (0);
     HEAPF32[i32 >> 2] = +HEAPF32[i32 >> 2] + d2 * d2;
     if ((i11 | 0) == (HEAP32[i27 >> 2] | 0)) break;
     i1 = HEAP32[i36 >> 2] | 0;
    }
    i5 = i5 + 1 | 0;
    if (i5 >>> 0 >= i1 >>> 0) {
     i33 = 137;
     break;
    }
   }
   if ((i33 | 0) == 137) {
    STACKTOP = i37;
    return 0;
   }
   i4 = i36 + 48 | 0;
   i39 = i36 + 64 | 0;
   _liquid_repack_bytes(HEAP32[i10 >> 2] | 0, 1, i11, HEAP32[i4 >> 2] | 0, 8, HEAP32[i39 >> 2] | 0, i34);
   i1 = HEAP32[i34 >> 2] | 0;
   if ((i1 | 0) != (HEAP32[i39 >> 2] | 0)) ___assert_fail(gb + 26736 | 0, gb + 26768 | 0, 492, gb + 26804 | 0);
   _scramble_data(HEAP32[i4 >> 2] | 0, i1);
   i17 = i36 + 44 | 0;
   i1 = _packetizer_decode(HEAP32[i36 + 40 >> 2] | 0, HEAP32[i4 >> 2] | 0, HEAP32[i17 >> 2] | 0) | 0;
   i16 = i36 + 72 | 0;
   HEAP32[i16 >> 2] = i1;
   do if (i1 | 0) {
    i6 = HEAP32[i36 + 56 >> 2] | 0;
    i4 = HEAP32[i17 >> 2] | 0;
    if ((HEAP8[i4 + i6 >> 0] | 0) != 104) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i13 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i13;
       HEAP32[gb + 8728 + 20 >> 2] = i13;
       i12 = i13 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i12;
       i33 = 23;
       break;
      } else {
       HEAP32[gb + 8728 >> 2] = i1 | 32;
       break;
      }
     } else {
      i12 = i1;
      i13 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      i33 = 23;
     } while (0);
     do if ((i33 | 0) == 23) {
      if ((i12 - i13 | 0) >>> 0 < 68) {
       mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26836 | 0, 68) | 0;
       break;
      }
      i1 = i13;
      if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
       if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26836 | 0, 68) | 0) >>> 0 < 68) break;
       i4 = 0;
       i5 = gb + 26836 + 68 | 0;
       i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      } else {
       i4 = 68;
       i5 = gb + 26836 | 0;
      }
      _memcpy(i1 | 0, i5 | 0, i4 | 0) | 0;
      HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
     } while (0);
     HEAP32[i16 >> 2] = 0;
     i1 = 0;
     i4 = HEAP32[i17 >> 2] | 0;
    }
    i11 = HEAPU8[i4 + (i6 + 1) >> 0] << 8 | HEAPU8[i4 + (i6 + 2) >> 0];
    i39 = HEAP8[i4 + (i6 + 3) >> 0] | 0;
    i9 = i39 & 255;
    if ((i39 + -1 & 255) > 58) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i19 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i19;
       HEAP32[gb + 8728 + 20 >> 2] = i19;
       i14 = i19 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i14;
       i33 = 36;
       break;
      } else {
       HEAP32[gb + 8728 >> 2] = i1 | 32;
       break;
      }
     } else {
      i14 = i1;
      i19 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      i33 = 36;
     } while (0);
     do if ((i33 | 0) == 36) {
      if ((i14 - i19 | 0) >>> 0 < 70) {
       mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26905 | 0, 70) | 0;
       break;
      }
      i1 = i19;
      if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
       if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26905 | 0, 70) | 0) >>> 0 < 70) break;
       i4 = 0;
       i5 = gb + 26905 + 70 | 0;
       i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      } else {
       i4 = 70;
       i5 = gb + 26905 | 0;
      }
      _memcpy(i1 | 0, i5 | 0, i4 | 0) | 0;
      HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
     } while (0);
     HEAP32[i16 >> 2] = 0;
     break;
    }
    i7 = HEAPU8[i4 + (i6 + 4) >> 0] | 0;
    i5 = i7 >>> 5;
    i7 = i7 & 31;
    i10 = HEAPU8[i4 + (i6 + 5) >> 0] & 31;
    if ((i5 | 0) == 7) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i21 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i21;
       HEAP32[gb + 8728 + 20 >> 2] = i21;
       i20 = i21 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i20;
       i33 = 49;
       break;
      } else {
       HEAP32[gb + 8728 >> 2] = i1 | 32;
       break;
      }
     } else {
      i20 = i1;
      i21 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      i33 = 49;
     } while (0);
     do if ((i33 | 0) == 49) {
      if ((i20 - i21 | 0) >>> 0 < 74) {
       mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26976 | 0, 74) | 0;
       break;
      }
      i1 = i21;
      if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
       if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 26976 | 0, 74) | 0) >>> 0 < 74) break;
       i4 = 0;
       i5 = gb + 26976 + 74 | 0;
       i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      } else {
       i4 = 74;
       i5 = gb + 26976 | 0;
      }
      _memcpy(i1 | 0, i5 | 0, i4 | 0) | 0;
      HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
     } while (0);
     HEAP32[i16 >> 2] = 0;
     i1 = 0;
     i8 = 0;
    } else i8 = i5;
    if (i7 >>> 0 > 27) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i23 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i23;
       HEAP32[gb + 8728 + 20 >> 2] = i23;
       i22 = i23 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i22;
       i33 = 62;
       break;
      } else {
       HEAP32[gb + 8728 >> 2] = i1 | 32;
       break;
      }
     } else {
      i22 = i1;
      i23 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      i33 = 62;
     } while (0);
     do if ((i33 | 0) == 62) {
      if ((i22 - i23 | 0) >>> 0 < 82) {
       mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27051 | 0, 82) | 0;
       break;
      }
      i1 = i23;
      if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
       if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27051 | 0, 82) | 0) >>> 0 < 82) break;
       i4 = 0;
       i5 = gb + 27051 + 82 | 0;
       i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      } else {
       i4 = 82;
       i5 = gb + 27051 | 0;
      }
      _memcpy(i1 | 0, i5 | 0, i4 | 0) | 0;
      HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
     } while (0);
     HEAP32[i16 >> 2] = 0;
     i1 = 0;
     i7 = 0;
    }
    if (i10 >>> 0 > 27) {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i25 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i25;
       HEAP32[gb + 8728 + 20 >> 2] = i25;
       i24 = i25 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i24;
       i33 = 75;
       break;
      } else {
       HEAP32[gb + 8728 >> 2] = i1 | 32;
       break;
      }
     } else {
      i24 = i1;
      i25 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      i33 = 75;
     } while (0);
     do if ((i33 | 0) == 75) {
      if ((i24 - i25 | 0) >>> 0 < 82) {
       mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27134 | 0, 82) | 0;
       break;
      }
      i1 = i25;
      if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
       if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27134 | 0, 82) | 0) >>> 0 < 82) break;
       i4 = 0;
       i5 = gb + 27134 + 82 | 0;
       i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      } else {
       i4 = 82;
       i5 = gb + 27134 | 0;
      }
      _memcpy(i1 | 0, i5 | 0, i4 | 0) | 0;
      HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
     } while (0);
     HEAP32[i16 >> 2] = 0;
     break;
    }
    if (i1 | 0) {
     i1 = i36 + 76 | 0;
     if ((i9 | 0) == (HEAP32[i1 >> 2] | 0)) i4 = i36 + 80 | 0; else {
      HEAP32[i1 >> 2] = i9;
      i4 = i36 + 80 | 0;
      HEAP32[i4 >> 2] = HEAP32[gb + 508 + (i9 << 4) + 12 >> 2];
      i5 = i36 + 104 | 0;
      i1 = HEAP32[i5 >> 2] | 0;
      if ((HEAP32[i1 >> 2] | 0) != (i9 | 0)) {
       _modem_destroy(i1);
       i1 = _modem_create(i9) | 0;
      }
      HEAP32[i5 >> 2] = i1;
     }
     i5 = i36 + 84 | 0;
     HEAP32[i5 >> 2] = i11;
     HEAP32[i36 + 88 >> 2] = i8;
     HEAP32[i36 + 92 >> 2] = i7;
     HEAP32[i36 + 96 >> 2] = i10;
     i6 = i36 + 100 | 0;
     i1 = HEAP32[i6 >> 2] | 0;
     do if (!i1) i1 = _packetizer_create(i11, i8, i7, i10) | 0; else {
      if ((((HEAP32[i1 >> 2] | 0) == (i11 | 0) ? (HEAP32[i1 + 8 >> 2] | 0) == (i8 | 0) : 0) ? (i26 = HEAP32[i1 + 16 >> 2] | 0, (HEAP32[i26 + 8 >> 2] | 0) == (i7 | 0)) : 0) ? (HEAP32[i26 + 28 >> 2] | 0) == (i10 | 0) : 0) break;
      _packetizer_destroy(i1);
      i1 = _packetizer_create(i11, i8, i7, i10) | 0;
     } while (0);
     HEAP32[i6 >> 2] = i1;
     i26 = HEAP32[i1 + 4 >> 2] | 0;
     i39 = i36 + 116 | 0;
     HEAP32[i39 >> 2] = i26;
     i38 = i36 + 108 | 0;
     HEAP32[i38 >> 2] = _realloc(HEAP32[i38 >> 2] | 0, i26) | 0;
     i38 = i36 + 112 | 0;
     HEAP32[i38 >> 2] = _realloc(HEAP32[i38 >> 2] | 0, HEAP32[i5 >> 2] | 0) | 0;
     i39 = HEAP32[i39 >> 2] << 3;
     i38 = HEAP32[i4 >> 2] | 0;
     i38 = (((i39 | 0) % (i38 | 0) | 0 | 0) != 0 & 1) + ((i39 | 0) / (i38 | 0) | 0) | 0;
     HEAP32[i36 + 120 >> 2] = i38;
     i39 = i36 + 128 | 0;
     HEAP32[i39 >> 2] = _realloc(HEAP32[i39 >> 2] | 0, i38 << 3) | 0;
    }
   } while (0);
   d2 = +HEAPF32[i32 >> 2] / +((HEAP32[i27 >> 2] | 0) >>> 0);
   i1 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
   i4 = (i1 | 0) < 0;
   do if (i1 >>> 0 < 8388608 | i4) {
    d15 = +Math_abs(+d2);
    if (!((HEAPF32[tempDoublePtr >> 2] = d15, HEAP32[tempDoublePtr >> 2] | 0) | 0)) {
     d31 = -1.0 / (d2 * d2);
     break;
    }
    if (i4) {
     d31 = (d2 - d2) / 0.0;
     break;
    } else {
     i29 = (HEAPF32[tempDoublePtr >> 2] = d2 * 33554432.0, HEAP32[tempDoublePtr >> 2] | 0);
     i30 = -152;
     i33 = 104;
     break;
    }
   } else if (i1 >>> 0 <= 2139095039) if ((i1 | 0) == 1065353216) d31 = 0.0; else {
    i29 = i1;
    i30 = -127;
    i33 = 104;
   } else d31 = d2; while (0);
   if ((i33 | 0) == 104) {
    i39 = i29 + 4913933 | 0;
    d41 = (HEAP32[tempDoublePtr >> 2] = (i39 & 8388607) + 1060439283, +HEAPF32[tempDoublePtr >> 2]) + -1.0;
    d40 = d41 / (d41 + 2.0);
    d3 = d40 * d40;
    d31 = d3 * d3;
    d2 = d41 * (d41 * .5);
    d15 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d41 - d2, HEAP32[tempDoublePtr >> 2] | 0) & -4096, +HEAPF32[tempDoublePtr >> 2]);
    d31 = d41 - d15 - d2 + d40 * (d2 + (d3 * (d31 * .2849878668785095 + .6666666269302368) + d31 * (d31 * .24279078841209412 + .40000972151756287)));
    d3 = +((i39 >>> 23) + i30 | 0);
    d31 = d3 * .3010292053222656 + (d15 * .434326171875 + (d31 * .434326171875 + (d3 * 7.903415166765626e-07 - (d15 + d31) * 3.168997136526741e-05)));
   }
   i7 = i36 + 140 | 0;
   HEAPF32[i7 >> 2] = d31 * 10.0;
   if (HEAP32[i16 >> 2] | 0) {
    HEAP32[i28 >> 2] = 1;
    STACKTOP = i37;
    return 0;
   }
   i5 = i36 + 184 | 0;
   i6 = HEAP32[i5 >> 2] | 0;
   HEAPF32[i36 + 144 >> 2] = +_log10(+HEAPF32[i6 + 80 >> 2]) * -10.0;
   HEAP32[i36 + 148 >> 2] = HEAP32[(HEAP32[i6 + 108 >> 2] | 0) + 8 >> 2];
   i6 = i36 + 152 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   HEAP32[i6 + 16 >> 2] = 0;
   HEAP32[i6 + 20 >> 2] = 0;
   HEAP32[i6 + 24 >> 2] = 0;
   i6 = HEAP32[i36 + 132 >> 2] | 0;
   i4 = HEAP32[i17 >> 2] | 0;
   i1 = HEAP32[i36 + 136 >> 2] | 0;
   i12 = i34;
   i13 = i7;
   i14 = i12 + 40 | 0;
   do {
    HEAP32[i12 >> 2] = HEAP32[i13 >> 2];
    i12 = i12 + 4 | 0;
    i13 = i13 + 4 | 0;
   } while ((i12 | 0) < (i14 | 0));
   mftCall_iiiiiiii(i6 | 0, i4 | 0, 0, 0, 0, 0, i34 | 0, i1 | 0) | 0;
   HEAP32[i35 >> 2] = 0;
   HEAP32[i35 + 4 >> 2] = 0;
   HEAP32[i35 + 8 >> 2] = 0;
   HEAP32[i35 + 12 >> 2] = 0;
   HEAP32[i35 + 16 >> 2] = 0;
   HEAPF32[i32 >> 2] = 9.999999960041972e-13;
   i12 = i7;
   i14 = i12 + 40 | 0;
   do {
    HEAP32[i12 >> 2] = 0;
    i12 = i12 + 4 | 0;
   } while ((i12 | 0) < (i14 | 0));
   i4 = HEAP32[i5 >> 2] | 0;
   i1 = HEAP32[i4 + 108 >> 2] | 0;
   HEAPF32[i1 + 4 >> 2] = 0.0;
   HEAPF32[i1 + 8 >> 2] = 0.0;
   HEAP32[i1 + 1036 >> 2] = 0;
   HEAPF32[i1 + 1040 >> 2] = 0.0;
   HEAPF32[i1 + 1044 >> 2] = 1.0;
   i1 = HEAP32[i4 + 112 >> 2] | 0;
   HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
   i1 = i4 + 136 | 0;
   i39 = i4 + 116 | 0;
   HEAP32[i39 >> 2] = 0;
   HEAP32[i39 + 4 >> 2] = 0;
   HEAP32[i39 + 8 >> 2] = 0;
   HEAP32[i39 + 12 >> 2] = 0;
   HEAP32[i1 >> 2] = 0;
   HEAP32[i1 + 4 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i1 + 12 >> 2] = 0;
   i1 = HEAP32[i4 >> 2] | 0;
   if (i1 >>> 0 > 44) {
    d2 = .3499999940395355;
    d3 = .30000001192092896;
   } else {
    d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
    d2 = d3 + .3499999940395355;
    d3 = d3 + .30000001192092896;
   }
   HEAPF32[i4 + 152 >> 2] = d2;
   HEAPF32[i4 + 156 >> 2] = d3;
   HEAP32[i4 + 104 >> 2] = 0;
   STACKTOP = i37;
   return 0;
  }
 case 1:
  {
   i1 = HEAP32[i36 >> 2] | 0;
   if (!i1) {
    STACKTOP = i37;
    return 0;
   }
   i5 = i36 + 12 | 0;
   i6 = i36 + 104 | 0;
   i7 = i36 + 200 | 0;
   i12 = i36 + 128 | 0;
   i11 = i36 + 108 | 0;
   i8 = i36 + 116 | 0;
   i9 = i36 + 204 | 0;
   i13 = i36 + 80 | 0;
   i14 = i36 + 120 | 0;
   i10 = i16 + 4 | 0;
   i4 = 0;
   while (1) {
    if ((HEAP8[(HEAP32[i5 >> 2] | 0) + i4 >> 0] | 0) == 2) {
     i39 = HEAP32[i6 >> 2] | 0;
     i30 = i18 + (i4 << 3) | 0;
     i32 = i18 + (i4 << 3) + 4 | 0;
     i29 = HEAP32[i32 >> 2] | 0;
     i38 = HEAP32[i39 + 240 >> 2] | 0;
     HEAP32[i16 >> 2] = HEAP32[i30 >> 2];
     HEAP32[i10 >> 2] = i29;
     HEAP32[i34 >> 2] = HEAP32[i16 >> 2];
     HEAP32[i34 + 4 >> 2] = HEAP32[i16 + 4 >> 2];
     mftCall_viii(i38 | 0, i39 | 0, i34 | 0, i17 | 0);
     i32 = HEAP32[i32 >> 2] | 0;
     i39 = HEAP32[i7 >> 2] | 0;
     i38 = HEAP32[i12 >> 2] | 0;
     HEAP32[i38 + (i39 << 3) >> 2] = HEAP32[i30 >> 2];
     HEAP32[i38 + (i39 << 3) + 4 >> 2] = i32;
     _liquid_pack_array(HEAP32[i11 >> 2] | 0, HEAP32[i8 >> 2] | 0, HEAP32[i9 >> 2] | 0, HEAP32[i13 >> 2] | 0, HEAP32[i17 >> 2] | 0);
     HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + (HEAP32[i13 >> 2] | 0);
     i39 = (HEAP32[i7 >> 2] | 0) + 1 | 0;
     HEAP32[i7 >> 2] = i39;
     if ((i39 | 0) == (HEAP32[i14 >> 2] | 0)) break;
     i1 = HEAP32[i36 >> 2] | 0;
    }
    i4 = i4 + 1 | 0;
    if (i4 >>> 0 >= i1 >>> 0) {
     i33 = 137;
     break;
    }
   }
   if ((i33 | 0) == 137) {
    STACKTOP = i37;
    return 0;
   }
   i1 = i36 + 112 | 0;
   i8 = _packetizer_decode(HEAP32[i36 + 100 >> 2] | 0, HEAP32[i11 >> 2] | 0, HEAP32[i1 >> 2] | 0) | 0;
   HEAP32[i36 + 124 >> 2] = i8;
   i9 = HEAP32[i36 + 132 >> 2] | 0;
   if (!i9) {
    HEAP32[i35 >> 2] = 0;
    HEAP32[i35 + 4 >> 2] = 0;
    HEAP32[i35 + 8 >> 2] = 0;
    HEAP32[i35 + 12 >> 2] = 0;
    HEAP32[i35 + 16 >> 2] = 0;
    HEAPF32[i36 + 180 >> 2] = 9.999999960041972e-13;
    i12 = i36 + 140 | 0;
    i14 = i12 + 40 | 0;
    do {
     HEAP32[i12 >> 2] = 0;
     i12 = i12 + 4 | 0;
    } while ((i12 | 0) < (i14 | 0));
    i4 = HEAP32[i36 + 184 >> 2] | 0;
    i1 = HEAP32[i4 + 108 >> 2] | 0;
    HEAPF32[i1 + 4 >> 2] = 0.0;
    HEAPF32[i1 + 8 >> 2] = 0.0;
    HEAP32[i1 + 1036 >> 2] = 0;
    HEAPF32[i1 + 1040 >> 2] = 0.0;
    HEAPF32[i1 + 1044 >> 2] = 1.0;
    i1 = HEAP32[i4 + 112 >> 2] | 0;
    HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
    i1 = i4 + 136 | 0;
    i39 = i4 + 116 | 0;
    HEAP32[i39 >> 2] = 0;
    HEAP32[i39 + 4 >> 2] = 0;
    HEAP32[i39 + 8 >> 2] = 0;
    HEAP32[i39 + 12 >> 2] = 0;
    HEAP32[i1 >> 2] = 0;
    HEAP32[i1 + 4 >> 2] = 0;
    HEAP32[i1 + 8 >> 2] = 0;
    HEAP32[i1 + 12 >> 2] = 0;
    i1 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 > 44) {
     d2 = .3499999940395355;
     d3 = .30000001192092896;
    } else {
     d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
     d2 = d3 + .3499999940395355;
     d3 = d3 + .30000001192092896;
    }
    HEAPF32[i4 + 152 >> 2] = d2;
    HEAPF32[i4 + 156 >> 2] = d3;
    HEAP32[i4 + 104 >> 2] = 0;
    STACKTOP = i37;
    return 0;
   } else {
    i10 = i36 + 184 | 0;
    i6 = HEAP32[i10 >> 2] | 0;
    i11 = i36 + 140 | 0;
    HEAPF32[i36 + 144 >> 2] = +_log10(+HEAPF32[i6 + 80 >> 2]) * -10.0;
    HEAP32[i36 + 148 >> 2] = HEAP32[(HEAP32[i6 + 108 >> 2] | 0) + 8 >> 2];
    HEAP32[i36 + 152 >> 2] = HEAP32[i12 >> 2];
    HEAP32[i36 + 156 >> 2] = HEAP32[i14 >> 2];
    HEAP32[i36 + 160 >> 2] = HEAP32[i36 + 76 >> 2];
    HEAP32[i36 + 164 >> 2] = HEAP32[i13 >> 2];
    HEAP32[i36 + 168 >> 2] = HEAP32[i36 + 88 >> 2];
    HEAP32[i36 + 172 >> 2] = HEAP32[i36 + 92 >> 2];
    HEAP32[i36 + 176 >> 2] = HEAP32[i36 + 96 >> 2];
    i6 = HEAP32[i36 + 44 >> 2] | 0;
    i7 = HEAP32[i36 + 72 >> 2] | 0;
    i1 = HEAP32[i1 >> 2] | 0;
    i4 = HEAP32[i36 + 84 >> 2] | 0;
    i5 = HEAP32[i36 + 136 >> 2] | 0;
    i12 = i34;
    i13 = i11;
    i14 = i12 + 40 | 0;
    do {
     HEAP32[i12 >> 2] = HEAP32[i13 >> 2];
     i12 = i12 + 4 | 0;
     i13 = i13 + 4 | 0;
    } while ((i12 | 0) < (i14 | 0));
    mftCall_iiiiiiii(i9 | 0, i6 | 0, i7 | 0, i1 | 0, i4 | 0, i8 | 0, i34 | 0, i5 | 0) | 0;
    HEAP32[i35 >> 2] = 0;
    HEAP32[i35 + 4 >> 2] = 0;
    HEAP32[i35 + 8 >> 2] = 0;
    HEAP32[i35 + 12 >> 2] = 0;
    HEAP32[i35 + 16 >> 2] = 0;
    HEAPF32[i36 + 180 >> 2] = 9.999999960041972e-13;
    i12 = i11;
    i14 = i12 + 40 | 0;
    do {
     HEAP32[i12 >> 2] = 0;
     i12 = i12 + 4 | 0;
    } while ((i12 | 0) < (i14 | 0));
    i4 = HEAP32[i10 >> 2] | 0;
    i1 = HEAP32[i4 + 108 >> 2] | 0;
    HEAPF32[i1 + 4 >> 2] = 0.0;
    HEAPF32[i1 + 8 >> 2] = 0.0;
    HEAP32[i1 + 1036 >> 2] = 0;
    HEAPF32[i1 + 1040 >> 2] = 0.0;
    HEAPF32[i1 + 1044 >> 2] = 1.0;
    i1 = HEAP32[i4 + 112 >> 2] | 0;
    HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
    i1 = i4 + 136 | 0;
    i39 = i4 + 116 | 0;
    HEAP32[i39 >> 2] = 0;
    HEAP32[i39 + 4 >> 2] = 0;
    HEAP32[i39 + 8 >> 2] = 0;
    HEAP32[i39 + 12 >> 2] = 0;
    HEAP32[i1 >> 2] = 0;
    HEAP32[i1 + 4 >> 2] = 0;
    HEAP32[i1 + 8 >> 2] = 0;
    HEAP32[i1 + 12 >> 2] = 0;
    i1 = HEAP32[i4 >> 2] | 0;
    if (i1 >>> 0 > 44) {
     d2 = .3499999940395355;
     d3 = .30000001192092896;
    } else {
     d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
     d2 = d3 + .3499999940395355;
     d3 = d3 + .30000001192092896;
    }
    HEAPF32[i4 + 152 >> 2] = d2;
    HEAPF32[i4 + 156 >> 2] = d3;
    HEAP32[i4 + 104 >> 2] = 0;
    STACKTOP = i37;
    return 0;
   }
  }
 default:
  {
   i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i4) {
    i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
    i4 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i4 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i6 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i6;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i4 | 32;
    _exit(1);
   } else {
    i6 = i4;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i6 - i1 | 0) >>> 0 < 81) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27217 | 0, 81) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27217 | 0, 81) | 0) >>> 0 < 81) _exit(1); else {
    i7 = 0;
    i8 = gb + 27217 + 81 | 0;
    i9 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i7 = 81;
    i8 = gb + 27217 | 0;
    i9 = i1;
   } while (0);
   _memcpy(i9 | 0, i8 | 0, i7 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i7;
   _exit(1);
  }
 }
 return 0;
}

function _parse_value(i39, i38) {
 i39 = i39 | 0;
 i38 = i38 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i40 = 0, d41 = 0.0;
 i40 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i5 = i40 + 96 | 0;
 i4 = i40 + 88 | 0;
 i19 = i40 + 80 | 0;
 i35 = i40 + 72 | 0;
 i34 = i40 + 64 | 0;
 i33 = i40 + 56 | 0;
 i32 = i40 + 48 | 0;
 i11 = i40 + 40 | 0;
 i8 = i40 + 32 | 0;
 i7 = i40 + 16 | 0;
 i10 = i40 + 8 | 0;
 i15 = i40;
 i9 = i40 + 100 | 0;
 i37 = i39 + 56 | 0;
 do switch (HEAP32[i37 >> 2] | 0) {
 case 256:
  {
   i7 = i39 + 64 | 0;
   i8 = HEAP32[i7 >> 2] | 0;
   i9 = i7 + 4 | 0;
   i10 = HEAP32[i9 >> 2] | 0;
   i4 = (i10 | 0) != 0;
   L5 : do if (i4 & (i8 & 3 | 0) != 0) {
    i5 = i10;
    i4 = i8;
    while (1) {
     if (!(HEAP8[i4 >> 0] | 0)) {
      i13 = i5;
      i14 = i4;
      i36 = 14;
      break L5;
     }
     i4 = i4 + 1 | 0;
     i5 = i5 + -1 | 0;
     i6 = (i5 | 0) != 0;
     if (!(i6 & (i4 & 3 | 0) != 0)) {
      i1 = i5;
      i12 = i6;
      i3 = i4;
      i36 = 5;
      break;
     }
    }
   } else {
    i1 = i10;
    i12 = i4;
    i3 = i8;
    i36 = 5;
   } while (0);
   L9 : do if ((i36 | 0) == 5 ? i12 : 0) if (!(HEAP8[i3 >> 0] | 0)) {
    i13 = i1;
    i14 = i3;
    i36 = 14;
   } else {
    L13 : do if (i1 >>> 0 > 3) while (1) {
     i37 = HEAP32[i3 >> 2] | 0;
     if ((i37 & -2139062144 ^ -2139062144) & i37 + -16843009 | 0) break L13;
     i3 = i3 + 4 | 0;
     i1 = i1 + -4 | 0;
     if (i1 >>> 0 <= 3) {
      i36 = 10;
      break;
     }
    } else i36 = 10; while (0);
    if ((i36 | 0) == 10) if (!i1) break;
    while (1) {
     if (!(HEAP8[i3 >> 0] | 0)) {
      i13 = i1;
      i14 = i3;
      i36 = 14;
      break L9;
     }
     i1 = i1 + -1 | 0;
     if (!i1) break; else i3 = i3 + 1 | 0;
    }
   } while (0);
   if ((i36 | 0) == 14 ? !((i13 | 0) == 0 | (i14 | 0) == 0) : 0) {
    _error_set(i38, i39, gb + 38263 | 0, i15);
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   if (!i8) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   i1 = _malloc(16) | 0;
   if (!i1) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   HEAP32[i1 >> 2] = 2;
   HEAP32[i1 + 4 >> 2] = 1;
   HEAP32[i1 + 8 >> 2] = i8;
   HEAP32[i1 + 12 >> 2] = i10;
   HEAP32[i7 >> 2] = 0;
   HEAP32[i9 >> 2] = 0;
   i39 = i1;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 257:
  {
   i3 = i39 + 64 | 0;
   i1 = HEAP32[i3 >> 2] | 0;
   i3 = HEAP32[i3 + 4 >> 2] | 0;
   i4 = _malloc(16) | 0;
   if (!i4) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   HEAP32[i4 >> 2] = 3;
   HEAP32[i4 + 4 >> 2] = 1;
   i39 = i4 + 8 | 0;
   HEAP32[i39 >> 2] = i1;
   HEAP32[i39 + 4 >> 2] = i3;
   i39 = i4;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 258:
  {
   d2 = +HEAPF64[i39 + 64 >> 3];
   d41 = +Math_abs(+d2);
   HEAPF64[tempDoublePtr >> 3] = d41;
   i39 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   if (i39 >>> 0 > 2146435071 | (i39 | 0) == 2146435071 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 4294967295) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   i1 = _malloc(16) | 0;
   if (!i1) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   HEAP32[i1 >> 2] = 4;
   HEAP32[i1 + 4 >> 2] = 1;
   HEAPF64[i1 + 8 >> 3] = d2;
   i39 = i1;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 260:
  {
   i39 = gb + 8712 | 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 261:
  {
   i39 = gb + 8720 | 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 123:
  {
   i1 = _malloc(36) | 0;
   if (!i1) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   L56 : do if ((HEAP32[gb + 41356 >> 2] | 0) == 0 ? (HEAP32[gb + 41356 >> 2] | 0) == 0 : 0) {
    i25 = HEAP8[gb + 41904 >> 0] | 0;
    HEAP8[gb + 41904 >> 0] = 1;
    if (i25 << 24 >> 24) while (1) {
     _sched_yield() | 0;
     if (HEAP32[gb + 41356 >> 2] | 0) break L56;
    }
    i6 = _open(gb + 38530 | 0, 0, i10) | 0;
    if ((i6 | 0) != -1) {
     HEAP32[i7 >> 2] = i6;
     HEAP32[i7 + 4 >> 2] = i9;
     HEAP32[i7 + 8 >> 2] = 4;
     i3 = ___syscall3(3, i7 | 0) | 0;
     if (i3 >>> 0 > 4294963200) {
      if (!(HEAP32[gb + 41360 >> 2] | 0)) i4 = gb + 41404 | 0; else i4 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
      HEAP32[i4 >> 2] = 0 - i3;
      i3 = -1;
     }
     i5 = (i3 | 0) == 4;
     HEAP32[i8 >> 2] = i6;
     i3 = ___syscall6(6, i8 | 0) | 0;
     i3 = (i3 | 0) == -4 ? -115 : i3;
     if (i3 >>> 0 > 4294963200) {
      if (!(HEAP32[gb + 41360 >> 2] | 0)) i4 = gb + 41404 | 0; else i4 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
      HEAP32[i4 >> 2] = 0 - i3;
     }
     if (i5) i3 = ((HEAPU8[i9 + 1 >> 0] | HEAPU8[i9 >> 0] << 8) << 8 | HEAPU8[i9 + 2 >> 0]) << 8 | HEAPU8[i9 + 3 >> 0]; else i36 = 40;
    } else i36 = 40;
    if ((i36 | 0) == 40) {
     _gettimeofday(i10 | 0, 0) | 0;
     i3 = HEAP32[i10 + 4 >> 2] ^ HEAP32[i10 >> 2];
     i3 = i3 ^ (___syscall20(20, i11 | 0) | 0);
    }
    HEAP32[gb + 41356 >> 2] = (i3 | 0) == 0 ? 1 : i3;
   } while (0);
   HEAP32[i1 >> 2] = 0;
   i25 = i1 + 4 | 0;
   HEAP32[i25 >> 2] = 1;
   i20 = i1 + 8 | 0;
   HEAP32[i20 >> 2] = 0;
   i21 = i1 + 16 | 0;
   HEAP32[i21 >> 2] = 3;
   i3 = _malloc(64) | 0;
   i22 = i1 + 12 | 0;
   HEAP32[i22 >> 2] = i3;
   if (!i3) {
    _free(i1);
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   i23 = i1 + 20 | 0;
   i24 = i1 + 24 | 0;
   HEAP32[i24 >> 2] = i23;
   HEAP32[i23 >> 2] = i23;
   HEAP32[i3 + 4 >> 2] = i23;
   HEAP32[HEAP32[i22 >> 2] >> 2] = i23;
   if (HEAP32[i21 >> 2] | 0) {
    i3 = 1;
    do {
     HEAP32[(HEAP32[i22 >> 2] | 0) + (i3 << 3) + 4 >> 2] = i23;
     HEAP32[(HEAP32[i22 >> 2] | 0) + (i3 << 3) >> 2] = i23;
     i3 = i3 + 1 | 0;
    } while (i3 >>> 0 < 1 << HEAP32[i21 >> 2] >>> 0);
   }
   i16 = i1 + 28 | 0;
   HEAP32[i16 >> 2] = 0;
   HEAP32[i1 + 32 >> 2] = 0;
   _lex_scan(i39, i38);
   switch (HEAP32[i37 >> 2] | 0) {
   case 256:
    {
     i36 = 49;
     break;
    }
   case 125:
    {
     i39 = i1;
     STACKTOP = i40;
     return i39 | 0;
    }
   default:
    i36 = 50;
   }
   L92 : do if ((i36 | 0) == 49) {
    i17 = i39 + 64 | 0;
    i18 = i17 + 4 | 0;
    L94 : while (1) {
     i19 = HEAP32[i17 >> 2] | 0;
     i3 = HEAP32[i18 >> 2] | 0;
     HEAP32[i17 >> 2] = 0;
     HEAP32[i18 >> 2] = 0;
     if (!i19) {
      i1 = 0;
      i36 = 194;
      break;
     }
     i13 = i19;
     i11 = i13 & 3;
     i4 = (i3 | 0) != 0;
     L97 : do if (i4 & (i11 | 0) != 0) {
      i4 = i19;
      while (1) {
       if (!(HEAP8[i4 >> 0] | 0)) {
        i27 = i3;
        i31 = i4;
        i36 = 64;
        break L97;
       }
       i4 = i4 + 1 | 0;
       i3 = i3 + -1 | 0;
       i5 = (i3 | 0) != 0;
       if (!(i5 & (i4 & 3 | 0) != 0)) {
        i26 = i3;
        i28 = i5;
        i30 = i4;
        i36 = 55;
        break;
       }
      }
     } else {
      i26 = i3;
      i28 = i4;
      i30 = i19;
      i36 = 55;
     } while (0);
     L101 : do if ((i36 | 0) == 55 ? (i36 = 0, i28) : 0) if (!(HEAP8[i30 >> 0] | 0)) {
      i27 = i26;
      i31 = i30;
      i36 = 64;
     } else {
      L105 : do if (i26 >>> 0 > 3) {
       i3 = i26;
       i4 = i30;
       while (1) {
        i15 = HEAP32[i4 >> 2] | 0;
        if ((i15 & -2139062144 ^ -2139062144) & i15 + -16843009 | 0) break L105;
        i4 = i4 + 4 | 0;
        i3 = i3 + -4 | 0;
        if (i3 >>> 0 <= 3) {
         i36 = 60;
         break;
        }
       }
      } else {
       i3 = i26;
       i4 = i30;
       i36 = 60;
      } while (0);
      if ((i36 | 0) == 60) {
       i36 = 0;
       if (!i3) break;
      }
      while (1) {
       if (!(HEAP8[i4 >> 0] | 0)) {
        i27 = i3;
        i31 = i4;
        i36 = 64;
        break L101;
       }
       i3 = i3 + -1 | 0;
       if (!i3) break; else i4 = i4 + 1 | 0;
      }
     } while (0);
     if ((i36 | 0) == 64 ? (i36 = 0, !((i27 | 0) == 0 | (i31 | 0) == 0)) : 0) {
      i36 = 65;
      break;
     }
     _lex_scan(i39, i38);
     if ((HEAP32[i37 >> 2] | 0) != 58) {
      i36 = 67;
      break;
     }
     _lex_scan(i39, i38);
     i14 = _parse_value(i39, i38) | 0;
     if (!i14) {
      i36 = 69;
      break;
     }
     i15 = i14 + 4 | 0;
     i3 = HEAP32[i15 >> 2] | 0;
     if ((i3 | 0) == -1) i3 = -1; else {
      i3 = i3 + 1 | 0;
      HEAP32[i15 >> 2] = i3;
     }
     if ((i1 | 0) == (i14 | 0) | (HEAP32[i1 >> 2] | 0) != 0) {
      i36 = 73;
      break;
     }
     i12 = HEAP32[i16 >> 2] | 0;
     HEAP32[i16 >> 2] = i12 + 1;
     i3 = HEAP32[i21 >> 2] | 0;
     if ((HEAP32[i20 >> 2] | 0) >>> 0 >= 1 << i3 >>> 0) {
      i4 = HEAP32[i22 >> 2] | 0;
      if (i4) {
       _free(i4);
       i3 = HEAP32[i21 >> 2] | 0;
      }
      i4 = i3 + 1 | 0;
      HEAP32[i21 >> 2] = i4;
      i4 = 1 << i4;
      i3 = i4 << 3;
      if (!i3) {
       i36 = 80;
       break;
      }
      i3 = _malloc(i3) | 0;
      HEAP32[i22 >> 2] = i3;
      if (!i3) {
       i36 = 143;
       break;
      }
      HEAP32[i3 + 4 >> 2] = i23;
      HEAP32[HEAP32[i22 >> 2] >> 2] = i23;
      if (HEAP32[i21 >> 2] | 0) {
       i3 = 1;
       do {
        HEAP32[(HEAP32[i22 >> 2] | 0) + (i3 << 3) + 4 >> 2] = i23;
        HEAP32[(HEAP32[i22 >> 2] | 0) + (i3 << 3) >> 2] = i23;
        i3 = i3 + 1 | 0;
       } while (i3 >>> 0 < 1 << HEAP32[i21 >> 2] >>> 0);
      }
      i3 = HEAP32[i24 >> 2] | 0;
      HEAP32[i24 >> 2] = i23;
      HEAP32[i23 >> 2] = i23;
      if ((i3 | 0) != (i23 | 0)) {
       i10 = i4 + -1 | 0;
       do {
        i6 = i3 + 4 | 0;
        i9 = i3;
        i3 = HEAP32[i6 >> 2] | 0;
        i4 = HEAP32[i9 + 8 >> 2] & i10;
        i5 = HEAP32[i22 >> 2] | 0;
        i7 = i5 + (i4 << 3) | 0;
        i8 = HEAP32[i7 >> 2] | 0;
        do if ((i8 | 0) == (i23 | 0)) {
         i4 = i5 + (i4 << 3) + 4 | 0;
         if ((i23 | 0) != (HEAP32[i4 >> 2] | 0)) {
          i36 = 89;
          break;
         }
         HEAP32[i6 >> 2] = i23;
         HEAP32[i9 >> 2] = HEAP32[i23 >> 2];
         HEAP32[(HEAP32[i23 >> 2] | 0) + 4 >> 2] = i9;
         HEAP32[i23 >> 2] = i9;
         HEAP32[i4 >> 2] = i9;
        } else i36 = 89; while (0);
        if ((i36 | 0) == 89) {
         i36 = 0;
         HEAP32[i6 >> 2] = i8;
         HEAP32[i9 >> 2] = HEAP32[i8 >> 2];
         HEAP32[(HEAP32[i8 >> 2] | 0) + 4 >> 2] = i9;
         HEAP32[i8 >> 2] = i9;
        }
        HEAP32[i7 >> 2] = i9;
       } while ((i3 | 0) != (i23 | 0));
      }
     }
     i9 = (i11 | 0) == 0;
     L145 : do if (i9) {
      i3 = i19;
      i36 = 94;
     } else {
      i4 = i19;
      i3 = i13;
      while (1) {
       if (!(HEAP8[i4 >> 0] | 0)) break L145;
       i4 = i4 + 1 | 0;
       i3 = i4;
       if (!(i3 & 3)) {
        i3 = i4;
        i36 = 94;
        break;
       }
      }
     } while (0);
     if ((i36 | 0) == 94) {
      while (1) {
       i4 = HEAP32[i3 >> 2] | 0;
       if (!((i4 & -2139062144 ^ -2139062144) & i4 + -16843009)) i3 = i3 + 4 | 0; else break;
      }
      if ((i4 & 255) << 24 >> 24) do i3 = i3 + 1 | 0; while ((HEAP8[i3 >> 0] | 0) != 0);
     }
     i8 = _hashlittle(i19, i3 - i13 | 0, HEAP32[gb + 41356 >> 2] | 0) | 0;
     i11 = (1 << HEAP32[i21 >> 2]) + -1 & i8;
     i36 = HEAP32[i22 >> 2] | 0;
     i10 = i36 + (i11 << 3) | 0;
     i3 = HEAP32[i10 >> 2] | 0;
     i11 = i36 + (i11 << 3) + 4 | 0;
     if ((i3 | 0) == (i23 | 0) ? (i23 | 0) == (HEAP32[i11 >> 2] | 0) : 0) i36 = 113; else i36 = 101;
     L161 : do if ((i36 | 0) == 101) {
      while (1) {
       i36 = 0;
       if ((HEAP32[i3 + 8 >> 2] | 0) == (i8 | 0)) {
        i5 = i3 + 20 | 0;
        i6 = HEAP8[i5 >> 0] | 0;
        i4 = HEAP8[i19 >> 0] | 0;
        if (!(i6 << 24 >> 24 == 0 ? 1 : i6 << 24 >> 24 != i4 << 24 >> 24)) {
         i7 = i19;
         do {
          i5 = i5 + 1 | 0;
          i7 = i7 + 1 | 0;
          i6 = HEAP8[i5 >> 0] | 0;
          i4 = HEAP8[i7 >> 0] | 0;
         } while (!(i6 << 24 >> 24 == 0 ? 1 : i6 << 24 >> 24 != i4 << 24 >> 24));
        }
        if (i6 << 24 >> 24 == i4 << 24 >> 24) break;
       }
       if ((i3 | 0) == (HEAP32[i11 >> 2] | 0)) {
        i36 = 113;
        break L161;
       }
       i3 = HEAP32[i3 + 4 >> 2] | 0;
       i36 = 101;
      }
      if (!i3) i36 = 113; else {
       i3 = i3 + 12 | 0;
       i4 = HEAP32[i3 >> 2] | 0;
       do if (i4 | 0) {
        i5 = i4 + 4 | 0;
        i6 = HEAP32[i5 >> 2] | 0;
        if ((i6 | 0) == -1) break;
        i13 = i6 + -1 | 0;
        HEAP32[i5 >> 2] = i13;
        if (i13 | 0) break;
        _json_delete(i4);
       } while (0);
       HEAP32[i3 >> 2] = i14;
      }
     } while (0);
     if ((i36 | 0) == 113) {
      i36 = 0;
      L181 : do if (i9) {
       i3 = i19;
       i36 = 116;
      } else {
       i3 = i19;
       i4 = i13;
       while (1) {
        if (!(HEAP8[i3 >> 0] | 0)) {
         i3 = i4;
         break L181;
        }
        i3 = i3 + 1 | 0;
        i4 = i3;
        if (!(i4 & 3)) {
         i36 = 116;
         break;
        }
       }
      } while (0);
      if ((i36 | 0) == 116) {
       i36 = 0;
       while (1) {
        i4 = HEAP32[i3 >> 2] | 0;
        if (!((i4 & -2139062144 ^ -2139062144) & i4 + -16843009)) i3 = i3 + 4 | 0; else break;
       }
       if ((i4 & 255) << 24 >> 24) do i3 = i3 + 1 | 0; while ((HEAP8[i3 >> 0] | 0) != 0);
      }
      i5 = i3 - i13 | 0;
      if (i5 >>> 0 > 4294967274) {
       i36 = 143;
       break;
      }
      i3 = i5 + 21 | 0;
      if (!i3) {
       i36 = 143;
       break;
      }
      i7 = _malloc(i3) | 0;
      if (!i7) {
       i36 = 143;
       break;
      }
      HEAP32[i7 + 8 >> 2] = i8;
      HEAP32[i7 + 16 >> 2] = i12;
      i4 = i7 + 20 | 0;
      i3 = i5 + 1 | 0;
      L198 : do if (!((i4 ^ i13) & 3)) {
       if (!i9) {
        i6 = i19;
        do {
         i13 = HEAP8[i6 >> 0] | 0;
         HEAP8[i4 >> 0] = i13;
         if (!(i13 << 24 >> 24)) break L198;
         i3 = i3 + -1 | 0;
         i6 = i6 + 1 | 0;
         i4 = i4 + 1 | 0;
         i5 = (i3 | 0) != 0;
        } while (i5 & (i6 & 3 | 0) != 0);
        if (i5) i5 = i6; else {
         i3 = 0;
         break;
        }
       } else i5 = i19;
       if (!(HEAP8[i5 >> 0] | 0)) break;
       if (i3 >>> 0 <= 3) {
        i36 = 136;
        break;
       }
       i6 = i4;
       while (1) {
        i4 = HEAP32[i5 >> 2] | 0;
        if ((i4 & -2139062144 ^ -2139062144) & i4 + -16843009 | 0) {
         i36 = 133;
         break;
        }
        HEAP32[i6 >> 2] = i4;
        i3 = i3 + -4 | 0;
        i5 = i5 + 4 | 0;
        i4 = i6 + 4 | 0;
        if (i3 >>> 0 > 3) i6 = i4; else {
         i36 = 135;
         break;
        }
       }
       if ((i36 | 0) == 133) {
        i4 = i6;
        i36 = 136;
        break;
       } else if ((i36 | 0) == 135) {
        i36 = 0;
        if (!i3) {
         i3 = 0;
         break;
        } else {
         i36 = 136;
         break;
        }
       }
      } else {
       i5 = i19;
       i36 = 136;
      } while (0);
      L214 : do if ((i36 | 0) == 136) while (1) {
       i36 = 0;
       i13 = HEAP8[i5 >> 0] | 0;
       HEAP8[i4 >> 0] = i13;
       if (!(i13 << 24 >> 24)) break L214;
       i3 = i3 + -1 | 0;
       i4 = i4 + 1 | 0;
       if (!i3) {
        i3 = 0;
        break;
       } else {
        i5 = i5 + 1 | 0;
        i36 = 136;
       }
      } while (0);
      _memset(i4 | 0, 0, i3 | 0) | 0;
      HEAP32[i7 + 12 >> 2] = i14;
      i3 = i7 + 4 | 0;
      HEAP32[i3 >> 2] = i7;
      HEAP32[i7 >> 2] = i7;
      i4 = HEAP32[i10 >> 2] | 0;
      do if ((i4 | 0) == (i23 | 0)) {
       if ((i23 | 0) != (HEAP32[i11 >> 2] | 0)) {
        i36 = 141;
        break;
       }
       HEAP32[i3 >> 2] = i23;
       HEAP32[i7 >> 2] = HEAP32[i23 >> 2];
       HEAP32[(HEAP32[i23 >> 2] | 0) + 4 >> 2] = i7;
       HEAP32[i23 >> 2] = i7;
       HEAP32[i11 >> 2] = i7;
      } else i36 = 141; while (0);
      if ((i36 | 0) == 141) {
       HEAP32[i3 >> 2] = i4;
       HEAP32[i7 >> 2] = HEAP32[i4 >> 2];
       HEAP32[(HEAP32[i4 >> 2] | 0) + 4 >> 2] = i7;
       HEAP32[i4 >> 2] = i7;
      }
      HEAP32[i10 >> 2] = i7;
      HEAP32[i20 >> 2] = (HEAP32[i20 >> 2] | 0) + 1;
     }
     i3 = HEAP32[i15 >> 2] | 0;
     if ((i3 | 0) != -1 ? (i36 = i3 + -1 | 0, HEAP32[i15 >> 2] = i36, (i36 | 0) == 0) : 0) _json_delete(i14);
     _free(i19);
     _lex_scan(i39, i38);
     switch (HEAP32[i37 >> 2] | 0) {
     case 125:
      {
       i36 = 194;
       break L94;
      }
     case 44:
      break;
     default:
      {
       i36 = 154;
       break L94;
      }
     }
     _lex_scan(i39, i38);
     if ((HEAP32[i37 >> 2] | 0) != 256) {
      i36 = 50;
      break L92;
     }
    }
    if ((i36 | 0) == 65) {
     _free(i19);
     _error_set(i38, i39, gb + 38331 | 0, i33);
     break;
    } else if ((i36 | 0) == 67) {
     _free(i19);
     _error_set(i38, i39, gb + 38368 | 0, i34);
     break;
    } else if ((i36 | 0) == 69) {
     _free(i19);
     break;
    } else if ((i36 | 0) == 73) {
     if ((i3 | 0) != -1 ? (i39 = i3 + -1 | 0, HEAP32[i15 >> 2] = i39, (i39 | 0) == 0) : 0) _json_delete(i14);
    } else if ((i36 | 0) == 80) {
     HEAP32[i22 >> 2] = 0;
     i36 = 143;
    } else if ((i36 | 0) == 154) {
     _error_set(i38, i39, gb + 38381 | 0, i35);
     break;
    } else if ((i36 | 0) == 194) {
     STACKTOP = i40;
     return i1 | 0;
    }
    if (((i36 | 0) == 143 ? (i29 = HEAP32[i15 >> 2] | 0, (i29 | 0) != -1) : 0) ? (i39 = i29 + -1 | 0, HEAP32[i15 >> 2] = i39, (i39 | 0) == 0) : 0) _json_delete(i14);
    _free(i19);
    i3 = HEAP32[i15 >> 2] | 0;
    if ((i3 | 0) != -1 ? (i39 = i3 + -1 | 0, HEAP32[i15 >> 2] = i39, (i39 | 0) == 0) : 0) _json_delete(i14);
   } while (0);
   if ((i36 | 0) == 50) _error_set(i38, i39, gb + 38308 | 0, i32);
   i3 = HEAP32[i25 >> 2] | 0;
   if ((i3 | 0) == -1) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   i39 = i3 + -1 | 0;
   HEAP32[i25 >> 2] = i39;
   if (i39 | 0) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   _json_delete(i1);
   i39 = 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 91:
  {
   i1 = _malloc(24) | 0;
   if (!i1) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   i11 = i1 + 4 | 0;
   SIMD_Int32x4_store(HEAPU8, i1, SIMD_Int32x4(1, 1, 8, 0));
   i36 = _malloc(32) | 0;
   i6 = i1 + 16 | 0;
   HEAP32[i6 >> 2] = i36;
   if (!i36) {
    _free(i1);
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   HEAP32[i1 + 20 >> 2] = 0;
   _lex_scan(i39, i38);
   switch (HEAP32[i37 >> 2] | 0) {
   case 0:
    {
     i36 = 188;
     break;
    }
   case 93:
    {
     i39 = i1;
     STACKTOP = i40;
     return i39 | 0;
    }
   default:
    i36 = 162;
   }
   L269 : do if ((i36 | 0) == 162) {
    i7 = i1 + 12 | 0;
    i8 = i1 + 8 | 0;
    L271 : while (1) {
     i9 = _parse_value(i39, i38) | 0;
     if (!i9) break L269;
     i10 = i9 + 4 | 0;
     i3 = HEAP32[i10 >> 2] | 0;
     if ((i3 | 0) == -1) i3 = -1; else {
      i3 = i3 + 1 | 0;
      HEAP32[i10 >> 2] = i3;
     }
     do if ((i1 | 0) == (i9 | 0) | (HEAP32[i1 >> 2] | 0) != 1) {
      if ((i3 | 0) == -1) break L269;
      i4 = i3 + -1 | 0;
      HEAP32[i10 >> 2] = i4;
      if (!i4) {
       _json_delete(i9);
       i3 = 0;
       i36 = 181;
      } else {
       i3 = 0;
       i36 = 183;
      }
     } else {
      i3 = HEAP32[i8 >> 2] | 0;
      i5 = HEAP32[i6 >> 2] | 0;
      if (((HEAP32[i7 >> 2] | 0) + 1 | 0) >>> 0 > i3 >>> 0) {
       i4 = i3 + 1 | 0;
       i3 = i3 << 1;
       i3 = i4 >>> 0 > i3 >>> 0 ? i4 : i3;
       i4 = i3 << 2;
       if (i4 | 0 ? (i17 = _malloc(i4) | 0, i17 | 0) : 0) {
        HEAP32[i8 >> 2] = i3;
        HEAP32[i6 >> 2] = i17;
        _memcpy(i17 | 0, i5 | 0, HEAP32[i7 >> 2] << 2 | 0) | 0;
        if (i5 | 0) _free(i5);
        i18 = HEAP32[i6 >> 2] | 0;
        i36 = 176;
       }
      } else {
       i18 = i5;
       i36 = 176;
      }
      if ((i36 | 0) == 176 ? (i36 = 0, i18 | 0) : 0) {
       HEAP32[i18 + (HEAP32[i7 >> 2] << 2) >> 2] = i9;
       HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + 1;
       i3 = 1;
       i36 = 181;
       break;
      }
      i3 = HEAP32[i10 >> 2] | 0;
      if ((i3 | 0) == -1) break L269;
      i4 = i3 + -1 | 0;
      HEAP32[i10 >> 2] = i4;
      if (!i4) {
       _json_delete(i9);
       i3 = 0;
       i36 = 181;
      } else {
       i3 = 0;
       i36 = 182;
      }
     } while (0);
     if ((i36 | 0) == 181) {
      i4 = HEAP32[i10 >> 2] | 0;
      i36 = 182;
     }
     if ((i36 | 0) == 182) if ((i4 | 0) == -1) {
      i16 = i3;
      i36 = 185;
     } else i36 = 183;
     if ((i36 | 0) == 183) {
      i36 = 0;
      i35 = i4 + -1 | 0;
      HEAP32[i10 >> 2] = i35;
      if (!i35) {
       _json_delete(i9);
       if (!i3) break L269;
      } else {
       i16 = i3;
       i36 = 185;
      }
     }
     if ((i36 | 0) == 185 ? (i36 = 0, !i16) : 0) break L269;
     _lex_scan(i39, i38);
     switch (HEAP32[i37 >> 2] | 0) {
     case 93:
      break L271;
     case 44:
      break;
     default:
      {
       i36 = 188;
       break L269;
      }
     }
     _lex_scan(i39, i38);
     if (!(HEAP32[i37 >> 2] | 0)) {
      i36 = 188;
      break L269;
     }
    }
    STACKTOP = i40;
    return i1 | 0;
   } while (0);
   if ((i36 | 0) == 188) _error_set(i38, i39, gb + 38394 | 0, i19);
   i3 = HEAP32[i11 >> 2] | 0;
   if ((i3 | 0) == -1) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   i39 = i3 + -1 | 0;
   HEAP32[i11 >> 2] = i39;
   if (i39 | 0) {
    i39 = 0;
    STACKTOP = i40;
    return i39 | 0;
   }
   _json_delete(i1);
   i39 = 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 case -1:
  {
   _error_set(i38, i39, gb + 38407 | 0, i4);
   i39 = 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 case 259:
  {
   i39 = gb + 8704 | 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 default:
  {
   _error_set(i38, i39, gb + 38421 | 0, i5);
   i39 = 0;
   STACKTOP = i40;
   return i39 | 0;
  }
 } while (0);
 return 0;
}

function _ofdmframesync_execute(i74, i75, i73) {
 i74 = i74 | 0;
 i75 = i75 | 0;
 i73 = i73 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, d6 = 0.0, i7 = 0, d8 = 0.0, d9 = 0.0, i10 = 0, d11 = 0.0, i12 = 0, d13 = 0.0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0, i76 = 0, i77 = 0;
 i77 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i16 = i77 + 40 | 0;
 i17 = i77 + 32 | 0;
 i28 = i77 + 24 | 0;
 i39 = i77 + 16 | 0;
 i50 = i77 + 8 | 0;
 i61 = i77;
 if (!i73) {
  STACKTOP = i77;
  return;
 }
 i70 = i74 + 104 | 0;
 i71 = i74 + 60 | 0;
 i72 = i74 + 168 | 0;
 i18 = i74 + 124 | 0;
 i19 = i74 + 4 | 0;
 i20 = i74 + 8 | 0;
 i21 = i74 + 84 | 0;
 i22 = i74 + 80 | 0;
 i23 = i16 + 4 | 0;
 i24 = i74 + 140 | 0;
 i25 = i74 + 136 | 0;
 i26 = i74 + 176 | 0;
 i27 = i74 + 180 | 0;
 i29 = i74 + 108 | 0;
 i30 = i16 + 4 | 0;
 i31 = i16 + 4 | 0;
 i32 = i74 + 152 | 0;
 i33 = i74 + 132 | 0;
 i34 = i74 + 88 | 0;
 i35 = i16 + 4 | 0;
 i36 = i74 + 148 | 0;
 i37 = i74 + 144 | 0;
 i38 = i74 + 68 | 0;
 i40 = i28 + 4 | 0;
 i41 = i39 + 4 | 0;
 i42 = i50 + 4 | 0;
 i43 = i74 + 128 | 0;
 i44 = i74 + 92 | 0;
 i45 = i74 + 56 | 0;
 i46 = i74 + 48 | 0;
 i47 = i74 + 32 | 0;
 i48 = i28 + 4 | 0;
 i49 = i39 + 4 | 0;
 i51 = i74 + 156 | 0;
 i52 = i74 + 20 | 0;
 i53 = i74 + 24 | 0;
 i54 = i74 + 96 | 0;
 i55 = i61 + 4 | 0;
 i56 = i74 + 100 | 0;
 i57 = i50 + 4 | 0;
 i58 = i74 + 112 | 0;
 i59 = i74 + 116 | 0;
 i60 = i17 + 4 | 0;
 i62 = i74 + 12 | 0;
 i63 = i74 + 52 | 0;
 i64 = i74 + 72 | 0;
 i65 = i16 + 4 | 0;
 i66 = i74 + 160 | 0;
 i67 = i74 + 164 | 0;
 i68 = i74 + 184 | 0;
 i76 = 0;
 do {
  i1 = HEAP32[i75 + (i76 << 3) >> 2] | 0;
  i4 = HEAP32[i75 + (i76 << 3) + 4 >> 2] | 0;
  do if (HEAP32[i70 >> 2] | 0) {
   i15 = HEAP32[i29 >> 2] | 0;
   mftCall_vi(HEAP32[i15 + 1048 >> 2] | 0, i15 | 0);
   d11 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]);
   d6 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
   d9 = +HEAPF32[i15 + 1040 >> 2];
   d8 = +HEAPF32[i15 + 1044 >> 2] - d9 * 0.0;
   d9 = -d9;
   d2 = d11 * d8 - d6 * d9;
   d3 = d11 * d9 + d6 * d8;
   if ((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
    ___mulsc3(i16, d11, d6, d8, d9);
    d2 = +HEAPF32[i16 >> 2];
    d3 = +HEAPF32[i30 >> 2];
   }
   i1 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
   i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
   i15 = HEAP32[i29 >> 2] | 0;
   i5 = i15 + 4 | 0;
   d2 = +HEAPF32[i15 + 8 >> 2] + +HEAPF32[i5 >> 2];
   HEAPF32[i5 >> 2] = d2;
   if (d2 > 3.141592653589793) {
    HEAPF32[i5 >> 2] = d2 + -6.283185307179586;
    break;
   }
   if (d2 < -3.141592653589793) HEAPF32[i5 >> 2] = d2 + 6.283185307179586;
  } while (0);
  i7 = HEAP32[i71 >> 2] | 0;
  i10 = i7 + 24 | 0;
  i5 = HEAP32[i7 + 16 >> 2] & (HEAP32[i10 >> 2] | 0) + 1;
  HEAP32[i10 >> 2] = i5;
  if (!i5) {
   i5 = HEAP32[i7 >> 2] | 0;
   i12 = i7 + 4 | 0;
   _memmove(i5 | 0, i5 + (HEAP32[i7 + 12 >> 2] << 3) | 0, (HEAP32[i12 >> 2] << 3) + -8 | 0) | 0;
   i5 = HEAP32[i10 >> 2] | 0;
  } else i12 = i7 + 4 | 0;
  i15 = i5 + -1 + (HEAP32[i12 >> 2] | 0) | 0;
  i12 = HEAP32[i7 >> 2] | 0;
  HEAP32[i12 + (i15 << 3) >> 2] = i1;
  HEAP32[i12 + (i15 << 3) + 4 >> 2] = i4;
  if (HEAP32[i72 >> 2] | 0) {
   i7 = HEAP32[i26 >> 2] | 0;
   i10 = i7 + 24 | 0;
   i5 = HEAP32[i7 + 16 >> 2] & (HEAP32[i10 >> 2] | 0) + 1;
   HEAP32[i10 >> 2] = i5;
   if (!i5) {
    i5 = HEAP32[i7 >> 2] | 0;
    i12 = i7 + 4 | 0;
    _memmove(i5 | 0, i5 + (HEAP32[i7 + 12 >> 2] << 3) | 0, (HEAP32[i12 >> 2] << 3) + -8 | 0) | 0;
    i5 = HEAP32[i10 >> 2] | 0;
   } else i12 = i7 + 4 | 0;
   i10 = i5 + -1 + (HEAP32[i12 >> 2] | 0) | 0;
   i5 = HEAP32[i7 >> 2] | 0;
   HEAP32[i5 + (i10 << 3) >> 2] = i1;
   HEAP32[i5 + (i10 << 3) + 4 >> 2] = i4;
   i10 = HEAP32[i27 >> 2] | 0;
   d3 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]);
   d2 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
   i5 = i10 + 24 | 0;
   i1 = HEAP32[i10 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
   HEAP32[i5 >> 2] = i1;
   if (!i1) {
    i4 = HEAP32[i10 >> 2] | 0;
    i7 = i10 + 4 | 0;
    _memmove(i4 | 0, i4 + (HEAP32[i10 + 12 >> 2] << 2) | 0, (HEAP32[i7 >> 2] << 2) + -4 | 0) | 0;
    i4 = i10;
    i1 = HEAP32[i5 >> 2] | 0;
   } else {
    i7 = i10 + 4 | 0;
    i4 = i10;
   }
   HEAPF32[(HEAP32[i4 >> 2] | 0) + (i1 + -1 + (HEAP32[i7 >> 2] | 0) << 2) >> 2] = d3 * d3 + d2 * d2;
  }
  switch (HEAP32[i70 >> 2] | 0) {
  case 0:
   {
    i15 = (HEAP32[i18 >> 2] | 0) + 1 | 0;
    HEAP32[i18 >> 2] = i15;
    i5 = HEAP32[i74 >> 2] | 0;
    if (i15 >>> 0 >= i5 >>> 0) {
     HEAP32[i18 >> 2] = 0;
     i7 = HEAP32[i71 >> 2] | 0;
     i7 = (HEAP32[i7 >> 2] | 0) + (HEAP32[i7 + 24 >> 2] << 3) | 0;
     i10 = HEAP32[i20 >> 2] | 0;
     i1 = i5 + i10 | 0;
     if (i10 >>> 0 < i1 >>> 0) {
      d2 = 0.0;
      i4 = i10;
      do {
       d13 = +HEAPF32[i7 + (i4 << 3) >> 2];
       d14 = +HEAPF32[i7 + (i4 << 3) + 4 >> 2];
       d2 = d2 + (d13 * d13 + d14 * d14);
       i4 = i4 + 1 | 0;
      } while ((i4 | 0) != (i1 | 0));
     } else d2 = 0.0;
     d14 = +(i5 >>> 0) / d2;
     _ofdmframesync_estimate_gain_S0(i74, i7 + (i10 << 3) | 0, HEAP32[i21 >> 2] | 0);
     _ofdmframesync_S0_metrics(i74, HEAP32[i21 >> 2] | 0, i16);
     d2 = d14 * +HEAPF32[i16 >> 2];
     d3 = d14 * +HEAPF32[i31 >> 2];
     HEAPF32[i16 >> 2] = d2;
     HEAPF32[i31 >> 2] = d3;
     d8 = +Math_atan2(+d3, +d2);
     i5 = HEAP32[i19 >> 2] | 0;
     HEAPF32[i22 >> 2] = d14;
     d2 = +Math_abs(+d2);
     i15 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
     d3 = +Math_abs(+d3);
     i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     i12 = i15 >>> 0 < i4 >>> 0;
     i1 = i12 ? i4 : i15;
     i4 = i12 ? i15 : i4;
     d3 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]);
     d2 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) != 2139095040) {
      if (i1 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i1 - i4 | 0) >>> 0 > 209715199) {
       d2 = d3 + d2;
       break;
      }
      if (i1 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
       d2 = d2 * 1237940039285380274899124.0e3;
       d3 = d3 * 1237940039285380274899124.0e3;
       d6 = 8.077935669463161e-28;
      } else d6 = 1.0; else {
       d2 = d2 * 8.077935669463161e-28;
       d3 = d3 * 8.077935669463161e-28;
       d6 = 1237940039285380274899124.0e3;
      }
      d14 = d3;
      d2 = d6 * +Math_sqrt(+(d14 * d14 + d2 * d2));
     } while (0);
     if (d2 > +HEAPF32[i32 >> 2]) {
      i12 = ~~+_roundf(+(d8 * +(i5 >>> 0) / 6.283185307179586));
      i15 = HEAP32[i74 >> 2] | 0;
      HEAP32[i18 >> 2] = (((i15 + i12 | 0) >>> 0) % (i5 >>> 0) | 0) + i15;
      HEAP32[i70 >> 2] = 1;
     }
    }
    break;
   }
  case 1:
   {
    i15 = (HEAP32[i18 >> 2] | 0) + 1 | 0;
    HEAP32[i18 >> 2] = i15;
    if (i15 >>> 0 >= (HEAP32[i19 >> 2] | 0) >>> 0) {
     HEAP32[i18 >> 2] = 0;
     i15 = HEAP32[i71 >> 2] | 0;
     _ofdmframesync_estimate_gain_S0(i74, (HEAP32[i15 >> 2] | 0) + (HEAP32[i15 + 24 >> 2] << 3) + (HEAP32[i20 >> 2] << 3) | 0, HEAP32[i21 >> 2] | 0);
     _ofdmframesync_S0_metrics(i74, HEAP32[i21 >> 2] | 0, i16);
     d13 = +HEAPF32[i22 >> 2];
     d14 = d13 * +HEAPF32[i23 >> 2];
     HEAPF32[i25 >> 2] = d13 * +HEAPF32[i16 >> 2];
     HEAPF32[i24 >> 2] = d14;
     HEAP32[i70 >> 2] = 2;
    }
    break;
   }
  case 2:
   {
    i15 = (HEAP32[i18 >> 2] | 0) + 1 | 0;
    HEAP32[i18 >> 2] = i15;
    if (i15 >>> 0 >= (HEAP32[i19 >> 2] | 0) >>> 0) {
     i1 = HEAP32[i20 >> 2] | 0;
     HEAP32[i18 >> 2] = i1 + (HEAP32[i74 >> 2] | 0) - (HEAP32[i33 >> 2] | 0);
     i5 = HEAP32[i71 >> 2] | 0;
     i5 = (HEAP32[i5 >> 2] | 0) + (HEAP32[i5 + 24 >> 2] << 3) | 0;
     _ofdmframesync_estimate_gain_S0(i74, i5 + (i1 << 3) | 0, HEAP32[i34 >> 2] | 0);
     _ofdmframesync_S0_metrics(i74, HEAP32[i34 >> 2] | 0, i16);
     d13 = +HEAPF32[i22 >> 2];
     d14 = d13 * +HEAPF32[i16 >> 2];
     d13 = d13 * +HEAPF32[i35 >> 2];
     HEAPF32[i16 >> 2] = d14;
     HEAPF32[i35 >> 2] = d13;
     HEAPF32[i37 >> 2] = d14;
     HEAPF32[i36 >> 2] = d13;
     d14 = +Math_atan2(+(d13 + +HEAPF32[i24 >> 2]), +(d14 + +HEAPF32[i25 >> 2]));
     i1 = HEAP32[i19 >> 2] | 0;
     i4 = ~~+_roundf(+(d14 * +(i1 >>> 0) / 6.283185307179586));
     HEAP32[i18 >> 2] = (HEAP32[i18 >> 2] | 0) - i4;
     i4 = HEAP32[i74 >> 2] | 0;
     if (i4) {
      i1 = 0;
      do {
       i15 = HEAP32[i34 >> 2] | 0;
       d2 = +HEAPF32[i15 + (i1 << 3) >> 2];
       d3 = +HEAPF32[i15 + (i1 << 3) + 4 >> 2];
       i15 = HEAP32[i21 >> 2] | 0;
       d6 = +HEAPF32[i15 + (i1 << 3) >> 2];
       d8 = -+HEAPF32[i15 + (i1 << 3) + 4 >> 2];
       d13 = d2 * d6 - d3 * d8;
       d14 = d3 * d6 + d2 * d8;
       if ((d13 != d13 | 0.0 != 0.0) & (d14 != d14 | 0.0 != 0.0)) {
        ___mulsc3(i17, d2, d3, d6, d8);
        i4 = HEAP32[i74 >> 2] | 0;
       }
       i1 = i1 + 1 | 0;
      } while (i1 >>> 0 < i4 >>> 0);
      i1 = HEAP32[i19 >> 2] | 0;
     }
     if (!i1) {
      i1 = 0;
      d3 = 0.0;
      d2 = 0.0;
     } else {
      i4 = 0;
      d3 = 0.0;
      d2 = 0.0;
      do {
       d6 = +HEAPF32[i5 + (i4 << 3) >> 2];
       d8 = -+HEAPF32[i5 + (i4 << 3) + 4 >> 2];
       i15 = HEAP32[i38 >> 2] | 0;
       d9 = +HEAPF32[i15 + (i4 << 3) >> 2];
       d11 = +HEAPF32[i15 + (i4 << 3) + 4 >> 2];
       d13 = d6 * d9 - d11 * d8;
       d14 = d9 * d8 + d6 * d11;
       if ((d13 != d13 | 0.0 != 0.0) & (d14 != d14 | 0.0 != 0.0)) {
        ___mulsc3(i28, d6, d8, d9, d11);
        i1 = HEAP32[i19 >> 2] | 0;
        d11 = +HEAPF32[i28 >> 2];
        d9 = +HEAPF32[i40 >> 2];
       } else {
        d11 = d13;
        d9 = d14;
       }
       i15 = i1 + i4 | 0;
       d6 = +HEAPF32[i5 + (i15 << 3) >> 2];
       d8 = +HEAPF32[i5 + (i15 << 3) + 4 >> 2];
       d14 = d11 * d6 - d9 * d8;
       d13 = d9 * d6 + d11 * d8;
       if ((d14 != d14 | 0.0 != 0.0) & (d13 != d13 | 0.0 != 0.0)) {
        ___mulsc3(i39, d11, d9, d6, d8);
        i1 = HEAP32[i19 >> 2] | 0;
        d14 = +HEAPF32[i39 >> 2];
        d13 = +HEAPF32[i41 >> 2];
       }
       i15 = i1 + i4 | 0;
       i12 = HEAP32[i38 >> 2] | 0;
       d9 = +HEAPF32[i12 + (i15 << 3) >> 2];
       d11 = -+HEAPF32[i12 + (i15 << 3) + 4 >> 2];
       d6 = d14 * d9 - d13 * d11;
       d8 = d13 * d9 + d14 * d11;
       if ((d6 != d6 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
        ___mulsc3(i50, d14, d13, d9, d11);
        d6 = +HEAPF32[i50 >> 2];
        d8 = +HEAPF32[i42 >> 2];
        i1 = HEAP32[i19 >> 2] | 0;
       }
       d3 = d3 + d6;
       d2 = d2 + d8;
       i4 = i4 + 1 | 0;
      } while (i4 >>> 0 < i1 >>> 0);
     }
     d14 = +Math_atan2(+d2, +d3) / +(i1 >>> 0);
     HEAPF32[(HEAP32[i29 >> 2] | 0) + 8 >> 2] = d14;
     HEAP32[i70 >> 2] = 3;
    }
    break;
   }
  case 3:
   {
    i15 = (HEAP32[i18 >> 2] | 0) + -1 | 0;
    HEAP32[i18 >> 2] = i15;
    L80 : do if (!i15) {
     HEAP32[i43 >> 2] = (HEAP32[i43 >> 2] | 0) + 1;
     i15 = HEAP32[i71 >> 2] | 0;
     i5 = HEAP32[i44 >> 2] | 0;
     _memmove(HEAP32[i45 >> 2] | 0, (HEAP32[i15 >> 2] | 0) + (HEAP32[i15 + 24 >> 2] << 3) + (HEAP32[i20 >> 2] << 3) | 0, HEAP32[i74 >> 2] << 3 | 0) | 0;
     i15 = HEAP32[i46 >> 2] | 0;
     mftCall_vi(HEAP32[i15 + 28 >> 2] | 0, i15 | 0);
     d13 = +Math_sqrt(+(+((HEAP32[i47 >> 2] | 0) >>> 0)));
     i15 = HEAP32[i74 >> 2] | 0;
     d13 = d13 / +(i15 >>> 0);
     if (i15) {
      i7 = 0;
      do {
       if (!(HEAP8[(HEAP32[i62 >> 2] | 0) + i7 >> 0] | 0)) {
        i1 = i5 + (i7 << 3) | 0;
        i4 = i5 + (i7 << 3) + 4 | 0;
        HEAPF32[i1 >> 2] = 0.0;
        HEAPF32[i4 >> 2] = 0.0;
        d3 = 0.0;
        d2 = 0.0;
       } else {
        i15 = HEAP32[i63 >> 2] | 0;
        d6 = +HEAPF32[i15 + (i7 << 3) >> 2];
        d8 = +HEAPF32[i15 + (i7 << 3) + 4 >> 2];
        i15 = HEAP32[i64 >> 2] | 0;
        d9 = +HEAPF32[i15 + (i7 << 3) >> 2];
        d11 = -+HEAPF32[i15 + (i7 << 3) + 4 >> 2];
        d3 = d6 * d9 - d8 * d11;
        d2 = d8 * d9 + d6 * d11;
        if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
         ___mulsc3(i16, d6, d8, d9, d11);
         d3 = +HEAPF32[i16 >> 2];
         d2 = +HEAPF32[i65 >> 2];
        }
        i1 = i5 + (i7 << 3) | 0;
        i4 = i5 + (i7 << 3) + 4 | 0;
        HEAPF32[i1 >> 2] = d3;
        HEAPF32[i4 >> 2] = d2;
       }
       HEAPF32[i1 >> 2] = d13 * d3;
       HEAPF32[i4 >> 2] = d13 * d2;
       i7 = i7 + 1 | 0;
       i1 = HEAP32[i74 >> 2] | 0;
      } while (i7 >>> 0 < i1 >>> 0);
      if (i1) {
       d3 = 0.0;
       d2 = 0.0;
       i4 = 0;
       do {
        i15 = i4;
        i4 = i4 + 1 | 0;
        i10 = (i4 >>> 0) % (i1 >>> 0) | 0;
        i12 = HEAP32[i44 >> 2] | 0;
        d9 = +HEAPF32[i12 + (i10 << 3) >> 2];
        d11 = +HEAPF32[i12 + (i10 << 3) + 4 >> 2];
        d13 = +HEAPF32[i12 + (i15 << 3) >> 2];
        d14 = -+HEAPF32[i12 + (i15 << 3) + 4 >> 2];
        d6 = d9 * d13 - d11 * d14;
        d8 = d11 * d13 + d9 * d14;
        if ((d6 != d6 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
         ___mulsc3(i17, d9, d11, d13, d14);
         d6 = +HEAPF32[i17 >> 2];
         d8 = +HEAPF32[i60 >> 2];
         i1 = HEAP32[i74 >> 2] | 0;
        }
        d3 = d3 + d6;
        d2 = d2 + d8;
       } while (i4 >>> 0 < i1 >>> 0);
      } else {
       d3 = 0.0;
       d2 = 0.0;
      }
     } else {
      d3 = 0.0;
      d2 = 0.0;
     }
     ___divsc3(i28, d3, d2, +((HEAP32[i47 >> 2] | 0) >>> 0), 0.0);
     d3 = +HEAPF32[i22 >> 2];
     d2 = +HEAPF32[i28 >> 2] * d3;
     d3 = +HEAPF32[i48 >> 2] * d3;
     d8 = +((HEAP32[i33 >> 2] | 0) >>> 0) * 2.0 * 3.141592653589793 / +((HEAP32[i74 >> 2] | 0) >>> 0);
     d6 = +Math_sin(+d8);
     d8 = +Math_cos(+d8) + d6 * 0.0;
     d9 = d2 * d8 - d3 * d6;
     d11 = d2 * d6 + d3 * d8;
     if ((d9 != d9 | 0.0 != 0.0) & (d11 != d11 | 0.0 != 0.0)) {
      ___mulsc3(i39, d2, d3, d8, d6);
      d9 = +HEAPF32[i39 >> 2];
      d11 = +HEAPF32[i49 >> 2];
     }
     d3 = +Math_abs(+d9);
     i15 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     d3 = +Math_abs(+d11);
     i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
     i12 = i15 >>> 0 < i4 >>> 0;
     i1 = i12 ? i4 : i15;
     i4 = i12 ? i15 : i4;
     d3 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]);
     d2 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
     do if ((i4 | 0) != 2139095040) {
      if (i1 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i1 - i4 | 0) >>> 0 > 209715199) {
       d2 = d3 + d2;
       break;
      }
      if (i1 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
       d2 = d2 * 1237940039285380274899124.0e3;
       d3 = d3 * 1237940039285380274899124.0e3;
       d6 = 8.077935669463161e-28;
      } else d6 = 1.0; else {
       d2 = d2 * 8.077935669463161e-28;
       d3 = d3 * 8.077935669463161e-28;
       d6 = 1237940039285380274899124.0e3;
      }
      d14 = d3;
      d2 = d6 * +Math_sqrt(+(d14 * d14 + d2 * d2));
     } while (0);
     if (d2 > +HEAPF32[i51 >> 2] ? +Math_abs(+(+Math_atan2(+d11, +d9))) < .3141592700403172 : 0) {
      HEAP32[i70 >> 2] = 4;
      i15 = HEAP32[i74 >> 2] | 0;
      HEAP32[i18 >> 2] = (HEAP32[i20 >> 2] | 0) + i15 + (HEAP32[i33 >> 2] | 0);
      HEAP32[i43 >> 2] = 0;
      i4 = HEAP32[i52 >> 2] | 0;
      i1 = HEAP32[i53 >> 2] | 0;
      d13 = +(i15 >>> 0) / +Math_sqrt(+(+((i1 + i4 | 0) >>> 0)));
      if (i15) {
       i5 = 0;
       do {
        i4 = HEAP32[i44 >> 2] | 0;
        i1 = i4 + (i5 << 3) | 0;
        i4 = i4 + (i5 << 3) + 4 | 0;
        d6 = d13 * +HEAPF32[i4 >> 2];
        HEAPF32[i1 >> 2] = d13 * +HEAPF32[i1 >> 2];
        HEAPF32[i4 >> 2] = d6;
        i4 = HEAP32[i54 >> 2] | 0;
        d6 = +HEAPF32[i4 + (i5 << 3) >> 2];
        d8 = +HEAPF32[i4 + (i5 << 3) + 4 >> 2];
        i4 = HEAP32[i44 >> 2] | 0;
        i1 = i4 + (i5 << 3) | 0;
        d9 = +HEAPF32[i1 >> 2];
        i4 = i4 + (i5 << 3) + 4 | 0;
        d11 = +HEAPF32[i4 >> 2];
        d3 = d6 * d9 - d8 * d11;
        d2 = d8 * d9 + d6 * d11;
        if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
         ___mulsc3(i50, d9, d11, d6, d8);
         d3 = +HEAPF32[i50 >> 2];
         d2 = +HEAPF32[i57 >> 2];
        }
        HEAPF32[i1 >> 2] = d3;
        HEAPF32[i4 >> 2] = d2;
        i5 = i5 + 1 | 0;
       } while (i5 >>> 0 < (HEAP32[i74 >> 2] | 0) >>> 0);
       i4 = HEAP32[i52 >> 2] | 0;
       i1 = HEAP32[i53 >> 2] | 0;
      }
      i15 = i4 + i1 | 0;
      _ofdmframesync_estimate_eqgain_poly(i74, i15 >>> 0 < 5 ? i15 + -1 | 0 : 4);
      if (!(HEAP32[i74 >> 2] | 0)) break; else i1 = 0;
      while (1) {
       i15 = HEAP32[i54 >> 2] | 0;
       i12 = HEAP32[i44 >> 2] | 0;
       ___divsc3(i61, +HEAPF32[i15 + (i1 << 3) >> 2], +HEAPF32[i15 + (i1 << 3) + 4 >> 2], +HEAPF32[i12 + (i1 << 3) >> 2], +HEAPF32[i12 + (i1 << 3) + 4 >> 2]);
       i12 = HEAP32[i55 >> 2] | 0;
       i15 = HEAP32[i56 >> 2] | 0;
       HEAP32[i15 + (i1 << 3) >> 2] = HEAP32[i61 >> 2];
       HEAP32[i15 + (i1 << 3) + 4 >> 2] = i12;
       i1 = i1 + 1 | 0;
       if (i1 >>> 0 >= (HEAP32[i74 >> 2] | 0) >>> 0) break L80;
      }
     }
     if ((HEAP32[i43 >> 2] | 0) == 16) {
      i1 = HEAP32[i29 >> 2] | 0;
      HEAPF32[i1 + 4 >> 2] = 0.0;
      HEAPF32[i1 + 8 >> 2] = 0.0;
      HEAP32[i1 + 1036 >> 2] = 0;
      HEAPF32[i1 + 1040 >> 2] = 0.0;
      HEAPF32[i1 + 1044 >> 2] = 1.0;
      i1 = HEAP32[i58 >> 2] | 0;
      HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
      HEAP32[i59 >> 2] = 0;
      HEAP32[i59 + 4 >> 2] = 0;
      HEAP32[i59 + 8 >> 2] = 0;
      HEAP32[i59 + 12 >> 2] = 0;
      HEAP32[i25 >> 2] = 0;
      HEAP32[i25 + 4 >> 2] = 0;
      HEAP32[i25 + 8 >> 2] = 0;
      HEAP32[i25 + 12 >> 2] = 0;
      i1 = HEAP32[i74 >> 2] | 0;
      if (i1 >>> 0 > 44) {
       d2 = .3499999940395355;
       d3 = .30000001192092896;
      } else {
       d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
       d2 = d3 + .3499999940395355;
       d3 = d3 + .30000001192092896;
      }
      HEAPF32[i32 >> 2] = d2;
      HEAPF32[i51 >> 2] = d3;
      HEAP32[i70 >> 2] = 0;
     }
     HEAP32[i18 >> 2] = HEAP32[i19 >> 2];
    } while (0);
    break;
   }
  case 4:
   {
    i15 = (HEAP32[i18 >> 2] | 0) + -1 | 0;
    HEAP32[i18 >> 2] = i15;
    if (!i15) {
     i15 = HEAP32[i71 >> 2] | 0;
     _memmove(HEAP32[i45 >> 2] | 0, (HEAP32[i15 >> 2] | 0) + (HEAP32[i15 + 24 >> 2] << 3) + ((HEAP32[i20 >> 2] | 0) - (HEAP32[i33 >> 2] | 0) << 3) | 0, HEAP32[i74 >> 2] << 3 | 0) | 0;
     i15 = HEAP32[i46 >> 2] | 0;
     mftCall_vi(HEAP32[i15 + 28 >> 2] | 0, i15 | 0);
     _ofdmframesync_rxsymbol(i74);
     if (HEAP32[i72 >> 2] | 0 ? (i69 = HEAP32[i74 >> 2] | 0, i69 | 0) : 0) {
      i1 = i69;
      i15 = 0;
      do {
       if ((HEAP8[(HEAP32[i62 >> 2] | 0) + i15 >> 0] | 0) == 2) {
        i4 = HEAP32[i68 >> 2] | 0;
        i12 = HEAP32[i63 >> 2] | 0;
        i10 = HEAP32[i12 + (i15 << 3) >> 2] | 0;
        i12 = HEAP32[i12 + (i15 << 3) + 4 >> 2] | 0;
        i5 = i4 + 24 | 0;
        i1 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
        HEAP32[i5 >> 2] = i1;
        if (!i1) {
         i1 = HEAP32[i4 >> 2] | 0;
         i7 = i4 + 4 | 0;
         _memmove(i1 | 0, i1 + (HEAP32[i4 + 12 >> 2] << 3) | 0, (HEAP32[i7 >> 2] << 3) + -8 | 0) | 0;
         i1 = HEAP32[i5 >> 2] | 0;
        } else i7 = i4 + 4 | 0;
        i1 = i1 + -1 + (HEAP32[i7 >> 2] | 0) | 0;
        i7 = HEAP32[i4 >> 2] | 0;
        HEAP32[i7 + (i1 << 3) >> 2] = i10;
        HEAP32[i7 + (i1 << 3) + 4 >> 2] = i12;
        i1 = HEAP32[i74 >> 2] | 0;
       }
       i15 = i15 + 1 | 0;
      } while (i15 >>> 0 < i1 >>> 0);
     }
     i1 = HEAP32[i66 >> 2] | 0;
     if (i1 | 0 ? mftCall_iiiii(i1 | 0, HEAP32[i63 >> 2] | 0, HEAP32[i62 >> 2] | 0, HEAP32[i74 >> 2] | 0, HEAP32[i67 >> 2] | 0) | 0 : 0) {
      i1 = HEAP32[i29 >> 2] | 0;
      HEAPF32[i1 + 4 >> 2] = 0.0;
      HEAPF32[i1 + 8 >> 2] = 0.0;
      HEAP32[i1 + 1036 >> 2] = 0;
      HEAPF32[i1 + 1040 >> 2] = 0.0;
      HEAPF32[i1 + 1044 >> 2] = 1.0;
      i1 = HEAP32[i58 >> 2] | 0;
      HEAP32[i1 + 16 >> 2] = HEAP32[i1 + 8 >> 2];
      HEAP32[i59 >> 2] = 0;
      HEAP32[i59 + 4 >> 2] = 0;
      HEAP32[i59 + 8 >> 2] = 0;
      HEAP32[i59 + 12 >> 2] = 0;
      HEAP32[i25 >> 2] = 0;
      HEAP32[i25 + 4 >> 2] = 0;
      HEAP32[i25 + 8 >> 2] = 0;
      HEAP32[i25 + 12 >> 2] = 0;
      i1 = HEAP32[i74 >> 2] | 0;
      if (i1 >>> 0 > 44) {
       d2 = .3499999940395355;
       d3 = .30000001192092896;
      } else {
       d3 = +((44 - i1 | 0) >>> 0) * .009999999776482582;
       d2 = d3 + .3499999940395355;
       d3 = d3 + .30000001192092896;
      }
      HEAPF32[i32 >> 2] = d2;
      HEAPF32[i51 >> 2] = d3;
      HEAP32[i70 >> 2] = 0;
     }
     HEAP32[i18 >> 2] = (HEAP32[i20 >> 2] | 0) + (HEAP32[i74 >> 2] | 0);
    }
    break;
   }
  default:
   {}
  }
  i76 = i76 + 1 | 0;
 } while ((i76 | 0) != (i73 | 0));
 STACKTOP = i77;
 return;
}

function _fec_create(i9) {
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i2 = i10 + 16 | 0;
 i4 = i10 + 8 | 0;
 i3 = i10;
 i21 = i10 + 20 | 0;
 do switch (i9 | 0) {
 case 0:
  {
   i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
    HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8840 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8840 + 8 >> 2] = 0;
     HEAP32[gb + 8840 + 4 >> 2] = 0;
     i8 = HEAP32[gb + 8840 + 44 >> 2] | 0;
     HEAP32[gb + 8840 + 28 >> 2] = i8;
     HEAP32[gb + 8840 + 20 >> 2] = i8;
     i7 = i8 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8840 + 16 >> 2] = i7;
     break;
    }
    HEAP32[gb + 8840 >> 2] = i1 | 32;
    _exit(-1);
   } else {
    i7 = i1;
    i8 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   } while (0);
   if ((i7 - i8 | 0) >>> 0 < 63) {
    if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 11810 | 0, 63) | 0) >>> 0 < 63) _exit(-1);
   } else {
    i1 = i8;
    i2 = gb + 11810 | 0;
    i3 = i1 + 63 | 0;
    do {
     HEAP8[i1 >> 0] = HEAP8[i2 >> 0] | 0;
     i1 = i1 + 1 | 0;
     i2 = i2 + 1 | 0;
    } while ((i1 | 0) < (i3 | 0));
    HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 63;
   }
   i1 = HEAP8[gb + 8840 + 75 >> 0] | 0;
   if (i1 << 24 >> 24 != 10) {
    i2 = HEAP32[gb + 8840 + 20 >> 2] | 0;
    i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
    if (i2 >>> 0 < i3 >>> 0) {
     HEAP32[gb + 8840 + 20 >> 2] = i2 + 1;
     HEAP8[i2 >> 0] = 10;
     _exit(-1);
    } else i20 = i3;
   } else i20 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   HEAP8[i21 >> 0] = 10;
   do if (!i20) {
    i2 = HEAP16[gb + 8840 + 74 >> 1] | 0;
    i1 = (i2 & 65535) << 24 >> 24;
    HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8840 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8840 + 8 >> 2] = 0;
     HEAP32[gb + 8840 + 4 >> 2] = 0;
     i4 = HEAP32[gb + 8840 + 44 >> 2] | 0;
     HEAP32[gb + 8840 + 28 >> 2] = i4;
     HEAP32[gb + 8840 + 20 >> 2] = i4;
     i3 = i4 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8840 + 16 >> 2] = i3;
     i1 = (i2 & 65535) >>> 8 & 255;
     i22 = 19;
     break;
    } else {
     HEAP32[gb + 8840 >> 2] = i1 | 32;
     break;
    }
   } else {
    i4 = HEAP32[gb + 8840 + 20 >> 2] | 0;
    i3 = i20;
    i22 = 19;
   } while (0);
   do if ((i22 | 0) == 19) if (i4 >>> 0 >= i3 >>> 0 | i1 << 24 >> 24 == 10) {
    mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i21 | 0, 1) | 0;
    break;
   } else {
    HEAP32[gb + 8840 + 20 >> 2] = i4 + 1;
    HEAP8[i4 >> 0] = 10;
    break;
   } while (0);
   _exit(-1);
   break;
  }
 case 1:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 1;
   HEAPF32[i22 + 4 >> 2] = 1.0;
   HEAP32[i22 + 136 >> 2] = fb + 1;
   HEAP32[i22 + 140 >> 2] = fb + 2;
   HEAP32[i22 + 144 >> 2] = 0;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 2:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 2;
   HEAPF32[i22 + 4 >> 2] = .3333333432674408;
   HEAP32[i22 + 136 >> 2] = fb + 3;
   HEAP32[i22 + 140 >> 2] = fb + 4;
   HEAP32[i22 + 144 >> 2] = fb + 5;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 3:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 3;
   HEAPF32[i22 + 4 >> 2] = .20000000298023224;
   HEAP32[i22 + 136 >> 2] = fb + 6;
   HEAP32[i22 + 140 >> 2] = fb + 7;
   HEAP32[i22 + 144 >> 2] = fb + 8;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 4:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 4;
   HEAPF32[i22 + 4 >> 2] = .5714285969734192;
   HEAP32[i22 + 136 >> 2] = fb + 9;
   HEAP32[i22 + 140 >> 2] = fb + 10;
   HEAP32[i22 + 144 >> 2] = fb + 11;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 5:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 5;
   HEAPF32[i22 + 4 >> 2] = .5;
   HEAP32[i22 + 136 >> 2] = fb + 12;
   HEAP32[i22 + 140 >> 2] = fb + 13;
   HEAP32[i22 + 144 >> 2] = fb + 14;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 6:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 6;
   HEAPF32[i22 + 4 >> 2] = .6666666865348816;
   HEAP32[i22 + 136 >> 2] = fb + 15;
   HEAP32[i22 + 140 >> 2] = fb + 16;
   HEAP32[i22 + 144 >> 2] = fb + 17;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 7:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 7;
   HEAPF32[i22 + 4 >> 2] = .5;
   HEAP32[i22 + 136 >> 2] = fb + 18;
   HEAP32[i22 + 140 >> 2] = fb + 19;
   HEAP32[i22 + 144 >> 2] = 0;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 8:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 8;
   HEAPF32[i22 + 4 >> 2] = .6666666865348816;
   HEAP32[i22 + 136 >> 2] = fb + 20;
   HEAP32[i22 + 140 >> 2] = fb + 21;
   HEAP32[i22 + 144 >> 2] = 0;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 9:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 9;
   HEAPF32[i22 + 4 >> 2] = .800000011920929;
   HEAP32[i22 + 136 >> 2] = fb + 22;
   HEAP32[i22 + 140 >> 2] = fb + 23;
   HEAP32[i22 + 144 >> 2] = 0;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 10:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 10;
   HEAPF32[i22 + 4 >> 2] = .8888888955116272;
   HEAP32[i22 + 136 >> 2] = fb + 24;
   HEAP32[i22 + 140 >> 2] = fb + 25;
   HEAP32[i22 + 144 >> 2] = 0;
   STACKTOP = i10;
   return i22 | 0;
  }
 case 14:
 case 13:
 case 12:
 case 11:
  {
   i2 = _malloc(148) | 0;
   HEAP32[i2 >> 2] = i9;
   do switch (i9 | 0) {
   case 0:
    {
     d5 = 0.0;
     break;
    }
   case 1:
    {
     d5 = 1.0;
     break;
    }
   case 2:
    {
     d5 = .3333333432674408;
     break;
    }
   case 3:
    {
     d5 = .20000000298023224;
     break;
    }
   case 4:
    {
     d5 = .5714285969734192;
     break;
    }
   case 5:
    {
     d5 = .5;
     break;
    }
   case 6:
    {
     d5 = .6666666865348816;
     break;
    }
   case 7:
    {
     d5 = .5;
     break;
    }
   case 8:
    {
     d5 = .6666666865348816;
     break;
    }
   case 9:
    {
     d5 = .800000011920929;
     break;
    }
   case 10:
    {
     d5 = .8888888955116272;
     break;
    }
   case 11:
    {
     HEAPF32[i2 + 4 >> 2] = .5;
     HEAP32[i2 + 136 >> 2] = fb + 26;
     HEAP32[i2 + 140 >> 2] = fb + 27;
     HEAP32[i2 + 144 >> 2] = fb + 28;
     HEAP32[i2 + 28 >> 2] = 2;
     HEAP32[i2 + 32 >> 2] = 7;
     HEAP32[i2 + 24 >> 2] = gb + 224;
     HEAP32[i2 + 44 >> 2] = fb + 2;
     HEAP32[i2 + 48 >> 2] = fb + 1;
     HEAP32[i2 + 52 >> 2] = fb + 5;
     HEAP32[i2 + 56 >> 2] = fb + 2;
     HEAP32[i2 + 60 >> 2] = fb + 3;
     i22 = 75;
     break;
    }
   case 12:
    {
     HEAPF32[i2 + 4 >> 2] = .5;
     HEAP32[i2 + 136 >> 2] = fb + 26;
     HEAP32[i2 + 140 >> 2] = fb + 27;
     HEAP32[i2 + 144 >> 2] = fb + 28;
     HEAP32[i2 + 28 >> 2] = 2;
     HEAP32[i2 + 32 >> 2] = 9;
     HEAP32[i2 + 24 >> 2] = gb + 232;
     HEAP32[i2 + 44 >> 2] = fb + 3;
     HEAP32[i2 + 48 >> 2] = fb + 2;
     HEAP32[i2 + 52 >> 2] = fb + 6;
     HEAP32[i2 + 56 >> 2] = fb + 3;
     HEAP32[i2 + 60 >> 2] = fb + 4;
     i22 = 75;
     break;
    }
   case 13:
    {
     HEAPF32[i2 + 4 >> 2] = .3333333432674408;
     HEAP32[i2 + 136 >> 2] = fb + 26;
     HEAP32[i2 + 140 >> 2] = fb + 27;
     HEAP32[i2 + 144 >> 2] = fb + 28;
     HEAP32[i2 + 28 >> 2] = 3;
     HEAP32[i2 + 32 >> 2] = 9;
     HEAP32[i2 + 24 >> 2] = gb + 240;
     HEAP32[i2 + 44 >> 2] = fb + 4;
     HEAP32[i2 + 48 >> 2] = fb + 3;
     HEAP32[i2 + 52 >> 2] = fb + 7;
     HEAP32[i2 + 56 >> 2] = fb + 4;
     HEAP32[i2 + 60 >> 2] = fb + 5;
     i22 = 75;
     break;
    }
   case 14:
    {
     HEAPF32[i2 + 4 >> 2] = .1666666716337204;
     HEAP32[i2 + 136 >> 2] = fb + 26;
     HEAP32[i2 + 140 >> 2] = fb + 27;
     HEAP32[i2 + 144 >> 2] = fb + 28;
     HEAP32[i2 + 28 >> 2] = 6;
     HEAP32[i2 + 32 >> 2] = 15;
     HEAP32[i2 + 24 >> 2] = gb + 252;
     HEAP32[i2 + 44 >> 2] = fb + 5;
     HEAP32[i2 + 48 >> 2] = fb + 4;
     HEAP32[i2 + 52 >> 2] = fb + 8;
     HEAP32[i2 + 56 >> 2] = fb + 5;
     HEAP32[i2 + 60 >> 2] = fb + 6;
     i22 = 75;
     break;
    }
   case 15:
    {
     d5 = .6666666865348816;
     break;
    }
   case 16:
    {
     d5 = .75;
     break;
    }
   case 17:
    {
     d5 = .800000011920929;
     break;
    }
   case 18:
    {
     d5 = .8333333134651184;
     break;
    }
   case 19:
    {
     d5 = .8571428656578064;
     break;
    }
   case 20:
    {
     d5 = .875;
     break;
    }
   case 21:
    {
     d5 = .6666666865348816;
     break;
    }
   case 22:
    {
     d5 = .75;
     break;
    }
   case 23:
    {
     d5 = .800000011920929;
     break;
    }
   case 24:
    {
     d5 = .8333333134651184;
     break;
    }
   case 25:
    {
     d5 = .8571428656578064;
     break;
    }
   case 26:
    {
     d5 = .875;
     break;
    }
   case 27:
    {
     d5 = .8745098114013672;
     break;
    }
   default:
    {
     HEAP32[i3 >> 2] = i9;
     _printf(gb + 11755 | 0, i3);
     _exit(-1);
    }
   } while (0);
   if ((i22 | 0) == 75) {
    HEAP32[i2 + 8 >> 2] = 0;
    HEAP32[i2 + 16 >> 2] = 0;
    HEAP32[i2 + 20 >> 2] = 0;
    i22 = i2;
    STACKTOP = i10;
    return i22 | 0;
   }
   HEAPF32[i2 + 4 >> 2] = d5;
   HEAP32[i2 + 136 >> 2] = fb + 26;
   HEAP32[i2 + 140 >> 2] = fb + 27;
   HEAP32[i2 + 144 >> 2] = fb + 28;
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i11 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i11;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i11 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i11 - i1 | 0) >>> 0 < 39) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 12086 | 0, 39) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 12086 | 0, 39) | 0) >>> 0 < 39) _exit(1); else {
    i14 = 0;
    i16 = gb + 12086 + 39 | 0;
    i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i14 = 39;
    i16 = gb + 12086 | 0;
    i18 = i1;
   } while (0);
   _memcpy(i18 | 0, i16 | 0, i14 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i14;
   _exit(1);
   break;
  }
 case 26:
 case 25:
 case 24:
 case 23:
 case 22:
 case 21:
 case 20:
 case 19:
 case 18:
 case 17:
 case 16:
 case 15:
  {
   i1 = _malloc(148) | 0;
   HEAP32[i1 >> 2] = i9;
   do switch (i9 | 0) {
   case 0:
    {
     d6 = 0.0;
     break;
    }
   case 1:
    {
     d6 = 1.0;
     break;
    }
   case 2:
    {
     d6 = .3333333432674408;
     break;
    }
   case 3:
    {
     d6 = .20000000298023224;
     break;
    }
   case 4:
    {
     d6 = .5714285969734192;
     break;
    }
   case 5:
    {
     d6 = .5;
     break;
    }
   case 6:
    {
     d6 = .6666666865348816;
     break;
    }
   case 7:
    {
     d6 = .5;
     break;
    }
   case 8:
    {
     d6 = .6666666865348816;
     break;
    }
   case 9:
    {
     d6 = .800000011920929;
     break;
    }
   case 10:
    {
     d6 = .8888888955116272;
     break;
    }
   case 11:
    {
     d6 = .5;
     break;
    }
   case 12:
    {
     d6 = .5;
     break;
    }
   case 13:
    {
     d6 = .3333333432674408;
     break;
    }
   case 14:
    {
     d6 = .1666666716337204;
     break;
    }
   case 15:
    {
     HEAPF32[i1 + 4 >> 2] = .6666666865348816;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 7;
     HEAP32[i1 + 24 >> 2] = gb + 224;
     HEAP32[i1 + 44 >> 2] = fb + 2;
     HEAP32[i1 + 48 >> 2] = fb + 1;
     HEAP32[i1 + 52 >> 2] = fb + 5;
     HEAP32[i1 + 56 >> 2] = fb + 2;
     HEAP32[i1 + 60 >> 2] = fb + 3;
     HEAP32[i1 + 36 >> 2] = 2;
     HEAP32[i1 + 40 >> 2] = gb + 8272;
     i22 = 117;
     break;
    }
   case 16:
    {
     HEAPF32[i1 + 4 >> 2] = .75;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 7;
     HEAP32[i1 + 24 >> 2] = gb + 224;
     HEAP32[i1 + 44 >> 2] = fb + 2;
     HEAP32[i1 + 48 >> 2] = fb + 1;
     HEAP32[i1 + 52 >> 2] = fb + 5;
     HEAP32[i1 + 56 >> 2] = fb + 2;
     HEAP32[i1 + 60 >> 2] = fb + 3;
     HEAP32[i1 + 36 >> 2] = 3;
     HEAP32[i1 + 40 >> 2] = gb + 8288;
     i22 = 117;
     break;
    }
   case 17:
    {
     HEAPF32[i1 + 4 >> 2] = .800000011920929;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 7;
     HEAP32[i1 + 24 >> 2] = gb + 224;
     HEAP32[i1 + 44 >> 2] = fb + 2;
     HEAP32[i1 + 48 >> 2] = fb + 1;
     HEAP32[i1 + 52 >> 2] = fb + 5;
     HEAP32[i1 + 56 >> 2] = fb + 2;
     HEAP32[i1 + 60 >> 2] = fb + 3;
     HEAP32[i1 + 36 >> 2] = 4;
     HEAP32[i1 + 40 >> 2] = gb + 8312;
     i22 = 117;
     break;
    }
   case 18:
    {
     HEAPF32[i1 + 4 >> 2] = .8333333134651184;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 7;
     HEAP32[i1 + 24 >> 2] = gb + 224;
     HEAP32[i1 + 44 >> 2] = fb + 2;
     HEAP32[i1 + 48 >> 2] = fb + 1;
     HEAP32[i1 + 52 >> 2] = fb + 5;
     HEAP32[i1 + 56 >> 2] = fb + 2;
     HEAP32[i1 + 60 >> 2] = fb + 3;
     HEAP32[i1 + 36 >> 2] = 5;
     HEAP32[i1 + 40 >> 2] = gb + 8344;
     i22 = 117;
     break;
    }
   case 19:
    {
     HEAPF32[i1 + 4 >> 2] = .8571428656578064;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 7;
     HEAP32[i1 + 24 >> 2] = gb + 224;
     HEAP32[i1 + 44 >> 2] = fb + 2;
     HEAP32[i1 + 48 >> 2] = fb + 1;
     HEAP32[i1 + 52 >> 2] = fb + 5;
     HEAP32[i1 + 56 >> 2] = fb + 2;
     HEAP32[i1 + 60 >> 2] = fb + 3;
     HEAP32[i1 + 36 >> 2] = 6;
     HEAP32[i1 + 40 >> 2] = gb + 8384;
     i22 = 117;
     break;
    }
   case 20:
    {
     HEAPF32[i1 + 4 >> 2] = .875;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 7;
     HEAP32[i1 + 24 >> 2] = gb + 224;
     HEAP32[i1 + 44 >> 2] = fb + 2;
     HEAP32[i1 + 48 >> 2] = fb + 1;
     HEAP32[i1 + 52 >> 2] = fb + 5;
     HEAP32[i1 + 56 >> 2] = fb + 2;
     HEAP32[i1 + 60 >> 2] = fb + 3;
     HEAP32[i1 + 36 >> 2] = 7;
     HEAP32[i1 + 40 >> 2] = gb + 8432;
     i22 = 117;
     break;
    }
   case 21:
    {
     HEAPF32[i1 + 4 >> 2] = .6666666865348816;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 9;
     HEAP32[i1 + 24 >> 2] = gb + 232;
     HEAP32[i1 + 44 >> 2] = fb + 3;
     HEAP32[i1 + 48 >> 2] = fb + 2;
     HEAP32[i1 + 52 >> 2] = fb + 6;
     HEAP32[i1 + 56 >> 2] = fb + 3;
     HEAP32[i1 + 60 >> 2] = fb + 4;
     HEAP32[i1 + 36 >> 2] = 2;
     HEAP32[i1 + 40 >> 2] = gb + 8488;
     i22 = 117;
     break;
    }
   case 22:
    {
     HEAPF32[i1 + 4 >> 2] = .75;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 9;
     HEAP32[i1 + 24 >> 2] = gb + 232;
     HEAP32[i1 + 44 >> 2] = fb + 3;
     HEAP32[i1 + 48 >> 2] = fb + 2;
     HEAP32[i1 + 52 >> 2] = fb + 6;
     HEAP32[i1 + 56 >> 2] = fb + 3;
     HEAP32[i1 + 60 >> 2] = fb + 4;
     HEAP32[i1 + 36 >> 2] = 3;
     HEAP32[i1 + 40 >> 2] = gb + 8504;
     i22 = 117;
     break;
    }
   case 23:
    {
     HEAPF32[i1 + 4 >> 2] = .800000011920929;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 9;
     HEAP32[i1 + 24 >> 2] = gb + 232;
     HEAP32[i1 + 44 >> 2] = fb + 3;
     HEAP32[i1 + 48 >> 2] = fb + 2;
     HEAP32[i1 + 52 >> 2] = fb + 6;
     HEAP32[i1 + 56 >> 2] = fb + 3;
     HEAP32[i1 + 60 >> 2] = fb + 4;
     HEAP32[i1 + 36 >> 2] = 4;
     HEAP32[i1 + 40 >> 2] = gb + 8528;
     i22 = 117;
     break;
    }
   case 24:
    {
     HEAPF32[i1 + 4 >> 2] = .8333333134651184;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 9;
     HEAP32[i1 + 24 >> 2] = gb + 232;
     HEAP32[i1 + 44 >> 2] = fb + 3;
     HEAP32[i1 + 48 >> 2] = fb + 2;
     HEAP32[i1 + 52 >> 2] = fb + 6;
     HEAP32[i1 + 56 >> 2] = fb + 3;
     HEAP32[i1 + 60 >> 2] = fb + 4;
     HEAP32[i1 + 36 >> 2] = 5;
     HEAP32[i1 + 40 >> 2] = gb + 8560;
     i22 = 117;
     break;
    }
   case 25:
    {
     HEAPF32[i1 + 4 >> 2] = .8571428656578064;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 9;
     HEAP32[i1 + 24 >> 2] = gb + 232;
     HEAP32[i1 + 44 >> 2] = fb + 3;
     HEAP32[i1 + 48 >> 2] = fb + 2;
     HEAP32[i1 + 52 >> 2] = fb + 6;
     HEAP32[i1 + 56 >> 2] = fb + 3;
     HEAP32[i1 + 60 >> 2] = fb + 4;
     HEAP32[i1 + 36 >> 2] = 6;
     HEAP32[i1 + 40 >> 2] = gb + 8600;
     i22 = 117;
     break;
    }
   case 26:
    {
     HEAPF32[i1 + 4 >> 2] = .875;
     HEAP32[i1 + 136 >> 2] = fb + 29;
     HEAP32[i1 + 140 >> 2] = fb + 30;
     HEAP32[i1 + 144 >> 2] = fb + 31;
     HEAP32[i1 + 28 >> 2] = 2;
     HEAP32[i1 + 32 >> 2] = 9;
     HEAP32[i1 + 24 >> 2] = gb + 232;
     HEAP32[i1 + 44 >> 2] = fb + 3;
     HEAP32[i1 + 48 >> 2] = fb + 2;
     HEAP32[i1 + 52 >> 2] = fb + 6;
     HEAP32[i1 + 56 >> 2] = fb + 3;
     HEAP32[i1 + 60 >> 2] = fb + 4;
     HEAP32[i1 + 36 >> 2] = 7;
     HEAP32[i1 + 40 >> 2] = gb + 8648;
     i22 = 117;
     break;
    }
   case 27:
    {
     d6 = .8745098114013672;
     break;
    }
   default:
    {
     HEAP32[i4 >> 2] = i9;
     _printf(gb + 11755 | 0, i4);
     _exit(-1);
    }
   } while (0);
   if ((i22 | 0) == 117) {
    HEAP32[i1 + 8 >> 2] = 0;
    HEAP32[i1 + 16 >> 2] = 0;
    HEAP32[i1 + 20 >> 2] = 0;
    i22 = i1;
    STACKTOP = i10;
    return i22 | 0;
   }
   HEAPF32[i1 + 4 >> 2] = d6;
   HEAP32[i1 + 136 >> 2] = fb + 29;
   HEAP32[i1 + 140 >> 2] = fb + 30;
   HEAP32[i1 + 144 >> 2] = fb + 31;
   i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i13 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i13;
     HEAP32[gb + 8728 + 20 >> 2] = i13;
     i12 = i13 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i12;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i1 | 32;
    _exit(1);
   } else {
    i12 = i1;
    i13 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i12 - i13 | 0) >>> 0 < 49) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 12240 | 0, 49) | 0;
    _exit(1);
   }
   i1 = i13;
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 12240 | 0, 49) | 0) >>> 0 < 49) _exit(1); else {
    i15 = 0;
    i17 = gb + 12240 + 49 | 0;
    i19 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i15 = 49;
    i17 = gb + 12240 | 0;
    i19 = i1;
   } while (0);
   _memcpy(i19 | 0, i17 | 0, i15 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i15;
   _exit(1);
   break;
  }
 case 27:
  {
   i22 = _malloc(148) | 0;
   HEAP32[i22 >> 2] = 27;
   HEAPF32[i22 + 4 >> 2] = .8745098114013672;
   HEAP32[i22 + 136 >> 2] = fb + 32;
   HEAP32[i22 + 140 >> 2] = fb + 33;
   HEAP32[i22 + 144 >> 2] = 0;
   SIMD_Int32x4_store(HEAPU8, i22 + 64 | 0, SIMD_Int32x4(8, 285, 1, 1));
   HEAP32[i22 + 80 >> 2] = 32;
   HEAP32[i22 + 88 >> 2] = 255;
   HEAP32[i22 + 92 >> 2] = 223;
   HEAP32[i22 + 8 >> 2] = 0;
   HEAP32[i22 + 96 >> 2] = 0;
   HEAP32[i22 + 120 >> 2] = _malloc(255) | 0;
   HEAP32[i22 + 124 >> 2] = _malloc(1020) | 0;
   HEAP32[i22 + 128 >> 2] = _malloc(1020) | 0;
   STACKTOP = i10;
   return i22 | 0;
  }
 default:
  {
   HEAP32[i2 >> 2] = i9;
   _printf(gb + 11874 | 0, i2);
   _exit(-1);
  }
 } while (0);
 return 0;
}

function _fft_create_plan(i32, i20, i21, i22, i29) {
 i32 = i32 | 0;
 i20 = i20 | 0;
 i21 = i21 | 0;
 i22 = i22 | 0;
 i29 = i29 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, d13 = 0.0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i30 = 0, i31 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0;
 i36 = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 i26 = i36 + 40 | 0;
 i25 = i36 + 32 | 0;
 i23 = i36 + 24 | 0;
 i18 = i36 + 16 | 0;
 i34 = i36 + 216 | 0;
 i35 = i36;
 i33 = i36 + 208 | 0;
 i30 = i36 + 48 | 0;
 if (!i32) {
  i9 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i9) {
   i9 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i9 + 255 | i9;
   i9 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i9 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i10 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i10;
    HEAP32[gb + 8728 + 20 >> 2] = i10;
    i9 = i10 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i9;
    i31 = 7;
    break;
   } else {
    HEAP32[gb + 8728 >> 2] = i9 | 32;
    break;
   }
  } else {
   i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   i31 = 7;
  } while (0);
  do if ((i31 | 0) == 7) {
   if ((i9 - i10 | 0) >>> 0 < 58) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37423 | 0, 58) | 0;
    break;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37423 | 0, 58) | 0) >>> 0 < 58) break;
    i9 = 0;
    i11 = gb + 37423 + 58 | 0;
    i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i9 = 58;
    i11 = gb + 37423 | 0;
   }
   _memcpy(i10 | 0, i11 | 0, i9 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i9;
  } while (0);
  i9 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i9) {
   i9 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i9 + 255 | i9;
   i9 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i9 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i3;
    HEAP32[gb + 8728 + 20 >> 2] = i3;
    i12 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i12;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i9 | 32;
   _exit(1);
  } else {
   i12 = i9;
   i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i12 - i3 | 0) >>> 0 < 53) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37261 | 0, 53) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37261 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
   i15 = 0;
   i16 = gb + 37261 + 53 | 0;
   i17 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i15 = 53;
   i16 = gb + 37261 | 0;
   i17 = i3;
  } while (0);
  _memcpy(i17 | 0, i16 | 0, i15 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i15;
  _exit(1);
 }
 if ((i32 | 1 | 0) == 17 | ((i32 | 0) == 13 | (i32 >>> 0 < 9 | (i32 | 0) == 11))) {
  i18 = _malloc(72) | 0;
  HEAP32[i18 >> 2] = i32;
  HEAP32[i18 + 4 >> 2] = i20;
  HEAP32[i18 + 8 >> 2] = i21;
  HEAP32[i18 + 16 >> 2] = i29;
  i2 = (i22 | 0) == 1;
  i15 = i2 ? 1 : -1;
  HEAP32[i18 + 20 >> 2] = i15;
  HEAP32[i18 + 12 >> 2] = i15;
  HEAP32[i18 + 24 >> 2] = 5;
  i15 = i18 + 40 | 0;
  HEAP32[i15 >> 2] = 0;
  i3 = i18 + 44 | 0;
  HEAP32[i3 >> 2] = 0;
  L41 : do switch (i32 | 0) {
  case 2:
   {
    HEAP32[i18 + 28 >> 2] = fb + 10;
    break;
   }
  case 3:
   {
    HEAP32[i18 + 28 >> 2] = fb + 11;
    break;
   }
  case 4:
   {
    HEAP32[i18 + 28 >> 2] = fb + 12;
    break;
   }
  case 5:
   {
    HEAP32[i18 + 28 >> 2] = fb + 13;
    break;
   }
  case 6:
   {
    HEAP32[i18 + 28 >> 2] = fb + 14;
    break;
   }
  case 7:
   {
    HEAP32[i18 + 28 >> 2] = fb + 15;
    break;
   }
  case 8:
   {
    HEAP32[i18 + 28 >> 2] = fb + 16;
    break;
   }
  default:
   {
    i1 = i18 + 28 | 0;
    if ((i32 | 0) == 16) {
     HEAP32[i1 >> 2] = fb + 17;
     break L41;
    }
    HEAP32[i1 >> 2] = fb + 18;
    i16 = _malloc(i32 << 3) | 0;
    HEAP32[i15 >> 2] = i16;
    i17 = _malloc(i32 << 2) | 0;
    HEAP32[i3 >> 2] = i17;
    d4 = i2 ? -1.0 : 1.0;
    d5 = d4 * 0.0;
    d6 = d5 * 2.0 - d5;
    d7 = d4 * 2.0 + d5 * 0.0;
    i12 = (d6 != d6 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0);
    i2 = i34 + 4 | 0;
    i3 = i35 + 4 | 0;
    d6 = d6 * 3.141592653589793;
    d7 = d7 * 3.141592653589793;
    if (i32 >>> 0 > 1) i11 = 0; else {
     i1 = i32 + -1 | 0;
     i2 = i1 << 3;
     i3 = 0;
     while (1) {
      i35 = _malloc(8) | 0;
      HEAP32[i35 + 4 >> 2] = i1;
      i34 = _malloc(i2) | 0;
      HEAP32[i35 >> 2] = i34;
      _memcpy(i34 | 0, i16 | 0, i2 | 0) | 0;
      HEAP32[i17 + (i3 << 2) >> 2] = i35;
      i3 = i3 + 1 | 0;
      if ((i3 | 0) == (i32 | 0)) break L41;
     }
    }
    do {
     i9 = HEAP32[i18 >> 2] | 0;
     d8 = +(i9 >>> 0);
     i10 = HEAP32[i15 >> 2] | 0;
     if (i12) {
      i1 = 1;
      do {
       ___mulsc3(i34, d5, d4, 2.0, 0.0);
       d19 = +((Math_imul(i1, i11) | 0) >>> 0);
       _cexpf(i35, d19 * (+HEAPF32[i34 >> 2] * 3.141592653589793) / d8, d19 * (+HEAPF32[i2 >> 2] * 3.141592653589793) / d8);
       i31 = HEAP32[i3 >> 2] | 0;
       i33 = i1 + -1 | 0;
       HEAP32[i10 + (i33 << 3) >> 2] = HEAP32[i35 >> 2];
       HEAP32[i10 + (i33 << 3) + 4 >> 2] = i31;
       i1 = i1 + 1 | 0;
      } while (i1 >>> 0 < i9 >>> 0);
     } else {
      i1 = 1;
      do {
       d19 = +((Math_imul(i1, i11) | 0) >>> 0);
       _cexpf(i35, d6 * d19 / d8, d7 * d19 / d8);
       i31 = HEAP32[i3 >> 2] | 0;
       i33 = i1 + -1 | 0;
       HEAP32[i10 + (i33 << 3) >> 2] = HEAP32[i35 >> 2];
       HEAP32[i10 + (i33 << 3) + 4 >> 2] = i31;
       i1 = i1 + 1 | 0;
      } while (i1 >>> 0 < i9 >>> 0);
     }
     i31 = i9 + -1 | 0;
     i33 = _malloc(8) | 0;
     HEAP32[i33 + 4 >> 2] = i31;
     i31 = i31 << 3;
     i30 = _malloc(i31) | 0;
     HEAP32[i33 >> 2] = i30;
     _memcpy(i30 | 0, i16 | 0, i31 | 0) | 0;
     HEAP32[i17 + (i11 << 2) >> 2] = i33;
     i11 = i11 + 1 | 0;
    } while ((i11 | 0) != (i32 | 0));
   }
  } while (0);
  i35 = i18;
  STACKTOP = i36;
  return i35 | 0;
 }
 L68 : do if (((i32 >>> 31) + (i32 & 1) + (i32 >>> 1 & 1) + (i32 >>> 2 & 1) + (i32 >>> 3 & 1) + (i32 >>> 4 & 1) + (i32 >>> 5 & 1) + (i32 >>> 6 & 1) + (i32 >>> 7 & 1) + (i32 >>> 8 & 1) + (i32 >>> 9 & 1) + (i32 >>> 10 & 1) + (i32 >>> 11 & 1) + (i32 >>> 12 & 1) + (i32 >>> 13 & 1) + (i32 >>> 14 & 1) + (i32 >>> 15 & 1) + (i32 >>> 16 & 1) + (i32 >>> 17 & 1) + (i32 >>> 18 & 1) + (i32 >>> 19 & 1) + (i32 >>> 20 & 1) + (i32 >>> 21 & 1) + (i32 >>> 22 & 1) + (i32 >>> 23 & 1) + (i32 >>> 24 & 1) + (i32 >>> 25 & 1) + (i32 >>> 26 & 1) + (i32 >>> 27 & 1) + (i32 >>> 28 & 1) + (i32 >>> 29 & 1) + (i32 >>> 30 & 1) | 0) != 1) {
  if (i32 >>> 0 > 3) {
   i3 = 2;
   do {
    if (!((i32 >>> 0) % (i3 >>> 0) | 0)) break L68;
    i3 = i3 + 1 | 0;
   } while (i3 >>> 0 < i32 >>> 0);
  }
  i17 = i32 + -1 | 0;
  if (((i17 >>> 31) + (i17 & 1) + (i17 >>> 1 & 1) + (i17 >>> 2 & 1) + (i17 >>> 3 & 1) + (i17 >>> 4 & 1) + (i17 >>> 5 & 1) + (i17 >>> 6 & 1) + (i17 >>> 7 & 1) + (i17 >>> 8 & 1) + (i17 >>> 9 & 1) + (i17 >>> 10 & 1) + (i17 >>> 11 & 1) + (i17 >>> 12 & 1) + (i17 >>> 13 & 1) + (i17 >>> 14 & 1) + (i17 >>> 15 & 1) + (i17 >>> 16 & 1) + (i17 >>> 17 & 1) + (i17 >>> 18 & 1) + (i17 >>> 19 & 1) + (i17 >>> 20 & 1) + (i17 >>> 21 & 1) + (i17 >>> 22 & 1) + (i17 >>> 23 & 1) + (i17 >>> 24 & 1) + (i17 >>> 25 & 1) + (i17 >>> 26 & 1) + (i17 >>> 27 & 1) + (i17 >>> 28 & 1) + (i17 >>> 29 & 1) + (i17 >>> 30 & 1) | 0) == 1) {
   i23 = _malloc(72) | 0;
   HEAP32[i23 >> 2] = i32;
   HEAP32[i23 + 4 >> 2] = i20;
   HEAP32[i23 + 8 >> 2] = i21;
   HEAP32[i23 + 16 >> 2] = i29;
   i18 = (i22 | 0) == 1 ? 1 : -1;
   HEAP32[i23 + 20 >> 2] = i18;
   i12 = i23 + 12 | 0;
   HEAP32[i12 >> 2] = i18;
   HEAP32[i23 + 24 >> 2] = 3;
   HEAP32[i23 + 28 >> 2] = fb + 8;
   i18 = (i32 << 3) + -8 | 0;
   i1 = _malloc(i18) | 0;
   i15 = i23 + 40 | 0;
   i16 = i23 + 48 | 0;
   HEAP32[i16 >> 2] = i1;
   i18 = _malloc(i18) | 0;
   HEAP32[i23 + 52 >> 2] = i18;
   i20 = _fft_create_plan(i17, i1, i18, 1, i29) | 0;
   HEAP32[i23 + 56 >> 2] = i20;
   HEAP32[i23 + 60 >> 2] = _fft_create_plan(i17, i18, i1, -1, i29) | 0;
   i1 = i17;
   i3 = 0;
   while (1) {
    if (i1 >>> 0 < 2) {
     i2 = i3;
     break;
    } else i2 = 2;
    while (1) {
     if (!((i1 >>> 0) % (i2 >>> 0) | 0)) {
      i31 = 48;
      break;
     }
     i2 = i2 + 1 | 0;
     if (i2 >>> 0 > i1 >>> 0) {
      i2 = i3;
      break;
     }
    }
    if ((i31 | 0) == 48) {
     i31 = 0;
     i1 = (i1 >>> 0) / (i2 >>> 0) | 0;
     HEAP32[i30 + (i3 << 2) >> 2] = i2;
     if (!i3) i2 = 1; else i2 = ((HEAP32[i30 + (i3 + -1 << 2) >> 2] | 0) != (i2 | 0) & 1) + i3 | 0;
    }
    if (i1 >>> 0 > 1 & i2 >>> 0 < 40) i3 = i2; else break;
   }
   L87 : do if (i32 >>> 0 < 3 | (i2 | 0) == 0) i1 = 2; else {
    i1 = 2;
    do {
     i11 = 0;
     while (1) {
      i10 = (i17 >>> 0) / ((HEAP32[i30 + (i11 << 2) >> 2] | 0) >>> 0) | 0;
      if (!i10) break; else {
       i3 = 1;
       i9 = 0;
      }
      do {
       i3 = ((Math_imul(i3, i1) | 0) >>> 0) % (i32 >>> 0) | 0;
       i9 = i9 + 1 | 0;
      } while ((i9 | 0) != (i10 | 0));
      i28 = (i3 | 0) == 1;
      i11 = i11 + 1 | 0;
      if (!(i11 >>> 0 < i2 >>> 0 & (i28 ^ 1))) {
       i31 = 56;
       break;
      }
     }
     if ((i31 | 0) == 56 ? (i31 = 0, !i28) : 0) break L87;
     i1 = i1 + 1 | 0;
    } while (i1 >>> 0 < i32 >>> 0);
   } while (0);
   i2 = _malloc((i32 << 2) + -4 | 0) | 0;
   HEAP32[i15 >> 2] = i2;
   if ((i32 | 0) != 1) {
    i10 = 0;
    do {
     i11 = i10;
     i10 = i10 + 1 | 0;
     i3 = 1;
     i9 = 0;
     do {
      i3 = ((Math_imul(i3, i1) | 0) >>> 0) % (i32 >>> 0) | 0;
      i9 = i9 + 1 | 0;
     } while ((i9 | 0) != (i10 | 0));
     HEAP32[i2 + (i11 << 2) >> 2] = i3;
    } while ((i10 | 0) != (i17 | 0));
    i1 = HEAP32[i23 >> 2] | 0;
    d13 = (HEAP32[i12 >> 2] | 0) == 1 ? -1.0 : 1.0;
    if ((i1 | 0) != 1) {
     d14 = d13 * 0.0;
     d4 = d14 * 2.0 - d14;
     d5 = d13 * 2.0 + d14 * 0.0;
     i9 = i34 + 4 | 0;
     i11 = HEAP32[i15 >> 2] | 0;
     i12 = i35 + 8 | 0;
     d19 = +(i1 >>> 0);
     i15 = i33 + 4 | 0;
     i10 = HEAP32[i16 >> 2] | 0;
     if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
      i2 = i1 + -1 | 0;
      i3 = 0;
      do {
       ___mulsc3(i34, d14, d13, 2.0, 0.0);
       d6 = +HEAPF32[i34 >> 2] * 3.141592653589793;
       d7 = +HEAPF32[i9 >> 2] * 3.141592653589793;
       d8 = +((HEAP32[i11 + (i3 << 2) >> 2] | 0) >>> 0);
       d5 = d6 * d8 - d7 * 0.0;
       d4 = d6 * 0.0 + d7 * d8;
       if ((d5 != d5 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
        ___muldc3(i35, d6, d7, d8, 0.0);
        d5 = +HEAPF64[i35 >> 3];
        d4 = +HEAPF64[i12 >> 3];
       }
       _cexpf(i33, d5 / d19, d4 / d19);
       i32 = HEAP32[i15 >> 2] | 0;
       HEAP32[i10 + (i3 << 3) >> 2] = HEAP32[i33 >> 2];
       HEAP32[i10 + (i3 << 3) + 4 >> 2] = i32;
       i3 = i3 + 1 | 0;
      } while ((i3 | 0) != (i2 | 0));
     } else {
      d14 = d4 * 3.141592653589793;
      d7 = d5 * 3.141592653589793;
      d8 = d7 * 0.0;
      d13 = d14 * 0.0;
      i2 = i1 + -1 | 0;
      i3 = 0;
      do {
       d5 = +((HEAP32[i11 + (i3 << 2) >> 2] | 0) >>> 0);
       d6 = d14 * d5 - d8;
       d4 = d13 + d7 * d5;
       if ((d6 != d6 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
        ___muldc3(i35, d14, d7, d5, 0.0);
        d6 = +HEAPF64[i35 >> 3];
        d4 = +HEAPF64[i12 >> 3];
       }
       _cexpf(i33, d6 / d19, d4 / d19);
       i34 = HEAP32[i15 >> 2] | 0;
       HEAP32[i10 + (i3 << 3) >> 2] = HEAP32[i33 >> 2];
       HEAP32[i10 + (i3 << 3) + 4 >> 2] = i34;
       i3 = i3 + 1 | 0;
      } while ((i3 | 0) != (i2 | 0));
     }
    } else i1 = 1;
   } else i1 = 1;
   mftCall_vi(HEAP32[i20 + 28 >> 2] | 0, i20 | 0);
   i35 = (i1 << 3) + -8 | 0;
   i34 = _malloc(i35) | 0;
   HEAP32[i23 + 44 >> 2] = i34;
   _memcpy(i34 | 0, i18 | 0, i35 | 0) | 0;
   i35 = i23;
   STACKTOP = i36;
   return i35 | 0;
  }
  i23 = _malloc(72) | 0;
  HEAP32[i23 >> 2] = i32;
  HEAP32[i23 + 4 >> 2] = i20;
  HEAP32[i23 + 8 >> 2] = i21;
  i15 = i23 + 16 | 0;
  HEAP32[i15 >> 2] = i29;
  i1 = (i22 | 0) == 1 ? 1 : -1;
  HEAP32[i23 + 20 >> 2] = i1;
  i16 = i23 + 12 | 0;
  HEAP32[i16 >> 2] = i1;
  HEAP32[i23 + 24 >> 2] = 4;
  HEAP32[i23 + 28 >> 2] = fb + 9;
  i1 = i17;
  i3 = 0;
  while (1) {
   if (i1 >>> 0 < 2) {
    i2 = i3;
    break;
   } else i2 = 2;
   while (1) {
    if (!((i1 >>> 0) % (i2 >>> 0) | 0)) {
     i31 = 77;
     break;
    }
    i2 = i2 + 1 | 0;
    if (i2 >>> 0 > i1 >>> 0) {
     i2 = i3;
     break;
    }
   }
   if ((i31 | 0) == 77) {
    i31 = 0;
    i1 = (i1 >>> 0) / (i2 >>> 0) | 0;
    HEAP32[i30 + (i3 << 2) >> 2] = i2;
    if (!i3) i2 = 1; else i2 = ((HEAP32[i30 + (i3 + -1 << 2) >> 2] | 0) != (i2 | 0) & 1) + i3 | 0;
   }
   if (i1 >>> 0 > 1 & i2 >>> 0 < 40) i3 = i2; else break;
  }
  L133 : do if (i32 >>> 0 < 3 | (i2 | 0) == 0) i1 = 2; else {
   i1 = 2;
   do {
    i11 = 0;
    while (1) {
     i10 = (i17 >>> 0) / ((HEAP32[i30 + (i11 << 2) >> 2] | 0) >>> 0) | 0;
     if (!i10) break; else {
      i3 = 1;
      i9 = 0;
     }
     do {
      i3 = ((Math_imul(i3, i1) | 0) >>> 0) % (i32 >>> 0) | 0;
      i9 = i9 + 1 | 0;
     } while ((i9 | 0) != (i10 | 0));
     i27 = (i3 | 0) == 1;
     i11 = i11 + 1 | 0;
     if (!(i11 >>> 0 < i2 >>> 0 & (i27 ^ 1))) {
      i31 = 85;
      break;
     }
    }
    if ((i31 | 0) == 85 ? (i31 = 0, !i27) : 0) break L133;
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < i32 >>> 0);
  } while (0);
  i2 = _malloc((i32 << 2) + -4 | 0) | 0;
  i21 = i23 + 40 | 0;
  i12 = i23 + 44 | 0;
  HEAP32[i12 >> 2] = i2;
  if ((i32 | 0) == 1) i1 = -3; else {
   i10 = 0;
   do {
    i11 = i10;
    i10 = i10 + 1 | 0;
    i3 = 1;
    i9 = 0;
    do {
     i3 = ((Math_imul(i3, i1) | 0) >>> 0) % (i32 >>> 0) | 0;
     i9 = i9 + 1 | 0;
    } while ((i9 | 0) != (i10 | 0));
    HEAP32[i2 + (i11 << 2) >> 2] = i3;
   } while ((i10 | 0) != (i17 | 0));
   i1 = (i32 << 1) + -5 | 0;
  }
  HEAP32[i21 >> 2] = i1;
  i2 = 0;
  do {
   i1 = i1 >>> 1;
   i2 = i2 + 1 | 0;
  } while ((i1 | 0) != 0);
  i17 = 1 << i2;
  HEAP32[i21 >> 2] = i17;
  i10 = i17 << 3;
  i18 = _malloc(i10) | 0;
  HEAP32[i23 + 52 >> 2] = i18;
  i10 = _malloc(i10) | 0;
  i20 = i23 + 56 | 0;
  HEAP32[i20 >> 2] = i10;
  i2 = HEAP32[i15 >> 2] | 0;
  i15 = i23 + 60 | 0;
  HEAP32[i15 >> 2] = _fft_create_plan(i17, i18, i10, 1, i2) | 0;
  HEAP32[i23 + 64 >> 2] = _fft_create_plan(i17, i10, i18, -1, i2) | 0;
  d13 = (HEAP32[i16 >> 2] | 0) == 1 ? -1.0 : 1.0;
  d14 = d13 * 0.0;
  d4 = d14 * 2.0 - d14;
  d5 = d13 * 2.0 + d14 * 0.0;
  i2 = i34 + 4 | 0;
  i10 = HEAP32[i23 >> 2] | 0;
  i11 = i10 + -1 | 0;
  i3 = HEAP32[i12 >> 2] | 0;
  i9 = i35 + 8 | 0;
  d19 = +(i10 >>> 0);
  i10 = i33 + 4 | 0;
  if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
   i1 = 0;
   do {
    ___mulsc3(i34, d14, d13, 2.0, 0.0);
    d6 = +HEAPF32[i34 >> 2] * 3.141592653589793;
    d7 = +HEAPF32[i2 >> 2] * 3.141592653589793;
    d8 = +((HEAP32[i3 + (((i1 >>> 0) % (i11 >>> 0) | 0) << 2) >> 2] | 0) >>> 0);
    d5 = d6 * d8 - d7 * 0.0;
    d4 = d6 * 0.0 + d7 * d8;
    if ((d5 != d5 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
     ___muldc3(i35, d6, d7, d8, 0.0);
     d5 = +HEAPF64[i35 >> 3];
     d4 = +HEAPF64[i9 >> 3];
    }
    _cexpf(i33, d5 / d19, d4 / d19);
    i32 = HEAP32[i10 >> 2] | 0;
    HEAP32[i18 + (i1 << 3) >> 2] = HEAP32[i33 >> 2];
    HEAP32[i18 + (i1 << 3) + 4 >> 2] = i32;
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < i17 >>> 0);
  } else {
   d14 = d4 * 3.141592653589793;
   d7 = d5 * 3.141592653589793;
   d8 = d7 * 0.0;
   d13 = d14 * 0.0;
   i1 = 0;
   do {
    d5 = +((HEAP32[i3 + (((i1 >>> 0) % (i11 >>> 0) | 0) << 2) >> 2] | 0) >>> 0);
    d6 = d14 * d5 - d8;
    d4 = d13 + d7 * d5;
    if ((d6 != d6 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
     ___muldc3(i35, d14, d7, d5, 0.0);
     d6 = +HEAPF64[i35 >> 3];
     d4 = +HEAPF64[i9 >> 3];
    }
    _cexpf(i33, d6 / d19, d4 / d19);
    i34 = HEAP32[i10 >> 2] | 0;
    HEAP32[i18 + (i1 << 3) >> 2] = HEAP32[i33 >> 2];
    HEAP32[i18 + (i1 << 3) + 4 >> 2] = i34;
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < i17 >>> 0);
  }
  i35 = HEAP32[i15 >> 2] | 0;
  mftCall_vi(HEAP32[i35 + 28 >> 2] | 0, i35 | 0);
  i35 = HEAP32[i21 >> 2] << 3;
  i34 = _malloc(i35) | 0;
  HEAP32[i23 + 48 >> 2] = i34;
  _memmove(i34 | 0, HEAP32[i20 >> 2] | 0, i35 | 0) | 0;
  i35 = i23;
  STACKTOP = i36;
  return i35 | 0;
 } while (0);
 i15 = _malloc(72) | 0;
 HEAP32[i15 >> 2] = i32;
 HEAP32[i15 + 4 >> 2] = i20;
 HEAP32[i15 + 8 >> 2] = i21;
 HEAP32[i15 + 16 >> 2] = i29;
 i12 = (i22 | 0) == 1;
 i11 = i12 ? 1 : -1;
 HEAP32[i15 + 20 >> 2] = i11;
 HEAP32[i15 + 12 >> 2] = i11;
 HEAP32[i15 + 24 >> 2] = 2;
 HEAP32[i15 + 28 >> 2] = fb + 7;
 i9 = i32;
 i10 = 0;
 while (1) {
  if (i9 >>> 0 < 2) {
   i24 = i10;
   break;
  } else i3 = 2;
  do {
   if (!((i9 >>> 0) % (i3 >>> 0) | 0)) {
    i31 = 22;
    break;
   }
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 <= i9 >>> 0);
  if ((i31 | 0) == 22) {
   i31 = 0;
   HEAP32[i30 + (i10 << 2) >> 2] = i3;
   i9 = (i9 >>> 0) / (i3 >>> 0) | 0;
   i10 = i10 + 1 | 0;
  }
  i3 = i9 >>> 0 > 1;
  if (!(i3 & i10 >>> 0 < 40)) {
   i31 = 25;
   break;
  }
 }
 if ((i31 | 0) == 25) if (i3 & (i10 | 0) == 40) {
  HEAP32[i18 >> 2] = i32;
  HEAP32[i18 + 4 >> 2] = 40;
  _fprintf(gb + 8728 | 0, gb + 37615 | 0, i18);
  _exit(1);
 } else i24 = i10;
 if (i24 >>> 0 < 2) {
  HEAP32[i23 >> 2] = i32;
  _fprintf(gb + 8728 | 0, gb + 37081 | 0, i23);
  HEAP32[i25 >> 2] = i32;
  _fprintf(gb + 8728 | 0, gb + 37131 | 0, i25);
  _exit(1);
 } else i2 = 0;
 while (1) {
  if ((HEAP32[i30 + (i2 << 2) >> 2] | 0) != 2) {
   i31 = 31;
   break;
  }
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= i24 >>> 0) {
   i31 = 32;
   break;
  }
 }
 if ((i31 | 0) == 31) if (!i2) {
  i2 = HEAP32[i30 >> 2] | 0;
  if (!i2) {
   HEAP32[i25 >> 2] = i32;
   _fprintf(gb + 8728 | 0, gb + 37131 | 0, i25);
   _exit(1);
  } else i1 = i2;
 } else i31 = 32;
 if ((i31 | 0) == 32) if (i32 & 15) if (!(i32 & 7)) i1 = 8; else i1 = (i32 & 3 | 0) == 0 ? 4 : 2; else i1 = 16;
 if ((i32 >>> 0) % (i1 >>> 0) | 0 | 0) {
  HEAP32[i26 >> 2] = i32;
  HEAP32[i26 + 4 >> 2] = i1;
  _fprintf(gb + 8728 | 0, gb + 37188 | 0, i26);
  _exit(1);
 }
 i33 = (i32 >>> 0) / (i1 >>> 0) | 0;
 HEAP32[i15 + 44 >> 2] = i1;
 HEAP32[i15 + 40 >> 2] = i33;
 i2 = (i1 >>> 0 > i33 >>> 0 ? i1 : i33) << 3;
 i3 = _malloc(i2) | 0;
 HEAP32[i15 + 52 >> 2] = i3;
 i2 = _malloc(i2) | 0;
 HEAP32[i15 + 56 >> 2] = i2;
 i9 = i32 << 3;
 HEAP32[i15 + 48 >> 2] = _malloc(i9) | 0;
 HEAP32[i15 + 64 >> 2] = _fft_create_plan(i33, i3, i2, i11, i29) | 0;
 HEAP32[i15 + 68 >> 2] = _fft_create_plan(i1, i3, i2, i11, i29) | 0;
 i9 = _malloc(i9) | 0;
 HEAP32[i15 + 60 >> 2] = i9;
 d5 = i12 ? -1.0 : 1.0;
 d6 = d5 * 0.0;
 d4 = d6 * 2.0 - d6;
 d7 = d5 * 2.0 + d6 * 0.0;
 i2 = i34 + 4 | 0;
 d8 = +(i32 >>> 0);
 i3 = i35 + 4 | 0;
 if ((d4 != d4 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
  i1 = 0;
  do {
   ___mulsc3(i34, d6, d5, 2.0, 0.0);
   d19 = +(i1 >>> 0);
   _cexpf(i35, d19 * (+HEAPF32[i34 >> 2] * 3.141592653589793) / d8, d19 * (+HEAPF32[i2 >> 2] * 3.141592653589793) / d8);
   i33 = HEAP32[i3 >> 2] | 0;
   HEAP32[i9 + (i1 << 3) >> 2] = HEAP32[i35 >> 2];
   HEAP32[i9 + (i1 << 3) + 4 >> 2] = i33;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i32 | 0));
 } else {
  d5 = d4 * 3.141592653589793;
  d4 = d7 * 3.141592653589793;
  i1 = 0;
  do {
   d19 = +(i1 >>> 0);
   _cexpf(i35, d5 * d19 / d8, d4 * d19 / d8);
   i34 = HEAP32[i3 >> 2] | 0;
   HEAP32[i9 + (i1 << 3) >> 2] = HEAP32[i35 >> 2];
   HEAP32[i9 + (i1 << 3) + 4 >> 2] = i34;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i32 | 0));
 }
 i35 = i15;
 STACKTOP = i36;
 return i35 | 0;
}

function _fft_execute_dft_7(i15) {
 i15 = i15 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, i16 = 0, i17 = 0, d18 = 0.0, d19 = 0.0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, d52 = 0.0, i53 = 0, i54 = 0, i55 = 0, d56 = 0.0, i57 = 0, i58 = 0, i59 = 0, d60 = 0.0, i61 = 0, i62 = 0, i63 = 0, d64 = 0.0, i65 = 0, i66 = 0, i67 = 0, d68 = 0.0, i69 = 0, i70 = 0, i71 = 0, d72 = 0.0, i73 = 0, i74 = 0, i75 = 0;
 i75 = STACKTOP;
 STACKTOP = STACKTOP + 288 | 0;
 i16 = i75 + 280 | 0;
 i17 = i75 + 272 | 0;
 i20 = i75 + 264 | 0;
 i21 = i75 + 256 | 0;
 i22 = i75 + 248 | 0;
 i23 = i75 + 240 | 0;
 i24 = i75 + 232 | 0;
 i25 = i75 + 224 | 0;
 i26 = i75 + 216 | 0;
 i27 = i75 + 208 | 0;
 i28 = i75 + 200 | 0;
 i29 = i75 + 192 | 0;
 i30 = i75 + 184 | 0;
 i31 = i75 + 176 | 0;
 i32 = i75 + 168 | 0;
 i33 = i75 + 160 | 0;
 i34 = i75 + 152 | 0;
 i35 = i75 + 144 | 0;
 i36 = i75 + 136 | 0;
 i37 = i75 + 128 | 0;
 i38 = i75 + 120 | 0;
 i39 = i75 + 112 | 0;
 i40 = i75 + 104 | 0;
 i41 = i75 + 96 | 0;
 i42 = i75 + 88 | 0;
 i43 = i75 + 80 | 0;
 i44 = i75 + 72 | 0;
 i45 = i75 + 64 | 0;
 i46 = i75 + 56 | 0;
 i47 = i75 + 48 | 0;
 i53 = i75 + 40 | 0;
 i57 = i75 + 32 | 0;
 i61 = i75 + 24 | 0;
 i65 = i75 + 16 | 0;
 i69 = i75 + 8 | 0;
 i73 = i75;
 i48 = HEAP32[i15 + 4 >> 2] | 0;
 i74 = HEAP32[i15 + 8 >> 2] | 0;
 i49 = i48 + 4 | 0;
 i50 = i48 + 8 | 0;
 i51 = i48 + 12 | 0;
 i54 = i48 + 16 | 0;
 i55 = i48 + 20 | 0;
 i58 = i48 + 24 | 0;
 i59 = i48 + 28 | 0;
 i62 = i48 + 32 | 0;
 i63 = i48 + 36 | 0;
 i66 = i48 + 40 | 0;
 i67 = i48 + 44 | 0;
 i70 = i48 + 48 | 0;
 i71 = i48 + 52 | 0;
 d64 = +HEAPF32[i49 >> 2] + +HEAPF32[i51 >> 2] + +HEAPF32[i55 >> 2] + +HEAPF32[i59 >> 2] + +HEAPF32[i63 >> 2] + +HEAPF32[i67 >> 2] + +HEAPF32[i71 >> 2];
 HEAPF32[i74 >> 2] = +HEAPF32[i48 >> 2] + +HEAPF32[i50 >> 2] + +HEAPF32[i54 >> 2] + +HEAPF32[i58 >> 2] + +HEAPF32[i62 >> 2] + +HEAPF32[i66 >> 2] + +HEAPF32[i70 >> 2];
 HEAPF32[i74 + 4 >> 2] = d64;
 i15 = (HEAP32[i15 + 12 >> 2] | 0) == 1;
 d64 = i15 ? -.4338837265968323 : .4338837265968323;
 d68 = i15 ? -.9749279022216797 : .9749279022216797;
 d72 = i15 ? -.7818315029144287 : .7818315029144287;
 d60 = -d64;
 d56 = -d68;
 d52 = -d72;
 d18 = +HEAPF32[i48 >> 2];
 d19 = +HEAPF32[i49 >> 2];
 d1 = +HEAPF32[i50 >> 2];
 d2 = +HEAPF32[i51 >> 2];
 d3 = d1 * .6234897971153259 - d72 * d2;
 d4 = d72 * d1 + d2 * .6234897971153259;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i16, d1, d2, .6234897971153259, d72);
  d3 = +HEAPF32[i16 >> 2];
  d14 = +HEAPF32[i16 + 4 >> 2];
 } else d14 = d4;
 d1 = +HEAPF32[i54 >> 2];
 d2 = +HEAPF32[i55 >> 2];
 d4 = d1 * -.22252093255519867 - d68 * d2;
 d5 = d68 * d1 - d2 * .22252093255519867;
 if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
  ___mulsc3(i17, d1, d2, -.22252093255519867, d68);
  d4 = +HEAPF32[i17 >> 2];
  d5 = +HEAPF32[i17 + 4 >> 2];
 }
 d1 = +HEAPF32[i58 >> 2];
 d2 = +HEAPF32[i59 >> 2];
 d6 = d1 * -.9009688496589661 - d64 * d2;
 d7 = d64 * d1 - d2 * .9009688496589661;
 if ((d6 != d6 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0)) {
  ___mulsc3(i20, d1, d2, -.9009688496589661, d64);
  d6 = +HEAPF32[i20 >> 2];
  d7 = +HEAPF32[i20 + 4 >> 2];
 }
 d1 = +HEAPF32[i62 >> 2];
 d2 = +HEAPF32[i63 >> 2];
 d8 = d1 * -.9009688496589661 - d2 * d60;
 d9 = d1 * d60 - d2 * .9009688496589661;
 if ((d8 != d8 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
  ___mulsc3(i21, d1, d2, -.9009688496589661, d60);
  d8 = +HEAPF32[i21 >> 2];
  d9 = +HEAPF32[i21 + 4 >> 2];
 }
 d1 = +HEAPF32[i66 >> 2];
 d2 = +HEAPF32[i67 >> 2];
 d10 = d1 * -.22252093255519867 - d2 * d56;
 d11 = d1 * d56 - d2 * .22252093255519867;
 if ((d10 != d10 | 0.0 != 0.0) & (d11 != d11 | 0.0 != 0.0)) {
  ___mulsc3(i22, d1, d2, -.22252093255519867, d56);
  d10 = +HEAPF32[i22 >> 2];
  d11 = +HEAPF32[i22 + 4 >> 2];
 }
 d12 = +HEAPF32[i70 >> 2];
 d13 = +HEAPF32[i71 >> 2];
 d2 = d12 * .6234897971153259 - d13 * d52;
 d1 = d12 * d52 + d13 * .6234897971153259;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i23, d12, d13, .6234897971153259, d52);
  d2 = +HEAPF32[i23 >> 2];
  d1 = +HEAPF32[i23 + 4 >> 2];
 }
 HEAPF32[i74 + 8 >> 2] = d18 + d3 + d4 + d6 + d8 + d10 + d2;
 HEAPF32[i74 + 12 >> 2] = d19 + d14 + d5 + d7 + d9 + d11 + d1;
 d18 = +HEAPF32[i48 >> 2];
 d19 = +HEAPF32[i49 >> 2];
 d1 = +HEAPF32[i50 >> 2];
 d2 = +HEAPF32[i51 >> 2];
 d3 = d1 * -.22252093255519867 - d68 * d2;
 d4 = d68 * d1 - d2 * .22252093255519867;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i24, d1, d2, -.22252093255519867, d68);
  d3 = +HEAPF32[i24 >> 2];
  d4 = +HEAPF32[i24 + 4 >> 2];
 }
 d1 = +HEAPF32[i54 >> 2];
 d2 = +HEAPF32[i55 >> 2];
 d5 = d1 * -.9009688496589661 - d2 * d60;
 d6 = d1 * d60 - d2 * .9009688496589661;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i25, d1, d2, -.9009688496589661, d60);
  d5 = +HEAPF32[i25 >> 2];
  d6 = +HEAPF32[i25 + 4 >> 2];
 }
 d1 = +HEAPF32[i58 >> 2];
 d2 = +HEAPF32[i59 >> 2];
 d7 = d1 * .6234897971153259 - d2 * d52;
 d8 = d1 * d52 + d2 * .6234897971153259;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i26, d1, d2, .6234897971153259, d52);
  d7 = +HEAPF32[i26 >> 2];
  d8 = +HEAPF32[i26 + 4 >> 2];
 }
 d1 = +HEAPF32[i62 >> 2];
 d2 = +HEAPF32[i63 >> 2];
 d9 = d1 * .6234897971153259 - d72 * d2;
 d10 = d72 * d1 + d2 * .6234897971153259;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i27, d1, d2, .6234897971153259, d72);
  d9 = +HEAPF32[i27 >> 2];
  d10 = +HEAPF32[i27 + 4 >> 2];
 }
 d1 = +HEAPF32[i66 >> 2];
 d2 = +HEAPF32[i67 >> 2];
 d11 = d1 * -.9009688496589661 - d64 * d2;
 d12 = d64 * d1 - d2 * .9009688496589661;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i28, d1, d2, -.9009688496589661, d64);
  d11 = +HEAPF32[i28 >> 2];
  d12 = +HEAPF32[i28 + 4 >> 2];
 }
 d13 = +HEAPF32[i70 >> 2];
 d14 = +HEAPF32[i71 >> 2];
 d2 = d13 * -.22252093255519867 - d14 * d56;
 d1 = d13 * d56 - d14 * .22252093255519867;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i29, d13, d14, -.22252093255519867, d56);
  d2 = +HEAPF32[i29 >> 2];
  d1 = +HEAPF32[i29 + 4 >> 2];
 }
 HEAPF32[i74 + 16 >> 2] = d18 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i74 + 20 >> 2] = d19 + d4 + d6 + d8 + d10 + d12 + d1;
 d18 = +HEAPF32[i48 >> 2];
 d19 = +HEAPF32[i49 >> 2];
 d1 = +HEAPF32[i50 >> 2];
 d2 = +HEAPF32[i51 >> 2];
 d3 = d1 * -.9009688496589661 - d64 * d2;
 d4 = d64 * d1 - d2 * .9009688496589661;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i30, d1, d2, -.9009688496589661, d64);
  d3 = +HEAPF32[i30 >> 2];
  d4 = +HEAPF32[i30 + 4 >> 2];
 }
 d1 = +HEAPF32[i54 >> 2];
 d2 = +HEAPF32[i55 >> 2];
 d5 = d1 * .6234897971153259 - d2 * d52;
 d6 = d1 * d52 + d2 * .6234897971153259;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i31, d1, d2, .6234897971153259, d52);
  d5 = +HEAPF32[i31 >> 2];
  d6 = +HEAPF32[i31 + 4 >> 2];
 }
 d1 = +HEAPF32[i58 >> 2];
 d2 = +HEAPF32[i59 >> 2];
 d7 = d1 * -.22252093255519867 - d68 * d2;
 d8 = d68 * d1 - d2 * .22252093255519867;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i32, d1, d2, -.22252093255519867, d68);
  d7 = +HEAPF32[i32 >> 2];
  d8 = +HEAPF32[i32 + 4 >> 2];
 }
 d1 = +HEAPF32[i62 >> 2];
 d2 = +HEAPF32[i63 >> 2];
 d9 = d1 * -.22252093255519867 - d2 * d56;
 d10 = d1 * d56 - d2 * .22252093255519867;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i33, d1, d2, -.22252093255519867, d56);
  d9 = +HEAPF32[i33 >> 2];
  d10 = +HEAPF32[i33 + 4 >> 2];
 }
 d1 = +HEAPF32[i66 >> 2];
 d2 = +HEAPF32[i67 >> 2];
 d11 = d1 * .6234897971153259 - d72 * d2;
 d12 = d72 * d1 + d2 * .6234897971153259;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i34, d1, d2, .6234897971153259, d72);
  d11 = +HEAPF32[i34 >> 2];
  d12 = +HEAPF32[i34 + 4 >> 2];
 }
 d13 = +HEAPF32[i70 >> 2];
 d14 = +HEAPF32[i71 >> 2];
 d2 = d13 * -.9009688496589661 - d14 * d60;
 d1 = d13 * d60 - d14 * .9009688496589661;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i35, d13, d14, -.9009688496589661, d60);
  d2 = +HEAPF32[i35 >> 2];
  d1 = +HEAPF32[i35 + 4 >> 2];
 }
 HEAPF32[i74 + 24 >> 2] = d18 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i74 + 28 >> 2] = d19 + d4 + d6 + d8 + d10 + d12 + d1;
 d18 = +HEAPF32[i48 >> 2];
 d19 = +HEAPF32[i49 >> 2];
 d1 = +HEAPF32[i50 >> 2];
 d2 = +HEAPF32[i51 >> 2];
 d3 = d1 * -.9009688496589661 - d2 * d60;
 d4 = d1 * d60 - d2 * .9009688496589661;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i36, d1, d2, -.9009688496589661, d60);
  d3 = +HEAPF32[i36 >> 2];
  d4 = +HEAPF32[i36 + 4 >> 2];
 }
 d1 = +HEAPF32[i54 >> 2];
 d2 = +HEAPF32[i55 >> 2];
 d5 = d1 * .6234897971153259 - d72 * d2;
 d6 = d72 * d1 + d2 * .6234897971153259;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i37, d1, d2, .6234897971153259, d72);
  d5 = +HEAPF32[i37 >> 2];
  d6 = +HEAPF32[i37 + 4 >> 2];
 }
 d1 = +HEAPF32[i58 >> 2];
 d2 = +HEAPF32[i59 >> 2];
 d7 = d1 * -.22252093255519867 - d2 * d56;
 d8 = d1 * d56 - d2 * .22252093255519867;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i38, d1, d2, -.22252093255519867, d56);
  d7 = +HEAPF32[i38 >> 2];
  d8 = +HEAPF32[i38 + 4 >> 2];
 }
 d1 = +HEAPF32[i62 >> 2];
 d2 = +HEAPF32[i63 >> 2];
 d9 = d1 * -.22252093255519867 - d68 * d2;
 d10 = d68 * d1 - d2 * .22252093255519867;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i39, d1, d2, -.22252093255519867, d68);
  d9 = +HEAPF32[i39 >> 2];
  d10 = +HEAPF32[i39 + 4 >> 2];
 }
 d1 = +HEAPF32[i66 >> 2];
 d2 = +HEAPF32[i67 >> 2];
 d11 = d1 * .6234897971153259 - d2 * d52;
 d12 = d1 * d52 + d2 * .6234897971153259;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i40, d1, d2, .6234897971153259, d52);
  d11 = +HEAPF32[i40 >> 2];
  d12 = +HEAPF32[i40 + 4 >> 2];
 }
 d13 = +HEAPF32[i70 >> 2];
 d14 = +HEAPF32[i71 >> 2];
 d2 = d13 * -.9009688496589661 - d64 * d14;
 d1 = d64 * d13 - d14 * .9009688496589661;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i41, d13, d14, -.9009688496589661, d64);
  d2 = +HEAPF32[i41 >> 2];
  d1 = +HEAPF32[i41 + 4 >> 2];
 }
 HEAPF32[i74 + 32 >> 2] = d18 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i74 + 36 >> 2] = d19 + d4 + d6 + d8 + d10 + d12 + d1;
 d18 = +HEAPF32[i48 >> 2];
 d19 = +HEAPF32[i49 >> 2];
 d1 = +HEAPF32[i50 >> 2];
 d2 = +HEAPF32[i51 >> 2];
 d3 = d1 * -.22252093255519867 - d2 * d56;
 d4 = d1 * d56 - d2 * .22252093255519867;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i42, d1, d2, -.22252093255519867, d56);
  d3 = +HEAPF32[i42 >> 2];
  d4 = +HEAPF32[i42 + 4 >> 2];
 }
 d1 = +HEAPF32[i54 >> 2];
 d2 = +HEAPF32[i55 >> 2];
 d5 = d1 * -.9009688496589661 - d64 * d2;
 d6 = d64 * d1 - d2 * .9009688496589661;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i43, d1, d2, -.9009688496589661, d64);
  d5 = +HEAPF32[i43 >> 2];
  d6 = +HEAPF32[i43 + 4 >> 2];
 }
 d1 = +HEAPF32[i58 >> 2];
 d2 = +HEAPF32[i59 >> 2];
 d7 = d1 * .6234897971153259 - d72 * d2;
 d8 = d72 * d1 + d2 * .6234897971153259;
 if ((d7 != d7 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
  ___mulsc3(i44, d1, d2, .6234897971153259, d72);
  d7 = +HEAPF32[i44 >> 2];
  d8 = +HEAPF32[i44 + 4 >> 2];
 }
 d1 = +HEAPF32[i62 >> 2];
 d2 = +HEAPF32[i63 >> 2];
 d9 = d1 * .6234897971153259 - d2 * d52;
 d10 = d1 * d52 + d2 * .6234897971153259;
 if ((d9 != d9 | 0.0 != 0.0) & (d10 != d10 | 0.0 != 0.0)) {
  ___mulsc3(i45, d1, d2, .6234897971153259, d52);
  d9 = +HEAPF32[i45 >> 2];
  d10 = +HEAPF32[i45 + 4 >> 2];
 }
 d1 = +HEAPF32[i66 >> 2];
 d2 = +HEAPF32[i67 >> 2];
 d11 = d1 * -.9009688496589661 - d2 * d60;
 d12 = d1 * d60 - d2 * .9009688496589661;
 if ((d11 != d11 | 0.0 != 0.0) & (d12 != d12 | 0.0 != 0.0)) {
  ___mulsc3(i46, d1, d2, -.9009688496589661, d60);
  d11 = +HEAPF32[i46 >> 2];
  d12 = +HEAPF32[i46 + 4 >> 2];
 }
 d13 = +HEAPF32[i70 >> 2];
 d14 = +HEAPF32[i71 >> 2];
 d2 = d13 * -.22252093255519867 - d68 * d14;
 d1 = d68 * d13 - d14 * .22252093255519867;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i47, d13, d14, -.22252093255519867, d68);
  d2 = +HEAPF32[i47 >> 2];
  d1 = +HEAPF32[i47 + 4 >> 2];
 }
 HEAPF32[i74 + 40 >> 2] = d18 + d3 + d5 + d7 + d9 + d11 + d2;
 HEAPF32[i74 + 44 >> 2] = d19 + d4 + d6 + d8 + d10 + d12 + d1;
 d13 = +HEAPF32[i48 >> 2];
 d14 = +HEAPF32[i49 >> 2];
 d3 = +HEAPF32[i50 >> 2];
 d1 = +HEAPF32[i51 >> 2];
 d2 = d3 * .6234897971153259 - d1 * d52;
 d4 = d3 * d52 + d1 * .6234897971153259;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i53, d3, d1, .6234897971153259, d52);
  d12 = +HEAPF32[i53 >> 2];
  d11 = +HEAPF32[i53 + 4 >> 2];
 } else {
  d12 = d2;
  d11 = d4;
 }
 d3 = +HEAPF32[i54 >> 2];
 d1 = +HEAPF32[i55 >> 2];
 d2 = d3 * -.22252093255519867 - d1 * d56;
 d4 = d3 * d56 - d1 * .22252093255519867;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i57, d3, d1, -.22252093255519867, d56);
  d10 = +HEAPF32[i57 >> 2];
  d9 = +HEAPF32[i57 + 4 >> 2];
 } else {
  d10 = d2;
  d9 = d4;
 }
 d3 = +HEAPF32[i58 >> 2];
 d1 = +HEAPF32[i59 >> 2];
 d2 = d3 * -.9009688496589661 - d1 * d60;
 d4 = d3 * d60 - d1 * .9009688496589661;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i61, d3, d1, -.9009688496589661, d60);
  d8 = +HEAPF32[i61 >> 2];
  d7 = +HEAPF32[i61 + 4 >> 2];
 } else {
  d8 = d2;
  d7 = d4;
 }
 d3 = +HEAPF32[i62 >> 2];
 d1 = +HEAPF32[i63 >> 2];
 d2 = d3 * -.9009688496589661 - d64 * d1;
 d4 = d64 * d3 - d1 * .9009688496589661;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i65, d3, d1, -.9009688496589661, d64);
  d6 = +HEAPF32[i65 >> 2];
  d5 = +HEAPF32[i65 + 4 >> 2];
 } else {
  d6 = d2;
  d5 = d4;
 }
 d4 = +HEAPF32[i66 >> 2];
 d3 = +HEAPF32[i67 >> 2];
 d2 = d4 * -.22252093255519867 - d68 * d3;
 d1 = d68 * d4 - d3 * .22252093255519867;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i69, d4, d3, -.22252093255519867, d68);
  d2 = +HEAPF32[i69 >> 2];
  d1 = +HEAPF32[i69 + 4 >> 2];
 }
 d6 = d13 + d12 + d10 + d8 + d6 + d2;
 d5 = d14 + d11 + d9 + d7 + d5 + d1;
 d4 = +HEAPF32[i70 >> 2];
 d1 = +HEAPF32[i71 >> 2];
 d2 = d4 * .6234897971153259 - d72 * d1;
 d3 = d72 * d4 + d1 * .6234897971153259;
 if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
  d68 = d2;
  d72 = d3;
  d68 = d6 + d68;
  d72 = d5 + d72;
  i73 = i74 + 48 | 0;
  i74 = i74 + 52 | 0;
  HEAPF32[i73 >> 2] = d68;
  HEAPF32[i74 >> 2] = d72;
  STACKTOP = i75;
  return;
 }
 ___mulsc3(i73, d4, d1, .6234897971153259, d72);
 d68 = +HEAPF32[i73 >> 2];
 d72 = +HEAPF32[i73 + 4 >> 2];
 d68 = d6 + d68;
 d72 = d5 + d72;
 i73 = i74 + 48 | 0;
 i74 = i74 + 52 | 0;
 HEAPF32[i73 >> 2] = d68;
 HEAPF32[i74 >> 2] = d72;
 STACKTOP = i75;
 return;
}

function _quiet_decoder_profile_str(i1, i3) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 var d2 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 272 | 0;
 i4 = i16;
 i13 = i16 + 256 | 0;
 i14 = _json_loads(i1, i16 + 4 | 0) | 0;
 if (!i14) {
  i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
   HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8840 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8840 + 8 >> 2] = 0;
    HEAP32[gb + 8840 + 4 >> 2] = 0;
    i3 = HEAP32[gb + 8840 + 44 >> 2] | 0;
    HEAP32[gb + 8840 + 28 >> 2] = i3;
    HEAP32[gb + 8840 + 20 >> 2] = i3;
    i1 = i3 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8840 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8840 >> 2] = i1 | 32;
   i15 = 0;
   STACKTOP = i16;
   return i15 | 0;
  } else i3 = HEAP32[gb + 8840 + 20 >> 2] | 0; while (0);
  if ((i1 - i3 | 0) >>> 0 < 23) {
   if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 10300 | 0, 23) | 0) >>> 0 < 23) {
    i15 = 0;
    STACKTOP = i16;
    return i15 | 0;
   }
  } else {
   i1 = gb + 10300 | 0;
   i5 = i3 + 23 | 0;
   do {
    HEAP8[i3 >> 0] = HEAP8[i1 >> 0] | 0;
    i3 = i3 + 1 | 0;
    i1 = i1 + 1 | 0;
   } while ((i3 | 0) < (i5 | 0));
   HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 23;
  }
  i4 = HEAP8[gb + 8840 + 75 >> 0] | 0;
  if (i4 << 24 >> 24 != 10) {
   i1 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   if (i1 >>> 0 < i3 >>> 0) {
    HEAP32[gb + 8840 + 20 >> 2] = i1 + 1;
    HEAP8[i1 >> 0] = 10;
    i15 = 0;
    STACKTOP = i16;
    return i15 | 0;
   }
  } else i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
  HEAP8[i13 >> 0] = 10;
  do if (!i3) {
   i4 = HEAP16[gb + 8840 + 74 >> 1] | 0;
   i1 = (i4 & 65535) << 24 >> 24;
   HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8840 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8840 + 8 >> 2] = 0;
    HEAP32[gb + 8840 + 4 >> 2] = 0;
    i5 = HEAP32[gb + 8840 + 44 >> 2] | 0;
    HEAP32[gb + 8840 + 28 >> 2] = i5;
    HEAP32[gb + 8840 + 20 >> 2] = i5;
    i3 = i5 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8840 + 16 >> 2] = i3;
    i1 = (i4 & 65535) >>> 8 & 255;
    i15 = 19;
    break;
   } else {
    HEAP32[gb + 8840 >> 2] = i1 | 32;
    break;
   }
  } else {
   i5 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   i1 = i4;
   i15 = 19;
  } while (0);
  do if ((i15 | 0) == 19) if (i5 >>> 0 >= i3 >>> 0 | i1 << 24 >> 24 == 10) {
   mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i13 | 0, 1) | 0;
   break;
  } else {
   HEAP32[gb + 8840 + 20 >> 2] = i5 + 1;
   HEAP8[i5 >> 0] = 10;
   break;
  } while (0);
  i15 = 0;
  STACKTOP = i16;
  return i15 | 0;
 }
 L36 : do if (((i3 | 0) != 0 ? (HEAP32[i14 >> 2] | 0) == 0 : 0) ? (i10 = _hashtable_get(i14 + 8 | 0, i3) | 0, (i10 | 0) != 0) : 0) {
  i4 = _malloc(60) | 0;
  if (!i4) {
   i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
    HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8840 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8840 + 8 >> 2] = 0;
     HEAP32[gb + 8840 + 4 >> 2] = 0;
     i3 = HEAP32[gb + 8840 + 44 >> 2] | 0;
     HEAP32[gb + 8840 + 28 >> 2] = i3;
     HEAP32[gb + 8840 + 20 >> 2] = i3;
     i1 = i3 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8840 + 16 >> 2] = i1;
     break;
    } else {
     HEAP32[gb + 8840 >> 2] = i1 | 32;
     i4 = 0;
     break L36;
    }
   } else i3 = HEAP32[gb + 8840 + 20 >> 2] | 0; while (0);
   if ((i1 - i3 | 0) >>> 0 < 36) {
    if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 10324 | 0, 36) | 0) >>> 0 < 36) {
     i4 = 0;
     break;
    }
   } else {
    i1 = gb + 10324 | 0;
    i5 = i3 + 36 | 0;
    do {
     HEAP8[i3 >> 0] = HEAP8[i1 >> 0] | 0;
     i3 = i3 + 1 | 0;
     i1 = i1 + 1 | 0;
    } while ((i3 | 0) < (i5 | 0));
    HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 36;
   }
   i3 = HEAP8[gb + 8840 + 75 >> 0] | 0;
   if (i3 << 24 >> 24 != 10) {
    i4 = HEAP32[gb + 8840 + 20 >> 2] | 0;
    i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
    if (i4 >>> 0 < i1 >>> 0) {
     HEAP32[gb + 8840 + 20 >> 2] = i4 + 1;
     HEAP8[i4 >> 0] = 10;
     i4 = 0;
     break;
    }
   } else i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   HEAP8[i13 >> 0] = 10;
   do if (!i1) {
    i3 = HEAP16[gb + 8840 + 74 >> 1] | 0;
    i1 = (i3 & 65535) << 24 >> 24;
    HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8840 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8840 + 8 >> 2] = 0;
     HEAP32[gb + 8840 + 4 >> 2] = 0;
     i4 = HEAP32[gb + 8840 + 44 >> 2] | 0;
     HEAP32[gb + 8840 + 28 >> 2] = i4;
     HEAP32[gb + 8840 + 20 >> 2] = i4;
     i1 = i4 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8840 + 16 >> 2] = i1;
     i3 = (i3 & 65535) >>> 8 & 255;
     i15 = 47;
     break;
    } else {
     HEAP32[gb + 8840 >> 2] = i1 | 32;
     break;
    }
   } else {
    i4 = HEAP32[gb + 8840 + 20 >> 2] | 0;
    i15 = 47;
   } while (0);
   do if ((i15 | 0) == 47) if (i4 >>> 0 >= i1 >>> 0 | i3 << 24 >> 24 == 10) {
    mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i13 | 0, 1) | 0;
    break;
   } else {
    HEAP32[gb + 8840 + 20 >> 2] = i4 + 1;
    HEAP8[i4 >> 0] = 10;
    break;
   } while (0);
   i4 = 0;
   break;
  }
  if (HEAP32[i4 + -4 >> 2] & 3 | 0) {
   i3 = i4;
   i5 = i3 + 60 | 0;
   do {
    HEAP8[i3 >> 0] = 0;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) < (i5 | 0));
  }
  do if (!(HEAP32[i10 >> 2] | 0)) {
   i7 = i10 + 8 | 0;
   i1 = _hashtable_get(i7, gb + 9965 | 0) | 0;
   if (!i1) i1 = 0; else {
    if ((HEAP32[i1 >> 2] | 0) == 2) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
    i3 = HEAP8[i1 >> 0] | 0;
    if (i3 << 24 >> 24 == 103) {
     i5 = gb + 9976 | 0;
     do {
      i1 = i1 + 1 | 0;
      i5 = i5 + 1 | 0;
      i3 = HEAP8[i1 >> 0] | 0;
      i6 = HEAP8[i5 >> 0] | 0;
     } while (!(i3 << 24 >> 24 == 0 ? 1 : i3 << 24 >> 24 != i6 << 24 >> 24));
     i1 = i6;
    } else i1 = 103;
    i1 = i3 << 24 >> 24 == i1 << 24 >> 24 ? 2 : 1;
    HEAP32[i4 + 52 >> 2] = i1;
   }
   if (!(HEAP32[i10 >> 2] | 0)) {
    i5 = _hashtable_get(i7, gb + 9994 | 0) | 0;
    do if (i5 | 0) {
     if ((i1 | 0) == 2) {
      i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
      do if (!i1) {
       i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
       HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
       i1 = HEAP32[gb + 8840 >> 2] | 0;
       if (!(i1 & 8)) {
        HEAP32[gb + 8840 + 8 >> 2] = 0;
        HEAP32[gb + 8840 + 4 >> 2] = 0;
        i3 = HEAP32[gb + 8840 + 44 >> 2] | 0;
        HEAP32[gb + 8840 + 28 >> 2] = i3;
        HEAP32[gb + 8840 + 20 >> 2] = i3;
        i1 = i3 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
        HEAP32[gb + 8840 + 16 >> 2] = i1;
        break;
       } else {
        HEAP32[gb + 8840 >> 2] = i1 | 32;
        i4 = 0;
        break L36;
       }
      } else i3 = HEAP32[gb + 8840 + 20 >> 2] | 0; while (0);
      if ((i1 - i3 | 0) >>> 0 < 46) {
       if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 9999 | 0, 46) | 0) >>> 0 < 46) {
        i4 = 0;
        break L36;
       }
      } else {
       i1 = gb + 9999 | 0;
       i5 = i3 + 46 | 0;
       do {
        HEAP8[i3 >> 0] = HEAP8[i1 >> 0] | 0;
        i3 = i3 + 1 | 0;
        i1 = i1 + 1 | 0;
       } while ((i3 | 0) < (i5 | 0));
       HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 46;
      }
      i4 = HEAP8[gb + 8840 + 75 >> 0] | 0;
      if (i4 << 24 >> 24 != 10) {
       i1 = HEAP32[gb + 8840 + 20 >> 2] | 0;
       i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
       if (i1 >>> 0 < i3 >>> 0) {
        HEAP32[gb + 8840 + 20 >> 2] = i1 + 1;
        HEAP8[i1 >> 0] = 10;
        i4 = 0;
        break L36;
       }
      } else i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
      HEAP8[i13 >> 0] = 10;
      do if (!i3) {
       i4 = HEAP16[gb + 8840 + 74 >> 1] | 0;
       i1 = (i4 & 65535) << 24 >> 24;
       HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
       i1 = HEAP32[gb + 8840 >> 2] | 0;
       if (!(i1 & 8)) {
        HEAP32[gb + 8840 + 8 >> 2] = 0;
        HEAP32[gb + 8840 + 4 >> 2] = 0;
        i5 = HEAP32[gb + 8840 + 44 >> 2] | 0;
        HEAP32[gb + 8840 + 28 >> 2] = i5;
        HEAP32[gb + 8840 + 20 >> 2] = i5;
        i3 = i5 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
        HEAP32[gb + 8840 + 16 >> 2] = i3;
        i1 = (i4 & 65535) >>> 8 & 255;
        i15 = 78;
        break;
       } else {
        HEAP32[gb + 8840 >> 2] = i1 | 32;
        break;
       }
      } else {
       i5 = HEAP32[gb + 8840 + 20 >> 2] | 0;
       i1 = i4;
       i15 = 78;
      } while (0);
      do if ((i15 | 0) == 78) if (i5 >>> 0 >= i3 >>> 0 | i1 << 24 >> 24 == 10) {
       mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i13 | 0, 1) | 0;
       break;
      } else {
       HEAP32[gb + 8840 + 20 >> 2] = i5 + 1;
       HEAP8[i5 >> 0] = 10;
       break;
      } while (0);
      i4 = 0;
      break L36;
     }
     HEAP32[i4 + 52 >> 2] = 0;
     if (!(HEAP32[i5 >> 2] | 0)) {
      i3 = i5 + 8 | 0;
      i1 = _hashtable_get(i3, gb + 10046 | 0) | 0;
      if (i1 | 0) {
       if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
       HEAP32[i4 >> 2] = i1;
      }
      if (!(HEAP32[i5 >> 2] | 0)) {
       i1 = _hashtable_get(i3, gb + 10062 | 0) | 0;
       if (i1 | 0) {
        if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
        HEAP32[i4 + 4 >> 2] = i1;
       }
       if (!(HEAP32[i5 >> 2] | 0)) {
        i1 = _hashtable_get(i3, gb + 10083 | 0) | 0;
        if (i1 | 0) {
         if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
         HEAP32[i4 + 8 >> 2] = i1;
        }
        if (HEAP32[i5 >> 2] | 0) break;
        i1 = _hashtable_get(i3, gb + 10096 | 0) | 0;
        if (i1 | 0) {
         if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
         HEAP32[i4 + 12 >> 2] = i1;
        }
        if (HEAP32[i5 >> 2] | 0) break;
        i1 = _hashtable_get(i3, gb + 10106 | 0) | 0;
        if (!i1) break;
        if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
        HEAP32[i4 + 16 >> 2] = i1;
       }
      }
     }
    } while (0);
    if (!(HEAP32[i10 >> 2] | 0)) {
     i1 = _hashtable_get(i7, gb + 10117 | 0) | 0;
     if ((i1 | 0 ? (HEAP32[i1 >> 2] | 0) == 0 : 0) ? (i8 = _hashtable_get(i1 + 8 | 0, gb + 10128 | 0) | 0, i8 | 0) : 0) {
      switch (HEAP32[i8 >> 2] | 0) {
      case 3:
       {
        i13 = i8 + 8 | 0;
        d2 = +((HEAP32[i13 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i13 + 4 >> 2] | 0);
        break;
       }
      case 4:
       {
        d2 = +HEAPF64[i8 + 8 >> 3];
        break;
       }
      default:
       d2 = 0.0;
      }
      HEAPF32[i4 + 32 >> 2] = d2 / 44100.0 * 3.141592653589793 * 2.0;
     }
     if ((HEAP32[i10 >> 2] | 0) == 0 ? (i9 = _hashtable_get(i7, gb + 10150 | 0) | 0, (i9 | 0) != 0) : 0) {
      if (!(HEAP32[i9 >> 2] | 0)) {
       i3 = i9 + 8 | 0;
       i1 = _hashtable_get(i3, gb + 10164 | 0) | 0;
       if (i1 | 0) {
        if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
        HEAP32[i4 + 20 >> 2] = i1;
       }
       if (!(HEAP32[i9 >> 2] | 0)) {
        i1 = _hashtable_get(i3, gb + 10183 | 0) | 0;
        if (i1 | 0) {
         if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
         HEAP32[i4 + 24 >> 2] = i1;
        }
        if (HEAP32[i9 >> 2] | 0) break;
        i1 = _hashtable_get(i3, gb + 10196 | 0) | 0;
        if (!i1) break;
        switch (HEAP32[i1 >> 2] | 0) {
        case 3:
         {
          i13 = i1 + 8 | 0;
          d2 = +((HEAP32[i13 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i13 + 4 >> 2] | 0);
          break;
         }
        case 4:
         {
          d2 = +HEAPF64[i1 + 8 >> 3];
          break;
         }
        default:
         d2 = 0.0;
        }
        HEAPF32[i4 + 28 >> 2] = d2;
       }
      }
     } else i15 = 133;
    } else i15 = 133;
   } else i15 = 133;
  } else i15 = 133; while (0);
  if ((i15 | 0) == 133) HEAP32[i4 + 20 >> 2] = 1;
  if (((HEAP32[i10 >> 2] | 0) == 0 ? (i11 = _hashtable_get(i10 + 8 | 0, gb + 10245 | 0) | 0, (i11 | 0) != 0) : 0) ? (HEAP32[i11 >> 2] | 0) == 0 : 0) {
   i3 = i11 + 8 | 0;
   i1 = _hashtable_get(i3, gb + 10255 | 0) | 0;
   if (i1 | 0) {
    if ((HEAP32[i1 >> 2] | 0) == 3) i1 = HEAP32[i1 + 8 >> 2] | 0; else i1 = 0;
    HEAP32[i4 + 36 >> 2] = i1;
   }
   if (!(HEAP32[i11 >> 2] | 0)) {
    i1 = _hashtable_get(i3, gb + 10261 | 0) | 0;
    if (i1 | 0) {
     switch (HEAP32[i1 >> 2] | 0) {
     case 3:
      {
       i13 = i1 + 8 | 0;
       d2 = +((HEAP32[i13 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i13 + 4 >> 2] | 0);
       break;
      }
     case 4:
      {
       d2 = +HEAPF64[i1 + 8 >> 3];
       break;
      }
     default:
      d2 = 0.0;
     }
     HEAPF32[i4 + 40 >> 2] = d2;
    }
    if (!(HEAP32[i11 >> 2] | 0)) {
     i1 = _hashtable_get(i3, gb + 10271 | 0) | 0;
     if (i1 | 0) {
      switch (HEAP32[i1 >> 2] | 0) {
      case 3:
       {
        i13 = i1 + 8 | 0;
        d2 = +((HEAP32[i13 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i13 + 4 >> 2] | 0);
        break;
       }
      case 4:
       {
        d2 = +HEAPF64[i1 + 8 >> 3];
        break;
       }
      default:
       d2 = 0.0;
      }
      HEAPF32[i4 + 44 >> 2] = d2;
     }
     if ((HEAP32[i11 >> 2] | 0) == 0 ? (i12 = _hashtable_get(i3, gb + 10283 | 0) | 0, (i12 | 0) != 0) : 0) {
      switch (HEAP32[i12 >> 2] | 0) {
      case 3:
       {
        i13 = i12 + 8 | 0;
        d2 = +((HEAP32[i13 >> 2] | 0) >>> 0) + 4294967296.0 * +(HEAP32[i13 + 4 >> 2] | 0);
        break;
       }
      case 4:
       {
        d2 = +HEAPF64[i12 + 8 >> 3];
        break;
       }
      default:
       d2 = 0.0;
      }
      HEAP32[i4 + 48 >> 2] = ~~d2 >>> 0;
     }
    }
   }
  }
 } else i15 = 26; while (0);
 if ((i15 | 0) == 26) {
  HEAP32[i4 >> 2] = i3;
  _printf(gb + 9849 | 0, i4);
  i4 = 0;
 }
 i1 = i14 + 4 | 0;
 i3 = HEAP32[i1 >> 2] | 0;
 if ((i3 | 0) == -1) {
  i15 = i4;
  STACKTOP = i16;
  return i15 | 0;
 }
 i15 = i3 + -1 | 0;
 HEAP32[i1 >> 2] = i15;
 if (i15 | 0) {
  i15 = i4;
  STACKTOP = i16;
  return i15 | 0;
 }
 _json_delete(i14);
 i15 = i4;
 STACKTOP = i16;
 return i15 | 0;
}

function _liquid_firdes_fnyquist(i27, i33, i34, i32, d1, i35) {
 i27 = i27 | 0;
 i33 = i33 | 0;
 i34 = i34 | 0;
 i32 = i32 | 0;
 d1 = +d1;
 i35 = i35 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, d26 = 0.0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i36 = 0;
 i36 = STACKTOP;
 if (!i34) {
  i13 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i13) {
   i13 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i13 + 255 | i13;
   i13 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i13 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i12 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i12;
    HEAP32[gb + 8728 + 20 >> 2] = i12;
    i14 = i12 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i14;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i13 | 32;
   _exit(1);
  } else {
   i14 = i13;
   i12 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i14 - i12 | 0) >>> 0 < 58) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21167 | 0, 58) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21167 | 0, 58) | 0) >>> 0 < 58) _exit(1); else {
   i15 = 0;
   i16 = gb + 21167 + 58 | 0;
   i17 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i15 = 58;
   i16 = gb + 21167 | 0;
   i17 = i12;
  } while (0);
  _memcpy(i17 | 0, i16 | 0, i15 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i15;
  _exit(1);
 }
 if (!i32) {
  i12 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i12) {
   i12 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i12 + 255 | i12;
   i12 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i12 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i5 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i5;
    HEAP32[gb + 8728 + 20 >> 2] = i5;
    i18 = i5 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i18;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i12 | 32;
   _exit(1);
  } else {
   i18 = i12;
   i5 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i18 - i5 | 0) >>> 0 < 58) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21226 | 0, 58) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21226 | 0, 58) | 0) >>> 0 < 58) _exit(1); else {
   i19 = 0;
   i20 = gb + 21226 + 58 | 0;
   i21 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i19 = 58;
   i20 = gb + 21226 | 0;
   i21 = i5;
  } while (0);
  _memcpy(i21 | 0, i20 | 0, i19 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i19;
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  i5 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i5) {
   i5 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i5 + 255 | i5;
   i5 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i5 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i4;
    HEAP32[gb + 8728 + 20 >> 2] = i4;
    i22 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i22;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i5 | 32;
   _exit(1);
  } else {
   i22 = i5;
   i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i22 - i4 | 0) >>> 0 < 55) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21285 | 0, 55) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21285 | 0, 55) | 0) >>> 0 < 55) _exit(1); else {
   i23 = 0;
   i24 = gb + 21285 + 55 | 0;
   i25 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i23 = 55;
   i24 = gb + 21285 | 0;
   i25 = i4;
  } while (0);
  _memcpy(i25 | 0, i24 | 0, i23 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i23;
  _exit(1);
 }
 i15 = Math_imul(i34 << 1, i32) | 0 | 1;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i15 << 2) | 0) + 15 & -16) | 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i15 << 3) | 0) + 15 & -16) | 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i15 << 3) | 0) + 15 & -16) | 0;
 switch (i27 | 0) {
 case 4:
  {
   d6 = 1.0 - d1;
   d11 = +(i34 >>> 0);
   d9 = d6 * .5 / d11;
   d10 = .5 / d11;
   d7 = d1 + 1.0;
   d11 = d7 * .5 / d11;
   d1 = .6931471824645996 / (d10 * d1);
   d2 = +(i15 >>> 0);
   d6 = d10 * d6;
   d7 = d10 * d7;
   i3 = 0;
   do {
    d8 = +(i3 >>> 0) / d2;
    d8 = +Math_abs(+(d8 > .5 ? d8 + -1.0 : d8));
    do if (!(d8 < d9)) {
     if (!(d8 > d9 & d8 < d11)) {
      HEAPF32[i13 + (i3 << 2) >> 2] = 0.0;
      break;
     }
     if (d8 < d10) {
      HEAPF32[i13 + (i3 << 2) >> 2] = +Math_exp(+(d1 * (d6 - d8)));
      break;
     } else {
      HEAPF32[i13 + (i3 << 2) >> 2] = 1.0 - +Math_exp(+(d1 * (d8 - d7)));
      break;
     }
    } else HEAPF32[i13 + (i3 << 2) >> 2] = 1.0; while (0);
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i15 | 0));
   break;
  }
 case 5:
  {
   d7 = 1.0 - d1;
   d11 = +(i34 >>> 0);
   d9 = d7 * .5 / d11;
   d10 = .5 / d11;
   d8 = d1 + 1.0;
   d11 = d8 * .5 / d11;
   d2 = 1.316957950592041 / (d10 * d1);
   d6 = +(i15 >>> 0);
   d7 = d10 * d7;
   d8 = d10 * d8;
   i4 = 0;
   do {
    d1 = +(i4 >>> 0) / d6;
    d1 = +Math_abs(+(d1 > .5 ? d1 + -1.0 : d1));
    do if (!(d1 < d9)) {
     if (!(d1 > d9 & d1 < d11)) {
      HEAPF32[i13 + (i4 << 2) >> 2] = 0.0;
      break;
     }
     if (d1 < d10) {
      d1 = +Math_abs(+(d2 * (d1 - d7)));
      i3 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
      do if (i3 >>> 0 < 1060205079) if (i3 >>> 0 < 964689920) d1 = 1.0; else {
       d1 = +_expm1f(d1);
       d1 = d1 * d1 / ((d1 + 1.0) * 2.0) + 1.0;
      } else if (i3 >>> 0 < 1118925335) {
       d1 = +Math_exp(+d1);
       d1 = (d1 + 1.0 / d1) * .5;
       break;
      } else {
       d1 = +Math_exp(+(d1 + -162.88958740234375)) * 1661534994731144841129758.0e11 * 1661534994731144841129758.0e11;
       break;
      } while (0);
      HEAPF32[i13 + (i4 << 2) >> 2] = 1.0 / d1;
      break;
     } else {
      d1 = +Math_abs(+(d2 * (d8 - d1)));
      i3 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
      do if (i3 >>> 0 < 1060205079) if (i3 >>> 0 < 964689920) d1 = 1.0; else {
       d1 = +_expm1f(d1);
       d1 = d1 * d1 / ((d1 + 1.0) * 2.0) + 1.0;
      } else if (i3 >>> 0 < 1118925335) {
       d1 = +Math_exp(+d1);
       d1 = (d1 + 1.0 / d1) * .5;
       break;
      } else {
       d1 = +Math_exp(+(d1 + -162.88958740234375)) * 1661534994731144841129758.0e11 * 1661534994731144841129758.0e11;
       break;
      } while (0);
      HEAPF32[i13 + (i4 << 2) >> 2] = 1.0 - 1.0 / d1;
      break;
     }
    } else HEAPF32[i13 + (i4 << 2) >> 2] = 1.0; while (0);
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != (i15 | 0));
   break;
  }
 case 6:
  {
   d7 = 1.0 - d1;
   d10 = +(i34 >>> 0);
   d8 = d7 * .5 / d10;
   d9 = .5 / d10;
   d6 = d1 + 1.0;
   d10 = d6 * .5 / d10;
   d11 = 1.0 / (d9 * (d1 * 2.0));
   d26 = +(i15 >>> 0);
   d2 = d11 / (1.316957950592041 / (d9 * d1));
   d6 = d9 * d6;
   d7 = d9 * d7;
   i12 = 0;
   do {
    d1 = +(i12 >>> 0) / d26;
    d1 = +Math_abs(+(d1 > .5 ? d1 + -1.0 : d1));
    do if (!(d1 < d8)) {
     if (!(d1 > d8 & d1 < d10)) {
      HEAPF32[i13 + (i12 << 2) >> 2] = 0.0;
      break;
     }
     if (d1 < d9) {
      d1 = d11 * (d6 - d1);
      L141 : do if (d1 <= 0.0 | d1 > 1.0) {
       i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i3) {
        i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
        i3 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i3 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i3 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i3;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i3 | 32;
         d1 = 0.0;
         break L141;
        }
       } else i4 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
       if ((i3 - i4 | 0) >>> 0 < 45) {
        mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21341 | 0, 45) | 0;
        d1 = 0.0;
        break;
       }
       if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
        if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21341 | 0, 45) | 0) >>> 0 < 45) {
         d1 = 0.0;
         break;
        }
        i3 = 0;
        i5 = gb + 21341 + 45 | 0;
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       } else {
        i3 = 45;
        i5 = gb + 21341 | 0;
       }
       _memcpy(i4 | 0, i5 | 0, i3 | 0) | 0;
       HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i3;
       d1 = 0.0;
      } else {
       d1 = 1.0 / d1;
       d1 = +Math_log(+(d1 + +Math_sqrt(+(d1 + -1.0)) * +Math_sqrt(+(d1 + 1.0))));
      } while (0);
      HEAPF32[i13 + (i12 << 2) >> 2] = 1.0 - d2 * d1;
      break;
     } else {
      d1 = d11 * (d1 - d7);
      L160 : do if (d1 <= 0.0 | d1 > 1.0) {
       i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
       do if (!i3) {
        i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
        HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
        i3 = HEAP32[gb + 8728 >> 2] | 0;
        if (!(i3 & 8)) {
         HEAP32[gb + 8728 + 8 >> 2] = 0;
         HEAP32[gb + 8728 + 4 >> 2] = 0;
         i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
         HEAP32[gb + 8728 + 28 >> 2] = i4;
         HEAP32[gb + 8728 + 20 >> 2] = i4;
         i3 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
         HEAP32[gb + 8728 + 16 >> 2] = i3;
         break;
        } else {
         HEAP32[gb + 8728 >> 2] = i3 | 32;
         d1 = 0.0;
         break L160;
        }
       } else i4 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
       if ((i3 - i4 | 0) >>> 0 < 45) {
        mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21341 | 0, 45) | 0;
        d1 = 0.0;
        break;
       }
       if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
        if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21341 | 0, 45) | 0) >>> 0 < 45) {
         d1 = 0.0;
         break;
        }
        i3 = 0;
        i5 = gb + 21341 + 45 | 0;
        i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
       } else {
        i3 = 45;
        i5 = gb + 21341 | 0;
       }
       _memcpy(i4 | 0, i5 | 0, i3 | 0) | 0;
       HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i3;
       d1 = 0.0;
      } else {
       d1 = 1.0 / d1;
       d1 = +Math_log(+(d1 + +Math_sqrt(+(d1 + -1.0)) * +Math_sqrt(+(d1 + 1.0))));
      } while (0);
      HEAPF32[i13 + (i12 << 2) >> 2] = d2 * d1;
      break;
     }
    } else HEAPF32[i13 + (i12 << 2) >> 2] = 1.0; while (0);
    i12 = i12 + 1 | 0;
   } while ((i12 | 0) != (i15 | 0));
   break;
  }
 default:
  {
   i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i4) {
    i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
    i4 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i4 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i3;
     HEAP32[gb + 8728 + 20 >> 2] = i3;
     i28 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i28;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i4 | 32;
    _exit(1);
   } else {
    i28 = i4;
    i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i28 - i3 | 0) >>> 0 < 65) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21387 | 0, 65) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21387 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
    i29 = 0;
    i30 = gb + 21387 + 65 | 0;
    i31 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i29 = 65;
    i30 = gb + 21387 | 0;
    i31 = i3;
   } while (0);
   _memcpy(i31 | 0, i30 | 0, i29 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i29;
   _exit(1);
  }
 }
 i4 = Math_imul(i32, i34) | 0;
 i5 = i4 << 1 | 1;
 if (!i33) {
  i3 = 0;
  do {
   HEAP32[i14 + (i3 << 3) >> 2] = HEAP32[i13 + (i3 << 2) >> 2];
   HEAPF32[i14 + (i3 << 3) + 4 >> 2] = 0.0;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i5 | 0));
 } else {
  i3 = 0;
  do {
   HEAPF32[i14 + (i3 << 3) >> 2] = +Math_sqrt(+(+HEAPF32[i13 + (i3 << 2) >> 2]));
   HEAPF32[i14 + (i3 << 3) + 4 >> 2] = 0.0;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i5 | 0));
 }
 i3 = _fft_create_plan(i15, i14, i16, -1, 0) | 0;
 mftCall_vi(HEAP32[i3 + 28 >> 2] | 0, i3 | 0);
 _fft_destroy_plan(i3);
 i4 = i4 + 1 | 0;
 d1 = +(i34 >>> 0);
 d2 = +(i15 >>> 0);
 i3 = 0;
 do {
  HEAPF32[i35 + (i3 << 2) >> 2] = d1 * +HEAPF32[i16 + ((((i4 + i3 | 0) >>> 0) % (i15 >>> 0) | 0) << 3) >> 2] / d2;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i5 | 0));
 STACKTOP = i36;
 return;
}

function _gmskframesync_create(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, d37 = 0.0, d38 = 0.0, d39 = 0.0, d40 = 0.0, d41 = 0.0;
 i36 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i34 = i36;
 i30 = i36 + 32 | 0;
 i6 = i36 + 8 | 0;
 i35 = _malloc(256) | 0;
 HEAP32[i35 + 16 >> 2] = fb + 1;
 HEAP32[i35 + 20 >> 2] = i1;
 i31 = i35 + 4 | 0;
 HEAP32[i31 >> 2] = 2;
 i32 = i35 + 8 | 0;
 HEAP32[i32 >> 2] = 3;
 i33 = i35 + 12 | 0;
 HEAPF32[i33 >> 2] = .5;
 _liquid_iirdes(i30, i6);
 i5 = _malloc(36) | 0;
 HEAP32[i5 + 24 >> 2] = 1;
 HEAP32[i5 + 32 >> 2] = 2;
 i1 = _malloc(8) | 0;
 HEAP32[i5 + 28 >> 2] = i1;
 HEAP32[i5 + 12 >> 2] = 4;
 i2 = _malloc(24) | 0;
 HEAP32[i5 >> 2] = i2;
 i3 = _malloc(24) | 0;
 HEAP32[i5 + 4 >> 2] = i3;
 HEAP32[i2 >> 2] = HEAP32[i30 >> 2];
 HEAP32[i2 + 4 >> 2] = HEAP32[i30 + 4 >> 2];
 HEAP32[i2 + 8 >> 2] = HEAP32[i30 + 8 >> 2];
 HEAP32[i2 + 12 >> 2] = HEAP32[i30 + 12 >> 2];
 HEAP32[i2 + 16 >> 2] = HEAP32[i30 + 16 >> 2];
 HEAP32[i2 + 20 >> 2] = HEAP32[i30 + 20 >> 2];
 HEAP32[i3 >> 2] = HEAP32[i6 >> 2];
 HEAP32[i3 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
 HEAP32[i3 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
 HEAP32[i3 + 12 >> 2] = HEAP32[i6 + 12 >> 2];
 HEAP32[i3 + 16 >> 2] = HEAP32[i6 + 16 >> 2];
 HEAP32[i3 + 20 >> 2] = HEAP32[i6 + 20 >> 2];
 i6 = 0;
 do {
  i9 = i6 * 3 | 0;
  i4 = i2 + (i9 << 2) | 0;
  i9 = i3 + (i9 << 2) | 0;
  d11 = +HEAPF32[i9 >> 2];
  d38 = +HEAPF32[i9 + 4 >> 2];
  d37 = +HEAPF32[i9 + 8 >> 2];
  d41 = +HEAPF32[i4 >> 2];
  d40 = +HEAPF32[i4 + 4 >> 2];
  d39 = +HEAPF32[i4 + 8 >> 2];
  i4 = _malloc(96) | 0;
  HEAPF32[i4 >> 2] = d41 / d11;
  HEAPF32[i4 + 4 >> 2] = d40 / d11;
  HEAPF32[i4 + 8 >> 2] = d39 / d11;
  HEAPF32[i4 + 12 >> 2] = d11 / d11;
  HEAPF32[i4 + 16 >> 2] = d38 / d11;
  HEAPF32[i4 + 20 >> 2] = d37 / d11;
  i9 = i4 + 24 | 0;
  i10 = i9 + 72 | 0;
  do {
   HEAP32[i9 >> 2] = 0;
   i9 = i9 + 4 | 0;
  } while ((i9 | 0) < (i10 | 0));
  HEAP32[i1 + (i6 << 2) >> 2] = i4;
  i6 = i6 + 1 | 0;
 } while ((i6 | 0) != 2);
 HEAP32[i35 >> 2] = i5;
 i30 = i35 + 132 | 0;
 HEAP32[i30 >> 2] = 63;
 i9 = i35 + 136 | 0;
 HEAP32[i9 >> 2] = _malloc(252) | 0;
 HEAP32[i35 + 140 >> 2] = _malloc(252) | 0;
 i29 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[i31 >> 2] | 0) * 63 << 3) | 0) + 15 & -16) | 0;
 i10 = _malloc(24) | 0;
 i25 = i10 + 4 | 0;
 i26 = i10 + 12 | 0;
 SIMD_Int32x4_store(HEAPU8, i10, SIMD_Int32x4(6, 54, 32, 63));
 i27 = i10 + 16 | 0;
 HEAP32[i27 >> 2] = 32;
 i28 = i10 + 20 | 0;
 HEAP32[i28 >> 2] = 0;
 i2 = HEAP32[i31 >> 2] | 0;
 i3 = HEAP32[i32 >> 2] | 0;
 d11 = +HEAPF32[i33 >> 2];
 if (i2 >>> 0 < 2) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i8 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i8;
    HEAP32[gb + 8728 + 20 >> 2] = i8;
    i7 = i8 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i7;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i7 = i1;
   i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i7 - i8 | 0) >>> 0 < 59) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28156 | 0, 59) | 0;
   _exit(1);
  }
  i1 = i8;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28156 | 0, 59) | 0) >>> 0 < 59) _exit(1); else {
   i12 = 0;
   i13 = gb + 28156 + 59 | 0;
   i14 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i12 = 59;
   i13 = gb + 28156 | 0;
   i14 = i1;
  } while (0);
  _memcpy(i14 | 0, i13 | 0, i12 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i12;
  _exit(1);
 }
 if (!i3) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i16 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i16;
    HEAP32[gb + 8728 + 20 >> 2] = i16;
    i15 = i16 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i15;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i15 = i1;
   i16 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i15 - i16 | 0) >>> 0 < 57) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28216 | 0, 57) | 0;
   _exit(1);
  }
  i1 = i16;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28216 | 0, 57) | 0) >>> 0 < 57) _exit(1); else {
   i17 = 0;
   i18 = gb + 28216 + 57 | 0;
   i19 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i17 = 57;
   i18 = gb + 28216 | 0;
   i19 = i1;
  } while (0);
  _memcpy(i19 | 0, i18 | 0, i17 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i17;
  _exit(1);
 }
 if (d11 <= 0.0 | d11 >= 1.0) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i21 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i21;
    HEAP32[gb + 8728 + 20 >> 2] = i21;
    i20 = i21 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i20;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i20 = i1;
   i21 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i20 - i21 | 0) >>> 0 < 65) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28274 | 0, 65) | 0;
   _exit(1);
  }
  i1 = i21;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28274 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
   i22 = 0;
   i23 = gb + 28274 + 65 | 0;
   i24 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i22 = 65;
   i23 = gb + 28274 | 0;
   i24 = i1;
  } while (0);
  _memcpy(i24 | 0, i23 | 0, i22 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i22;
  _exit(1);
 }
 i6 = _malloc(32) | 0;
 HEAP32[i6 >> 2] = i2;
 HEAP32[i6 + 4 >> 2] = i3;
 HEAPF32[i6 + 8 >> 2] = d11;
 HEAPF32[i6 + 28 >> 2] = 1.0 / +(i2 >>> 0);
 i1 = Math_imul(i2 << 1, i3) | 0 | 1;
 HEAP32[i6 + 12 >> 2] = i1;
 i1 = _malloc(i1 << 2) | 0;
 i7 = i6 + 16 | 0;
 HEAP32[i7 >> 2] = i1;
 _liquid_firdes_gmsktx(i2, i3, d11, i1);
 i1 = _firinterp_rrrf_create_prototype(i2, i3, d11) | 0;
 i5 = i6 + 20 | 0;
 HEAP32[i5 >> 2] = i1;
 HEAPF32[i6 + 24 >> 2] = 0.0;
 i1 = HEAP32[(HEAP32[i1 + 16 >> 2] | 0) + 16 >> 2] | 0;
 HEAP32[i1 + 24 >> 2] = 0;
 _memset(HEAP32[i1 >> 2] | 0, 0, HEAP32[i1 + 20 >> 2] << 2 | 0) | 0;
 i1 = HEAP32[i30 >> 2] | 0;
 i2 = HEAP32[i32 >> 2] | 0;
 if ((i2 | 0) != (0 - i1 | 0)) {
  i4 = 0;
  do {
   i24 = HEAP32[i27 >> 2] | 0;
   i3 = HEAP32[i25 >> 2] & i24;
   i3 = (HEAPU8[(i3 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i3 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i3 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i3 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
   HEAP32[i28 >> 2] = i3;
   HEAP32[i27 >> 2] = (i3 | i24 << 1) & HEAP32[i26 >> 2];
   if (i4 >>> 0 < i1 >>> 0) HEAPF32[(HEAP32[i9 >> 2] | 0) + (i4 << 2) >> 2] = i3 | 0 ? 1.0 : -1.0;
   if (i4 >>> 0 < i2 >>> 0) _gmskmod_modulate(i6, i3, i29); else _gmskmod_modulate(i6, i3, i29 + ((Math_imul(HEAP32[i31 >> 2] | 0, i4 - i2 | 0) | 0) << 3) | 0);
   i4 = i4 + 1 | 0;
   i1 = HEAP32[i30 >> 2] | 0;
   i2 = HEAP32[i32 >> 2] | 0;
  } while (i4 >>> 0 < (i2 + i1 | 0) >>> 0);
 }
 _firinterp_rrrf_destroy(HEAP32[i5 >> 2] | 0);
 _free(HEAP32[i7 >> 2] | 0);
 _free(i6);
 _free(i10);
 i8 = i35 + 108 | 0;
 HEAP32[i8 >> 2] = _detector_cccf_create(i29, Math_imul(HEAP32[i31 >> 2] | 0, HEAP32[i30 >> 2] | 0) | 0) | 0;
 i7 = i35 + 124 | 0;
 HEAP32[i7 >> 2] = _windowcf_create(Math_imul((HEAP32[i32 >> 2] | 0) + (HEAP32[i30 >> 2] | 0) | 0, HEAP32[i31 >> 2] | 0) | 0) | 0;
 i3 = i35 + 84 | 0;
 HEAP32[i3 >> 2] = 32;
 i5 = i35 + 76 | 0;
 HEAP32[i5 >> 2] = _firpfb_rrrf_create_rnyquist(HEAP32[i31 >> 2] | 0, HEAP32[i32 >> 2] | 0, +HEAPF32[i33 >> 2]) | 0;
 i6 = i35 + 80 | 0;
 HEAP32[i6 >> 2] = _firpfb_rrrf_create_drnyquist(HEAP32[i3 >> 2] | 0, HEAP32[i31 >> 2] | 0, HEAP32[i32 >> 2] | 0, +HEAPF32[i33 >> 2]) | 0;
 i3 = _malloc(1060) | 0;
 HEAP32[i3 >> 2] = 0;
 i1 = i3 + 12 | 0;
 i2 = 0;
 do {
  HEAPF32[i1 + (i2 << 2) >> 2] = +Math_sin(+(+(i2 >>> 0) * 6.283185307179586 * .00390625));
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 256);
 HEAPF32[i3 + 1052 >> 2] = .10000000149011612;
 HEAPF32[i3 + 1056 >> 2] = .3162277638912201;
 i1 = HEAP32[i3 >> 2] | 0;
 switch (i1 | 0) {
 case 0:
  {
   HEAP32[i3 + 1048 >> 2] = fb + 1;
   break;
  }
 case 1:
  {
   HEAP32[i3 + 1048 >> 2] = fb + 2;
   break;
  }
 default:
  {
   HEAP32[i34 >> 2] = i1;
   _fprintf(gb + 8728 | 0, gb + 36150 | 0, i34);
   _exit(1);
  }
 }
 HEAPF32[i3 + 4 >> 2] = 0.0;
 HEAPF32[i3 + 8 >> 2] = 0.0;
 HEAP32[i3 + 1036 >> 2] = 0;
 HEAPF32[i3 + 1040 >> 2] = 0.0;
 HEAPF32[i3 + 1044 >> 2] = 1.0;
 i4 = i35 + 128 | 0;
 HEAP32[i4 >> 2] = i3;
 i1 = i35 + 156 | 0;
 HEAP32[i1 >> 2] = 0;
 HEAP32[i1 + 4 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 12 >> 2] = 0;
 HEAP32[i35 + 144 >> 2] = 8;
 HEAP32[i35 + 164 >> 2] = _malloc(13) | 0;
 i2 = i35 + 168 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _packetizer_destroy(i3);
 i34 = _packetizer_create(13, 6, 6, 1) | 0;
 HEAP32[i2 >> 2] = i34;
 i34 = HEAP32[i34 + 4 >> 2] | 0;
 i10 = i35 + 148 | 0;
 HEAP32[i10 >> 2] = i34;
 i9 = i35 + 160 | 0;
 HEAP32[i9 >> 2] = _realloc(HEAP32[i9 >> 2] | 0, i34) | 0;
 i10 = HEAP32[i10 >> 2] << 3;
 HEAP32[i35 + 152 >> 2] = i10;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i10) | 0;
 i10 = i35 + 196 | 0;
 HEAP32[i10 >> 2] = 1;
 HEAP32[i35 + 180 >> 2] = 6;
 HEAP32[i35 + 184 >> 2] = 1;
 HEAP32[i35 + 188 >> 2] = 1;
 i9 = _packetizer_create(1, 6, 1, 1) | 0;
 HEAP32[i35 + 208 >> 2] = i9;
 i9 = HEAP32[i9 + 4 >> 2] | 0;
 HEAP32[i35 + 192 >> 2] = i9;
 HEAP32[i35 + 204 >> 2] = _malloc(HEAP32[i10 >> 2] | 0) | 0;
 HEAP32[i35 + 200 >> 2] = _malloc(i9) | 0;
 i9 = i35 + 216 | 0;
 i10 = i9 + 40 | 0;
 do {
  HEAP32[i9 >> 2] = 0;
  i9 = i9 + 4 | 0;
 } while ((i9 | 0) < (i10 | 0));
 i33 = HEAP32[i7 >> 2] | 0;
 HEAP32[i33 + 24 >> 2] = 0;
 _memset(HEAP32[i33 >> 2] | 0, 0, HEAP32[i33 + 20 >> 2] << 3 | 0) | 0;
 i33 = HEAP32[i8 >> 2] | 0;
 i34 = HEAP32[i33 + 16 >> 2] | 0;
 HEAP32[i34 + 24 >> 2] = 0;
 _memset(HEAP32[i34 >> 2] | 0, 0, HEAP32[i34 + 20 >> 2] << 3 | 0) | 0;
 i34 = HEAP32[i33 + 60 >> 2] | 0;
 HEAP32[i34 + 8 >> 2] = 0;
 _memset(HEAP32[i34 >> 2] | 0, 0, HEAP32[i34 + 4 >> 2] << 2 | 0) | 0;
 HEAP32[i33 + 76 >> 2] = HEAP32[i33 + 4 >> 2];
 HEAP32[i33 + 72 >> 2] = 0;
 HEAP32[i33 + 52 >> 2] = 0;
 HEAP32[i33 + 56 >> 2] = 0;
 HEAPF32[i33 + 64 >> 2] = 0.0;
 i34 = i33 + 24 | 0;
 _memset(HEAP32[i33 + 44 >> 2] | 0, 0, HEAP32[i34 >> 2] << 2 | 0) | 0;
 _memset(HEAP32[i33 + 48 >> 2] | 0, 0, HEAP32[i34 >> 2] << 2 | 0) | 0;
 i34 = HEAP32[i4 >> 2] | 0;
 HEAPF32[i34 + 4 >> 2] = 0.0;
 HEAPF32[i34 + 8 >> 2] = 0.0;
 HEAP32[i34 + 1036 >> 2] = 0;
 HEAPF32[i34 + 1040 >> 2] = 0.0;
 HEAPF32[i34 + 1044 >> 2] = 1.0;
 HEAPF32[i35 + 64 >> 2] = 0.0;
 HEAPF32[i35 + 68 >> 2] = 0.0;
 HEAPF32[i35 + 72 >> 2] = 0.0;
 i34 = HEAP32[(HEAP32[i5 >> 2] | 0) + 16 >> 2] | 0;
 HEAP32[i34 + 24 >> 2] = 0;
 _memset(HEAP32[i34 >> 2] | 0, 0, HEAP32[i34 + 20 >> 2] << 2 | 0) | 0;
 i34 = HEAP32[(HEAP32[i6 >> 2] | 0) + 16 >> 2] | 0;
 HEAP32[i34 + 24 >> 2] = 0;
 _memset(HEAP32[i34 >> 2] | 0, 0, HEAP32[i34 + 20 >> 2] << 2 | 0) | 0;
 HEAPF32[i35 + 88 >> 2] = 0.0;
 STACKTOP = i36;
 return i35 | 0;
}

function _modem_demodulate_sqam32(i15, i2, i11) {
 i15 = i15 | 0;
 i2 = i2 | 0;
 i11 = i11 | 0;
 var d1 = 0.0, d3 = 0.0, i4 = 0, d5 = 0.0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i12 = 0, d13 = 0.0, d14 = 0.0, i16 = 0, i17 = 0;
 d14 = +HEAPF32[i2 >> 2];
 d13 = +HEAPF32[i2 + 4 >> 2];
 i10 = (d14 < 0.0 & 1) << 1 | d13 < 0.0;
 switch (i10 | 0) {
 case 0:
  {
   d8 = d14;
   d9 = d13;
   break;
  }
 case 1:
  {
   d8 = d14;
   d9 = -d13;
   break;
  }
 case 2:
  {
   d8 = -d14;
   d9 = d13;
   break;
  }
 case 3:
  {
   d8 = -d14;
   d9 = -d13;
   break;
  }
 default:
  {}
 }
 if (!(d8 >= 0.0)) ___assert_fail(gb + 29167 | 0, gb + 29191 | 0, 98, gb + 29220 | 0);
 if (!(d9 >= 0.0)) ___assert_fail(gb + 29244 | 0, gb + 29191 | 0, 99, gb + 29220 | 0);
 i12 = HEAP32[i15 + 100 >> 2] | 0;
 d1 = +Math_abs(+(d8 - +HEAPF32[i12 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 d1 = +Math_abs(+(d9 - +HEAPF32[i12 + 4 >> 2]));
 i4 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 i16 = i6 >>> 0 < i4 >>> 0;
 i2 = i16 ? i4 : i6;
 i4 = i16 ? i6 : i4;
 d1 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
 d5 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i4 | 0) != 2139095040) {
  if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
   d5 = d1 + d5;
   break;
  }
  if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
   d5 = d5 * 1237940039285380274899124.0e3;
   d1 = d1 * 1237940039285380274899124.0e3;
   d3 = 8.077935669463161e-28;
  } else d3 = 1.0; else {
   d5 = d5 * 8.077935669463161e-28;
   d1 = d1 * 8.077935669463161e-28;
   d3 = 1237940039285380274899124.0e3;
  }
  d7 = d1;
  d5 = d3 * +Math_sqrt(+(d7 * d7 + d5 * d5));
 } while (0);
 HEAP32[i11 >> 2] = 0;
 d3 = +Math_abs(+(d8 - +HEAPF32[i12 + 8 >> 2]));
 i16 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
 d3 = +Math_abs(+(d9 - +HEAPF32[i12 + 12 >> 2]));
 i4 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
 i6 = i16 >>> 0 < i4 >>> 0;
 i2 = i6 ? i4 : i16;
 i4 = i6 ? i16 : i4;
 d3 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
 d1 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i4 | 0) != 2139095040) {
  if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
   d1 = d3 + d1;
   break;
  }
  if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
   d1 = d1 * 1237940039285380274899124.0e3;
   d3 = d3 * 1237940039285380274899124.0e3;
   d7 = 8.077935669463161e-28;
  } else d7 = 1.0; else {
   d1 = d1 * 8.077935669463161e-28;
   d3 = d3 * 8.077935669463161e-28;
   d7 = 1237940039285380274899124.0e3;
  }
  d1 = d7 * +Math_sqrt(+(d3 * d3 + d1 * d1));
 } while (0);
 if (d1 < d5) {
  HEAP32[i11 >> 2] = 1;
  i2 = 1;
 } else {
  i2 = 0;
  d1 = d5;
 }
 d5 = +Math_abs(+(d8 - +HEAPF32[i12 + 16 >> 2]));
 i16 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 d5 = +Math_abs(+(d9 - +HEAPF32[i12 + 20 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 i17 = i16 >>> 0 < i6 >>> 0;
 i4 = i17 ? i6 : i16;
 i6 = i17 ? i16 : i6;
 d5 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i6 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i6 | 0) == 0 | (i4 - i6 | 0) >>> 0 > 209715199) {
   d3 = d5 + d3;
   break;
  }
  if (i4 >>> 0 <= 1568669695) if (i6 >>> 0 < 562036736) {
   d3 = d3 * 1237940039285380274899124.0e3;
   d5 = d5 * 1237940039285380274899124.0e3;
   d7 = 8.077935669463161e-28;
  } else d7 = 1.0; else {
   d3 = d3 * 8.077935669463161e-28;
   d5 = d5 * 8.077935669463161e-28;
   d7 = 1237940039285380274899124.0e3;
  }
  d3 = d7 * +Math_sqrt(+(d5 * d5 + d3 * d3));
 } while (0);
 if (d3 < d1) {
  HEAP32[i11 >> 2] = 2;
  i2 = 2;
  d1 = d3;
 }
 d5 = +Math_abs(+(d8 - +HEAPF32[i12 + 24 >> 2]));
 i17 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 d5 = +Math_abs(+(d9 - +HEAPF32[i12 + 28 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 i16 = i17 >>> 0 < i6 >>> 0;
 i4 = i16 ? i6 : i17;
 i6 = i16 ? i17 : i6;
 d5 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i6 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i6 | 0) == 0 | (i4 - i6 | 0) >>> 0 > 209715199) {
   d3 = d5 + d3;
   break;
  }
  if (i4 >>> 0 <= 1568669695) if (i6 >>> 0 < 562036736) {
   d3 = d3 * 1237940039285380274899124.0e3;
   d5 = d5 * 1237940039285380274899124.0e3;
   d7 = 8.077935669463161e-28;
  } else d7 = 1.0; else {
   d3 = d3 * 8.077935669463161e-28;
   d5 = d5 * 8.077935669463161e-28;
   d7 = 1237940039285380274899124.0e3;
  }
  d3 = d7 * +Math_sqrt(+(d5 * d5 + d3 * d3));
 } while (0);
 if (d3 < d1) {
  HEAP32[i11 >> 2] = 3;
  i2 = 3;
  d1 = d3;
 }
 d5 = +Math_abs(+(d8 - +HEAPF32[i12 + 32 >> 2]));
 i17 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 d5 = +Math_abs(+(d9 - +HEAPF32[i12 + 36 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 i16 = i17 >>> 0 < i6 >>> 0;
 i4 = i16 ? i6 : i17;
 i6 = i16 ? i17 : i6;
 d5 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i6 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i6 | 0) == 0 | (i4 - i6 | 0) >>> 0 > 209715199) {
   d3 = d5 + d3;
   break;
  }
  if (i4 >>> 0 <= 1568669695) if (i6 >>> 0 < 562036736) {
   d3 = d3 * 1237940039285380274899124.0e3;
   d5 = d5 * 1237940039285380274899124.0e3;
   d7 = 8.077935669463161e-28;
  } else d7 = 1.0; else {
   d3 = d3 * 8.077935669463161e-28;
   d5 = d5 * 8.077935669463161e-28;
   d7 = 1237940039285380274899124.0e3;
  }
  d3 = d7 * +Math_sqrt(+(d5 * d5 + d3 * d3));
 } while (0);
 if (d3 < d1) {
  HEAP32[i11 >> 2] = 4;
  i2 = 4;
  d1 = d3;
 }
 d5 = +Math_abs(+(d8 - +HEAPF32[i12 + 40 >> 2]));
 i17 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 d5 = +Math_abs(+(d9 - +HEAPF32[i12 + 44 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 i16 = i17 >>> 0 < i6 >>> 0;
 i4 = i16 ? i6 : i17;
 i6 = i16 ? i17 : i6;
 d5 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i6 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i6 | 0) == 0 | (i4 - i6 | 0) >>> 0 > 209715199) {
   d3 = d5 + d3;
   break;
  }
  if (i4 >>> 0 <= 1568669695) if (i6 >>> 0 < 562036736) {
   d3 = d3 * 1237940039285380274899124.0e3;
   d5 = d5 * 1237940039285380274899124.0e3;
   d7 = 8.077935669463161e-28;
  } else d7 = 1.0; else {
   d3 = d3 * 8.077935669463161e-28;
   d5 = d5 * 8.077935669463161e-28;
   d7 = 1237940039285380274899124.0e3;
  }
  d3 = d7 * +Math_sqrt(+(d5 * d5 + d3 * d3));
 } while (0);
 if (d3 < d1) {
  HEAP32[i11 >> 2] = 5;
  i2 = 5;
  d1 = d3;
 }
 d5 = +Math_abs(+(d8 - +HEAPF32[i12 + 48 >> 2]));
 i17 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 d5 = +Math_abs(+(d9 - +HEAPF32[i12 + 52 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 i16 = i17 >>> 0 < i6 >>> 0;
 i4 = i16 ? i6 : i17;
 i6 = i16 ? i17 : i6;
 d5 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i6 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i6 | 0) == 0 | (i4 - i6 | 0) >>> 0 > 209715199) {
   d3 = d5 + d3;
   break;
  }
  if (i4 >>> 0 <= 1568669695) if (i6 >>> 0 < 562036736) {
   d3 = d3 * 1237940039285380274899124.0e3;
   d5 = d5 * 1237940039285380274899124.0e3;
   d7 = 8.077935669463161e-28;
  } else d7 = 1.0; else {
   d3 = d3 * 8.077935669463161e-28;
   d5 = d5 * 8.077935669463161e-28;
   d7 = 1237940039285380274899124.0e3;
  }
  d3 = d7 * +Math_sqrt(+(d5 * d5 + d3 * d3));
 } while (0);
 if (d3 < d1) {
  HEAP32[i11 >> 2] = 6;
  i2 = 6;
  d7 = d3;
 } else d7 = d1;
 d3 = +Math_abs(+(d8 - +HEAPF32[i12 + 56 >> 2]));
 i17 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
 d3 = +Math_abs(+(d9 - +HEAPF32[i12 + 60 >> 2]));
 i6 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
 i16 = i17 >>> 0 < i6 >>> 0;
 i4 = i16 ? i6 : i17;
 i6 = i16 ? i17 : i6;
 d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 d1 = (HEAP32[tempDoublePtr >> 2] = i6, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i6 | 0) != 2139095040) {
  if (i4 >>> 0 > 2139095039 | (i6 | 0) == 0 | (i4 - i6 | 0) >>> 0 > 209715199) {
   d1 = d3 + d1;
   break;
  }
  do if (i4 >>> 0 > 1568669695) {
   d1 = d1 * 8.077935669463161e-28;
   d3 = d3 * 8.077935669463161e-28;
   d5 = 1237940039285380274899124.0e3;
  } else {
   if (i6 >>> 0 >= 562036736) {
    d5 = 1.0;
    break;
   }
   d1 = d1 * 1237940039285380274899124.0e3;
   d3 = d3 * 1237940039285380274899124.0e3;
   d5 = 8.077935669463161e-28;
  } while (0);
  d9 = d3;
  d1 = d5 * +Math_sqrt(+(d9 * d9 + d1 * d1));
 } while (0);
 if (d1 < d7) {
  HEAP32[i11 >> 2] = 7;
  i2 = 7;
 }
 i17 = i2 | i10 << 3;
 HEAP32[i11 >> 2] = i17;
 i4 = i15 + 92 | 0;
 i16 = i2 & 7;
 d3 = +HEAPF32[i12 + (i16 << 3) >> 2];
 d1 = +HEAPF32[i12 + (i16 << 3) + 4 >> 2];
 switch (i17 >>> 3 & 3 | 0) {
 case 0:
  {
   HEAPF32[i4 >> 2] = d3;
   HEAPF32[i15 + 96 >> 2] = d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 case 1:
  {
   HEAPF32[i4 >> 2] = d3;
   HEAPF32[i15 + 96 >> 2] = -d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 case 2:
  {
   HEAPF32[i4 >> 2] = -d3;
   HEAPF32[i15 + 96 >> 2] = d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 case 3:
  {
   HEAPF32[i4 >> 2] = -d3;
   HEAPF32[i15 + 96 >> 2] = -d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 default:
  {}
 }
}

function _free(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 if (!i1) return;
 i3 = i1 + -8 | 0;
 i7 = HEAP32[gb + 41408 + 16 >> 2] | 0;
 if (i3 >>> 0 < i7 >>> 0) _abort();
 i1 = HEAP32[i1 + -4 >> 2] | 0;
 i2 = i1 & 3;
 if ((i2 | 0) == 1) _abort();
 i4 = i1 & -8;
 i12 = i3 + i4 | 0;
 do if (!(i1 & 1)) {
  i1 = HEAP32[i3 >> 2] | 0;
  if (!i2) return;
  i10 = i3 + (0 - i1) | 0;
  i9 = i1 + i4 | 0;
  if (i10 >>> 0 < i7 >>> 0) _abort();
  if ((i10 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   i1 = i12 + 4 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if ((i2 & 3 | 0) != 3) {
    i16 = i10;
    i5 = i9;
    break;
   }
   HEAP32[gb + 41408 + 8 >> 2] = i9;
   HEAP32[i1 >> 2] = i2 & -2;
   HEAP32[i10 + 4 >> 2] = i9 | 1;
   HEAP32[i10 + i9 >> 2] = i9;
   return;
  }
  i4 = i1 >>> 3;
  if (i1 >>> 0 < 256) {
   i2 = HEAP32[i10 + 8 >> 2] | 0;
   i3 = HEAP32[i10 + 12 >> 2] | 0;
   i1 = gb + 41408 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < i7 >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i10 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 41408 >> 2] = HEAP32[gb + 41408 >> 2] & ~(1 << i4);
    i16 = i10;
    i5 = i9;
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < i7 >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i10 | 0)) i6 = i1; else _abort();
   } else i6 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i6 >> 2] = i2;
   i16 = i10;
   i5 = i9;
   break;
  }
  i6 = HEAP32[i10 + 24 >> 2] | 0;
  i3 = HEAP32[i10 + 12 >> 2] | 0;
  do if ((i3 | 0) == (i10 | 0)) {
   i3 = i10 + 16 | 0;
   i2 = i3 + 4 | 0;
   i1 = HEAP32[i2 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i3 >> 2] | 0;
    if (!i1) {
     i8 = 0;
     break;
    } else i2 = i3;
   }
   while (1) {
    i3 = i1 + 20 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i2 = i3;
     continue;
    }
    i3 = i1 + 16 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (!i4) break; else {
     i1 = i4;
     i2 = i3;
    }
   }
   if (i2 >>> 0 < i7 >>> 0) _abort(); else {
    HEAP32[i2 >> 2] = 0;
    i8 = i1;
    break;
   }
  } else {
   i4 = HEAP32[i10 + 8 >> 2] | 0;
   if (i4 >>> 0 < i7 >>> 0) _abort();
   i1 = i4 + 12 | 0;
   if ((HEAP32[i1 >> 2] | 0) != (i10 | 0)) _abort();
   i2 = i3 + 8 | 0;
   if ((HEAP32[i2 >> 2] | 0) == (i10 | 0)) {
    HEAP32[i1 >> 2] = i3;
    HEAP32[i2 >> 2] = i4;
    i8 = i3;
    break;
   } else _abort();
  } while (0);
  if (i6) {
   i1 = HEAP32[i10 + 28 >> 2] | 0;
   i2 = gb + 41408 + 304 + (i1 << 2) | 0;
   if ((i10 | 0) == (HEAP32[i2 >> 2] | 0)) {
    HEAP32[i2 >> 2] = i8;
    if (!i8) {
     HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
     i16 = i10;
     i5 = i9;
     break;
    }
   } else {
    if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i6 + 16 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i10 | 0)) HEAP32[i1 >> 2] = i8; else HEAP32[i6 + 20 >> 2] = i8;
    if (!i8) {
     i16 = i10;
     i5 = i9;
     break;
    }
   }
   i3 = HEAP32[gb + 41408 + 16 >> 2] | 0;
   if (i8 >>> 0 < i3 >>> 0) _abort();
   HEAP32[i8 + 24 >> 2] = i6;
   i1 = i10 + 16 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
    HEAP32[i8 + 16 >> 2] = i2;
    HEAP32[i2 + 24 >> 2] = i8;
    break;
   } while (0);
   i1 = HEAP32[i1 + 4 >> 2] | 0;
   if (i1) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
    HEAP32[i8 + 20 >> 2] = i1;
    HEAP32[i1 + 24 >> 2] = i8;
    i16 = i10;
    i5 = i9;
    break;
   } else {
    i16 = i10;
    i5 = i9;
   }
  } else {
   i16 = i10;
   i5 = i9;
  }
 } else {
  i16 = i3;
  i5 = i4;
 } while (0);
 if (i16 >>> 0 >= i12 >>> 0) _abort();
 i1 = i12 + 4 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (!(i2 & 1)) _abort();
 if (!(i2 & 2)) {
  if ((i12 | 0) == (HEAP32[gb + 41408 + 24 >> 2] | 0)) {
   i15 = (HEAP32[gb + 41408 + 12 >> 2] | 0) + i5 | 0;
   HEAP32[gb + 41408 + 12 >> 2] = i15;
   HEAP32[gb + 41408 + 24 >> 2] = i16;
   HEAP32[i16 + 4 >> 2] = i15 | 1;
   if ((i16 | 0) != (HEAP32[gb + 41408 + 20 >> 2] | 0)) return;
   HEAP32[gb + 41408 + 20 >> 2] = 0;
   HEAP32[gb + 41408 + 8 >> 2] = 0;
   return;
  }
  if ((i12 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   i15 = (HEAP32[gb + 41408 + 8 >> 2] | 0) + i5 | 0;
   HEAP32[gb + 41408 + 8 >> 2] = i15;
   HEAP32[gb + 41408 + 20 >> 2] = i16;
   HEAP32[i16 + 4 >> 2] = i15 | 1;
   HEAP32[i16 + i15 >> 2] = i15;
   return;
  }
  i5 = (i2 & -8) + i5 | 0;
  i4 = i2 >>> 3;
  do if (i2 >>> 0 >= 256) {
   i6 = HEAP32[i12 + 24 >> 2] | 0;
   i1 = HEAP32[i12 + 12 >> 2] | 0;
   do if ((i1 | 0) == (i12 | 0)) {
    i3 = i12 + 16 | 0;
    i2 = i3 + 4 | 0;
    i1 = HEAP32[i2 >> 2] | 0;
    if (!i1) {
     i1 = HEAP32[i3 >> 2] | 0;
     if (!i1) {
      i13 = 0;
      break;
     } else i2 = i3;
    }
    while (1) {
     i3 = i1 + 20 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (i4 | 0) {
      i1 = i4;
      i2 = i3;
      continue;
     }
     i3 = i1 + 16 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (!i4) break; else {
      i1 = i4;
      i2 = i3;
     }
    }
    if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i2 >> 2] = 0;
     i13 = i1;
     break;
    }
   } else {
    i2 = HEAP32[i12 + 8 >> 2] | 0;
    if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
    i3 = i2 + 12 | 0;
    if ((HEAP32[i3 >> 2] | 0) != (i12 | 0)) _abort();
    i4 = i1 + 8 | 0;
    if ((HEAP32[i4 >> 2] | 0) == (i12 | 0)) {
     HEAP32[i3 >> 2] = i1;
     HEAP32[i4 >> 2] = i2;
     i13 = i1;
     break;
    } else _abort();
   } while (0);
   if (i6 | 0) {
    i1 = HEAP32[i12 + 28 >> 2] | 0;
    i2 = gb + 41408 + 304 + (i1 << 2) | 0;
    if ((i12 | 0) == (HEAP32[i2 >> 2] | 0)) {
     HEAP32[i2 >> 2] = i13;
     if (!i13) {
      HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
      break;
     }
    } else {
     if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
     i1 = i6 + 16 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i12 | 0)) HEAP32[i1 >> 2] = i13; else HEAP32[i6 + 20 >> 2] = i13;
     if (!i13) break;
    }
    i3 = HEAP32[gb + 41408 + 16 >> 2] | 0;
    if (i13 >>> 0 < i3 >>> 0) _abort();
    HEAP32[i13 + 24 >> 2] = i6;
    i1 = i12 + 16 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
     HEAP32[i13 + 16 >> 2] = i2;
     HEAP32[i2 + 24 >> 2] = i13;
     break;
    } while (0);
    i1 = HEAP32[i1 + 4 >> 2] | 0;
    if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i13 + 20 >> 2] = i1;
     HEAP32[i1 + 24 >> 2] = i13;
     break;
    }
   }
  } else {
   i2 = HEAP32[i12 + 8 >> 2] | 0;
   i3 = HEAP32[i12 + 12 >> 2] | 0;
   i1 = gb + 41408 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i12 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 41408 >> 2] = HEAP32[gb + 41408 >> 2] & ~(1 << i4);
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i12 | 0)) i11 = i1; else _abort();
   } else i11 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i11 >> 2] = i2;
  } while (0);
  HEAP32[i16 + 4 >> 2] = i5 | 1;
  HEAP32[i16 + i5 >> 2] = i5;
  if ((i16 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   HEAP32[gb + 41408 + 8 >> 2] = i5;
   return;
  }
 } else {
  HEAP32[i1 >> 2] = i2 & -2;
  HEAP32[i16 + 4 >> 2] = i5 | 1;
  HEAP32[i16 + i5 >> 2] = i5;
 }
 i1 = i5 >>> 3;
 if (i5 >>> 0 < 256) {
  i3 = gb + 41408 + 40 + (i1 << 1 << 2) | 0;
  i2 = HEAP32[gb + 41408 >> 2] | 0;
  i1 = 1 << i1;
  if (i2 & i1) {
   i1 = i3 + 8 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
    i14 = i1;
    i15 = i2;
   }
  } else {
   HEAP32[gb + 41408 >> 2] = i2 | i1;
   i14 = i3 + 8 | 0;
   i15 = i3;
  }
  HEAP32[i14 >> 2] = i16;
  HEAP32[i15 + 12 >> 2] = i16;
  HEAP32[i16 + 8 >> 2] = i15;
  HEAP32[i16 + 12 >> 2] = i3;
  return;
 }
 i1 = i5 >>> 8;
 if (i1) if (i5 >>> 0 > 16777215) i3 = 31; else {
  i14 = (i1 + 1048320 | 0) >>> 16 & 8;
  i15 = i1 << i14;
  i13 = (i15 + 520192 | 0) >>> 16 & 4;
  i15 = i15 << i13;
  i3 = (i15 + 245760 | 0) >>> 16 & 2;
  i3 = 14 - (i13 | i14 | i3) + (i15 << i3 >>> 15) | 0;
  i3 = i5 >>> (i3 + 7 | 0) & 1 | i3 << 1;
 } else i3 = 0;
 i4 = gb + 41408 + 304 + (i3 << 2) | 0;
 HEAP32[i16 + 28 >> 2] = i3;
 HEAP32[i16 + 20 >> 2] = 0;
 HEAP32[i16 + 16 >> 2] = 0;
 i1 = HEAP32[gb + 41408 + 4 >> 2] | 0;
 i2 = 1 << i3;
 do if (i1 & i2) {
  i3 = i5 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
  i4 = HEAP32[i4 >> 2] | 0;
  while (1) {
   if ((HEAP32[i4 + 4 >> 2] & -8 | 0) == (i5 | 0)) {
    i1 = 130;
    break;
   }
   i2 = i4 + 16 + (i3 >>> 31 << 2) | 0;
   i1 = HEAP32[i2 >> 2] | 0;
   if (!i1) {
    i1 = 127;
    break;
   } else {
    i3 = i3 << 1;
    i4 = i1;
   }
  }
  if ((i1 | 0) == 127) if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
   HEAP32[i2 >> 2] = i16;
   HEAP32[i16 + 24 >> 2] = i4;
   HEAP32[i16 + 12 >> 2] = i16;
   HEAP32[i16 + 8 >> 2] = i16;
   break;
  } else if ((i1 | 0) == 130) {
   i1 = i4 + 8 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   i15 = HEAP32[gb + 41408 + 16 >> 2] | 0;
   if (i2 >>> 0 >= i15 >>> 0 & i4 >>> 0 >= i15 >>> 0) {
    HEAP32[i2 + 12 >> 2] = i16;
    HEAP32[i1 >> 2] = i16;
    HEAP32[i16 + 8 >> 2] = i2;
    HEAP32[i16 + 12 >> 2] = i4;
    HEAP32[i16 + 24 >> 2] = 0;
    break;
   } else _abort();
  }
 } else {
  HEAP32[gb + 41408 + 4 >> 2] = i1 | i2;
  HEAP32[i4 >> 2] = i16;
  HEAP32[i16 + 24 >> 2] = i4;
  HEAP32[i16 + 12 >> 2] = i16;
  HEAP32[i16 + 8 >> 2] = i16;
 } while (0);
 i16 = (HEAP32[gb + 41408 + 32 >> 2] | 0) + -1 | 0;
 HEAP32[gb + 41408 + 32 >> 2] = i16;
 if (!i16) i1 = gb + 41408 + 456 | 0; else return;
 while (1) {
  i1 = HEAP32[i1 >> 2] | 0;
  if (!i1) break; else i1 = i1 + 8 | 0;
 }
 HEAP32[gb + 41408 + 32 >> 2] = -1;
 return;
}

function _dispose_chunk(i2, i3) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0;
 i14 = i2 + i3 | 0;
 i1 = HEAP32[i2 + 4 >> 2] | 0;
 do if (!(i1 & 1)) {
  i6 = HEAP32[i2 >> 2] | 0;
  if (!(i1 & 3)) return;
  i11 = i2 + (0 - i6) | 0;
  i10 = i6 + i3 | 0;
  i8 = HEAP32[gb + 41408 + 16 >> 2] | 0;
  if (i11 >>> 0 < i8 >>> 0) _abort();
  if ((i11 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   i2 = i14 + 4 | 0;
   i1 = HEAP32[i2 >> 2] | 0;
   if ((i1 & 3 | 0) != 3) {
    i17 = i11;
    i5 = i10;
    break;
   }
   HEAP32[gb + 41408 + 8 >> 2] = i10;
   HEAP32[i2 >> 2] = i1 & -2;
   HEAP32[i11 + 4 >> 2] = i10 | 1;
   HEAP32[i11 + i10 >> 2] = i10;
   return;
  }
  i4 = i6 >>> 3;
  if (i6 >>> 0 < 256) {
   i2 = HEAP32[i11 + 8 >> 2] | 0;
   i3 = HEAP32[i11 + 12 >> 2] | 0;
   i1 = gb + 41408 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < i8 >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i11 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 41408 >> 2] = HEAP32[gb + 41408 >> 2] & ~(1 << i4);
    i17 = i11;
    i5 = i10;
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < i8 >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i11 | 0)) i7 = i1; else _abort();
   } else i7 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i7 >> 2] = i2;
   i17 = i11;
   i5 = i10;
   break;
  }
  i6 = HEAP32[i11 + 24 >> 2] | 0;
  i3 = HEAP32[i11 + 12 >> 2] | 0;
  do if ((i3 | 0) == (i11 | 0)) {
   i3 = i11 + 16 | 0;
   i2 = i3 + 4 | 0;
   i1 = HEAP32[i2 >> 2] | 0;
   if (!i1) {
    i1 = HEAP32[i3 >> 2] | 0;
    if (!i1) {
     i9 = 0;
     break;
    } else i2 = i3;
   }
   while (1) {
    i3 = i1 + 20 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (i4 | 0) {
     i1 = i4;
     i2 = i3;
     continue;
    }
    i3 = i1 + 16 | 0;
    i4 = HEAP32[i3 >> 2] | 0;
    if (!i4) break; else {
     i1 = i4;
     i2 = i3;
    }
   }
   if (i2 >>> 0 < i8 >>> 0) _abort(); else {
    HEAP32[i2 >> 2] = 0;
    i9 = i1;
    break;
   }
  } else {
   i4 = HEAP32[i11 + 8 >> 2] | 0;
   if (i4 >>> 0 < i8 >>> 0) _abort();
   i1 = i4 + 12 | 0;
   if ((HEAP32[i1 >> 2] | 0) != (i11 | 0)) _abort();
   i2 = i3 + 8 | 0;
   if ((HEAP32[i2 >> 2] | 0) == (i11 | 0)) {
    HEAP32[i1 >> 2] = i3;
    HEAP32[i2 >> 2] = i4;
    i9 = i3;
    break;
   } else _abort();
  } while (0);
  if (i6) {
   i1 = HEAP32[i11 + 28 >> 2] | 0;
   i2 = gb + 41408 + 304 + (i1 << 2) | 0;
   if ((i11 | 0) == (HEAP32[i2 >> 2] | 0)) {
    HEAP32[i2 >> 2] = i9;
    if (!i9) {
     HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
     i17 = i11;
     i5 = i10;
     break;
    }
   } else {
    if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
    i1 = i6 + 16 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i11 | 0)) HEAP32[i1 >> 2] = i9; else HEAP32[i6 + 20 >> 2] = i9;
    if (!i9) {
     i17 = i11;
     i5 = i10;
     break;
    }
   }
   i3 = HEAP32[gb + 41408 + 16 >> 2] | 0;
   if (i9 >>> 0 < i3 >>> 0) _abort();
   HEAP32[i9 + 24 >> 2] = i6;
   i1 = i11 + 16 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
    HEAP32[i9 + 16 >> 2] = i2;
    HEAP32[i2 + 24 >> 2] = i9;
    break;
   } while (0);
   i1 = HEAP32[i1 + 4 >> 2] | 0;
   if (i1) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
    HEAP32[i9 + 20 >> 2] = i1;
    HEAP32[i1 + 24 >> 2] = i9;
    i17 = i11;
    i5 = i10;
    break;
   } else {
    i17 = i11;
    i5 = i10;
   }
  } else {
   i17 = i11;
   i5 = i10;
  }
 } else {
  i17 = i2;
  i5 = i3;
 } while (0);
 i7 = HEAP32[gb + 41408 + 16 >> 2] | 0;
 if (i14 >>> 0 < i7 >>> 0) _abort();
 i1 = i14 + 4 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (!(i2 & 2)) {
  if ((i14 | 0) == (HEAP32[gb + 41408 + 24 >> 2] | 0)) {
   i16 = (HEAP32[gb + 41408 + 12 >> 2] | 0) + i5 | 0;
   HEAP32[gb + 41408 + 12 >> 2] = i16;
   HEAP32[gb + 41408 + 24 >> 2] = i17;
   HEAP32[i17 + 4 >> 2] = i16 | 1;
   if ((i17 | 0) != (HEAP32[gb + 41408 + 20 >> 2] | 0)) return;
   HEAP32[gb + 41408 + 20 >> 2] = 0;
   HEAP32[gb + 41408 + 8 >> 2] = 0;
   return;
  }
  if ((i14 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   i16 = (HEAP32[gb + 41408 + 8 >> 2] | 0) + i5 | 0;
   HEAP32[gb + 41408 + 8 >> 2] = i16;
   HEAP32[gb + 41408 + 20 >> 2] = i17;
   HEAP32[i17 + 4 >> 2] = i16 | 1;
   HEAP32[i17 + i16 >> 2] = i16;
   return;
  }
  i5 = (i2 & -8) + i5 | 0;
  i4 = i2 >>> 3;
  do if (i2 >>> 0 >= 256) {
   i6 = HEAP32[i14 + 24 >> 2] | 0;
   i3 = HEAP32[i14 + 12 >> 2] | 0;
   do if ((i3 | 0) == (i14 | 0)) {
    i3 = i14 + 16 | 0;
    i2 = i3 + 4 | 0;
    i1 = HEAP32[i2 >> 2] | 0;
    if (!i1) {
     i1 = HEAP32[i3 >> 2] | 0;
     if (!i1) {
      i13 = 0;
      break;
     } else i2 = i3;
    }
    while (1) {
     i3 = i1 + 20 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (i4 | 0) {
      i1 = i4;
      i2 = i3;
      continue;
     }
     i3 = i1 + 16 | 0;
     i4 = HEAP32[i3 >> 2] | 0;
     if (!i4) break; else {
      i1 = i4;
      i2 = i3;
     }
    }
    if (i2 >>> 0 < i7 >>> 0) _abort(); else {
     HEAP32[i2 >> 2] = 0;
     i13 = i1;
     break;
    }
   } else {
    i4 = HEAP32[i14 + 8 >> 2] | 0;
    if (i4 >>> 0 < i7 >>> 0) _abort();
    i1 = i4 + 12 | 0;
    if ((HEAP32[i1 >> 2] | 0) != (i14 | 0)) _abort();
    i2 = i3 + 8 | 0;
    if ((HEAP32[i2 >> 2] | 0) == (i14 | 0)) {
     HEAP32[i1 >> 2] = i3;
     HEAP32[i2 >> 2] = i4;
     i13 = i3;
     break;
    } else _abort();
   } while (0);
   if (i6 | 0) {
    i1 = HEAP32[i14 + 28 >> 2] | 0;
    i2 = gb + 41408 + 304 + (i1 << 2) | 0;
    if ((i14 | 0) == (HEAP32[i2 >> 2] | 0)) {
     HEAP32[i2 >> 2] = i13;
     if (!i13) {
      HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
      break;
     }
    } else {
     if (i6 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
     i1 = i6 + 16 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i14 | 0)) HEAP32[i1 >> 2] = i13; else HEAP32[i6 + 20 >> 2] = i13;
     if (!i13) break;
    }
    i3 = HEAP32[gb + 41408 + 16 >> 2] | 0;
    if (i13 >>> 0 < i3 >>> 0) _abort();
    HEAP32[i13 + 24 >> 2] = i6;
    i1 = i14 + 16 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
     HEAP32[i13 + 16 >> 2] = i2;
     HEAP32[i2 + 24 >> 2] = i13;
     break;
    } while (0);
    i1 = HEAP32[i1 + 4 >> 2] | 0;
    if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
     HEAP32[i13 + 20 >> 2] = i1;
     HEAP32[i1 + 24 >> 2] = i13;
     break;
    }
   }
  } else {
   i2 = HEAP32[i14 + 8 >> 2] | 0;
   i3 = HEAP32[i14 + 12 >> 2] | 0;
   i1 = gb + 41408 + 40 + (i4 << 1 << 2) | 0;
   if ((i2 | 0) != (i1 | 0)) {
    if (i2 >>> 0 < i7 >>> 0) _abort();
    if ((HEAP32[i2 + 12 >> 2] | 0) != (i14 | 0)) _abort();
   }
   if ((i3 | 0) == (i2 | 0)) {
    HEAP32[gb + 41408 >> 2] = HEAP32[gb + 41408 >> 2] & ~(1 << i4);
    break;
   }
   if ((i3 | 0) != (i1 | 0)) {
    if (i3 >>> 0 < i7 >>> 0) _abort();
    i1 = i3 + 8 | 0;
    if ((HEAP32[i1 >> 2] | 0) == (i14 | 0)) i12 = i1; else _abort();
   } else i12 = i3 + 8 | 0;
   HEAP32[i2 + 12 >> 2] = i3;
   HEAP32[i12 >> 2] = i2;
  } while (0);
  HEAP32[i17 + 4 >> 2] = i5 | 1;
  HEAP32[i17 + i5 >> 2] = i5;
  if ((i17 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   HEAP32[gb + 41408 + 8 >> 2] = i5;
   return;
  }
 } else {
  HEAP32[i1 >> 2] = i2 & -2;
  HEAP32[i17 + 4 >> 2] = i5 | 1;
  HEAP32[i17 + i5 >> 2] = i5;
 }
 i1 = i5 >>> 3;
 if (i5 >>> 0 < 256) {
  i3 = gb + 41408 + 40 + (i1 << 1 << 2) | 0;
  i2 = HEAP32[gb + 41408 >> 2] | 0;
  i1 = 1 << i1;
  if (i2 & i1) {
   i1 = i3 + 8 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
   if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
    i15 = i1;
    i16 = i2;
   }
  } else {
   HEAP32[gb + 41408 >> 2] = i2 | i1;
   i15 = i3 + 8 | 0;
   i16 = i3;
  }
  HEAP32[i15 >> 2] = i17;
  HEAP32[i16 + 12 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i16;
  HEAP32[i17 + 12 >> 2] = i3;
  return;
 }
 i1 = i5 >>> 8;
 if (i1) if (i5 >>> 0 > 16777215) i3 = 31; else {
  i15 = (i1 + 1048320 | 0) >>> 16 & 8;
  i16 = i1 << i15;
  i14 = (i16 + 520192 | 0) >>> 16 & 4;
  i16 = i16 << i14;
  i3 = (i16 + 245760 | 0) >>> 16 & 2;
  i3 = 14 - (i14 | i15 | i3) + (i16 << i3 >>> 15) | 0;
  i3 = i5 >>> (i3 + 7 | 0) & 1 | i3 << 1;
 } else i3 = 0;
 i4 = gb + 41408 + 304 + (i3 << 2) | 0;
 HEAP32[i17 + 28 >> 2] = i3;
 HEAP32[i17 + 20 >> 2] = 0;
 HEAP32[i17 + 16 >> 2] = 0;
 i1 = HEAP32[gb + 41408 + 4 >> 2] | 0;
 i2 = 1 << i3;
 if (!(i1 & i2)) {
  HEAP32[gb + 41408 + 4 >> 2] = i1 | i2;
  HEAP32[i4 >> 2] = i17;
  HEAP32[i17 + 24 >> 2] = i4;
  HEAP32[i17 + 12 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i17;
  return;
 }
 i3 = i5 << ((i3 | 0) == 31 ? 0 : 25 - (i3 >>> 1) | 0);
 i4 = HEAP32[i4 >> 2] | 0;
 while (1) {
  if ((HEAP32[i4 + 4 >> 2] & -8 | 0) == (i5 | 0)) {
   i1 = 127;
   break;
  }
  i2 = i4 + 16 + (i3 >>> 31 << 2) | 0;
  i1 = HEAP32[i2 >> 2] | 0;
  if (!i1) {
   i1 = 124;
   break;
  } else {
   i3 = i3 << 1;
   i4 = i1;
  }
 }
 if ((i1 | 0) == 124) {
  if (i2 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
  HEAP32[i2 >> 2] = i17;
  HEAP32[i17 + 24 >> 2] = i4;
  HEAP32[i17 + 12 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i17;
  return;
 } else if ((i1 | 0) == 127) {
  i1 = i4 + 8 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  i16 = HEAP32[gb + 41408 + 16 >> 2] | 0;
  if (!(i2 >>> 0 >= i16 >>> 0 & i4 >>> 0 >= i16 >>> 0)) _abort();
  HEAP32[i2 + 12 >> 2] = i17;
  HEAP32[i1 >> 2] = i17;
  HEAP32[i17 + 8 >> 2] = i2;
  HEAP32[i17 + 12 >> 2] = i4;
  HEAP32[i17 + 24 >> 2] = 0;
  return;
 }
}

function _firdespm_create(i18, i21, i22, i20, i19) {
 i18 = i18 | 0;
 i21 = i21 | 0;
 i22 = i22 | 0;
 i20 = i20 | 0;
 i19 = i19 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, d15 = 0.0, i16 = 0, d17 = 0.0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0;
 i31 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i29 = i31;
 i4 = 1;
 i3 = 0;
 do {
  d17 = +HEAPF32[i21 + (i3 << 2) >> 2];
  i4 = d17 <= .5 & d17 >= 0.0 & 1 & i4;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 6);
 d5 = +HEAPF32[i21 >> 2];
 i3 = 1;
 do {
  d17 = d5;
  d5 = +HEAPF32[i21 + (i3 << 2) >> 2];
  i4 = d5 >= d17 & i4;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 6);
 i3 = 0;
 i6 = 1;
 do {
  i6 = +HEAPF32[i20 + (i3 << 2) >> 2] > 0.0 & i6;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 3);
 if (!i4) {
  i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i3) {
   i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
   i3 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i3 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i7 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i7;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i3 | 32;
   _exit(1);
  } else {
   i7 = i3;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i7 - i2 | 0) >>> 0 < 40) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 20745 | 0, 40) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 20745 | 0, 40) | 0) >>> 0 < 40) _exit(1); else {
   i8 = 0;
   i9 = gb + 20745 + 40 | 0;
   i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i8 = 40;
   i9 = gb + 20745 | 0;
   i10 = i2;
  } while (0);
  _memcpy(i10 | 0, i9 | 0, i8 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i8;
  _exit(1);
 }
 if (!i6) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i12 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i12;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i12 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i12 - i1 | 0) >>> 0 < 61) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 20786 | 0, 61) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 20786 | 0, 61) | 0) >>> 0 < 61) _exit(1); else {
   i13 = 0;
   i14 = gb + 20786 + 61 | 0;
   i16 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i13 = 61;
   i14 = gb + 20786 | 0;
   i16 = i1;
  } while (0);
  _memcpy(i16 | 0, i14 | 0, i13 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i13;
  _exit(1);
 }
 i28 = _malloc(96) | 0;
 HEAP32[i28 >> 2] = i18;
 i9 = i18 & 1;
 i26 = i28 + 4 | 0;
 HEAP32[i26 >> 2] = i9;
 i8 = (i18 - i9 | 0) >>> 1;
 HEAP32[i28 + 8 >> 2] = i8;
 i9 = i8 + i9 | 0;
 i8 = i28 + 12 | 0;
 HEAP32[i8 >> 2] = i9;
 i27 = i28 + 28 | 0;
 HEAP32[i27 >> 2] = 0;
 HEAP32[i28 + 88 >> 2] = _malloc((i9 << 2) + 4 | 0) | 0;
 i9 = (i9 << 3) + 8 | 0;
 HEAP32[i28 + 64 >> 2] = _malloc(i9) | 0;
 HEAP32[i28 + 68 >> 2] = _malloc(i9) | 0;
 HEAP32[i28 + 72 >> 2] = _malloc(i9) | 0;
 i9 = i28 + 16 | 0;
 HEAP32[i9 >> 2] = 3;
 i10 = i28 + 32 | 0;
 HEAP32[i10 >> 2] = _malloc(48) | 0;
 i23 = i28 + 36 | 0;
 HEAP32[i23 >> 2] = _malloc(24) | 0;
 i24 = i28 + 40 | 0;
 HEAP32[i24 >> 2] = _malloc(24) | 0;
 i1 = _malloc(12) | 0;
 i25 = i28 + 44 | 0;
 HEAP32[i25 >> 2] = i1;
 if (!i19) {
  HEAP32[i1 >> 2] = 0;
  i1 = HEAP32[i9 >> 2] | 0;
  if (i1 >>> 0 > 1) {
   i2 = 1;
   do {
    HEAP32[(HEAP32[i25 >> 2] | 0) + (i2 << 2) >> 2] = 0;
    i2 = i2 + 1 | 0;
    i1 = HEAP32[i9 >> 2] | 0;
   } while (i2 >>> 0 < i1 >>> 0);
  }
 } else {
  HEAP32[i1 >> 2] = HEAP32[i19 >> 2];
  i1 = HEAP32[i9 >> 2] | 0;
  if (i1 >>> 0 > 1) {
   i2 = 1;
   do {
    HEAP32[(HEAP32[i25 >> 2] | 0) + (i2 << 2) >> 2] = HEAP32[i19 + (i2 << 2) >> 2];
    i2 = i2 + 1 | 0;
    i1 = HEAP32[i9 >> 2] | 0;
   } while (i2 >>> 0 < i1 >>> 0);
  }
 }
 i7 = (i1 | 0) == 0;
 if (!i7) {
  i4 = HEAP32[i10 >> 2] | 0;
  i6 = HEAP32[i23 >> 2] | 0;
  i3 = HEAP32[i24 >> 2] | 0;
  if (!i20) {
   i2 = 0;
   do {
    i20 = i2 << 1;
    HEAPF64[i4 + (i20 << 3) >> 3] = +HEAPF32[i21 + (i20 << 2) >> 2];
    i20 = i20 | 1;
    HEAPF64[i4 + (i20 << 3) >> 3] = +HEAPF32[i21 + (i20 << 2) >> 2];
    HEAPF64[i6 + (i2 << 3) >> 3] = +HEAPF32[i22 + (i2 << 2) >> 2];
    HEAPF64[i3 + (i2 << 3) >> 3] = 1.0;
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i1 | 0));
  } else {
   i2 = 0;
   do {
    i19 = i2 << 1;
    HEAPF64[i4 + (i19 << 3) >> 3] = +HEAPF32[i21 + (i19 << 2) >> 2];
    i19 = i19 | 1;
    HEAPF64[i4 + (i19 << 3) >> 3] = +HEAPF32[i21 + (i19 << 2) >> 2];
    HEAPF64[i6 + (i2 << 3) >> 3] = +HEAPF32[i22 + (i2 << 2) >> 2];
    HEAPF64[i3 + (i2 << 3) >> 3] = +HEAPF32[i20 + (i2 << 2) >> 2];
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i1 | 0));
  }
 }
 i6 = i28 + 24 | 0;
 HEAP32[i6 >> 2] = 20;
 i19 = i28 + 20 | 0;
 HEAP32[i19 >> 2] = 0;
 d5 = .5 / +(((HEAP32[i8 >> 2] | 0) * 20 | 0) >>> 0);
 if (i7) i1 = 0; else {
  i2 = HEAP32[i10 >> 2] | 0;
  i3 = 0;
  i4 = 0;
  do {
   i22 = i4 << 1;
   i3 = (~~((+HEAPF64[i2 + ((i22 | 1) << 3) >> 3] - +HEAPF64[i2 + (i22 << 3) >> 3]) / d5 + 1.0) >>> 0) + i3 | 0;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i1 | 0));
  HEAP32[i19 >> 2] = i3;
  i1 = i3 << 3;
 }
 i16 = i28 + 48 | 0;
 HEAP32[i16 >> 2] = _malloc(i1) | 0;
 i18 = i28 + 52 | 0;
 HEAP32[i18 >> 2] = _malloc(i1) | 0;
 i20 = i28 + 56 | 0;
 HEAP32[i20 >> 2] = _malloc(i1) | 0;
 HEAP32[i28 + 60 >> 2] = _malloc(i1) | 0;
 d17 = .5 / +((Math_imul(HEAP32[i8 >> 2] | 0, HEAP32[i6 >> 2] | 0) | 0) >>> 0);
 i14 = HEAP32[i9 >> 2] | 0;
 L75 : do if (!i14) i30 = 0; else {
  i12 = HEAP32[i10 >> 2] | 0;
  i13 = 0;
  i1 = 0;
  L77 : while (1) {
   i22 = i13 << 1;
   d5 = +HEAPF64[i12 + (i22 << 3) >> 3];
   d15 = +HEAPF64[i12 + ((i22 | 1) << 3) >> 3];
   if ((i13 | 0) == 0 ? (HEAP32[i27 >> 2] | 0) != 0 : 0) d5 = d5 < d17 ? d17 : d5;
   i4 = ~~((d15 - d5) / d17 + .5) >>> 0;
   i4 = (i4 | 0) == 0 ? 1 : i4;
   i6 = HEAP32[i16 >> 2] | 0;
   i7 = HEAP32[i18 >> 2] | 0;
   i8 = (HEAP32[i23 >> 2] | 0) + (i13 << 3) | 0;
   i9 = (HEAP32[i25 >> 2] | 0) + (i13 << 2) | 0;
   i10 = 0;
   do {
    i3 = i6 + (i1 << 3) | 0;
    HEAPF64[i3 >> 3] = d5 + d17 * +(i10 >>> 0);
    HEAPF64[i7 + (i1 << 3) >> 3] = +HEAPF64[i8 >> 3];
    i2 = HEAP32[i9 >> 2] | 0;
    switch (i2 | 0) {
    case 0:
     {
      d11 = 1.0;
      break;
     }
    case 1:
     {
      d11 = +Math_exp(+(d17 * (+(i10 >>> 0) * 2.0)));
      break;
     }
    case 2:
     {
      d11 = d17 * (+(i10 >>> 0) * 2.700000047683716) + 1.0;
      break;
     }
    default:
     break L77;
    }
    HEAPF64[(HEAP32[i20 >> 2] | 0) + (i1 << 3) >> 3] = d11 * +HEAPF64[(HEAP32[i24 >> 2] | 0) + (i13 << 3) >> 3];
    i1 = i1 + 1 | 0;
    i10 = i10 + 1 | 0;
   } while (i10 >>> 0 < i4 >>> 0);
   HEAPF64[i3 >> 3] = d15;
   i13 = i13 + 1 | 0;
   if (i13 >>> 0 >= i14 >>> 0) {
    i30 = i1;
    break L75;
   }
  }
  HEAP32[i29 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 20848 | 0, i29);
  _exit(1);
 } while (0);
 HEAP32[i19 >> 2] = i30;
 i2 = (HEAP32[i26 >> 2] | 0) == 0;
 if (!(HEAP32[i27 >> 2] | 0)) {
  if ((i30 | 0) == 0 | i2 ^ 1) {
   STACKTOP = i31;
   return i28 | 0;
  }
  i4 = HEAP32[i16 >> 2] | 0;
  i3 = HEAP32[i18 >> 2] | 0;
  i1 = HEAP32[i20 >> 2] | 0;
  i2 = 0;
  do {
   i29 = i4 + (i2 << 3) | 0;
   d17 = +Math_cos(+(+HEAPF64[i29 >> 3] * 3.141592653589793));
   i27 = i3 + (i2 << 3) | 0;
   HEAPF64[i27 >> 3] = +HEAPF64[i27 >> 3] / d17;
   d17 = +Math_cos(+(+HEAPF64[i29 >> 3] * 3.141592653589793));
   i29 = i1 + (i2 << 3) | 0;
   HEAPF64[i29 >> 3] = d17 * +HEAPF64[i29 >> 3];
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i30 | 0));
  STACKTOP = i31;
  return i28 | 0;
 }
 i1 = (i30 | 0) != 0;
 if (i2) {
  if (!i1) {
   STACKTOP = i31;
   return i28 | 0;
  }
  i4 = HEAP32[i16 >> 2] | 0;
  i3 = HEAP32[i18 >> 2] | 0;
  i1 = HEAP32[i20 >> 2] | 0;
  i2 = 0;
  do {
   i29 = i4 + (i2 << 3) | 0;
   d17 = +Math_sin(+(+HEAPF64[i29 >> 3] * 3.141592653589793));
   i27 = i3 + (i2 << 3) | 0;
   HEAPF64[i27 >> 3] = +HEAPF64[i27 >> 3] / d17;
   d17 = +Math_sin(+(+HEAPF64[i29 >> 3] * 3.141592653589793));
   i29 = i1 + (i2 << 3) | 0;
   HEAPF64[i29 >> 3] = d17 * +HEAPF64[i29 >> 3];
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i30 | 0));
  STACKTOP = i31;
  return i28 | 0;
 } else {
  if (!i1) {
   STACKTOP = i31;
   return i28 | 0;
  }
  i4 = HEAP32[i16 >> 2] | 0;
  i3 = HEAP32[i18 >> 2] | 0;
  i1 = HEAP32[i20 >> 2] | 0;
  i2 = 0;
  do {
   i29 = i4 + (i2 << 3) | 0;
   d17 = +Math_sin(+(+HEAPF64[i29 >> 3] * 6.283185307179586));
   i27 = i3 + (i2 << 3) | 0;
   HEAPF64[i27 >> 3] = +HEAPF64[i27 >> 3] / d17;
   d17 = +Math_sin(+(+HEAPF64[i29 >> 3] * 6.283185307179586));
   i29 = i1 + (i2 << 3) | 0;
   HEAPF64[i29 >> 3] = d17 * +HEAPF64[i29 >> 3];
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i30 | 0));
  STACKTOP = i31;
  return i28 | 0;
 }
 return 0;
}

function _ofdmframesync_rxsymbol(i27) {
 i27 = i27 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i3 = i28 + 16 | 0;
 i26 = i28 + 24 | 0;
 i23 = i28 + 8 | 0;
 i25 = i28;
 if (!(HEAP32[i27 >> 2] | 0)) i2 = 0; else {
  i6 = i27 + 100 | 0;
  i7 = i27 + 52 | 0;
  i12 = i3 + 4 | 0;
  i13 = 0;
  do {
   i2 = HEAP32[i6 >> 2] | 0;
   d8 = +HEAPF32[i2 + (i13 << 3) >> 2];
   d9 = +HEAPF32[i2 + (i13 << 3) + 4 >> 2];
   i2 = HEAP32[i7 >> 2] | 0;
   i1 = i2 + (i13 << 3) | 0;
   d10 = +HEAPF32[i1 >> 2];
   i2 = i2 + (i13 << 3) + 4 | 0;
   d11 = +HEAPF32[i2 >> 2];
   d5 = d8 * d10 - d9 * d11;
   d4 = d9 * d10 + d8 * d11;
   if ((d5 != d5 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
    ___mulsc3(i3, d10, d11, d8, d9);
    d5 = +HEAPF32[i3 >> 2];
    d4 = +HEAPF32[i12 >> 2];
   }
   HEAPF32[i1 >> 2] = d5;
   HEAPF32[i2 >> 2] = d4;
   i13 = i13 + 1 | 0;
   i1 = HEAP32[i27 >> 2] | 0;
  } while (i13 >>> 0 < i1 >>> 0);
  i2 = i1;
 }
 i20 = i27 + 20 | 0;
 i1 = HEAP32[i20 >> 2] | 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 i22 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 do if (!i2) {
  i6 = i1;
  i1 = 0;
 } else {
  i13 = i27 + 4 | 0;
  i15 = i27 + 12 | 0;
  i16 = i27 + 112 | 0;
  i17 = i27 + 52 | 0;
  i18 = i23 + 4 | 0;
  i7 = i2;
  i3 = i2;
  i12 = 0;
  i1 = 0;
  while (1) {
   i2 = HEAP32[i13 >> 2] | 0;
   i6 = ((i2 + i12 | 0) >>> 0) % (i3 >>> 0) | 0;
   if ((HEAP8[(HEAP32[i15 >> 2] | 0) + i6 >> 0] | 0) == 1) {
    if ((i1 | 0) == (HEAP32[i20 >> 2] | 0)) break;
    i30 = HEAP32[i16 >> 2] | 0;
    i29 = i30 + 16 | 0;
    i31 = HEAP32[i29 >> 2] | 0;
    i3 = HEAP32[i30 + 4 >> 2] & i31;
    i3 = (HEAPU8[(i3 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i3 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i3 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i3 >>> 24) + (gb + 36491) >> 0] | 0) | 0;
    i32 = i3 & 1;
    HEAP32[i30 + 20 >> 2] = i32;
    HEAP32[i29 >> 2] = (i32 | i31 << 1) & HEAP32[i30 + 12 >> 2];
    d10 = +(i6 >>> 0);
    HEAPF32[i21 + (i1 << 2) >> 2] = i6 >>> 0 > i2 >>> 0 ? d10 - +(i7 >>> 0) : d10;
    i2 = HEAP32[i17 >> 2] | 0;
    d10 = +HEAPF32[i2 + (i6 << 3) >> 2];
    d8 = +HEAPF32[i2 + (i6 << 3) + 4 >> 2];
    d9 = (HEAP32[tempDoublePtr >> 2] = (i3 << 31) + -1082130432, +HEAPF32[tempDoublePtr >> 2]);
    d4 = d9 * d10 + d8 * 0.0;
    d5 = d9 * d8 - d10 * 0.0;
    if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
     ___mulsc3(i23, d10, d8, d9, -0.0);
     i2 = HEAP32[i27 >> 2] | 0;
     d5 = +HEAPF32[i18 >> 2];
     d4 = +HEAPF32[i23 >> 2];
    } else i2 = i7;
    HEAPF32[i22 + (i1 << 2) >> 2] = +Math_atan2(+d5, +d4);
    i3 = i2;
    i1 = i1 + 1 | 0;
   } else i2 = i7;
   i12 = i12 + 1 | 0;
   if (i12 >>> 0 >= i3 >>> 0) {
    i24 = 25;
    break;
   } else i7 = i2;
  }
  if ((i24 | 0) == 25) {
   i6 = HEAP32[i20 >> 2] | 0;
   break;
  }
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   STACKTOP = i28;
   return;
  } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i1 - i2 | 0) >>> 0 < 61) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33773 | 0, 61) | 0;
   STACKTOP = i28;
   return;
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33773 | 0, 61) | 0) >>> 0 < 61) {
   STACKTOP = i28;
   return;
  } else {
   i1 = 0;
   i3 = gb + 33773 + 61 | 0;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i1 = 61;
   i3 = gb + 33773 | 0;
  } while (0);
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  STACKTOP = i28;
  return;
 } while (0);
 if ((i1 | 0) != (i6 | 0)) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   STACKTOP = i28;
   return;
  } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i1 - i2 | 0) >>> 0 < 61) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33773 | 0, 61) | 0;
   STACKTOP = i28;
   return;
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33773 | 0, 61) | 0) >>> 0 < 61) {
   STACKTOP = i28;
   return;
  } else {
   i1 = 0;
   i3 = gb + 33773 + 61 | 0;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i1 = 61;
   i3 = gb + 33773 | 0;
  } while (0);
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  STACKTOP = i28;
  return;
 }
 if (i6 >>> 0 > 1) {
  d4 = +HEAPF32[i22 >> 2];
  i3 = 1;
  do {
   i2 = i22 + (i3 << 2) | 0;
   d5 = +HEAPF32[i2 >> 2];
   i1 = i22 + (i3 + -1 << 2) | 0;
   if (d5 - d4 > 3.141592653589793) {
    do d5 = d5 + -6.283185307179586; while (d5 - d4 > 3.141592653589793);
    HEAPF32[i2 >> 2] = d5;
    d4 = d5;
   } else d4 = d5;
   d5 = +HEAPF32[i1 >> 2];
   if (d4 - d5 < -3.141592653589793) {
    do d4 = d4 + 6.283185307179586; while (d4 - d5 < -3.141592653589793);
    HEAPF32[i2 >> 2] = d4;
   }
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i6 | 0));
 }
 _polyf_fit(i21, i22, i6, i26, 2);
 i31 = i26 + 4 | 0;
 i32 = i27 + 120 | 0;
 d19 = +HEAPF32[i31 >> 2] * .30000001192092896 + +HEAPF32[i32 >> 2] * .699999988079071;
 HEAPF32[i31 >> 2] = d19;
 HEAPF32[i32 >> 2] = d19;
 if (HEAP32[i27 + 168 >> 2] | 0) {
  _memcpy(HEAP32[i27 + 192 >> 2] | 0, i21 | 0, HEAP32[i20 >> 2] << 2 | 0) | 0;
  _memcpy(HEAP32[i27 + 196 >> 2] | 0, i22 | 0, HEAP32[i20 >> 2] << 2 | 0) | 0;
  HEAPF32[i27 + 200 >> 2] = d19;
  i7 = HEAP32[i26 >> 2] | 0;
  HEAP32[i27 + 204 >> 2] = i7;
  i2 = HEAP32[i27 + 208 >> 2] | 0;
  i3 = i2 + 24 | 0;
  i1 = HEAP32[i2 + 16 >> 2] & (HEAP32[i3 >> 2] | 0) + 1;
  HEAP32[i3 >> 2] = i1;
  if (!i1) {
   i1 = HEAP32[i2 >> 2] | 0;
   i6 = i2 + 4 | 0;
   _memmove(i1 | 0, i1 + (HEAP32[i2 + 12 >> 2] << 2) | 0, (HEAP32[i6 >> 2] << 2) + -4 | 0) | 0;
   i1 = HEAP32[i3 >> 2] | 0;
  } else i6 = i2 + 4 | 0;
  HEAP32[(HEAP32[i2 >> 2] | 0) + (i1 + -1 + (HEAP32[i6 >> 2] | 0) << 2) >> 2] = i7;
  i2 = HEAP32[i27 + 212 >> 2] | 0;
  i3 = i2 + 24 | 0;
  i1 = HEAP32[i2 + 16 >> 2] & (HEAP32[i3 >> 2] | 0) + 1;
  HEAP32[i3 >> 2] = i1;
  if (!i1) {
   i1 = HEAP32[i2 >> 2] | 0;
   i6 = i2 + 4 | 0;
   _memmove(i1 | 0, i1 + (HEAP32[i2 + 12 >> 2] << 2) | 0, (HEAP32[i6 >> 2] << 2) + -4 | 0) | 0;
   i1 = HEAP32[i3 >> 2] | 0;
  } else i6 = i2 + 4 | 0;
  HEAPF32[(HEAP32[i2 >> 2] | 0) + (i1 + -1 + (HEAP32[i6 >> 2] | 0) << 2) >> 2] = d19;
 }
 i1 = HEAP32[i27 >> 2] | 0;
 if (i1 | 0) {
  i6 = i27 + 12 | 0;
  i7 = i27 + 52 | 0;
  i12 = i27 + 4 | 0;
  i13 = i25 + 4 | 0;
  d14 = +HEAPF32[i26 >> 2] + 0.0;
  i3 = 0;
  do {
   if (!(HEAP8[(HEAP32[i6 >> 2] | 0) + i3 >> 0] | 0)) {
    i32 = HEAP32[i7 >> 2] | 0;
    HEAPF32[i32 + (i3 << 3) >> 2] = 0.0;
    HEAPF32[i32 + (i3 << 3) + 4 >> 2] = 0.0;
   } else {
    d9 = +(i3 >>> 0);
    d9 = d14 + (i3 >>> 0 > (HEAP32[i12 >> 2] | 0) >>> 0 ? d9 - +(i1 >>> 0) : d9) * d19;
    d8 = +Math_sin(+-d9);
    d9 = +Math_cos(+d9) + d8 * 0.0;
    i2 = HEAP32[i7 >> 2] | 0;
    i1 = i2 + (i3 << 3) | 0;
    d10 = +HEAPF32[i1 >> 2];
    i2 = i2 + (i3 << 3) + 4 | 0;
    d11 = +HEAPF32[i2 >> 2];
    d5 = d10 * d9 - d8 * d11;
    d4 = d8 * d10 + d9 * d11;
    if ((d5 != d5 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
     ___mulsc3(i25, d10, d11, d9, d8);
     d5 = +HEAPF32[i25 >> 2];
     d4 = +HEAPF32[i13 >> 2];
    }
    HEAPF32[i1 >> 2] = d5;
    HEAPF32[i2 >> 2] = d4;
   }
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i27 >> 2] | 0;
  } while (i3 >>> 0 < i1 >>> 0);
 }
 i6 = i27 + 128 | 0;
 i1 = HEAP32[i6 >> 2] | 0;
 if (!i1) {
  i3 = i27 + 116 | 0;
  i2 = HEAP32[i26 >> 2] | 0;
  i1 = 1;
 } else {
  d19 = +HEAPF32[i26 >> 2];
  i3 = i27 + 116 | 0;
  d4 = d19 - +HEAPF32[i3 >> 2];
  d5 = d4;
  i2 = (HEAPF32[tempDoublePtr >> 2] = d19, HEAP32[tempDoublePtr >> 2] | 0);
  if (d5 > 3.141592653589793) do {
   d4 = d5 + -.6366197723675814;
   d5 = d4;
  } while (d5 > 3.141592653589793);
  d5 = d4;
  if (d5 < -3.141592653589793) do {
   d4 = d5 + .6366197723675814;
   d5 = d4;
  } while (d5 < -3.141592653589793);
  i32 = (HEAP32[i27 + 108 >> 2] | 0) + 8 | 0;
  HEAPF32[i32 >> 2] = d4 * 1.0000000474974513e-03 + +HEAPF32[i32 >> 2];
  i1 = i1 + 1 | 0;
 }
 HEAP32[i3 >> 2] = i2;
 HEAP32[i6 >> 2] = i1;
 STACKTOP = i28;
 return;
}

function _matrixf_inv(i22, i23, i2) {
 i22 = i22 | 0;
 i23 = i23 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, d4 = 0.0, F45 = SIMD_Float32x4(0, 0, 0, 0), i6 = 0, i7 = 0, i8 = 0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i24 = 0, i25 = 0, i26 = 0, F427 = SIMD_Float32x4(0, 0, 0, 0);
 i24 = STACKTOP;
 if ((i23 | 0) != (i2 | 0)) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i3;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i3 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i3 - i1 | 0) >>> 0 < 40) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28008 | 0, 40) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28008 | 0, 40) | 0) >>> 0 < 40) _exit(1); else {
   i6 = 0;
   i7 = gb + 28008 + 40 | 0;
   i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i6 = 40;
   i7 = gb + 28008 | 0;
   i8 = i1;
  } while (0);
  _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
  _exit(1);
 }
 i19 = i23 << 1;
 i21 = (Math_imul(i19, i23) | 0) << 2;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * i21 | 0) + 15 & -16) | 0;
 if (!i23) {
  STACKTOP = i24;
  return;
 }
 i21 = i23 << 2;
 i3 = 0;
 do {
  i1 = Math_imul(i3, i19) | 0;
  _memcpy(i20 + (i1 << 2) | 0, i22 + ((Math_imul(i3, i23) | 0) << 2) | 0, i21 | 0) | 0;
  i1 = i1 + i23 | 0;
  i2 = 0;
  do {
   HEAPF32[i20 + (i1 + i2 << 2) >> 2] = +((i3 | 0) == (i2 | 0) & 1);
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i23 | 0));
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i23 | 0));
 i12 = (i19 | 0) == 0;
 i13 = (i19 | 0) != 0;
 i14 = i19 + -1 | 0;
 i16 = i19 >>> 0 < 4;
 i18 = i19 & -4;
 i15 = (i18 | 0) == (i19 | 0);
 i17 = 0;
 i1 = 0;
 d4 = 0.0;
 while (1) {
  i8 = Math_imul(i17, i19) | 0;
  i2 = i17;
  i11 = i1;
  do {
   d10 = +Math_abs(+(+HEAPF32[i20 + ((Math_imul(i2, i19) | 0) + i17 << 2) >> 2]));
   i7 = (i2 | 0) == (i17 | 0) | d10 > d4;
   d4 = i7 ? d10 : d4;
   i11 = i7 ? i2 : i11;
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i23 | 0));
  i6 = i20 + (i8 << 2) | 0;
  i7 = i20 + (i8 + i14 << 2) | 0;
  L37 : do if (d4 == 0.0) {
   i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i2;
     HEAP32[gb + 8728 + 20 >> 2] = i2;
     i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i1;
     break;
    } else {
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     break L37;
    }
   } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
   if ((i1 - i2 | 0) >>> 0 < 63) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28049 | 0, 63) | 0;
    break;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28049 | 0, 63) | 0) >>> 0 < 63) break;
    i1 = 0;
    i3 = gb + 28049 + 63 | 0;
    i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i1 = 63;
    i3 = gb + 28049 | 0;
   }
   _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  } while (0);
  if (i13 & (i17 | 0) != (i11 | 0)) {
   i1 = Math_imul(i11, i19) | 0;
   i2 = 0;
   do {
    i26 = i20 + (i2 + i8 << 2) | 0;
    i25 = HEAP32[i26 >> 2] | 0;
    i3 = i20 + (i2 + i1 << 2) | 0;
    HEAP32[i26 >> 2] = HEAP32[i3 >> 2];
    HEAP32[i3 >> 2] = i25;
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i19 | 0));
  }
  d10 = +HEAPF32[i20 + (i8 + i17 << 2) >> 2];
  L59 : do if (!(d10 == 0.0)) {
   if (!i12) {
    if (i16) {
     i3 = 0;
     while (1) {
      i1 = Math_imul(i3, i19) | 0;
      if ((i3 | 0) != (i17 | 0)) {
       d9 = +HEAPF32[i20 + (i1 + i17 << 2) >> 2] / d10;
       i2 = 0;
       do {
        i26 = i20 + (i2 + i1 << 2) | 0;
        HEAPF32[i26 >> 2] = d9 * +HEAPF32[i20 + (i2 + i8 << 2) >> 2] - +HEAPF32[i26 >> 2];
        i2 = i2 + 1 | 0;
       } while ((i2 | 0) != (i19 | 0));
      }
      i3 = i3 + 1 | 0;
      if ((i3 | 0) == (i23 | 0)) break L59;
     }
    } else i3 = 0;
    do {
     i2 = Math_imul(i3, i19) | 0;
     do if ((i3 | 0) != (i17 | 0)) {
      d9 = +HEAPF32[i20 + (i2 + i17 << 2) >> 2] / d10;
      if (!((i20 + (i2 << 2) | 0) >>> 0 <= i7 >>> 0 ? i6 >>> 0 <= (i20 + (i2 + i14 << 2) | 0) >>> 0 : 0)) {
       F45 = SIMD_Float32x4_splat(Math_fround(d9));
       i1 = 0;
       do {
        F427 = SIMD_Float32x4_mul(F45, SIMD_Float32x4_load(HEAPU8, i20 + (i1 + i8 << 2) | 0));
        i26 = i20 + (i1 + i2 << 2) | 0;
        i25 = i26;
        SIMD_Float32x4_store(HEAPU8, i25, SIMD_Float32x4_sub(F427, SIMD_Float32x4_load(HEAPU8, i26)));
        i1 = i1 + 4 | 0;
       } while ((i1 | 0) != (i18 | 0));
       if (i15) break; else i1 = i18;
      } else i1 = 0;
      do {
       i26 = i20 + (i1 + i2 << 2) | 0;
       HEAPF32[i26 >> 2] = d9 * +HEAPF32[i20 + (i1 + i8 << 2) >> 2] - +HEAPF32[i26 >> 2];
       i1 = i1 + 1 | 0;
      } while ((i1 | 0) != (i19 | 0));
     } while (0);
     i3 = i3 + 1 | 0;
    } while ((i3 | 0) != (i23 | 0));
   }
  } else {
   i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i2;
     HEAP32[gb + 8728 + 20 >> 2] = i2;
     i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i1;
     break;
    } else {
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     break L59;
    }
   } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
   if ((i1 - i2 | 0) >>> 0 < 42) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28113 | 0, 42) | 0;
    break;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28113 | 0, 42) | 0) >>> 0 < 42) break;
    i1 = 0;
    i3 = gb + 28113 + 42 | 0;
    i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i1 = 42;
    i3 = gb + 28113 | 0;
   }
   _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  } while (0);
  i17 = i17 + 1 | 0;
  if ((i17 | 0) == (i23 | 0)) break; else i1 = i11;
 }
 L99 : do if (i12) i1 = 0; else {
  if (i16) {
   i3 = 0;
   while (1) {
    i1 = Math_imul(i3, i19) | 0;
    d4 = 1.0 / +HEAPF32[i20 + (i1 + i3 << 2) >> 2];
    i2 = 0;
    do {
     i26 = i20 + (i2 + i1 << 2) | 0;
     HEAPF32[i26 >> 2] = d4 * +HEAPF32[i26 >> 2];
     i2 = i2 + 1 | 0;
    } while ((i2 | 0) != (i19 | 0));
    i3 = i3 + 1 | 0;
    if ((i3 | 0) == (i23 | 0)) {
     i1 = 0;
     break L99;
    }
   }
  }
  if (i15) {
   i3 = 0;
   while (1) {
    i1 = Math_imul(i3, i19) | 0;
    F45 = SIMD_Float32x4_splat(Math_fround(1.0 / +HEAPF32[i20 + (i1 + i3 << 2) >> 2]));
    i2 = 0;
    do {
     i26 = i20 + (i2 + i1 << 2) | 0;
     i25 = i26;
     SIMD_Float32x4_store(HEAPU8, i25, SIMD_Float32x4_mul(F45, SIMD_Float32x4_load(HEAPU8, i26)));
     i2 = i2 + 4 | 0;
    } while ((i2 | 0) != (i19 | 0));
    i3 = i3 + 1 | 0;
    if ((i3 | 0) == (i23 | 0)) {
     i1 = 0;
     break L99;
    }
   }
  } else i3 = 0;
  do {
   i2 = Math_imul(i3, i19) | 0;
   d4 = 1.0 / +HEAPF32[i20 + (i2 + i3 << 2) >> 2];
   F45 = SIMD_Float32x4_splat(Math_fround(d4));
   i1 = 0;
   do {
    i26 = i20 + (i1 + i2 << 2) | 0;
    i25 = i26;
    SIMD_Float32x4_store(HEAPU8, i25, SIMD_Float32x4_mul(F45, SIMD_Float32x4_load(HEAPU8, i26)));
    i1 = i1 + 4 | 0;
   } while ((i1 | 0) != (i18 | 0));
   i1 = i18;
   do {
    i26 = i20 + (i1 + i2 << 2) | 0;
    HEAPF32[i26 >> 2] = d4 * +HEAPF32[i26 >> 2];
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i19 | 0));
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i23 | 0));
  i1 = 0;
 } while (0);
 do {
  _memcpy(i22 + ((Math_imul(i1, i23) | 0) << 2) | 0, i20 + ((Math_imul(i1, i19) | 0) + i23 << 2) | 0, i21 | 0) | 0;
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i23 | 0));
 STACKTOP = i24;
 return;
}

function _modem_create_qam(i20) {
 i20 = i20 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0;
 if (!i20) {
  i5 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i5) {
   i5 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i5 + 255 | i5;
   i5 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i5 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i4;
    HEAP32[gb + 8728 + 20 >> 2] = i4;
    i6 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i6;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i5 | 32;
   _exit(1);
  } else {
   i6 = i5;
   i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i6 - i4 | 0) >>> 0 < 66) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28726 | 0, 66) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28726 | 0, 66) | 0) >>> 0 < 66) _exit(1); else {
   i7 = 0;
   i8 = gb + 28726 + 66 | 0;
   i9 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i7 = 66;
   i8 = gb + 28726 | 0;
   i9 = i4;
  } while (0);
  _memcpy(i9 | 0, i8 | 0, i7 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i7;
  _exit(1);
 }
 i14 = _malloc(252) | 0;
 if (i20 >>> 0 > 16) {
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i10 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i10;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i10 = i4;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i10 - i2 | 0) >>> 0 < 64) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28793 | 0, 64) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28793 | 0, 64) | 0) >>> 0 < 64) _exit(1); else {
   i11 = 0;
   i12 = gb + 28793 + 64 | 0;
   i13 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i11 = 64;
   i12 = gb + 28793 | 0;
   i13 = i2;
  } while (0);
  _memcpy(i13 | 0, i12 | 0, i11 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i11;
  _exit(1);
 }
 i8 = i14 + 76 | 0;
 HEAP32[i8 >> 2] = 0;
 i9 = i14 + 80 | 0;
 HEAP32[i9 >> 2] = 0;
 i10 = i14 + 4 | 0;
 HEAP32[i10 >> 2] = i20;
 i6 = 1 << i20;
 i7 = i14 + 8 | 0;
 HEAP32[i7 >> 2] = i6;
 i11 = i14 + 236 | 0;
 HEAP32[i11 >> 2] = 0;
 HEAP32[i11 + 4 >> 2] = 0;
 HEAP32[i11 + 8 >> 2] = 0;
 HEAP32[i11 + 12 >> 2] = 0;
 if (!(i20 & 1)) {
  i5 = i20 >>> 1;
  HEAP32[i14 + 100 >> 2] = i5;
  i12 = i14 + 104 | 0;
  HEAP32[i12 >> 2] = i5;
  i4 = i5;
 } else {
  i4 = (i20 + 1 | 0) >>> 1;
  HEAP32[i14 + 100 >> 2] = i4;
  i5 = (i20 + -1 | 0) >>> 1;
  i12 = i14 + 104 | 0;
  HEAP32[i12 >> 2] = i5;
 }
 i2 = 1 << i4;
 HEAP32[i14 + 108 >> 2] = i2;
 HEAP32[i14 + 112 >> 2] = 1 << i5;
 if ((i4 + i5 | 0) != (i20 | 0)) ___assert_fail(gb + 28858 | 0, gb + 28900 | 0, 54, gb + 28926 | 0);
 if ((i2 << i5 | 0) != (i6 | 0)) ___assert_fail(gb + 28943 | 0, gb + 28900 | 0, 55, gb + 28926 | 0);
 L55 : do if ((i6 | 0) >= 512) {
  if ((i6 | 0) < 8192) switch (i6 | 0) {
  case 512:
   {
    i4 = i14 + 116 | 0;
    HEAPF32[i4 >> 2] = .048450157046318054;
    HEAP32[i14 >> 2] = 32;
    d3 = .048450157046318054;
    i16 = 36;
    break L55;
   }
  case 1024:
   {
    i4 = i14 + 116 | 0;
    HEAPF32[i4 >> 2] = .03829197958111763;
    HEAP32[i14 >> 2] = 33;
    d3 = .03829197958111763;
    i16 = 36;
    break L55;
   }
  case 2048:
   {
    i4 = i14 + 116 | 0;
    HEAPF32[i4 >> 2] = .02421087585389614;
    HEAP32[i14 >> 2] = 34;
    d3 = .02421087585389614;
    i16 = 36;
    break L55;
   }
  case 4096:
   {
    i4 = i14 + 116 | 0;
    HEAPF32[i4 >> 2] = .01913897506892681;
    HEAP32[i14 >> 2] = 35;
    d3 = .01913897506892681;
    i16 = 36;
    break L55;
   }
  default:
   break L55;
  }
  if ((i6 | 0) < 32768) if ((i6 | 0) < 16384) {
   switch (i6 | 0) {
   case 8192:
    break;
   default:
    break L55;
   }
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .012103663757443428;
   HEAP32[i14 >> 2] = 36;
   d3 = .012103663757443428;
   i16 = 36;
   break;
  } else {
   switch (i6 | 0) {
   case 16384:
    break;
   default:
    break L55;
   }
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .009568611159920692;
   HEAP32[i14 >> 2] = 37;
   d3 = .009568611159920692;
   i16 = 36;
   break;
  } else if ((i6 | 0) < 65536) {
   switch (i6 | 0) {
   case 32768:
    break;
   default:
    break L55;
   }
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = 6.0516102239489555e-03;
   HEAP32[i14 >> 2] = 38;
   d3 = 6.0516102239489555e-03;
   i16 = 36;
   break;
  } else {
   switch (i6 | 0) {
   case 65536:
    break;
   default:
    break L55;
   }
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .004784196149557829;
   HEAP32[i14 >> 2] = 39;
   d3 = .004784196149557829;
   i16 = 36;
   break;
  }
 } else switch (i6 | 0) {
 case 4:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .7071067690849304;
   HEAP32[i14 >> 2] = 25;
   d3 = .7071067690849304;
   i16 = 36;
   break L55;
  }
 case 8:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .40824830532073975;
   HEAP32[i14 >> 2] = 26;
   d3 = .40824830532073975;
   i16 = 36;
   break L55;
  }
 case 16:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .3162277638912201;
   HEAP32[i14 >> 2] = 27;
   d3 = .3162277638912201;
   i16 = 36;
   break L55;
  }
 case 32:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .1961161345243454;
   HEAP32[i14 >> 2] = 28;
   d3 = .1961161345243454;
   i16 = 36;
   break L55;
  }
 case 64:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .15430335700511932;
   HEAP32[i14 >> 2] = 29;
   d3 = .15430335700511932;
   i16 = 36;
   break L55;
  }
 case 128:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .09712858498096466;
   HEAP32[i14 >> 2] = 30;
   d3 = .09712858498096466;
   i16 = 36;
   break L55;
  }
 case 256:
  {
   i4 = i14 + 116 | 0;
   HEAPF32[i4 >> 2] = .0766965001821518;
   HEAP32[i14 >> 2] = 31;
   d3 = .0766965001821518;
   i16 = 36;
   break L55;
  }
 default:
  break L55;
 } while (0);
 if ((i16 | 0) == 36) {
  i2 = i14 + 12 | 0;
  HEAPF32[i2 >> 2] = d3;
  if (i20 >>> 0 > 1 ? (HEAPF32[i14 + 16 >> 2] = d3 * 2.0, i20 >>> 0 > 2) : 0) {
   i1 = 2;
   do {
    HEAPF32[i2 + (i1 << 2) >> 2] = +HEAPF32[i4 >> 2] * +(1 << i1 | 0);
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < (HEAP32[i10 >> 2] | 0) >>> 0);
   i1 = HEAP32[i7 >> 2] | 0;
  } else i1 = i6;
  HEAP32[i11 >> 2] = fb + 19;
  HEAP32[i14 + 240 >> 2] = fb + 20;
  HEAP32[i8 >> 2] = _malloc(i1 << 3) | 0;
  _modem_init_map(i14);
  HEAP32[i9 >> 2] = 1;
  i1 = HEAP32[i10 >> 2] | 0;
  if ((i1 | 0) != 3) {
   if (i1 >>> 0 > 3) _modem_demodsoft_gentab(i14, 4);
  } else _modem_demodsoft_gentab(i14, 3);
  HEAPF32[i14 + 84 >> 2] = 1.0;
  HEAPF32[i14 + 88 >> 2] = 0.0;
  HEAP32[i14 + 92 >> 2] = 1065353216;
  HEAPF32[i14 + 96 >> 2] = 0.0;
  if (((HEAP32[i14 >> 2] | 0) + -9 | 0) >>> 0 >= 8) return i14 | 0;
  HEAPF32[i12 >> 2] = 0.0;
  return i14 | 0;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i15 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i15;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i15 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i15 - i1 | 0) >>> 0 < 58) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28985 | 0, 58) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28985 | 0, 58) | 0) >>> 0 < 58) _exit(1); else {
  i17 = 0;
  i18 = gb + 28985 + 58 | 0;
  i19 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i17 = 58;
  i18 = gb + 28985 | 0;
  i19 = i1;
 } while (0);
 _memcpy(i19 | 0, i18 | 0, i17 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i17;
 _exit(1);
 return 0;
}
function _hashlittle(i4, i3, i1) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i2 = 0, i5 = 0, i6 = 0, i7 = 0;
 i6 = i3 + -559038737 + i1 | 0;
 i1 = i4;
 L1 : do if (i1 & 3) if (!(i1 & 1)) {
  if (i3 >>> 0 > 12) {
   i2 = i6;
   i5 = i6;
   i1 = i6;
   do {
    i5 = ((HEAPU16[i4 + 6 >> 1] | 0) << 16 | (HEAPU16[i4 + 4 >> 1] | 0)) + i5 | 0;
    i1 = ((HEAPU16[i4 + 10 >> 1] | 0) << 16 | (HEAPU16[i4 + 8 >> 1] | 0)) + i1 | 0;
    i2 = (i1 << 4 | i1 >>> 28) ^ ((HEAPU16[i4 + 2 >> 1] | 0) << 16 | (HEAPU16[i4 >> 1] | 0)) + i2 - i1;
    i1 = i1 + i5 | 0;
    i5 = (i2 << 6 | i2 >>> 26) ^ i5 - i2;
    i2 = i2 + i1 | 0;
    i1 = (i5 << 8 | i5 >>> 24) ^ i1 - i5;
    i5 = i5 + i2 | 0;
    i2 = (i1 << 16 | i1 >>> 16) ^ i2 - i1;
    i1 = i1 + i5 | 0;
    i5 = (i2 << 19 | i2 >>> 13) ^ i5 - i2;
    i2 = i2 + i1 | 0;
    i1 = (i5 << 4 | i5 >>> 28) ^ i1 - i5;
    i5 = i5 + i2 | 0;
    i3 = i3 + -12 | 0;
    i4 = i4 + 12 | 0;
   } while (i3 >>> 0 > 12);
  } else {
   i2 = i6;
   i5 = i6;
   i1 = i6;
  }
  switch (i3 | 0) {
  case 12:
   {
    i2 = ((HEAPU16[i4 + 2 >> 1] | 0) << 16 | (HEAPU16[i4 >> 1] | 0)) + i2 | 0;
    i3 = ((HEAPU16[i4 + 6 >> 1] | 0) << 16 | (HEAPU16[i4 + 4 >> 1] | 0)) + i5 | 0;
    i1 = ((HEAPU16[i4 + 10 >> 1] | 0) << 16 | (HEAPU16[i4 + 8 >> 1] | 0)) + i1 | 0;
    break L1;
   }
  case 11:
   {
    i1 = ((HEAPU8[i4 + 10 >> 0] | 0) << 16) + i1 | 0;
    i7 = 24;
    break;
   }
  case 10:
   {
    i7 = 24;
    break;
   }
  case 9:
   {
    i1 = (HEAPU8[i4 + 8 >> 0] | 0) + i1 | 0;
    i7 = 26;
    break;
   }
  case 8:
   {
    i7 = 26;
    break;
   }
  case 7:
   {
    i3 = ((HEAPU8[i4 + 6 >> 0] | 0) << 16) + i5 | 0;
    i7 = 28;
    break;
   }
  case 6:
   {
    i3 = i5;
    i7 = 28;
    break;
   }
  case 5:
   {
    i3 = (HEAPU8[i4 + 4 >> 0] | 0) + i5 | 0;
    i7 = 30;
    break;
   }
  case 4:
   {
    i3 = i5;
    i7 = 30;
    break;
   }
  case 3:
   {
    i2 = ((HEAPU8[i4 + 2 >> 0] | 0) << 16) + i2 | 0;
    i7 = 32;
    break;
   }
  case 2:
   {
    i7 = 32;
    break;
   }
  case 1:
   {
    i2 = (HEAPU8[i4 >> 0] | 0) + i2 | 0;
    i3 = i5;
    break L1;
   }
  case 0:
   {
    i7 = i1;
    return i7 | 0;
   }
  default:
   {
    i3 = i5;
    break L1;
   }
  }
  if ((i7 | 0) == 24) {
   i2 = ((HEAPU16[i4 + 2 >> 1] | 0) << 16 | (HEAPU16[i4 >> 1] | 0)) + i2 | 0;
   i3 = ((HEAPU16[i4 + 6 >> 1] | 0) << 16 | (HEAPU16[i4 + 4 >> 1] | 0)) + i5 | 0;
   i1 = (HEAPU16[i4 + 8 >> 1] | 0) + i1 | 0;
   break;
  } else if ((i7 | 0) == 26) {
   i2 = ((HEAPU16[i4 + 2 >> 1] | 0) << 16 | (HEAPU16[i4 >> 1] | 0)) + i2 | 0;
   i3 = ((HEAPU16[i4 + 6 >> 1] | 0) << 16 | (HEAPU16[i4 + 4 >> 1] | 0)) + i5 | 0;
   break;
  } else if ((i7 | 0) == 28) {
   i2 = ((HEAPU16[i4 + 2 >> 1] | 0) << 16 | (HEAPU16[i4 >> 1] | 0)) + i2 | 0;
   i3 = (HEAPU16[i4 + 4 >> 1] | 0) + i3 | 0;
   break;
  } else if ((i7 | 0) == 30) {
   i2 = ((HEAPU16[i4 + 2 >> 1] | 0) << 16 | (HEAPU16[i4 >> 1] | 0)) + i2 | 0;
   break;
  } else if ((i7 | 0) == 32) {
   i2 = (HEAPU16[i4 >> 1] | 0) + i2 | 0;
   i3 = i5;
   break;
  }
 } else {
  if (i3 >>> 0 > 12) {
   i2 = i6;
   i5 = i6;
   i1 = i6;
   do {
    i5 = (HEAPU8[i4 + 4 >> 0] | 0) + i5 + ((HEAPU8[i4 + 5 >> 0] | 0) << 8) + ((HEAPU8[i4 + 6 >> 0] | 0) << 16) + ((HEAPU8[i4 + 7 >> 0] | 0) << 24) | 0;
    i1 = (HEAPU8[i4 + 8 >> 0] | 0) + i1 + ((HEAPU8[i4 + 9 >> 0] | 0) << 8) + ((HEAPU8[i4 + 10 >> 0] | 0) << 16) + ((HEAPU8[i4 + 11 >> 0] | 0) << 24) | 0;
    i2 = (i1 << 4 | i1 >>> 28) ^ (HEAPU8[i4 >> 0] | 0) + i2 + ((HEAPU8[i4 + 1 >> 0] | 0) << 8) + ((HEAPU8[i4 + 2 >> 0] | 0) << 16) + ((HEAPU8[i4 + 3 >> 0] | 0) << 24) - i1;
    i1 = i1 + i5 | 0;
    i5 = (i2 << 6 | i2 >>> 26) ^ i5 - i2;
    i2 = i2 + i1 | 0;
    i1 = (i5 << 8 | i5 >>> 24) ^ i1 - i5;
    i5 = i5 + i2 | 0;
    i2 = (i1 << 16 | i1 >>> 16) ^ i2 - i1;
    i1 = i1 + i5 | 0;
    i5 = (i2 << 19 | i2 >>> 13) ^ i5 - i2;
    i2 = i2 + i1 | 0;
    i1 = (i5 << 4 | i5 >>> 28) ^ i1 - i5;
    i5 = i5 + i2 | 0;
    i3 = i3 + -12 | 0;
    i4 = i4 + 12 | 0;
   } while (i3 >>> 0 > 12);
  } else {
   i2 = i6;
   i5 = i6;
   i1 = i6;
  }
  switch (i3 | 0) {
  case 12:
   {
    i1 = ((HEAPU8[i4 + 11 >> 0] | 0) << 24) + i1 | 0;
    i7 = 37;
    break;
   }
  case 11:
   {
    i7 = 37;
    break;
   }
  case 10:
   {
    i7 = 38;
    break;
   }
  case 9:
   {
    i7 = 39;
    break;
   }
  case 8:
   {
    i7 = 40;
    break;
   }
  case 7:
   {
    i3 = i5;
    i7 = 41;
    break;
   }
  case 6:
   {
    i3 = i5;
    i7 = 42;
    break;
   }
  case 5:
   {
    i3 = i5;
    i7 = 43;
    break;
   }
  case 4:
   {
    i3 = i5;
    i7 = 44;
    break;
   }
  case 3:
   {
    i3 = i5;
    i7 = 45;
    break;
   }
  case 2:
   {
    i3 = i5;
    i7 = 46;
    break;
   }
  case 1:
   {
    i3 = i5;
    break;
   }
  case 0:
   {
    i7 = i1;
    return i7 | 0;
   }
  default:
   {
    i3 = i5;
    break L1;
   }
  }
  if ((i7 | 0) == 37) {
   i1 = ((HEAPU8[i4 + 10 >> 0] | 0) << 16) + i1 | 0;
   i7 = 38;
  }
  if ((i7 | 0) == 38) {
   i1 = ((HEAPU8[i4 + 9 >> 0] | 0) << 8) + i1 | 0;
   i7 = 39;
  }
  if ((i7 | 0) == 39) {
   i1 = (HEAPU8[i4 + 8 >> 0] | 0) + i1 | 0;
   i7 = 40;
  }
  if ((i7 | 0) == 40) {
   i3 = ((HEAPU8[i4 + 7 >> 0] | 0) << 24) + i5 | 0;
   i7 = 41;
  }
  if ((i7 | 0) == 41) {
   i3 = ((HEAPU8[i4 + 6 >> 0] | 0) << 16) + i3 | 0;
   i7 = 42;
  }
  if ((i7 | 0) == 42) {
   i3 = ((HEAPU8[i4 + 5 >> 0] | 0) << 8) + i3 | 0;
   i7 = 43;
  }
  if ((i7 | 0) == 43) {
   i3 = (HEAPU8[i4 + 4 >> 0] | 0) + i3 | 0;
   i7 = 44;
  }
  if ((i7 | 0) == 44) {
   i2 = ((HEAPU8[i4 + 3 >> 0] | 0) << 24) + i2 | 0;
   i7 = 45;
  }
  if ((i7 | 0) == 45) {
   i2 = ((HEAPU8[i4 + 2 >> 0] | 0) << 16) + i2 | 0;
   i7 = 46;
  }
  if ((i7 | 0) == 46) i2 = ((HEAPU8[i4 + 1 >> 0] | 0) << 8) + i2 | 0;
  i2 = (HEAPU8[i4 >> 0] | 0) + i2 | 0;
  break;
 } else {
  if (i3 >>> 0 > 12) {
   i2 = i6;
   i5 = i6;
   i1 = i6;
   do {
    i5 = (HEAP32[i4 + 4 >> 2] | 0) + i5 | 0;
    i1 = (HEAP32[i4 + 8 >> 2] | 0) + i1 | 0;
    i2 = (i1 << 4 | i1 >>> 28) ^ (HEAP32[i4 >> 2] | 0) + i2 - i1;
    i1 = i1 + i5 | 0;
    i5 = (i2 << 6 | i2 >>> 26) ^ i5 - i2;
    i2 = i2 + i1 | 0;
    i1 = (i5 << 8 | i5 >>> 24) ^ i1 - i5;
    i5 = i5 + i2 | 0;
    i2 = (i1 << 16 | i1 >>> 16) ^ i2 - i1;
    i1 = i1 + i5 | 0;
    i5 = (i2 << 19 | i2 >>> 13) ^ i5 - i2;
    i2 = i2 + i1 | 0;
    i1 = (i5 << 4 | i5 >>> 28) ^ i1 - i5;
    i5 = i5 + i2 | 0;
    i3 = i3 + -12 | 0;
    i4 = i4 + 12 | 0;
   } while (i3 >>> 0 > 12);
  } else {
   i2 = i6;
   i5 = i6;
   i1 = i6;
  }
  do switch (i3 | 0) {
  case 12:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] | 0) + i5 | 0;
    i1 = (HEAP32[i4 + 8 >> 2] | 0) + i1 | 0;
    break L1;
   }
  case 11:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] | 0) + i5 | 0;
    i1 = (HEAP32[i4 + 8 >> 2] & 16777215) + i1 | 0;
    break L1;
   }
  case 10:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] | 0) + i5 | 0;
    i1 = (HEAP32[i4 + 8 >> 2] & 65535) + i1 | 0;
    break L1;
   }
  case 9:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] | 0) + i5 | 0;
    i1 = (HEAP32[i4 + 8 >> 2] & 255) + i1 | 0;
    break L1;
   }
  case 8:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] | 0) + i5 | 0;
    break L1;
   }
  case 7:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] & 16777215) + i5 | 0;
    break L1;
   }
  case 6:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] & 65535) + i5 | 0;
    break L1;
   }
  case 5:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = (HEAP32[i4 + 4 >> 2] & 255) + i5 | 0;
    break L1;
   }
  case 4:
   {
    i2 = (HEAP32[i4 >> 2] | 0) + i2 | 0;
    i3 = i5;
    break L1;
   }
  case 3:
   {
    i2 = (HEAP32[i4 >> 2] & 16777215) + i2 | 0;
    i3 = i5;
    break L1;
   }
  case 2:
   {
    i2 = (HEAP32[i4 >> 2] & 65535) + i2 | 0;
    i3 = i5;
    break L1;
   }
  case 1:
   {
    i2 = (HEAP32[i4 >> 2] & 255) + i2 | 0;
    i3 = i5;
    break L1;
   }
  case 0:
   {
    i7 = i1;
    return i7 | 0;
   }
  default:
   {
    i3 = i5;
    break L1;
   }
  } while (0);
 } while (0);
 i6 = (i1 ^ i3) - (i3 << 14 | i3 >>> 18) | 0;
 i7 = (i6 ^ i2) - (i6 << 11 | i6 >>> 21) | 0;
 i5 = (i7 ^ i3) - (i7 << 25 | i7 >>> 7) | 0;
 i6 = (i5 ^ i6) - (i5 << 16 | i5 >>> 16) | 0;
 i7 = (i6 ^ i7) - (i6 << 4 | i6 >>> 28) | 0;
 i7 = (i7 ^ i5) - (i7 << 14 | i7 >>> 18) | 0;
 i7 = (i7 ^ i6) - (i7 << 24 | i7 >>> 8) | 0;
 return i7 | 0;
}

function ___divdc3(i15, d13, d14, d6, d7) {
 i15 = i15 | 0;
 d13 = +d13;
 d14 = +d14;
 d6 = +d6;
 d7 = +d7;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, d8 = 0.0, i9 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, i16 = 0;
 d2 = +Math_abs(+d6);
 d3 = +Math_abs(+d7);
 HEAPF64[tempDoublePtr >> 3] = d2;
 i9 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 if (!(i9 >>> 0 > 2146435072 | (i9 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0)) {
  HEAPF64[tempDoublePtr >> 3] = d3;
  i9 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  if (!(i9 >>> 0 > 2146435072 | (i9 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0)) d2 = d2 < d3 ? d3 : d2;
 } else d2 = d3;
 HEAPF64[tempDoublePtr >> 3] = d2;
 i4 = HEAP32[tempDoublePtr >> 2] | 0;
 i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i9 = i5 & 2146435072;
 do if (i9 >>> 0 < 2146435072 | (i9 | 0) == 2146435072 & 0 < 0) {
  if (d2 == 0.0) {
   d11 = -1.0 / (d2 * d2);
   break;
  }
  i1 = _bitshift64Lshr(i4 | 0, i5 | 0, 52) | 0;
  getTempRet0() | 0;
  i1 = i1 & 2047;
  switch (i1 | 0) {
  case 0:
   {
    i1 = _bitshift64Shl(i4 | 0, i5 | 0, 12) | 0;
    i4 = getTempRet0() | 0;
    if (!((i1 | 0) == 0 & (i4 | 0) == 0)) if ((i4 | 0) > -1 | (i4 | 0) == -1 & i1 >>> 0 > 4294967295) {
     i5 = i1;
     i1 = -1023;
     do {
      i1 = i1 + -1 | 0;
      i5 = _bitshift64Shl(i5 | 0, i4 | 0, 1) | 0;
      i4 = getTempRet0() | 0;
     } while ((i4 | 0) > -1 | (i4 | 0) == -1 & i5 >>> 0 > 4294967295);
    } else i1 = -1023; else i1 = -2147483648;
    break;
   }
  case 2047:
   {
    i1 = (i4 | 0) != 0 | (i5 & 1048575 | 0) != 0 ? -2147483648 : 2147483647;
    break;
   }
  default:
   i1 = i1 + -1023 | 0;
  }
  d11 = +(i1 | 0);
 } else d11 = d2 * d2; while (0);
 d12 = +Math_abs(+d11);
 if (d11 == d11 & 0.0 == 0.0 & d12 != inf) {
  i4 = ~~d11;
  i1 = 0 - i4 | 0;
  do if ((i4 | 0) < -1023) {
   d2 = d6 * 8988465674311579538646525.0e283;
   i1 = -1023 - i4 | 0;
   if ((i1 | 0) > 1023) {
    i1 = -2046 - i4 | 0;
    i1 = (i1 | 0) > 1023 ? 1023 : i1;
    i5 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
    i9 = getTempRet0() | 0;
    HEAP32[tempDoublePtr >> 2] = i5;
    HEAP32[tempDoublePtr + 4 >> 2] = i9;
    d3 = d2 * 8988465674311579538646525.0e283 * +HEAPF64[tempDoublePtr >> 3];
    d2 = d7 * 8988465674311579538646525.0e283 * 8988465674311579538646525.0e283;
    break;
   } else {
    i5 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
    i9 = getTempRet0() | 0;
    HEAP32[tempDoublePtr >> 2] = i5;
    HEAP32[tempDoublePtr + 4 >> 2] = i9;
    d3 = d2 * +HEAPF64[tempDoublePtr >> 3];
    d2 = d7 * 8988465674311579538646525.0e283;
    break;
   }
  } else {
   if ((i4 | 0) <= 1022) {
    i5 = _bitshift64Shl(1023 - i4 | 0, 0, 52) | 0;
    i9 = getTempRet0() | 0;
    HEAP32[tempDoublePtr >> 2] = i5;
    HEAP32[tempDoublePtr + 4 >> 2] = i9;
    d3 = +HEAPF64[tempDoublePtr >> 3] * d6;
    d2 = d7;
    break;
   }
   d2 = d6 * 2.2250738585072014e-308;
   i1 = 1022 - i4 | 0;
   if ((i1 | 0) < -1022) {
    i1 = 2044 - i4 | 0;
    i1 = (i1 | 0) < -1022 ? -1022 : i1;
    i5 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
    i9 = getTempRet0() | 0;
    HEAP32[tempDoublePtr >> 2] = i5;
    HEAP32[tempDoublePtr + 4 >> 2] = i9;
    d3 = d2 * 2.2250738585072014e-308 * +HEAPF64[tempDoublePtr >> 3];
    d2 = d7 * 2.2250738585072014e-308 * 2.2250738585072014e-308;
    break;
   } else {
    i5 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
    i9 = getTempRet0() | 0;
    HEAP32[tempDoublePtr >> 2] = i5;
    HEAP32[tempDoublePtr + 4 >> 2] = i9;
    d3 = d2 * +HEAPF64[tempDoublePtr >> 3];
    d2 = d7 * 2.2250738585072014e-308;
    break;
   }
  } while (0);
  i5 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
  i9 = getTempRet0() | 0;
  HEAP32[tempDoublePtr >> 2] = i5;
  HEAP32[tempDoublePtr + 4 >> 2] = i9;
  d10 = d2 * +HEAPF64[tempDoublePtr >> 3];
  i9 = i4;
 } else {
  d10 = d7;
  d3 = d6;
  i9 = 0;
 }
 d6 = d3 * d3 + d10 * d10;
 d2 = (d3 * d13 + d10 * d14) / d6;
 i1 = 0 - i9 | 0;
 i5 = (i9 | 0) < -1023;
 if (i5) {
  d2 = d2 * 8988465674311579538646525.0e283;
  i4 = -1023 - i9 | 0;
  if ((i4 | 0) > 1023) {
   i4 = -2046 - i9 | 0;
   i4 = (i4 | 0) > 1023 ? 1023 : i4;
   d2 = d2 * 8988465674311579538646525.0e283;
  }
 } else if ((i9 | 0) > 1022) {
  d2 = d2 * 2.2250738585072014e-308;
  i4 = 1022 - i9 | 0;
  if ((i4 | 0) < -1022) {
   i4 = 2044 - i9 | 0;
   i4 = (i4 | 0) < -1022 ? -1022 : i4;
   d2 = d2 * 2.2250738585072014e-308;
  }
 } else i4 = i1;
 i16 = _bitshift64Shl(i4 + 1023 | 0, 0, 52) | 0;
 i4 = getTempRet0() | 0;
 HEAP32[tempDoublePtr >> 2] = i16;
 HEAP32[tempDoublePtr + 4 >> 2] = i4;
 d8 = d2 * +HEAPF64[tempDoublePtr >> 3];
 d2 = (d3 * d14 - d10 * d13) / d6;
 if (i5) {
  d2 = d2 * 8988465674311579538646525.0e283;
  i1 = -1023 - i9 | 0;
  if ((i1 | 0) > 1023) {
   i1 = -2046 - i9 | 0;
   i1 = (i1 | 0) > 1023 ? 1023 : i1;
   d2 = d2 * 8988465674311579538646525.0e283;
  }
 } else if ((i9 | 0) > 1022) {
  d2 = d2 * 2.2250738585072014e-308;
  i1 = 1022 - i9 | 0;
  if ((i1 | 0) < -1022) {
   i1 = 2044 - i9 | 0;
   i1 = (i1 | 0) < -1022 ? -1022 : i1;
   d2 = d2 * 2.2250738585072014e-308;
  }
 }
 i9 = _bitshift64Shl(i1 + 1023 | 0, 0, 52) | 0;
 i16 = getTempRet0() | 0;
 HEAP32[tempDoublePtr >> 2] = i9;
 HEAP32[tempDoublePtr + 4 >> 2] = i16;
 d7 = d2 * +HEAPF64[tempDoublePtr >> 3];
 if (!((d8 != d8 | 0.0 != 0.0) & (d7 != d7 | 0.0 != 0.0))) {
  d13 = d8;
  d14 = d7;
  i16 = i15 + 8 | 0;
  HEAPF64[i15 >> 3] = d13;
  HEAPF64[i16 >> 3] = d14;
  return;
 }
 if (d6 == 0.0 ? !((d13 != d13 | 0.0 != 0.0) & (d14 != d14 | 0.0 != 0.0)) : 0) {
  HEAPF64[tempDoublePtr >> 3] = d3;
  i16 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d12 = +Math_abs(inf);
  HEAPF64[tempDoublePtr >> 3] = d12;
  i16 = i16 & -2147483648 | HEAP32[tempDoublePtr + 4 >> 2];
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i16;
  d12 = +HEAPF64[tempDoublePtr >> 3];
  d13 = d12 * d13;
  d14 = d12 * d14;
  i16 = i15 + 8 | 0;
  HEAPF64[i15 >> 3] = d13;
  HEAPF64[i16 >> 3] = d14;
  return;
 }
 d2 = +Math_abs(+d13);
 i1 = d2 == inf;
 d6 = +Math_abs(+d14);
 i4 = d6 == inf;
 if ((i1 | i4 ? d3 == d3 & 0.0 == 0.0 & +Math_abs(+d3) != inf : 0) ? d10 == d10 & 0.0 == 0.0 & +Math_abs(+d10) != inf : 0) {
  HEAPF64[tempDoublePtr >> 3] = d13;
  i16 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d12 = +Math_abs(+(i1 ? 1.0 : 0.0));
  HEAPF64[tempDoublePtr >> 3] = d12;
  i16 = HEAP32[tempDoublePtr + 4 >> 2] | i16 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i16;
  d12 = +HEAPF64[tempDoublePtr >> 3];
  HEAPF64[tempDoublePtr >> 3] = d14;
  i16 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d14 = +Math_abs(+(i4 ? 1.0 : 0.0));
  HEAPF64[tempDoublePtr >> 3] = d14;
  i16 = HEAP32[tempDoublePtr + 4 >> 2] | i16 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i16;
  d14 = +HEAPF64[tempDoublePtr >> 3];
  d13 = (d12 * d3 + d14 * d10) * inf;
  d14 = (d14 * d3 - d12 * d10) * inf;
  i16 = i15 + 8 | 0;
  HEAPF64[i15 >> 3] = d13;
  HEAPF64[i16 >> 3] = d14;
  return;
 }
 if (!(d11 > 0.0 & d12 == inf)) {
  d13 = d8;
  d14 = d7;
  i16 = i15 + 8 | 0;
  HEAPF64[i15 >> 3] = d13;
  HEAPF64[i16 >> 3] = d14;
  return;
 }
 if (!(d13 == d13 & 0.0 == 0.0 & d2 != inf)) {
  d13 = d8;
  d14 = d7;
  i16 = i15 + 8 | 0;
  HEAPF64[i15 >> 3] = d13;
  HEAPF64[i16 >> 3] = d14;
  return;
 }
 if (!(d14 == d14 & 0.0 == 0.0 & d6 != inf)) {
  d13 = d8;
  d14 = d7;
  i16 = i15 + 8 | 0;
  HEAPF64[i15 >> 3] = d13;
  HEAPF64[i16 >> 3] = d14;
  return;
 }
 i16 = +Math_abs(+d3) == inf;
 HEAPF64[tempDoublePtr >> 3] = d3;
 i9 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 d8 = +Math_abs(+(i16 ? 1.0 : 0.0));
 HEAPF64[tempDoublePtr >> 3] = d8;
 i9 = HEAP32[tempDoublePtr + 4 >> 2] | i9 & -2147483648;
 HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
 HEAP32[tempDoublePtr + 4 >> 2] = i9;
 d8 = +HEAPF64[tempDoublePtr >> 3];
 i9 = +Math_abs(+d10) == inf;
 HEAPF64[tempDoublePtr >> 3] = d10;
 i16 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 d11 = +Math_abs(+(i9 ? 1.0 : 0.0));
 HEAPF64[tempDoublePtr >> 3] = d11;
 i16 = HEAP32[tempDoublePtr + 4 >> 2] | i16 & -2147483648;
 HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
 HEAP32[tempDoublePtr + 4 >> 2] = i16;
 d11 = +HEAPF64[tempDoublePtr >> 3];
 d12 = (d8 * d13 + d11 * d14) * 0.0;
 d14 = (d8 * d14 - d11 * d13) * 0.0;
 i16 = i15 + 8 | 0;
 HEAPF64[i15 >> 3] = d12;
 HEAPF64[i16 >> 3] = d14;
 return;
}

function _liquid_firdes_hM3(i31, i25, d26, i32) {
 i31 = i31 | 0;
 i25 = i25 | 0;
 d26 = +d26;
 i32 = i32 | 0;
 var i1 = 0, F42 = SIMD_Float32x4(0, 0, 0, 0), i3 = 0, d4 = 0.0, i5 = 0, i6 = 0, d7 = 0.0, i8 = 0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, d14 = 0.0, d15 = 0.0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, d24 = 0.0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i33 = 0;
 i33 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i27 = i33 + 40 | 0;
 i28 = i33 + 24 | 0;
 i29 = i33 + 12 | 0;
 i30 = i33;
 if (i31 >>> 0 < 2) {
  i8 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i8) {
   i8 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i8 + 255 | i8;
   i8 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i8 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i6 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i6;
    HEAP32[gb + 8728 + 20 >> 2] = i6;
    i10 = i6 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i10;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i8 | 32;
   _exit(1);
  } else {
   i10 = i8;
   i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i10 - i6 | 0) >>> 0 < 53) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21789 | 0, 53) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21789 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
   i11 = 0;
   i12 = gb + 21789 + 53 | 0;
   i13 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i11 = 53;
   i12 = gb + 21789 | 0;
   i13 = i6;
  } while (0);
  _memcpy(i13 | 0, i12 | 0, i11 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i11;
  _exit(1);
 }
 if (!i25) {
  i6 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i6) {
   i6 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i6 + 255 | i6;
   i6 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i6 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i5 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i5;
    HEAP32[gb + 8728 + 20 >> 2] = i5;
    i16 = i5 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i16;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i6 | 32;
   _exit(1);
  } else {
   i16 = i6;
   i5 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i16 - i5 | 0) >>> 0 < 53) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21843 | 0, 53) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21843 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
   i17 = 0;
   i18 = gb + 21843 + 53 | 0;
   i19 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i17 = 53;
   i18 = gb + 21843 | 0;
   i19 = i5;
  } while (0);
  _memcpy(i19 | 0, i18 | 0, i17 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i17;
  _exit(1);
 }
 if (d26 < 0.0 | d26 > 1.0) {
  i5 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i5) {
   i5 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i5 + 255 | i5;
   i5 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i5 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i3;
    HEAP32[gb + 8728 + 20 >> 2] = i3;
    i20 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i20;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i5 | 32;
   _exit(1);
  } else {
   i20 = i5;
   i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i20 - i3 | 0) >>> 0 < 50) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21897 | 0, 50) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21897 | 0, 50) | 0) >>> 0 < 50) _exit(1); else {
   i21 = 0;
   i22 = gb + 21897 + 50 | 0;
   i23 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i21 = 50;
   i22 = gb + 21897 | 0;
   i23 = i3;
  } while (0);
  _memcpy(i23 | 0, i22 | 0, i21 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i21;
  _exit(1);
 }
 i11 = i31 << 1;
 i16 = Math_imul(i11, i25) | 0;
 i17 = i16 | 1;
 d15 = 1.0 / +(i11 >>> 0);
 d24 = d15;
 d9 = d26;
 HEAPF32[i27 >> 2] = 0.0;
 i11 = i27 + 4 | 0;
 HEAPF32[i11 >> 2] = d24 * (1.0 - d9);
 HEAPF32[i27 + 8 >> 2] = d15;
 HEAPF32[i27 + 12 >> 2] = d15;
 HEAPF32[i27 + 16 >> 2] = d24 * (d9 + 1.0);
 HEAPF32[i27 + 20 >> 2] = .5;
 HEAPF32[i28 >> 2] = 1.0;
 HEAPF32[i28 + 4 >> 2] = .7071067690849304;
 HEAPF32[i28 + 8 >> 2] = 0.0;
 HEAP32[i29 >> 2] = HEAP32[gb + 468 >> 2];
 HEAP32[i29 + 4 >> 2] = HEAP32[gb + 468 + 4 >> 2];
 HEAP32[i29 + 8 >> 2] = HEAP32[gb + 468 + 8 >> 2];
 HEAP32[i30 >> 2] = HEAP32[gb + 480 >> 2];
 HEAP32[i30 + 4 >> 2] = HEAP32[gb + 480 + 4 >> 2];
 HEAP32[i30 + 8 >> 2] = HEAP32[gb + 480 + 8 >> 2];
 i12 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i17 << 2) | 0) + 15 & -16) | 0;
 i13 = _firdespm_create(i17, i27, i28, i29, i30) | 0;
 _firdespm_execute(i13, i12);
 _firdespm_destroy(i13);
 i13 = i17 << 2;
 _memcpy(i32 | 0, i12 | 0, i13 | 0) | 0;
 i3 = 0;
 d9 = 0.0;
 do {
  d15 = +HEAPF32[i12 + (i3 << 2) >> 2];
  d9 = d9 + d15 * d15;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i17 | 0));
 i10 = i25 << 1;
 L70 : do if (!i10) {
  i3 = 0;
  do {
   HEAPF32[i11 >> 2] = d24 * (1.0 - +(i3 >>> 0) * d26 / 100.0);
   i25 = _firdespm_create(i17, i27, i28, i29, i30) | 0;
   _firdespm_execute(i25, i12);
   _firdespm_destroy(i25);
   _memcpy(i32 | 0, i12 | 0, i13 | 0) | 0;
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < 100);
  d4 = 0.0;
  i3 = 0;
 } else {
  i6 = 1;
  d7 = 0.0;
  do {
   i3 = Math_imul(i6, i31) | 0;
   i3 = (i3 | 0) > -1 ? i3 : 0 - i3 | 0;
   if (i3 >>> 0 < i17 >>> 0) {
    i5 = i3;
    d4 = 0.0;
    do {
     d4 = d4 + +HEAPF32[i12 + (i5 << 2) >> 2] * +HEAPF32[i12 + (i5 - i3 << 2) >> 2];
     i5 = i5 + 1 | 0;
    } while ((i5 | 0) != (i17 | 0));
   } else d4 = 0.0;
   d15 = +Math_abs(+(d4 / d9));
   d7 = d7 + d15 * d15;
   i6 = i6 + 1 | 0;
  } while (i6 >>> 0 <= i10 >>> 0);
  d15 = +(i10 >>> 0);
  d9 = +Math_sqrt(+(d7 / d15));
  i8 = 0;
  while (1) {
   HEAPF32[i11 >> 2] = d24 * (1.0 - +(i8 >>> 0) * d26 / 100.0);
   i3 = _firdespm_create(i17, i27, i28, i29, i30) | 0;
   _firdespm_execute(i3, i12);
   _firdespm_destroy(i3);
   i3 = 0;
   d14 = 0.0;
   do {
    d7 = +HEAPF32[i12 + (i3 << 2) >> 2];
    d14 = d14 + d7 * d7;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i17 | 0));
   i6 = 1;
   d7 = 0.0;
   do {
    i3 = Math_imul(i6, i31) | 0;
    i3 = (i3 | 0) > -1 ? i3 : 0 - i3 | 0;
    if (i3 >>> 0 < i17 >>> 0) {
     i5 = i3;
     d4 = 0.0;
     do {
      d4 = d4 + +HEAPF32[i12 + (i5 << 2) >> 2] * +HEAPF32[i12 + (i5 - i3 << 2) >> 2];
      i5 = i5 + 1 | 0;
     } while ((i5 | 0) != (i17 | 0));
    } else d4 = 0.0;
    d4 = +Math_abs(+(d4 / d14));
    d7 = d7 + d4 * d4;
    i6 = i6 + 1 | 0;
   } while (i6 >>> 0 <= i10 >>> 0);
   d14 = d9;
   d9 = +Math_sqrt(+(d7 / d15));
   if (d9 > d14) {
    d4 = 0.0;
    i3 = 0;
    break L70;
   }
   _memcpy(i32 | 0, i12 | 0, i13 | 0) | 0;
   i8 = i8 + 1 | 0;
   if (i8 >>> 0 >= 100) {
    d4 = 0.0;
    i3 = 0;
    break;
   }
  }
 } while (0);
 do {
  d26 = +HEAPF32[i32 + (i3 << 2) >> 2];
  d4 = d4 + d26 * d26;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i17 | 0));
 d4 = +Math_sqrt(+(+(i31 >>> 0) / d4));
 if (i16 >>> 0 >= 4 ? (i1 = i16 & -4, (i1 | 0) != 0) : 0) {
  F42 = SIMD_Float32x4_splat(Math_fround(d4));
  i3 = 0;
  do {
   i31 = i32 + (i3 << 2) | 0;
   SIMD_Float32x4_store(HEAPU8, i31, SIMD_Float32x4_mul(F42, SIMD_Float32x4_load(HEAPU8, i31)));
   i3 = i3 + 4 | 0;
  } while ((i3 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  i31 = i32 + (i1 << 2) | 0;
  HEAPF32[i31 >> 2] = d4 * +HEAPF32[i31 >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i17 | 0));
 STACKTOP = i33;
 return;
}

function _liquid_firdes_gmskrx(i27, i24, d3, i28) {
 i27 = i27 | 0;
 i24 = i24 | 0;
 d3 = +d3;
 i28 = i28 | 0;
 var i1 = 0, i2 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0, d14 = 0.0, d15 = 0.0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, d23 = 0.0, d25 = 0.0, i26 = 0, i29 = 0;
 i29 = STACKTOP;
 if (!i27) {
  i7 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i7) {
   i7 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i7 + 255 | i7;
   i7 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i7 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i4;
    HEAP32[gb + 8728 + 20 >> 2] = i4;
    i8 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i8;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i7 | 32;
   _exit(1);
  } else {
   i8 = i7;
   i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i8 - i4 | 0) >>> 0 < 56) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21621 | 0, 56) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21621 | 0, 56) | 0) >>> 0 < 56) _exit(1); else {
   i9 = 0;
   i10 = gb + 21621 + 56 | 0;
   i12 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i9 = 56;
   i10 = gb + 21621 | 0;
   i12 = i4;
  } while (0);
  _memcpy(i12 | 0, i10 | 0, i9 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i9;
  _exit(1);
 }
 if (!i24) {
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i13 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i13;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i13 = i4;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i13 - i2 | 0) >>> 0 < 56) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21678 | 0, 56) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21678 | 0, 56) | 0) >>> 0 < 56) _exit(1); else {
   i16 = 0;
   i17 = gb + 21678 + 56 | 0;
   i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i16 = 56;
   i17 = gb + 21678 | 0;
   i18 = i2;
  } while (0);
  _memcpy(i18 | 0, i17 | 0, i16 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i16;
  _exit(1);
 }
 if (!(d3 < 0.0 | d3 > 1.0)) {
  i21 = Math_imul(i27 << 1, i24) | 0 | 1;
  i4 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
  i22 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_gmsktx(i27, i24, d3, i4);
  i7 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
  i8 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 2) | 0) + 15 & -16) | 0;
  i9 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i10 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i2 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i20 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i13 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i16 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i17 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  i18 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(1, i27, i24, d3, i7);
  d25 = +(i27 >>> 0);
  _liquid_firdes_kaiser(i21, (d3 * .1 + .699999988079071) / d25, 60.0, i8);
  i12 = Math_imul(i24, i27) | 0;
  i19 = i12 << 1 | 1;
  i1 = 0;
  do {
   i24 = ((i1 + i12 | 0) >>> 0) % (i21 >>> 0) | 0;
   HEAP32[i10 + (i1 << 3) >> 2] = HEAP32[i7 + (i24 << 2) >> 2];
   HEAPF32[i10 + (i1 << 3) + 4 >> 2] = 0.0;
   HEAP32[i2 + (i1 << 3) >> 2] = HEAP32[i8 + (i24 << 2) >> 2];
   HEAPF32[i2 + (i1 << 3) + 4 >> 2] = 0.0;
   HEAP32[i9 + (i1 << 3) >> 2] = HEAP32[i4 + (i24 << 2) >> 2];
   HEAPF32[i9 + (i1 << 3) + 4 >> 2] = 0.0;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i19 | 0));
  i1 = _fft_create_plan(i21, i10, i16, 1, 0) | 0;
  mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
  _fft_destroy_plan(i1);
  i1 = _fft_create_plan(i21, i2, i17, 1, 0) | 0;
  mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
  _fft_destroy_plan(i1);
  i1 = _fft_create_plan(i21, i9, i13, 1, 0) | 0;
  mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
  _fft_destroy_plan(i1);
  d5 = +HEAPF32[i16 >> 2];
  d23 = +HEAPF32[i17 >> 2];
  d14 = 0.0;
  d11 = 0.0;
  d3 = 0.0;
  i1 = 0;
  while (1) {
   d6 = +HEAPF32[i13 + (i1 << 3) >> 2];
   if (i1) {
    d6 = d6 < d3 ? d6 : d3;
    d3 = +HEAPF32[i16 + (i1 << 3) >> 2];
    d11 = d3 < d11 ? d3 : d11;
    d3 = +HEAPF32[i17 + (i1 << 3) >> 2];
    if (d3 < d14) i26 = 45; else {
     d3 = d14;
     d15 = d6;
    }
   } else {
    d3 = d23;
    d11 = d5;
    i26 = 45;
   }
   if ((i26 | 0) == 45) {
    i26 = 0;
    d15 = d6;
   }
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i19 | 0)) {
    d6 = d23;
    i1 = 0;
    break;
   } else {
    d14 = d3;
    d3 = d15;
   }
  }
  while (1) {
   d14 = (d6 - d3) / d23;
   HEAPF32[i18 + (i1 << 3) >> 2] = d14 * ((d5 - d11 + 1.0000000474974513e-03) / (+HEAPF32[i13 + (i1 << 3) >> 2] - d15 + 1.0000000474974513e-03));
   HEAPF32[i18 + (i1 << 3) + 4 >> 2] = d14 * 0.0;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i19 | 0)) break;
   d5 = +HEAPF32[i16 + (i1 << 3) >> 2];
   d6 = +HEAPF32[i17 + (i1 << 3) >> 2];
  }
  i2 = _fft_create_plan(i21, i18, i20, -1, 0) | 0;
  mftCall_vi(HEAP32[i2 + 28 >> 2] | 0, i2 | 0);
  _fft_destroy_plan(i2);
  i2 = i12 + 1 | 0;
  d3 = +((Math_imul(i21, i27) | 0) >>> 0);
  i1 = 0;
  do {
   HEAPF32[i22 + (i1 << 2) >> 2] = +HEAPF32[i20 + ((((i2 + i1 | 0) >>> 0) % (i21 >>> 0) | 0) << 3) >> 2] / d3;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i19 | 0));
  i1 = 0;
  do {
   HEAPF32[i28 + (i1 << 2) >> 2] = d25 * (d25 * +HEAPF32[i22 + (i1 << 2) >> 2]);
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i19 | 0));
  STACKTOP = i29;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i19 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i19;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i19 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i19 - i1 | 0) >>> 0 < 53) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21735 | 0, 53) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21735 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
  i20 = 0;
  i21 = gb + 21735 + 53 | 0;
  i22 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i20 = 53;
  i21 = gb + 21735 | 0;
  i22 = i1;
 } while (0);
 _memcpy(i22 | 0, i21 | 0, i20 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i20;
 _exit(1);
}

function runPostSets1() {
 HEAP32[gb + 860 >> 2] = (HEAP32[gb + 860 >> 2] | 0) + (gb + 30424 | 0);
 HEAP32[gb + 864 >> 2] = (HEAP32[gb + 864 >> 2] | 0) + (gb + 30430 | 0);
 HEAP32[gb + 876 >> 2] = (HEAP32[gb + 876 >> 2] | 0) + (gb + 30458 | 0);
 HEAP32[gb + 880 >> 2] = (HEAP32[gb + 880 >> 2] | 0) + (gb + 30465 | 0);
 HEAP32[gb + 892 >> 2] = (HEAP32[gb + 892 >> 2] | 0) + (gb + 30494 | 0);
 HEAP32[gb + 896 >> 2] = (HEAP32[gb + 896 >> 2] | 0) + (gb + 30501 | 0);
 HEAP32[gb + 908 >> 2] = (HEAP32[gb + 908 >> 2] | 0) + (gb + 30530 | 0);
 HEAP32[gb + 912 >> 2] = (HEAP32[gb + 912 >> 2] | 0) + (gb + 30535 | 0);
 HEAP32[gb + 924 >> 2] = (HEAP32[gb + 924 >> 2] | 0) + (gb + 30573 | 0);
 HEAP32[gb + 928 >> 2] = (HEAP32[gb + 928 >> 2] | 0) + (gb + 30578 | 0);
 HEAP32[gb + 940 >> 2] = (HEAP32[gb + 940 >> 2] | 0) + (gb + 30616 | 0);
 HEAP32[gb + 944 >> 2] = (HEAP32[gb + 944 >> 2] | 0) + (gb + 30622 | 0);
 HEAP32[gb + 956 >> 2] = (HEAP32[gb + 956 >> 2] | 0) + (gb + 30661 | 0);
 HEAP32[gb + 960 >> 2] = (HEAP32[gb + 960 >> 2] | 0) + (gb + 30667 | 0);
 HEAP32[gb + 972 >> 2] = (HEAP32[gb + 972 >> 2] | 0) + (gb + 30706 | 0);
 HEAP32[gb + 976 >> 2] = (HEAP32[gb + 976 >> 2] | 0) + (gb + 30712 | 0);
 HEAP32[gb + 988 >> 2] = (HEAP32[gb + 988 >> 2] | 0) + (gb + 30751 | 0);
 HEAP32[gb + 992 >> 2] = (HEAP32[gb + 992 >> 2] | 0) + (gb + 30758 | 0);
 HEAP32[gb + 1004 >> 2] = (HEAP32[gb + 1004 >> 2] | 0) + (gb + 30798 | 0);
 HEAP32[gb + 1008 >> 2] = (HEAP32[gb + 1008 >> 2] | 0) + (gb + 30805 | 0);
 HEAP32[gb + 1020 >> 2] = (HEAP32[gb + 1020 >> 2] | 0) + (gb + 30845 | 0);
 HEAP32[gb + 1024 >> 2] = (HEAP32[gb + 1024 >> 2] | 0) + (gb + 30852 | 0);
 HEAP32[gb + 1036 >> 2] = (HEAP32[gb + 1036 >> 2] | 0) + (gb + 30892 | 0);
 HEAP32[gb + 1040 >> 2] = (HEAP32[gb + 1040 >> 2] | 0) + (gb + 30900 | 0);
 HEAP32[gb + 1052 >> 2] = (HEAP32[gb + 1052 >> 2] | 0) + (gb + 30941 | 0);
 HEAP32[gb + 1056 >> 2] = (HEAP32[gb + 1056 >> 2] | 0) + (gb + 30949 | 0);
 HEAP32[gb + 1068 >> 2] = (HEAP32[gb + 1068 >> 2] | 0) + (gb + 30990 | 0);
 HEAP32[gb + 1072 >> 2] = (HEAP32[gb + 1072 >> 2] | 0) + (gb + 30998 | 0);
 HEAP32[gb + 1084 >> 2] = (HEAP32[gb + 1084 >> 2] | 0) + (gb + 31039 | 0);
 HEAP32[gb + 1088 >> 2] = (HEAP32[gb + 1088 >> 2] | 0) + (gb + 31047 | 0);
 HEAP32[gb + 1100 >> 2] = (HEAP32[gb + 1100 >> 2] | 0) + (gb + 31088 | 0);
 HEAP32[gb + 1104 >> 2] = (HEAP32[gb + 1104 >> 2] | 0) + (gb + 31097 | 0);
 HEAP32[gb + 1116 >> 2] = (HEAP32[gb + 1116 >> 2] | 0) + (gb + 31139 | 0);
 HEAP32[gb + 1120 >> 2] = (HEAP32[gb + 1120 >> 2] | 0) + (gb + 31148 | 0);
 HEAP32[gb + 1132 >> 2] = (HEAP32[gb + 1132 >> 2] | 0) + (gb + 31190 | 0);
 HEAP32[gb + 1136 >> 2] = (HEAP32[gb + 1136 >> 2] | 0) + (gb + 31199 | 0);
 HEAP32[gb + 1148 >> 2] = (HEAP32[gb + 1148 >> 2] | 0) + (gb + 31241 | 0);
 HEAP32[gb + 1152 >> 2] = (HEAP32[gb + 1152 >> 2] | 0) + (gb + 31247 | 0);
 HEAP32[gb + 1164 >> 2] = (HEAP32[gb + 1164 >> 2] | 0) + (gb + 31280 | 0);
 HEAP32[gb + 1168 >> 2] = (HEAP32[gb + 1168 >> 2] | 0) + (gb + 31286 | 0);
 HEAP32[gb + 1180 >> 2] = (HEAP32[gb + 1180 >> 2] | 0) + (gb + 31319 | 0);
 HEAP32[gb + 1184 >> 2] = (HEAP32[gb + 1184 >> 2] | 0) + (gb + 31326 | 0);
 HEAP32[gb + 1196 >> 2] = (HEAP32[gb + 1196 >> 2] | 0) + (gb + 31360 | 0);
 HEAP32[gb + 1200 >> 2] = (HEAP32[gb + 1200 >> 2] | 0) + (gb + 31367 | 0);
 HEAP32[gb + 1212 >> 2] = (HEAP32[gb + 1212 >> 2] | 0) + (gb + 31401 | 0);
 HEAP32[gb + 1216 >> 2] = (HEAP32[gb + 1216 >> 2] | 0) + (gb + 31408 | 0);
 HEAP32[gb + 1228 >> 2] = (HEAP32[gb + 1228 >> 2] | 0) + (gb + 31442 | 0);
 HEAP32[gb + 1232 >> 2] = (HEAP32[gb + 1232 >> 2] | 0) + (gb + 31450 | 0);
 HEAP32[gb + 1244 >> 2] = (HEAP32[gb + 1244 >> 2] | 0) + (gb + 31485 | 0);
 HEAP32[gb + 1248 >> 2] = (HEAP32[gb + 1248 >> 2] | 0) + (gb + 31493 | 0);
 HEAP32[gb + 1260 >> 2] = (HEAP32[gb + 1260 >> 2] | 0) + (gb + 31528 | 0);
 HEAP32[gb + 1264 >> 2] = (HEAP32[gb + 1264 >> 2] | 0) + (gb + 31533 | 0);
 HEAP32[gb + 1276 >> 2] = (HEAP32[gb + 1276 >> 2] | 0) + (gb + 31559 | 0);
 HEAP32[gb + 1280 >> 2] = (HEAP32[gb + 1280 >> 2] | 0) + (gb + 31564 | 0);
 HEAP32[gb + 1292 >> 2] = (HEAP32[gb + 1292 >> 2] | 0) + (gb + 31594 | 0);
 HEAP32[gb + 1296 >> 2] = (HEAP32[gb + 1296 >> 2] | 0) + (gb + 31598 | 0);
 HEAP32[gb + 1308 >> 2] = (HEAP32[gb + 1308 >> 2] | 0) + (gb + 31618 | 0);
 HEAP32[gb + 1312 >> 2] = (HEAP32[gb + 1312 >> 2] | 0) + (gb + 31625 | 0);
 HEAP32[gb + 1324 >> 2] = (HEAP32[gb + 1324 >> 2] | 0) + (gb + 31641 | 0);
 HEAP32[gb + 1328 >> 2] = (HEAP32[gb + 1328 >> 2] | 0) + (gb + 31649 | 0);
 HEAP32[gb + 1340 >> 2] = (HEAP32[gb + 1340 >> 2] | 0) + (gb + 31666 | 0);
 HEAP32[gb + 1344 >> 2] = (HEAP32[gb + 1344 >> 2] | 0) + (gb + 31670 | 0);
 HEAP32[gb + 1356 >> 2] = (HEAP32[gb + 1356 >> 2] | 0) + (gb + 31675 | 0);
 HEAP32[gb + 1360 >> 2] = (HEAP32[gb + 1360 >> 2] | 0) + (gb + 31684 | 0);
 HEAP32[gb + 1372 >> 2] = (HEAP32[gb + 1372 >> 2] | 0) + (gb + 31710 | 0);
 HEAP32[gb + 1376 >> 2] = (HEAP32[gb + 1376 >> 2] | 0) + (gb + 31719 | 0);
 HEAP32[gb + 1388 >> 2] = (HEAP32[gb + 1388 >> 2] | 0) + (gb + 31745 | 0);
 HEAP32[gb + 1392 >> 2] = (HEAP32[gb + 1392 >> 2] | 0) + (gb + 31754 | 0);
 HEAP32[gb + 1404 >> 2] = (HEAP32[gb + 1404 >> 2] | 0) + (gb + 31780 | 0);
 HEAP32[gb + 1408 >> 2] = (HEAP32[gb + 1408 >> 2] | 0) + (gb + 31790 | 0);
 HEAP32[gb + 1420 >> 2] = (HEAP32[gb + 1420 >> 2] | 0) + (gb + 31818 | 0);
 HEAP32[gb + 1424 >> 2] = (HEAP32[gb + 1424 >> 2] | 0) + (gb + 31828 | 0);
 HEAP32[gb + 1436 >> 2] = (HEAP32[gb + 1436 >> 2] | 0) + (gb + 31856 | 0);
 HEAP32[gb + 1440 >> 2] = (HEAP32[gb + 1440 >> 2] | 0) + (gb + 31864 | 0);
 HEAP32[gb + 1452 >> 2] = (HEAP32[gb + 1452 >> 2] | 0) + (gb + 31889 | 0);
 HEAP32[gb + 1456 >> 2] = (HEAP32[gb + 1456 >> 2] | 0) + (gb + 31893 | 0);
 HEAP32[gb + 1496 >> 2] = (HEAP32[gb + 1496 >> 2] | 0) + (gb + 1468 | 0);
 HEAP32[gb + 1500 >> 2] = (HEAP32[gb + 1500 >> 2] | 0) + (gb + 1476 | 0);
 HEAP32[gb + 1504 >> 2] = (HEAP32[gb + 1504 >> 2] | 0) + (gb + 41256 | 0);
 HEAP32[gb + 1508 >> 2] = (HEAP32[gb + 1508 >> 2] | 0) + (gb + 1484 | 0);
 HEAP32[gb + 1512 >> 2] = (HEAP32[gb + 1512 >> 2] | 0) + (gb + 31988 | 0);
 HEAP32[gb + 1544 >> 2] = (HEAP32[gb + 1544 >> 2] | 0) + (gb + 1516 | 0);
 HEAP32[gb + 1548 >> 2] = (HEAP32[gb + 1548 >> 2] | 0) + (gb + 1524 | 0);
 HEAP32[gb + 1552 >> 2] = (HEAP32[gb + 1552 >> 2] | 0) + (gb + 41264 | 0);
 HEAP32[gb + 1556 >> 2] = (HEAP32[gb + 1556 >> 2] | 0) + (gb + 1532 | 0);
 HEAP32[gb + 1560 >> 2] = (HEAP32[gb + 1560 >> 2] | 0) + (gb + 31992 | 0);
 HEAP32[gb + 1592 >> 2] = (HEAP32[gb + 1592 >> 2] | 0) + (gb + 1564 | 0);
 HEAP32[gb + 1596 >> 2] = (HEAP32[gb + 1596 >> 2] | 0) + (gb + 1572 | 0);
 HEAP32[gb + 1600 >> 2] = (HEAP32[gb + 1600 >> 2] | 0) + (gb + 41272 | 0);
 HEAP32[gb + 1604 >> 2] = (HEAP32[gb + 1604 >> 2] | 0) + (gb + 1580 | 0);
 HEAP32[gb + 1608 >> 2] = (HEAP32[gb + 1608 >> 2] | 0) + (gb + 32e3 | 0);
 HEAP32[gb + 1652 >> 2] = (HEAP32[gb + 1652 >> 2] | 0) + (gb + 1612 | 0);
 HEAP32[gb + 1656 >> 2] = (HEAP32[gb + 1656 >> 2] | 0) + (gb + 1624 | 0);
 HEAP32[gb + 1660 >> 2] = (HEAP32[gb + 1660 >> 2] | 0) + (gb + 41280 | 0);
 HEAP32[gb + 1664 >> 2] = (HEAP32[gb + 1664 >> 2] | 0) + (gb + 1636 | 0);
 HEAP32[gb + 1668 >> 2] = (HEAP32[gb + 1668 >> 2] | 0) + (gb + 32016 | 0);
 HEAP32[gb + 1724 >> 2] = (HEAP32[gb + 1724 >> 2] | 0) + (gb + 1672 | 0);
 HEAP32[gb + 1728 >> 2] = (HEAP32[gb + 1728 >> 2] | 0) + (gb + 1688 | 0);
 HEAP32[gb + 1732 >> 2] = (HEAP32[gb + 1732 >> 2] | 0) + (gb + 41292 | 0);
 HEAP32[gb + 1736 >> 2] = (HEAP32[gb + 1736 >> 2] | 0) + (gb + 1704 | 0);
 runPostSets2();
}

function _fft_execute_dft_5(i7) {
 i7 = i7 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, d14 = 0.0, d15 = 0.0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, d30 = 0.0, i31 = 0, i32 = 0, i33 = 0, d34 = 0.0, i35 = 0, i36 = 0, i37 = 0, d38 = 0.0, i39 = 0, i40 = 0, i41 = 0, d42 = 0.0, i43 = 0, i44 = 0, i45 = 0;
 i45 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i12 = i45 + 120 | 0;
 i13 = i45 + 112 | 0;
 i16 = i45 + 104 | 0;
 i17 = i45 + 96 | 0;
 i18 = i45 + 88 | 0;
 i19 = i45 + 80 | 0;
 i20 = i45 + 72 | 0;
 i21 = i45 + 64 | 0;
 i22 = i45 + 56 | 0;
 i23 = i45 + 48 | 0;
 i24 = i45 + 40 | 0;
 i25 = i45 + 32 | 0;
 i31 = i45 + 24 | 0;
 i35 = i45 + 16 | 0;
 i39 = i45 + 8 | 0;
 i43 = i45;
 i26 = HEAP32[i7 + 4 >> 2] | 0;
 i44 = HEAP32[i7 + 8 >> 2] | 0;
 i27 = i26 + 4 | 0;
 i28 = i26 + 8 | 0;
 i29 = i26 + 12 | 0;
 i32 = i26 + 16 | 0;
 i33 = i26 + 20 | 0;
 i36 = i26 + 24 | 0;
 i37 = i26 + 28 | 0;
 i40 = i26 + 32 | 0;
 i41 = i26 + 36 | 0;
 d38 = +HEAPF32[i27 >> 2] + +HEAPF32[i29 >> 2] + +HEAPF32[i33 >> 2] + +HEAPF32[i37 >> 2] + +HEAPF32[i41 >> 2];
 HEAPF32[i44 >> 2] = +HEAPF32[i26 >> 2] + +HEAPF32[i28 >> 2] + +HEAPF32[i32 >> 2] + +HEAPF32[i36 >> 2] + +HEAPF32[i40 >> 2];
 HEAPF32[i44 + 4 >> 2] = d38;
 i7 = (HEAP32[i7 + 12 >> 2] | 0) == -1;
 d38 = i7 ? .5877852439880371 : -.5877852439880371;
 d42 = i7 ? .9510565400123596 : -.9510565400123596;
 d30 = -d42;
 d34 = -d38;
 d14 = +HEAPF32[i26 >> 2];
 d15 = +HEAPF32[i27 >> 2];
 d1 = +HEAPF32[i28 >> 2];
 d2 = +HEAPF32[i29 >> 2];
 d3 = d1 * .30901700258255005 - d42 * d2;
 d4 = d42 * d1 + d2 * .30901700258255005;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i12, d1, d2, .30901700258255005, d42);
  d3 = +HEAPF32[i12 >> 2];
  d4 = +HEAPF32[i12 + 4 >> 2];
 }
 d1 = +HEAPF32[i32 >> 2];
 d2 = +HEAPF32[i33 >> 2];
 d5 = d1 * -.80901700258255 - d38 * d2;
 d6 = d38 * d1 - d2 * .80901700258255;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i13, d1, d2, -.80901700258255, d38);
  d5 = +HEAPF32[i13 >> 2];
  d6 = +HEAPF32[i13 + 4 >> 2];
 }
 d1 = +HEAPF32[i36 >> 2];
 d2 = +HEAPF32[i37 >> 2];
 d8 = d1 * -.80901700258255 - d2 * d34;
 d9 = d1 * d34 - d2 * .80901700258255;
 if ((d8 != d8 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
  ___mulsc3(i16, d1, d2, -.80901700258255, d34);
  d8 = +HEAPF32[i16 >> 2];
  d11 = +HEAPF32[i16 + 4 >> 2];
 } else d11 = d9;
 d9 = +HEAPF32[i40 >> 2];
 d10 = +HEAPF32[i41 >> 2];
 d2 = d9 * .30901700258255005 - d10 * d30;
 d1 = d9 * d30 + d10 * .30901700258255005;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i17, d9, d10, .30901700258255005, d30);
  d2 = +HEAPF32[i17 >> 2];
  d1 = +HEAPF32[i17 + 4 >> 2];
 }
 HEAPF32[i44 + 8 >> 2] = d14 + d3 + d5 + d8 + d2;
 HEAPF32[i44 + 12 >> 2] = d15 + d4 + d6 + d11 + d1;
 d14 = +HEAPF32[i26 >> 2];
 d15 = +HEAPF32[i27 >> 2];
 d1 = +HEAPF32[i28 >> 2];
 d2 = +HEAPF32[i29 >> 2];
 d3 = d1 * -.80901700258255 - d38 * d2;
 d4 = d38 * d1 - d2 * .80901700258255;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i18, d1, d2, -.80901700258255, d38);
  d3 = +HEAPF32[i18 >> 2];
  d4 = +HEAPF32[i18 + 4 >> 2];
 }
 d1 = +HEAPF32[i32 >> 2];
 d2 = +HEAPF32[i33 >> 2];
 d5 = d1 * .30901700258255005 - d2 * d30;
 d6 = d1 * d30 + d2 * .30901700258255005;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i19, d1, d2, .30901700258255005, d30);
  d5 = +HEAPF32[i19 >> 2];
  d6 = +HEAPF32[i19 + 4 >> 2];
 }
 d1 = +HEAPF32[i36 >> 2];
 d2 = +HEAPF32[i37 >> 2];
 d8 = d1 * .30901700258255005 - d42 * d2;
 d9 = d42 * d1 + d2 * .30901700258255005;
 if ((d8 != d8 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
  ___mulsc3(i20, d1, d2, .30901700258255005, d42);
  d8 = +HEAPF32[i20 >> 2];
  d9 = +HEAPF32[i20 + 4 >> 2];
 }
 d10 = +HEAPF32[i40 >> 2];
 d11 = +HEAPF32[i41 >> 2];
 d2 = d10 * -.80901700258255 - d11 * d34;
 d1 = d10 * d34 - d11 * .80901700258255;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i21, d10, d11, -.80901700258255, d34);
  d2 = +HEAPF32[i21 >> 2];
  d1 = +HEAPF32[i21 + 4 >> 2];
 }
 HEAPF32[i44 + 16 >> 2] = d14 + d3 + d5 + d8 + d2;
 HEAPF32[i44 + 20 >> 2] = d15 + d4 + d6 + d9 + d1;
 d14 = +HEAPF32[i26 >> 2];
 d15 = +HEAPF32[i27 >> 2];
 d1 = +HEAPF32[i28 >> 2];
 d2 = +HEAPF32[i29 >> 2];
 d3 = d1 * -.80901700258255 - d2 * d34;
 d4 = d1 * d34 - d2 * .80901700258255;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i22, d1, d2, -.80901700258255, d34);
  d3 = +HEAPF32[i22 >> 2];
  d4 = +HEAPF32[i22 + 4 >> 2];
 }
 d1 = +HEAPF32[i32 >> 2];
 d2 = +HEAPF32[i33 >> 2];
 d5 = d1 * .30901700258255005 - d42 * d2;
 d6 = d42 * d1 + d2 * .30901700258255005;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i23, d1, d2, .30901700258255005, d42);
  d5 = +HEAPF32[i23 >> 2];
  d6 = +HEAPF32[i23 + 4 >> 2];
 }
 d1 = +HEAPF32[i36 >> 2];
 d2 = +HEAPF32[i37 >> 2];
 d8 = d1 * .30901700258255005 - d2 * d30;
 d9 = d1 * d30 + d2 * .30901700258255005;
 if ((d8 != d8 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
  ___mulsc3(i24, d1, d2, .30901700258255005, d30);
  d8 = +HEAPF32[i24 >> 2];
  d9 = +HEAPF32[i24 + 4 >> 2];
 }
 d10 = +HEAPF32[i40 >> 2];
 d11 = +HEAPF32[i41 >> 2];
 d2 = d10 * -.80901700258255 - d38 * d11;
 d1 = d38 * d10 - d11 * .80901700258255;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i25, d10, d11, -.80901700258255, d38);
  d2 = +HEAPF32[i25 >> 2];
  d1 = +HEAPF32[i25 + 4 >> 2];
 }
 HEAPF32[i44 + 24 >> 2] = d14 + d3 + d5 + d8 + d2;
 HEAPF32[i44 + 28 >> 2] = d15 + d4 + d6 + d9 + d1;
 d10 = +HEAPF32[i26 >> 2];
 d11 = +HEAPF32[i27 >> 2];
 d3 = +HEAPF32[i28 >> 2];
 d1 = +HEAPF32[i29 >> 2];
 d2 = d3 * .30901700258255005 - d1 * d30;
 d4 = d3 * d30 + d1 * .30901700258255005;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i31, d3, d1, .30901700258255005, d30);
  d9 = +HEAPF32[i31 >> 2];
  d8 = +HEAPF32[i31 + 4 >> 2];
 } else {
  d9 = d2;
  d8 = d4;
 }
 d3 = +HEAPF32[i32 >> 2];
 d1 = +HEAPF32[i33 >> 2];
 d2 = d3 * -.80901700258255 - d1 * d34;
 d4 = d3 * d34 - d1 * .80901700258255;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i35, d3, d1, -.80901700258255, d34);
  d6 = +HEAPF32[i35 >> 2];
  d5 = +HEAPF32[i35 + 4 >> 2];
 } else {
  d6 = d2;
  d5 = d4;
 }
 d4 = +HEAPF32[i36 >> 2];
 d3 = +HEAPF32[i37 >> 2];
 d2 = d4 * -.80901700258255 - d38 * d3;
 d1 = d38 * d4 - d3 * .80901700258255;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i39, d4, d3, -.80901700258255, d38);
  d2 = +HEAPF32[i39 >> 2];
  d1 = +HEAPF32[i39 + 4 >> 2];
 }
 d6 = d10 + d9 + d6 + d2;
 d5 = d11 + d8 + d5 + d1;
 d4 = +HEAPF32[i40 >> 2];
 d1 = +HEAPF32[i41 >> 2];
 d2 = d4 * .30901700258255005 - d42 * d1;
 d3 = d42 * d4 + d1 * .30901700258255005;
 if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
  d38 = d2;
  d42 = d3;
  d38 = d6 + d38;
  d42 = d5 + d42;
  i43 = i44 + 32 | 0;
  i44 = i44 + 36 | 0;
  HEAPF32[i43 >> 2] = d38;
  HEAPF32[i44 >> 2] = d42;
  STACKTOP = i45;
  return;
 }
 ___mulsc3(i43, d4, d1, .30901700258255005, d42);
 d38 = +HEAPF32[i43 >> 2];
 d42 = +HEAPF32[i43 + 4 >> 2];
 d38 = d6 + d38;
 d42 = d5 + d42;
 i43 = i44 + 32 | 0;
 i44 = i44 + 36 | 0;
 HEAPF32[i43 >> 2] = d38;
 HEAPF32[i44 >> 2] = d42;
 STACKTOP = i45;
 return;
}

function _ofdmframesync_estimate_eqgain_poly(i30, i4) {
 i30 = i30 | 0;
 i4 = i4 | 0;
 var i1 = 0, d2 = 0.0, d3 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0;
 i35 = STACKTOP;
 if (!(HEAP32[i30 + 168 >> 2] | 0)) i34 = i30; else {
  _memmove(HEAP32[i30 + 188 >> 2] | 0, HEAP32[i30 + 92 >> 2] | 0, HEAP32[i30 >> 2] << 3 | 0) | 0;
  i34 = i30;
 }
 i29 = (HEAP32[i30 + 24 >> 2] | 0) + (HEAP32[i30 + 20 >> 2] | 0) | 0;
 i31 = i29 + -1 | 0;
 i31 = i31 >>> 0 < i4 >>> 0 ? i31 : i4;
 i26 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i29 << 2) | 0) + 15 & -16) | 0;
 i27 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i29 << 2) | 0) + 15 & -16) | 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i29 << 2) | 0) + 15 & -16) | 0;
 i31 = (i31 >>> 0 > 10 ? 10 : i31) + 1 | 0;
 i32 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i31 << 2) | 0) + 15 & -16) | 0;
 i33 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i31 << 2) | 0) + 15 & -16) | 0;
 i9 = HEAP32[i34 >> 2] | 0;
 L5 : do if (!i9) i21 = 0; else {
  i11 = i30 + 92 | 0;
  i12 = HEAP32[i30 + 4 >> 2] | 0;
  i13 = HEAP32[i30 + 12 >> 2] | 0;
  d14 = +(i9 >>> 0);
  i15 = 0;
  i4 = 0;
  while (1) {
   i7 = ((i12 + i15 | 0) >>> 0) % (i9 >>> 0) | 0;
   if (HEAP8[i13 + i7 >> 0] | 0) {
    if ((i4 | 0) == (i29 | 0)) break;
    d10 = +(i7 >>> 0);
    HEAPF32[i26 + (i4 << 2) >> 2] = (i7 >>> 0 > i12 >>> 0 ? d10 - d14 : d10) / d14;
    i36 = HEAP32[i11 >> 2] | 0;
    d10 = +HEAPF32[i36 + (i7 << 3) >> 2];
    d6 = +HEAPF32[i36 + (i7 << 3) + 4 >> 2];
    d3 = +Math_abs(+d10);
    i36 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
    d3 = +Math_abs(+d6);
    i8 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
    i37 = i36 >>> 0 < i8 >>> 0;
    i7 = i37 ? i8 : i36;
    i8 = i37 ? i36 : i8;
    d3 = (HEAP32[tempDoublePtr >> 2] = i7, +HEAPF32[tempDoublePtr >> 2]);
    d2 = (HEAP32[tempDoublePtr >> 2] = i8, +HEAPF32[tempDoublePtr >> 2]);
    do if ((i8 | 0) != 2139095040) {
     if (i7 >>> 0 > 2139095039 | (i8 | 0) == 0 | (i7 - i8 | 0) >>> 0 > 209715199) {
      d2 = d3 + d2;
      break;
     }
     if (i7 >>> 0 <= 1568669695) if (i8 >>> 0 < 562036736) {
      d2 = d2 * 1237940039285380274899124.0e3;
      d3 = d3 * 1237940039285380274899124.0e3;
      d5 = 8.077935669463161e-28;
     } else d5 = 1.0; else {
      d2 = d2 * 8.077935669463161e-28;
      d3 = d3 * 8.077935669463161e-28;
      d5 = 1237940039285380274899124.0e3;
     }
     d2 = d5 * +Math_sqrt(+(d3 * d3 + d2 * d2));
    } while (0);
    HEAPF32[i27 + (i4 << 2) >> 2] = d2;
    HEAPF32[i28 + (i4 << 2) >> 2] = +Math_atan2(+d6, +d10);
    i4 = i4 + 1 | 0;
   }
   i15 = i15 + 1 | 0;
   if (i15 >>> 0 >= i9 >>> 0) {
    i21 = i4;
    break L5;
   }
  }
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i17 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i17;
    HEAP32[gb + 8728 + 20 >> 2] = i17;
    i16 = i17 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i16;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i16 = i4;
   i17 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i16 - i17 | 0) >>> 0 < 71) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33701 | 0, 71) | 0;
   _exit(1);
  }
  i4 = i17;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33701 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
   i18 = 0;
   i19 = gb + 33701 + 71 | 0;
   i20 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i18 = 71;
   i19 = gb + 33701 | 0;
   i20 = i4;
  } while (0);
  _memcpy(i20 | 0, i19 | 0, i18 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i18;
  _exit(1);
 } while (0);
 if ((i21 | 0) != (i29 | 0)) {
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i22 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i22;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i22 = i4;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i22 - i1 | 0) >>> 0 < 71) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33701 | 0, 71) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 33701 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
   i23 = 0;
   i24 = gb + 33701 + 71 | 0;
   i25 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i23 = 71;
   i24 = gb + 33701 | 0;
   i25 = i1;
  } while (0);
  _memcpy(i25 | 0, i24 | 0, i23 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i23;
  _exit(1);
 }
 if (i29 >>> 0 > 1) {
  d2 = +HEAPF32[i28 >> 2];
  i7 = 1;
  do {
   i4 = i28 + (i7 << 2) | 0;
   d3 = +HEAPF32[i4 >> 2];
   i1 = i28 + (i7 + -1 << 2) | 0;
   if (d3 - d2 > 3.141592653589793) {
    do d3 = d3 + -6.283185307179586; while (d3 - d2 > 3.141592653589793);
    HEAPF32[i4 >> 2] = d3;
    d2 = d3;
   } else d2 = d3;
   d3 = +HEAPF32[i1 >> 2];
   if (d2 - d3 < -3.141592653589793) {
    do d2 = d2 + 6.283185307179586; while (d2 - d3 < -3.141592653589793);
    HEAPF32[i4 >> 2] = d2;
   }
   i7 = i7 + 1 | 0;
  } while ((i7 | 0) != (i29 | 0));
 }
 _polyf_fit(i26, i27, i29, i32, i31);
 _polyf_fit(i26, i28, i29, i33, i31);
 i1 = HEAP32[i34 >> 2] | 0;
 if (!i1) {
  STACKTOP = i35;
  return;
 }
 i7 = i30 + 4 | 0;
 i8 = i30 + 12 | 0;
 i9 = i30 + 92 | 0;
 if (!i31) {
  i1 = 0;
  do {
   i37 = HEAP32[i9 >> 2] | 0;
   HEAPF32[i37 + (i1 << 3) >> 2] = 0.0;
   HEAPF32[i37 + (i1 << 3) + 4 >> 2] = 0.0;
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < (HEAP32[i34 >> 2] | 0) >>> 0);
  STACKTOP = i35;
  return;
 } else i4 = 0;
 do {
  d2 = +(i4 >>> 0);
  d5 = +(i1 >>> 0);
  d5 = (i4 >>> 0 > (HEAP32[i7 >> 2] | 0) >>> 0 ? d2 - d5 : d2) / d5;
  i1 = 0;
  d2 = 1.0;
  d6 = 0.0;
  while (1) {
   d6 = d6 + d2 * +HEAPF32[i32 + (i1 << 2) >> 2];
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i31 | 0)) {
    i1 = 0;
    d2 = 1.0;
    d3 = 0.0;
    break;
   } else d2 = d5 * d2;
  }
  while (1) {
   d3 = d3 + d2 * +HEAPF32[i33 + (i1 << 2) >> 2];
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i31 | 0)) break; else d2 = d5 * d2;
  }
  if (!(HEAP8[(HEAP32[i8 >> 2] | 0) + i4 >> 0] | 0)) {
   d3 = 0.0;
   d2 = 0.0;
  } else {
   d2 = +Math_sin(+d3);
   d3 = d6 * (+Math_cos(+d3) + d2 * 0.0);
   d2 = d6 * d2;
  }
  i1 = HEAP32[i9 >> 2] | 0;
  HEAPF32[i1 + (i4 << 3) >> 2] = d3;
  HEAPF32[i1 + (i4 << 3) + 4 >> 2] = d2;
  i4 = i4 + 1 | 0;
  i1 = HEAP32[i34 >> 2] | 0;
 } while (i4 >>> 0 < i1 >>> 0);
 STACKTOP = i35;
 return;
}

function runPostSets() {
 HEAP32[gb + 0 >> 2] = (HEAP32[gb + 0 >> 2] | 0) + (gb + 29657 | 0);
 HEAP32[gb + 4 >> 2] = (HEAP32[gb + 4 >> 2] | 0) + (gb + 29657 | 0);
 HEAP32[gb + 8 >> 2] = (HEAP32[gb + 8 >> 2] | 0) + (gb + 10724 | 0);
 HEAP32[gb + 12 >> 2] = (HEAP32[gb + 12 >> 2] | 0) + (gb + 10724 | 0);
 HEAP32[gb + 16 >> 2] = (HEAP32[gb + 16 >> 2] | 0) + (gb + 10729 | 0);
 HEAP32[gb + 20 >> 2] = (HEAP32[gb + 20 >> 2] | 0) + (gb + 10734 | 0);
 HEAP32[gb + 24 >> 2] = (HEAP32[gb + 24 >> 2] | 0) + (gb + 10744 | 0);
 HEAP32[gb + 28 >> 2] = (HEAP32[gb + 28 >> 2] | 0) + (gb + 10749 | 0);
 HEAP32[gb + 32 >> 2] = (HEAP32[gb + 32 >> 2] | 0) + (gb + 10759 | 0);
 HEAP32[gb + 36 >> 2] = (HEAP32[gb + 36 >> 2] | 0) + (gb + 10763 | 0);
 HEAP32[gb + 40 >> 2] = (HEAP32[gb + 40 >> 2] | 0) + (gb + 10776 | 0);
 HEAP32[gb + 44 >> 2] = (HEAP32[gb + 44 >> 2] | 0) + (gb + 10780 | 0);
 HEAP32[gb + 48 >> 2] = (HEAP32[gb + 48 >> 2] | 0) + (gb + 10793 | 0);
 HEAP32[gb + 52 >> 2] = (HEAP32[gb + 52 >> 2] | 0) + (gb + 10798 | 0);
 HEAP32[gb + 56 >> 2] = (HEAP32[gb + 56 >> 2] | 0) + (gb + 10812 | 0);
 HEAP32[gb + 60 >> 2] = (HEAP32[gb + 60 >> 2] | 0) + (gb + 10818 | 0);
 HEAP32[gb + 64 >> 2] = (HEAP32[gb + 64 >> 2] | 0) + (gb + 10831 | 0);
 HEAP32[gb + 68 >> 2] = (HEAP32[gb + 68 >> 2] | 0) + (gb + 10842 | 0);
 HEAP32[gb + 72 >> 2] = (HEAP32[gb + 72 >> 2] | 0) + (gb + 10857 | 0);
 HEAP32[gb + 76 >> 2] = (HEAP32[gb + 76 >> 2] | 0) + (gb + 10868 | 0);
 HEAP32[gb + 80 >> 2] = (HEAP32[gb + 80 >> 2] | 0) + (gb + 10883 | 0);
 HEAP32[gb + 84 >> 2] = (HEAP32[gb + 84 >> 2] | 0) + (gb + 10894 | 0);
 HEAP32[gb + 88 >> 2] = (HEAP32[gb + 88 >> 2] | 0) + (gb + 10909 | 0);
 HEAP32[gb + 92 >> 2] = (HEAP32[gb + 92 >> 2] | 0) + (gb + 10913 | 0);
 HEAP32[gb + 96 >> 2] = (HEAP32[gb + 96 >> 2] | 0) + (gb + 10936 | 0);
 HEAP32[gb + 100 >> 2] = (HEAP32[gb + 100 >> 2] | 0) + (gb + 10940 | 0);
 HEAP32[gb + 104 >> 2] = (HEAP32[gb + 104 >> 2] | 0) + (gb + 10963 | 0);
 HEAP32[gb + 108 >> 2] = (HEAP32[gb + 108 >> 2] | 0) + (gb + 10967 | 0);
 HEAP32[gb + 112 >> 2] = (HEAP32[gb + 112 >> 2] | 0) + (gb + 10990 | 0);
 HEAP32[gb + 116 >> 2] = (HEAP32[gb + 116 >> 2] | 0) + (gb + 10995 | 0);
 HEAP32[gb + 120 >> 2] = (HEAP32[gb + 120 >> 2] | 0) + (gb + 11019 | 0);
 HEAP32[gb + 124 >> 2] = (HEAP32[gb + 124 >> 2] | 0) + (gb + 11026 | 0);
 HEAP32[gb + 128 >> 2] = (HEAP32[gb + 128 >> 2] | 0) + (gb + 11061 | 0);
 HEAP32[gb + 132 >> 2] = (HEAP32[gb + 132 >> 2] | 0) + (gb + 11068 | 0);
 HEAP32[gb + 136 >> 2] = (HEAP32[gb + 136 >> 2] | 0) + (gb + 11103 | 0);
 HEAP32[gb + 140 >> 2] = (HEAP32[gb + 140 >> 2] | 0) + (gb + 11110 | 0);
 HEAP32[gb + 144 >> 2] = (HEAP32[gb + 144 >> 2] | 0) + (gb + 11145 | 0);
 HEAP32[gb + 148 >> 2] = (HEAP32[gb + 148 >> 2] | 0) + (gb + 11152 | 0);
 HEAP32[gb + 152 >> 2] = (HEAP32[gb + 152 >> 2] | 0) + (gb + 11187 | 0);
 HEAP32[gb + 156 >> 2] = (HEAP32[gb + 156 >> 2] | 0) + (gb + 11194 | 0);
 HEAP32[gb + 160 >> 2] = (HEAP32[gb + 160 >> 2] | 0) + (gb + 11229 | 0);
 HEAP32[gb + 164 >> 2] = (HEAP32[gb + 164 >> 2] | 0) + (gb + 11236 | 0);
 HEAP32[gb + 168 >> 2] = (HEAP32[gb + 168 >> 2] | 0) + (gb + 11271 | 0);
 HEAP32[gb + 172 >> 2] = (HEAP32[gb + 172 >> 2] | 0) + (gb + 11278 | 0);
 HEAP32[gb + 176 >> 2] = (HEAP32[gb + 176 >> 2] | 0) + (gb + 11313 | 0);
 HEAP32[gb + 180 >> 2] = (HEAP32[gb + 180 >> 2] | 0) + (gb + 11320 | 0);
 HEAP32[gb + 184 >> 2] = (HEAP32[gb + 184 >> 2] | 0) + (gb + 11355 | 0);
 HEAP32[gb + 188 >> 2] = (HEAP32[gb + 188 >> 2] | 0) + (gb + 11362 | 0);
 HEAP32[gb + 192 >> 2] = (HEAP32[gb + 192 >> 2] | 0) + (gb + 11397 | 0);
 HEAP32[gb + 196 >> 2] = (HEAP32[gb + 196 >> 2] | 0) + (gb + 11404 | 0);
 HEAP32[gb + 200 >> 2] = (HEAP32[gb + 200 >> 2] | 0) + (gb + 11439 | 0);
 HEAP32[gb + 204 >> 2] = (HEAP32[gb + 204 >> 2] | 0) + (gb + 11446 | 0);
 HEAP32[gb + 208 >> 2] = (HEAP32[gb + 208 >> 2] | 0) + (gb + 11481 | 0);
 HEAP32[gb + 212 >> 2] = (HEAP32[gb + 212 >> 2] | 0) + (gb + 11488 | 0);
 HEAP32[gb + 216 >> 2] = (HEAP32[gb + 216 >> 2] | 0) + (gb + 11523 | 0);
 HEAP32[gb + 220 >> 2] = (HEAP32[gb + 220 >> 2] | 0) + (gb + 11527 | 0);
 HEAP32[gb + 508 >> 2] = (HEAP32[gb + 508 >> 2] | 0) + (gb + 29657 | 0);
 HEAP32[gb + 512 >> 2] = (HEAP32[gb + 512 >> 2] | 0) + (gb + 29665 | 0);
 HEAP32[gb + 524 >> 2] = (HEAP32[gb + 524 >> 2] | 0) + (gb + 29672 | 0);
 HEAP32[gb + 528 >> 2] = (HEAP32[gb + 528 >> 2] | 0) + (gb + 29677 | 0);
 HEAP32[gb + 540 >> 2] = (HEAP32[gb + 540 >> 2] | 0) + (gb + 29700 | 0);
 HEAP32[gb + 544 >> 2] = (HEAP32[gb + 544 >> 2] | 0) + (gb + 29705 | 0);
 HEAP32[gb + 556 >> 2] = (HEAP32[gb + 556 >> 2] | 0) + (gb + 29728 | 0);
 HEAP32[gb + 560 >> 2] = (HEAP32[gb + 560 >> 2] | 0) + (gb + 29733 | 0);
 HEAP32[gb + 572 >> 2] = (HEAP32[gb + 572 >> 2] | 0) + (gb + 29756 | 0);
 HEAP32[gb + 576 >> 2] = (HEAP32[gb + 576 >> 2] | 0) + (gb + 29762 | 0);
 HEAP32[gb + 588 >> 2] = (HEAP32[gb + 588 >> 2] | 0) + (gb + 29786 | 0);
 HEAP32[gb + 592 >> 2] = (HEAP32[gb + 592 >> 2] | 0) + (gb + 29792 | 0);
 HEAP32[gb + 604 >> 2] = (HEAP32[gb + 604 >> 2] | 0) + (gb + 29816 | 0);
 HEAP32[gb + 608 >> 2] = (HEAP32[gb + 608 >> 2] | 0) + (gb + 29822 | 0);
 HEAP32[gb + 620 >> 2] = (HEAP32[gb + 620 >> 2] | 0) + (gb + 29846 | 0);
 HEAP32[gb + 624 >> 2] = (HEAP32[gb + 624 >> 2] | 0) + (gb + 29853 | 0);
 HEAP32[gb + 636 >> 2] = (HEAP32[gb + 636 >> 2] | 0) + (gb + 29878 | 0);
 HEAP32[gb + 640 >> 2] = (HEAP32[gb + 640 >> 2] | 0) + (gb + 29885 | 0);
 HEAP32[gb + 652 >> 2] = (HEAP32[gb + 652 >> 2] | 0) + (gb + 29910 | 0);
 HEAP32[gb + 656 >> 2] = (HEAP32[gb + 656 >> 2] | 0) + (gb + 29916 | 0);
 HEAP32[gb + 668 >> 2] = (HEAP32[gb + 668 >> 2] | 0) + (gb + 29952 | 0);
 HEAP32[gb + 672 >> 2] = (HEAP32[gb + 672 >> 2] | 0) + (gb + 29958 | 0);
 HEAP32[gb + 684 >> 2] = (HEAP32[gb + 684 >> 2] | 0) + (gb + 29994 | 0);
 HEAP32[gb + 688 >> 2] = (HEAP32[gb + 688 >> 2] | 0) + (gb + 3e4 | 0);
 HEAP32[gb + 700 >> 2] = (HEAP32[gb + 700 >> 2] | 0) + (gb + 30036 | 0);
 HEAP32[gb + 704 >> 2] = (HEAP32[gb + 704 >> 2] | 0) + (gb + 30043 | 0);
 HEAP32[gb + 716 >> 2] = (HEAP32[gb + 716 >> 2] | 0) + (gb + 30080 | 0);
 HEAP32[gb + 720 >> 2] = (HEAP32[gb + 720 >> 2] | 0) + (gb + 30087 | 0);
 HEAP32[gb + 732 >> 2] = (HEAP32[gb + 732 >> 2] | 0) + (gb + 30124 | 0);
 HEAP32[gb + 736 >> 2] = (HEAP32[gb + 736 >> 2] | 0) + (gb + 30131 | 0);
 HEAP32[gb + 748 >> 2] = (HEAP32[gb + 748 >> 2] | 0) + (gb + 30168 | 0);
 HEAP32[gb + 752 >> 2] = (HEAP32[gb + 752 >> 2] | 0) + (gb + 30176 | 0);
 HEAP32[gb + 764 >> 2] = (HEAP32[gb + 764 >> 2] | 0) + (gb + 30214 | 0);
 HEAP32[gb + 768 >> 2] = (HEAP32[gb + 768 >> 2] | 0) + (gb + 30222 | 0);
 HEAP32[gb + 780 >> 2] = (HEAP32[gb + 780 >> 2] | 0) + (gb + 30260 | 0);
 HEAP32[gb + 784 >> 2] = (HEAP32[gb + 784 >> 2] | 0) + (gb + 30265 | 0);
 HEAP32[gb + 796 >> 2] = (HEAP32[gb + 796 >> 2] | 0) + (gb + 30292 | 0);
 HEAP32[gb + 800 >> 2] = (HEAP32[gb + 800 >> 2] | 0) + (gb + 30297 | 0);
 HEAP32[gb + 812 >> 2] = (HEAP32[gb + 812 >> 2] | 0) + (gb + 30324 | 0);
 HEAP32[gb + 816 >> 2] = (HEAP32[gb + 816 >> 2] | 0) + (gb + 30329 | 0);
 HEAP32[gb + 828 >> 2] = (HEAP32[gb + 828 >> 2] | 0) + (gb + 30356 | 0);
 HEAP32[gb + 832 >> 2] = (HEAP32[gb + 832 >> 2] | 0) + (gb + 30362 | 0);
 HEAP32[gb + 844 >> 2] = (HEAP32[gb + 844 >> 2] | 0) + (gb + 30390 | 0);
 HEAP32[gb + 848 >> 2] = (HEAP32[gb + 848 >> 2] | 0) + (gb + 30396 | 0);
 runPostSets1();
}

function _fft_execute_dft_6(i7) {
 i7 = i7 | 0;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, d30 = 0.0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, d39 = 0.0, i40 = 0, i41 = 0, i42 = 0;
 i42 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i11 = i42 + 120 | 0;
 i12 = i42 + 112 | 0;
 i13 = i42 + 104 | 0;
 i14 = i42 + 96 | 0;
 i15 = i42 + 88 | 0;
 i16 = i42 + 80 | 0;
 i17 = i42 + 72 | 0;
 i18 = i42 + 64 | 0;
 i19 = i42 + 56 | 0;
 i20 = i42 + 48 | 0;
 i21 = i42 + 40 | 0;
 i22 = i42 + 32 | 0;
 i27 = i42 + 24 | 0;
 i31 = i42 + 16 | 0;
 i36 = i42 + 8 | 0;
 i40 = i42;
 i23 = HEAP32[i7 + 4 >> 2] | 0;
 i41 = HEAP32[i7 + 8 >> 2] | 0;
 i24 = i23 + 4 | 0;
 i25 = i23 + 8 | 0;
 i26 = i23 + 12 | 0;
 i28 = i23 + 16 | 0;
 i29 = i23 + 20 | 0;
 i32 = i23 + 24 | 0;
 i33 = i23 + 28 | 0;
 i34 = i23 + 32 | 0;
 i35 = i23 + 36 | 0;
 i37 = i23 + 40 | 0;
 i38 = i23 + 44 | 0;
 d39 = +HEAPF32[i24 >> 2] + +HEAPF32[i26 >> 2] + +HEAPF32[i29 >> 2] + +HEAPF32[i33 >> 2] + +HEAPF32[i35 >> 2] + +HEAPF32[i38 >> 2];
 HEAPF32[i41 >> 2] = +HEAPF32[i23 >> 2] + +HEAPF32[i25 >> 2] + +HEAPF32[i28 >> 2] + +HEAPF32[i32 >> 2] + +HEAPF32[i34 >> 2] + +HEAPF32[i37 >> 2];
 HEAPF32[i41 + 4 >> 2] = d39;
 i7 = (HEAP32[i7 + 12 >> 2] | 0) == 1;
 d39 = i7 ? -.8660253882408142 : .8660253882408142;
 d30 = i7 ? .8660253882408142 : -.8660253882408142;
 d8 = +HEAPF32[i23 >> 2];
 d9 = +HEAPF32[i24 >> 2];
 d1 = +HEAPF32[i25 >> 2];
 d2 = +HEAPF32[i26 >> 2];
 d3 = d1 * .5 - d39 * d2;
 d4 = d39 * d1 + d2 * .5;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i11, d1, d2, .5, d39);
  d3 = +HEAPF32[i11 >> 2];
  d4 = +HEAPF32[i11 + 4 >> 2];
 }
 d5 = +HEAPF32[i28 >> 2];
 d6 = +HEAPF32[i29 >> 2];
 d2 = d5 * -.5 - d39 * d6;
 d1 = d39 * d5 - d6 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i12, d5, d6, -.5, d39);
  d2 = +HEAPF32[i12 >> 2];
  d1 = +HEAPF32[i12 + 4 >> 2];
 }
 d10 = d8 + d3 + d2 - +HEAPF32[i32 >> 2];
 d8 = d9 + d4 + d1 - +HEAPF32[i33 >> 2];
 d2 = +HEAPF32[i34 >> 2];
 d3 = +HEAPF32[i35 >> 2];
 d1 = d2 * -.5 - d30 * d3;
 d4 = d30 * d2 - d3 * .5;
 if ((d1 != d1 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i13, d2, d3, -.5, d30);
  d6 = +HEAPF32[i13 >> 2];
  d4 = +HEAPF32[i13 + 4 >> 2];
 } else d6 = d1;
 d3 = +HEAPF32[i37 >> 2];
 d5 = +HEAPF32[i38 >> 2];
 d2 = d3 * .5 - d30 * d5;
 d1 = d30 * d3 + d5 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i14, d3, d5, .5, d30);
  d2 = +HEAPF32[i14 >> 2];
  d1 = +HEAPF32[i14 + 4 >> 2];
 }
 HEAPF32[i41 + 8 >> 2] = d10 + d6 + d2;
 HEAPF32[i41 + 12 >> 2] = d8 + d4 + d1;
 d8 = +HEAPF32[i23 >> 2];
 d9 = +HEAPF32[i24 >> 2];
 d1 = +HEAPF32[i25 >> 2];
 d2 = +HEAPF32[i26 >> 2];
 d3 = d1 * -.5 - d39 * d2;
 d4 = d39 * d1 - d2 * .5;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i15, d1, d2, -.5, d39);
  d3 = +HEAPF32[i15 >> 2];
  d4 = +HEAPF32[i15 + 4 >> 2];
 }
 d5 = +HEAPF32[i28 >> 2];
 d6 = +HEAPF32[i29 >> 2];
 d2 = d5 * -.5 - d30 * d6;
 d1 = d30 * d5 - d6 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i16, d5, d6, -.5, d30);
  d2 = +HEAPF32[i16 >> 2];
  d1 = +HEAPF32[i16 + 4 >> 2];
 }
 d10 = d8 + d3 + d2 + +HEAPF32[i32 >> 2];
 d8 = d9 + d4 + d1 + +HEAPF32[i33 >> 2];
 d1 = +HEAPF32[i34 >> 2];
 d2 = +HEAPF32[i35 >> 2];
 d3 = d1 * -.5 - d39 * d2;
 d4 = d39 * d1 - d2 * .5;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i17, d1, d2, -.5, d39);
  d3 = +HEAPF32[i17 >> 2];
  d4 = +HEAPF32[i17 + 4 >> 2];
 }
 d5 = +HEAPF32[i37 >> 2];
 d6 = +HEAPF32[i38 >> 2];
 d2 = d5 * -.5 - d30 * d6;
 d1 = d30 * d5 - d6 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i18, d5, d6, -.5, d30);
  d2 = +HEAPF32[i18 >> 2];
  d1 = +HEAPF32[i18 + 4 >> 2];
 }
 HEAPF32[i41 + 16 >> 2] = d10 + d3 + d2;
 HEAPF32[i41 + 20 >> 2] = d8 + d4 + d1;
 d8 = +HEAPF32[i24 >> 2] - +HEAPF32[i26 >> 2] + +HEAPF32[i29 >> 2] - +HEAPF32[i33 >> 2] + +HEAPF32[i35 >> 2] - +HEAPF32[i38 >> 2];
 HEAPF32[i41 + 24 >> 2] = +HEAPF32[i23 >> 2] - +HEAPF32[i25 >> 2] + +HEAPF32[i28 >> 2] - +HEAPF32[i32 >> 2] + +HEAPF32[i34 >> 2] - +HEAPF32[i37 >> 2];
 HEAPF32[i41 + 28 >> 2] = d8;
 d8 = +HEAPF32[i23 >> 2];
 d9 = +HEAPF32[i24 >> 2];
 d1 = +HEAPF32[i25 >> 2];
 d2 = +HEAPF32[i26 >> 2];
 d3 = d1 * -.5 - d30 * d2;
 d4 = d30 * d1 - d2 * .5;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i19, d1, d2, -.5, d30);
  d3 = +HEAPF32[i19 >> 2];
  d4 = +HEAPF32[i19 + 4 >> 2];
 }
 d5 = +HEAPF32[i28 >> 2];
 d6 = +HEAPF32[i29 >> 2];
 d2 = d5 * -.5 - d39 * d6;
 d1 = d39 * d5 - d6 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i20, d5, d6, -.5, d39);
  d2 = +HEAPF32[i20 >> 2];
  d1 = +HEAPF32[i20 + 4 >> 2];
 }
 d10 = d8 + d3 + d2 + +HEAPF32[i32 >> 2];
 d8 = d9 + d4 + d1 + +HEAPF32[i33 >> 2];
 d1 = +HEAPF32[i34 >> 2];
 d2 = +HEAPF32[i35 >> 2];
 d3 = d1 * -.5 - d30 * d2;
 d4 = d30 * d1 - d2 * .5;
 if ((d3 != d3 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i21, d1, d2, -.5, d30);
  d3 = +HEAPF32[i21 >> 2];
  d4 = +HEAPF32[i21 + 4 >> 2];
 }
 d5 = +HEAPF32[i37 >> 2];
 d6 = +HEAPF32[i38 >> 2];
 d2 = d5 * -.5 - d39 * d6;
 d1 = d39 * d5 - d6 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i22, d5, d6, -.5, d39);
  d2 = +HEAPF32[i22 >> 2];
  d1 = +HEAPF32[i22 + 4 >> 2];
 }
 HEAPF32[i41 + 32 >> 2] = d10 + d3 + d2;
 HEAPF32[i41 + 36 >> 2] = d8 + d4 + d1;
 d8 = +HEAPF32[i23 >> 2];
 d9 = +HEAPF32[i24 >> 2];
 d3 = +HEAPF32[i25 >> 2];
 d1 = +HEAPF32[i26 >> 2];
 d2 = d3 * .5 - d30 * d1;
 d4 = d30 * d3 + d1 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d4 != d4 | 0.0 != 0.0)) {
  ___mulsc3(i27, d3, d1, .5, d30);
  d6 = +HEAPF32[i27 >> 2];
  d5 = +HEAPF32[i27 + 4 >> 2];
 } else {
  d6 = d2;
  d5 = d4;
 }
 d4 = +HEAPF32[i28 >> 2];
 d3 = +HEAPF32[i29 >> 2];
 d2 = d4 * -.5 - d30 * d3;
 d1 = d30 * d4 - d3 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i31, d4, d3, -.5, d30);
  d2 = +HEAPF32[i31 >> 2];
  d1 = +HEAPF32[i31 + 4 >> 2];
 }
 d6 = d8 + d6 + d2 - +HEAPF32[i32 >> 2];
 d5 = d9 + d5 + d1 - +HEAPF32[i33 >> 2];
 d4 = +HEAPF32[i34 >> 2];
 d3 = +HEAPF32[i35 >> 2];
 d2 = d4 * -.5 - d39 * d3;
 d1 = d39 * d4 - d3 * .5;
 if ((d2 != d2 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i36, d4, d3, -.5, d39);
  d2 = +HEAPF32[i36 >> 2];
  d1 = +HEAPF32[i36 + 4 >> 2];
 }
 d6 = d6 + d2;
 d5 = d5 + d1;
 d4 = +HEAPF32[i37 >> 2];
 d1 = +HEAPF32[i38 >> 2];
 d2 = d4 * .5 - d39 * d1;
 d3 = d39 * d4 + d1 * .5;
 if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
  d30 = d2;
  d39 = d3;
  d30 = d6 + d30;
  d39 = d5 + d39;
  i40 = i41 + 40 | 0;
  i41 = i41 + 44 | 0;
  HEAPF32[i40 >> 2] = d30;
  HEAPF32[i41 >> 2] = d39;
  STACKTOP = i42;
  return;
 }
 ___mulsc3(i40, d4, d1, .5, d39);
 d30 = +HEAPF32[i40 >> 2];
 d39 = +HEAPF32[i40 + 4 >> 2];
 d30 = d6 + d30;
 d39 = d5 + d39;
 i40 = i41 + 40 | 0;
 i41 = i41 + 44 | 0;
 HEAPF32[i40 >> 2] = d30;
 HEAPF32[i41 >> 2] = d39;
 STACKTOP = i42;
 return;
}

function _quiet_decoder_destroy(i6) {
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0;
 if (!i6) return;
 switch (HEAP32[i6 + 52 >> 2] | 0) {
 case 0:
  {
   i2 = HEAP32[i6 + 60 >> 2] | 0;
   i3 = HEAP32[i2 + 184 >> 2] | 0;
   i1 = HEAP32[i3 + 176 >> 2] | 0;
   if (i1 | 0) {
    _free(HEAP32[i1 >> 2] | 0);
    _free(i1);
   }
   i1 = HEAP32[i3 + 180 >> 2] | 0;
   if (i1 | 0) {
    _free(HEAP32[i1 >> 2] | 0);
    _free(i1);
   }
   i1 = HEAP32[i3 + 184 >> 2] | 0;
   if (i1 | 0) {
    _free(HEAP32[i1 >> 2] | 0);
    _free(i1);
   }
   i1 = HEAP32[i3 + 188 >> 2] | 0;
   if (i1 | 0) _free(i1);
   i1 = HEAP32[i3 + 192 >> 2] | 0;
   if (i1 | 0) _free(i1);
   i1 = HEAP32[i3 + 196 >> 2] | 0;
   if (i1 | 0) _free(i1);
   i1 = HEAP32[i3 + 208 >> 2] | 0;
   if (i1 | 0) {
    _free(HEAP32[i1 >> 2] | 0);
    _free(i1);
   }
   i1 = HEAP32[i3 + 212 >> 2] | 0;
   if (i1 | 0) {
    _free(HEAP32[i1 >> 2] | 0);
    _free(i1);
   }
   _free(HEAP32[i3 + 12 >> 2] | 0);
   i5 = HEAP32[i3 + 60 >> 2] | 0;
   _free(HEAP32[i5 >> 2] | 0);
   _free(i5);
   _free(HEAP32[i3 + 52 >> 2] | 0);
   _free(HEAP32[i3 + 56 >> 2] | 0);
   _fft_destroy_plan(HEAP32[i3 + 48 >> 2] | 0);
   _free(HEAP32[i3 + 64 >> 2] | 0);
   _free(HEAP32[i3 + 68 >> 2] | 0);
   _free(HEAP32[i3 + 72 >> 2] | 0);
   _free(HEAP32[i3 + 76 >> 2] | 0);
   _free(HEAP32[i3 + 84 >> 2] | 0);
   _free(HEAP32[i3 + 88 >> 2] | 0);
   _free(HEAP32[i3 + 92 >> 2] | 0);
   _free(HEAP32[i3 + 96 >> 2] | 0);
   _free(HEAP32[i3 + 100 >> 2] | 0);
   _free(HEAP32[i3 + 108 >> 2] | 0);
   _free(HEAP32[i3 + 112 >> 2] | 0);
   _free(i3);
   _packetizer_destroy(HEAP32[i2 + 40 >> 2] | 0);
   _modem_destroy(HEAP32[i2 + 36 >> 2] | 0);
   _packetizer_destroy(HEAP32[i2 + 100 >> 2] | 0);
   _modem_destroy(HEAP32[i2 + 104 >> 2] | 0);
   _free(HEAP32[i2 + 12 >> 2] | 0);
   _free(HEAP32[i2 + 108 >> 2] | 0);
   _free(HEAP32[i2 + 112 >> 2] | 0);
   _free(HEAP32[i2 + 128 >> 2] | 0);
   _free(HEAP32[i2 + 44 >> 2] | 0);
   _free(HEAP32[i2 + 48 >> 2] | 0);
   _free(HEAP32[i2 + 52 >> 2] | 0);
   _free(i2);
   break;
  }
 case 1:
  {
   i4 = HEAP32[i6 + 60 >> 2] | 0;
   if (HEAP32[i4 + 208 >> 2] | 0) {
    i5 = HEAP32[i4 + 216 >> 2] | 0;
    _free(HEAP32[i5 >> 2] | 0);
    _free(i5);
   }
   _free(HEAP32[i4 + 116 >> 2] | 0);
   _free(HEAP32[i4 + 120 >> 2] | 0);
   _free(HEAP32[i4 + 124 >> 2] | 0);
   _free(HEAP32[i4 + 136 >> 2] | 0);
   _free(HEAP32[i4 + 156 >> 2] | 0);
   _free(HEAP32[i4 + 168 >> 2] | 0);
   _free(HEAP32[i4 + 180 >> 2] | 0);
   i1 = HEAP32[i4 + 132 >> 2] | 0;
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 24 >> 2] | 0);
   _free(HEAP32[i1 + 28 >> 2] | 0);
   _fft_destroy_plan(HEAP32[i1 + 32 >> 2] | 0);
   _free(i1);
   i1 = HEAP32[i4 + 144 >> 2] | 0;
   _packetizer_destroy(HEAP32[i1 + 4 >> 2] | 0);
   _modem_destroy(HEAP32[i1 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 20 >> 2] | 0);
   _free(i1);
   _modem_destroy(HEAP32[i4 + 164 >> 2] | 0);
   i1 = HEAP32[i4 + 176 >> 2] | 0;
   _packetizer_destroy(HEAP32[i1 + 4 >> 2] | 0);
   _modem_destroy(HEAP32[i1 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 20 >> 2] | 0);
   _free(i1);
   i1 = HEAP32[i4 + 72 >> 2] | 0;
   _free(HEAP32[i1 + 4 >> 2] | 0);
   _free(HEAP32[i1 + 8 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 20 >> 2] | 0);
   _free(HEAP32[i1 + 24 >> 2] | 0);
   _free(HEAP32[i1 + 28 >> 2] | 0);
   _fft_destroy_plan(HEAP32[i1 + 36 >> 2] | 0);
   _fft_destroy_plan(HEAP32[i1 + 40 >> 2] | 0);
   _free(i1);
   i1 = HEAP32[i4 + 100 >> 2] | 0;
   i2 = i1 + 12 | 0;
   i3 = i1 + 20 | 0;
   if (HEAP32[i2 >> 2] | 0) {
    i5 = 0;
    do {
     i7 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0;
     _free(HEAP32[i7 >> 2] | 0);
     _free(i7);
     i5 = i5 + 1 | 0;
    } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   _free(HEAP32[i3 >> 2] | 0);
   i7 = HEAP32[i1 + 16 >> 2] | 0;
   _free(HEAP32[i7 >> 2] | 0);
   _free(i7);
   _free(i1);
   _free(HEAP32[i4 + 92 >> 2] | 0);
   _free(HEAP32[i4 + 96 >> 2] | 0);
   _free(i4);
   break;
  }
 case 2:
  {
   i5 = HEAP32[i6 + 60 >> 2] | 0;
   if (HEAP32[i5 + 236 >> 2] | 0) {
    i7 = HEAP32[i5 + 240 >> 2] | 0;
    _free(HEAP32[i7 >> 2] | 0);
    _free(i7);
    i7 = HEAP32[i5 + 244 >> 2] | 0;
    _free(HEAP32[i7 >> 2] | 0);
    _free(i7);
    i7 = HEAP32[i5 + 248 >> 2] | 0;
    _free(HEAP32[i7 >> 2] | 0);
    _free(i7);
    i7 = HEAP32[i5 + 252 >> 2] | 0;
    _free(HEAP32[i7 >> 2] | 0);
    _free(i7);
   }
   _iirfilt_crcf_destroy(HEAP32[i5 >> 2] | 0);
   i1 = HEAP32[i5 + 76 >> 2] | 0;
   i2 = i1 + 12 | 0;
   i3 = i1 + 20 | 0;
   if (HEAP32[i2 >> 2] | 0) {
    i4 = 0;
    do {
     i7 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i4 << 2) >> 2] | 0;
     _free(HEAP32[i7 >> 2] | 0);
     _free(i7);
     i4 = i4 + 1 | 0;
    } while (i4 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   _free(HEAP32[i3 >> 2] | 0);
   i2 = HEAP32[i1 + 16 >> 2] | 0;
   _free(HEAP32[i2 >> 2] | 0);
   _free(i2);
   _free(i1);
   i1 = HEAP32[i5 + 80 >> 2] | 0;
   i2 = i1 + 12 | 0;
   i3 = i1 + 20 | 0;
   if (HEAP32[i2 >> 2] | 0) {
    i4 = 0;
    do {
     i7 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i4 << 2) >> 2] | 0;
     _free(HEAP32[i7 >> 2] | 0);
     _free(i7);
     i4 = i4 + 1 | 0;
    } while (i4 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   _free(HEAP32[i3 >> 2] | 0);
   i2 = HEAP32[i1 + 16 >> 2] | 0;
   _free(HEAP32[i2 >> 2] | 0);
   _free(i2);
   _free(i1);
   _free(HEAP32[i5 + 128 >> 2] | 0);
   i1 = HEAP32[i5 + 108 >> 2] | 0;
   i2 = HEAP32[i1 + 16 >> 2] | 0;
   _free(HEAP32[i2 >> 2] | 0);
   _free(i2);
   i2 = i1 + 24 | 0;
   i3 = i1 + 20 | 0;
   if (HEAP32[i2 >> 2] | 0) {
    i4 = 0;
    do {
     i7 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i4 << 2) >> 2] | 0;
     _free(HEAP32[i7 >> 2] | 0);
     _free(i7);
     i4 = i4 + 1 | 0;
    } while (i4 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
   }
   _free(HEAP32[i3 >> 2] | 0);
   _free(HEAP32[i1 + 36 >> 2] | 0);
   _free(HEAP32[i1 + 40 >> 2] | 0);
   _free(HEAP32[i1 + 44 >> 2] | 0);
   _free(HEAP32[i1 + 48 >> 2] | 0);
   i7 = HEAP32[i1 + 60 >> 2] | 0;
   _free(HEAP32[i7 >> 2] | 0);
   _free(i7);
   _free(HEAP32[i1 >> 2] | 0);
   _free(i1);
   i7 = HEAP32[i5 + 124 >> 2] | 0;
   _free(HEAP32[i7 >> 2] | 0);
   _free(i7);
   _free(HEAP32[i5 + 136 >> 2] | 0);
   _free(HEAP32[i5 + 140 >> 2] | 0);
   _packetizer_destroy(HEAP32[i5 + 168 >> 2] | 0);
   _free(HEAP32[i5 + 156 >> 2] | 0);
   _free(HEAP32[i5 + 160 >> 2] | 0);
   _free(HEAP32[i5 + 164 >> 2] | 0);
   _packetizer_destroy(HEAP32[i5 + 208 >> 2] | 0);
   _free(HEAP32[i5 + 200 >> 2] | 0);
   _free(HEAP32[i5 + 204 >> 2] | 0);
   _free(i5);
   break;
  }
 default:
  {}
 }
 i1 = HEAP32[i6 + 96 >> 2] | 0;
 if (i1 | 0) _resamp_rrrf_destroy(i1);
 i1 = HEAP32[i6 + 100 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i6 + 64 >> 2] | 0;
 if (i1 | 0) {
  _free(HEAP32[i1 + 16 >> 2] | 0);
  i2 = HEAP32[i1 + 20 >> 2] | 0;
  if (i2 | 0) {
   i7 = HEAP32[i2 + 12 >> 2] | 0;
   _free(HEAP32[i7 >> 2] | 0);
   _free(i7);
   i7 = HEAP32[i2 + 16 >> 2] | 0;
   _free(HEAP32[i7 >> 2] | 0);
   _free(i7);
   _free(HEAP32[i2 >> 2] | 0);
   _free(i2);
  }
  _free(i1);
 }
 _free(HEAP32[i6 + 80 >> 2] | 0);
 _free(HEAP32[i6 + 68 >> 2] | 0);
 _free(i6);
 return;
}

function _fft_execute_dft_8(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, i6 = 0, i7 = 0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, d26 = 0.0, i27 = 0, i28 = 0, d29 = 0.0, d30 = 0.0, d31 = 0.0, d32 = 0.0, d33 = 0.0, d34 = 0.0, d35 = 0.0, d36 = 0.0, d37 = 0.0, d38 = 0.0, d39 = 0.0, d40 = 0.0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0;
 i23 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i6 = i23 + 48 | 0;
 i7 = i23 + 32 | 0;
 i17 = i23 + 16 | 0;
 i18 = i23;
 i21 = HEAP32[i1 + 4 >> 2] | 0;
 i25 = HEAP32[i1 + 8 >> 2] | 0;
 i16 = (HEAP32[i1 + 12 >> 2] | 0) == 1;
 i52 = HEAP32[i21 >> 2] | 0;
 i51 = HEAP32[i21 + 4 >> 2] | 0;
 i24 = i25 + 4 | 0;
 HEAP32[i25 >> 2] = i52;
 HEAP32[i24 >> 2] = i51;
 i54 = HEAP32[i21 + 32 >> 2] | 0;
 i53 = HEAP32[i21 + 36 >> 2] | 0;
 i1 = i25 + 8 | 0;
 i9 = i25 + 12 | 0;
 HEAP32[i1 >> 2] = i54;
 HEAP32[i9 >> 2] = i53;
 i48 = HEAP32[i21 + 16 >> 2] | 0;
 i47 = HEAP32[i21 + 20 >> 2] | 0;
 i10 = i25 + 16 | 0;
 i11 = i25 + 20 | 0;
 HEAP32[i10 >> 2] = i48;
 HEAP32[i11 >> 2] = i47;
 i50 = HEAP32[i21 + 48 >> 2] | 0;
 i49 = HEAP32[i21 + 52 >> 2] | 0;
 i19 = i25 + 24 | 0;
 i20 = i25 + 28 | 0;
 HEAP32[i19 >> 2] = i50;
 HEAP32[i20 >> 2] = i49;
 i44 = HEAP32[i21 + 8 >> 2] | 0;
 i43 = HEAP32[i21 + 12 >> 2] | 0;
 i28 = i25 + 32 | 0;
 i27 = i25 + 36 | 0;
 HEAP32[i28 >> 2] = i44;
 HEAP32[i27 >> 2] = i43;
 i46 = HEAP32[i21 + 40 >> 2] | 0;
 i45 = HEAP32[i21 + 44 >> 2] | 0;
 i12 = i25 + 40 | 0;
 i13 = i25 + 44 | 0;
 HEAP32[i12 >> 2] = i46;
 HEAP32[i13 >> 2] = i45;
 i42 = HEAP32[i21 + 24 >> 2] | 0;
 i41 = HEAP32[i21 + 28 >> 2] | 0;
 i14 = i25 + 48 | 0;
 i15 = i25 + 52 | 0;
 HEAP32[i14 >> 2] = i42;
 HEAP32[i15 >> 2] = i41;
 d3 = +HEAPF32[i21 + 56 >> 2];
 d2 = +HEAPF32[i21 + 60 >> 2];
 i21 = i25 + 56 | 0;
 i22 = i25 + 60 | 0;
 d38 = (HEAP32[tempDoublePtr >> 2] = i54, +HEAPF32[tempDoublePtr >> 2]);
 d37 = (HEAP32[tempDoublePtr >> 2] = i53, +HEAPF32[tempDoublePtr >> 2]);
 d4 = (HEAP32[tempDoublePtr >> 2] = i52, +HEAPF32[tempDoublePtr >> 2]);
 d26 = (HEAP32[tempDoublePtr >> 2] = i51, +HEAPF32[tempDoublePtr >> 2]);
 d34 = d4 - d38;
 d32 = d26 - d37;
 d38 = d4 + d38;
 d37 = d26 + d37;
 d26 = (HEAP32[tempDoublePtr >> 2] = i50, +HEAPF32[tempDoublePtr >> 2]);
 d4 = (HEAP32[tempDoublePtr >> 2] = i49, +HEAPF32[tempDoublePtr >> 2]);
 d35 = (HEAP32[tempDoublePtr >> 2] = i48, +HEAPF32[tempDoublePtr >> 2]);
 d36 = (HEAP32[tempDoublePtr >> 2] = i47, +HEAPF32[tempDoublePtr >> 2]);
 d31 = d35 - d26;
 d33 = d36 - d4;
 d26 = d35 + d26;
 d4 = d36 + d4;
 d36 = (HEAP32[tempDoublePtr >> 2] = i46, +HEAPF32[tempDoublePtr >> 2]);
 d35 = (HEAP32[tempDoublePtr >> 2] = i45, +HEAPF32[tempDoublePtr >> 2]);
 d39 = (HEAP32[tempDoublePtr >> 2] = i44, +HEAPF32[tempDoublePtr >> 2]);
 d40 = (HEAP32[tempDoublePtr >> 2] = i43, +HEAPF32[tempDoublePtr >> 2]);
 d30 = d39 - d36;
 d29 = d40 - d35;
 d36 = d39 + d36;
 d35 = d40 + d35;
 d40 = (HEAP32[tempDoublePtr >> 2] = i42, +HEAPF32[tempDoublePtr >> 2]);
 d39 = (HEAP32[tempDoublePtr >> 2] = i41, +HEAPF32[tempDoublePtr >> 2]);
 d8 = d40 - d3;
 d5 = d39 - d2;
 d3 = d40 + d3;
 d2 = d39 + d2;
 HEAPF32[i10 >> 2] = d38 - d26;
 HEAPF32[i11 >> 2] = d37 - d4;
 d26 = d38 + d26;
 d4 = d37 + d4;
 HEAPF32[i14 >> 2] = d36 - d3;
 HEAPF32[i15 >> 2] = d35 - d2;
 d3 = d36 + d3;
 d2 = d35 + d2;
 d35 = d31 * 0.0;
 d33 = i16 ? d33 - d35 : d35 - d33;
 d31 = i16 ? -d31 : d31;
 HEAPF32[i19 >> 2] = d34 - d33;
 HEAPF32[i20 >> 2] = d32 - d31;
 HEAPF32[i1 >> 2] = d34 + d33;
 HEAPF32[i9 >> 2] = d32 + d31;
 d31 = d8 * 0.0;
 d5 = i16 ? d5 - d31 : d31 - d5;
 d8 = i16 ? -d8 : d8;
 HEAPF32[i21 >> 2] = d30 - d5;
 HEAPF32[i22 >> 2] = d29 - d8;
 d5 = d30 + d5;
 d8 = d29 + d8;
 HEAPF32[i12 >> 2] = d5;
 HEAPF32[i13 >> 2] = d8;
 HEAPF32[i28 >> 2] = d26 - d3;
 HEAPF32[i27 >> 2] = d4 - d2;
 HEAPF32[i25 >> 2] = d26 + d3;
 HEAPF32[i24 >> 2] = d4 + d2;
 d2 = d5 * .7071067811865476;
 d4 = d8 * .7071067811865476;
 if (i16) {
  d3 = d4 + d2;
  d2 = d4 - d2;
  if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___muldc3(i6, d5, d8, .7071067811865476, -.7071067811865476);
   d3 = +HEAPF64[i6 >> 3];
   d2 = +HEAPF64[i6 + 8 >> 3];
  }
 } else {
  d3 = d2 - d4;
  d2 = d4 + d2;
  if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
   ___muldc3(i7, d5, d8, .7071067811865476, .7071067811865476);
   d3 = +HEAPF64[i7 >> 3];
   d2 = +HEAPF64[i7 + 8 >> 3];
  }
 }
 d5 = d2;
 d4 = d3;
 d40 = +HEAPF32[i1 >> 2];
 d2 = +HEAPF32[i9 >> 2];
 HEAPF32[i12 >> 2] = d40 - d4;
 HEAPF32[i13 >> 2] = d2 - d5;
 HEAPF32[i1 >> 2] = d4 + d40;
 HEAPF32[i9 >> 2] = d5 + d2;
 d2 = +HEAPF32[i15 >> 2];
 d5 = +HEAPF32[i14 >> 2];
 d40 = d5 * 0.0;
 d2 = i16 ? d2 - d40 : d40 - d2;
 d5 = i16 ? -d5 : d5;
 d40 = +HEAPF32[i10 >> 2];
 d4 = +HEAPF32[i11 >> 2];
 HEAPF32[i14 >> 2] = d40 - d2;
 HEAPF32[i15 >> 2] = d4 - d5;
 HEAPF32[i10 >> 2] = d40 + d2;
 HEAPF32[i11 >> 2] = d5 + d4;
 d4 = +HEAPF32[i21 >> 2];
 d5 = +HEAPF32[i22 >> 2];
 d2 = d4 * -.7071067811865476;
 if (i16) {
  d40 = d5 * -.7071067811865476;
  d3 = d2 - d40;
  d2 = d2 + d40;
  if (!((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0))) {
   d37 = d3;
   d38 = d2;
   d39 = +HEAPF32[i19 >> 2];
   d40 = +HEAPF32[i20 >> 2];
   d35 = d39 - d37;
   d36 = d40 - d38;
   HEAPF32[i21 >> 2] = d35;
   HEAPF32[i22 >> 2] = d36;
   d39 = d37 + d39;
   d40 = d38 + d40;
   HEAPF32[i19 >> 2] = d39;
   HEAPF32[i20 >> 2] = d40;
   STACKTOP = i23;
   return;
  }
  ___muldc3(i17, d4, d5, -.7071067811865476, -.7071067811865476);
  d37 = +HEAPF64[i17 >> 3];
  d38 = +HEAPF64[i17 + 8 >> 3];
  d39 = +HEAPF32[i19 >> 2];
  d40 = +HEAPF32[i20 >> 2];
  d35 = d39 - d37;
  d36 = d40 - d38;
  HEAPF32[i21 >> 2] = d35;
  HEAPF32[i22 >> 2] = d36;
  d39 = d37 + d39;
  d40 = d38 + d40;
  HEAPF32[i19 >> 2] = d39;
  HEAPF32[i20 >> 2] = d40;
  STACKTOP = i23;
  return;
 } else {
  d3 = d5 * .7071067811865476;
  d2 = d2 - d3;
  d3 = d4 * .7071067811865476 - d3;
  if (!((d2 != d2 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0))) {
   d37 = d2;
   d38 = d3;
   d39 = +HEAPF32[i19 >> 2];
   d40 = +HEAPF32[i20 >> 2];
   d35 = d39 - d37;
   d36 = d40 - d38;
   HEAPF32[i21 >> 2] = d35;
   HEAPF32[i22 >> 2] = d36;
   d39 = d37 + d39;
   d40 = d38 + d40;
   HEAPF32[i19 >> 2] = d39;
   HEAPF32[i20 >> 2] = d40;
   STACKTOP = i23;
   return;
  }
  ___muldc3(i18, d4, d5, -.7071067811865476, .7071067811865476);
  d37 = +HEAPF64[i18 >> 3];
  d38 = +HEAPF64[i18 + 8 >> 3];
  d39 = +HEAPF32[i19 >> 2];
  d40 = +HEAPF32[i20 >> 2];
  d35 = d39 - d37;
  d36 = d40 - d38;
  HEAPF32[i21 >> 2] = d35;
  HEAPF32[i22 >> 2] = d36;
  d39 = d37 + d39;
  d40 = d38 + d40;
  HEAPF32[i19 >> 2] = d39;
  HEAPF32[i20 >> 2] = d40;
  STACKTOP = i23;
  return;
 }
}

function _firdespm_compute_taps(i13, i25) {
 i13 = i13 | 0;
 i25 = i25 | 0;
 var i1 = 0, i2 = 0, i3 = 0, F44 = SIMD_Float32x4(0, 0, 0, 0), d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i26 = 0, d27 = 0.0;
 i26 = STACKTOP;
 _firdespm_compute_interp(i13);
 i23 = i13 + 12 | 0;
 i3 = HEAP32[i23 >> 2] | 0;
 i22 = HEAP32[i13 + 4 >> 2] | 0;
 i21 = i3 - i22 | 0;
 i19 = i21 + 1 | 0;
 i24 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i19 << 3) | 0) + 15 & -16) | 0;
 L1 : do if (!i19) {
  i2 = HEAP32[i13 + 28 >> 2] | 0;
  i20 = 19;
 } else {
  i14 = i3 + 1 | 0;
  i15 = i14 - i22 | 0;
  i11 = HEAP32[i13 >> 2] | 0;
  d10 = +(i11 >>> 0);
  i16 = HEAP32[i13 + 64 >> 2] | 0;
  i17 = HEAP32[i13 + 72 >> 2] | 0;
  i18 = HEAP32[i13 + 68 >> 2] | 0;
  i2 = HEAP32[i13 + 28 >> 2] | 0;
  i19 = (i14 | 0) == 0;
  if (i2 | 0) {
   i12 = 0;
   while (1) {
    d8 = +Math_cos(+(+(i12 >>> 0) / d10 * 6.283185307179586));
    L7 : do if (i19) {
     d6 = 0.0;
     d5 = 0.0;
     i20 = 17;
    } else {
     i11 = 0;
     d6 = 0.0;
     d5 = 0.0;
     while (1) {
      d7 = d8 - +HEAPF64[i16 + (i11 << 3) >> 3];
      if (+Math_abs(+d7) < 9.999999974752427e-07) break;
      d9 = +HEAPF64[i18 + (i11 << 3) >> 3];
      d6 = d6 + d9 * +HEAPF64[i17 + (i11 << 3) >> 3] / d7;
      d5 = d5 + d9 / d7;
      i11 = i11 + 1 | 0;
      if (i11 >>> 0 >= i14 >>> 0) {
       i20 = 17;
       break L7;
      }
     }
     d5 = +HEAPF64[i17 + (i11 << 3) >> 3];
    } while (0);
    if ((i20 | 0) == 17) {
     i20 = 0;
     d5 = d6 / d5;
    }
    HEAPF64[i24 + (i12 << 3) >> 3] = d5;
    i12 = i12 + 1 | 0;
    if ((i12 | 0) == (i15 | 0)) {
     i20 = 19;
     break L1;
    }
   }
  }
  i12 = (i22 | 0) == 0;
  i13 = 0;
  do {
   d9 = +(i13 >>> 0);
   d8 = +Math_cos(+(d9 / d10 * 6.283185307179586));
   L18 : do if (i19) {
    d6 = 0.0;
    d5 = 0.0;
    i20 = 9;
   } else {
    i2 = 0;
    d6 = 0.0;
    d5 = 0.0;
    while (1) {
     d7 = d8 - +HEAPF64[i16 + (i2 << 3) >> 3];
     if (+Math_abs(+d7) < 9.999999974752427e-07) break;
     d27 = +HEAPF64[i18 + (i2 << 3) >> 3];
     d6 = d6 + d27 * +HEAPF64[i17 + (i2 << 3) >> 3] / d7;
     d5 = d5 + d27 / d7;
     i2 = i2 + 1 | 0;
     if (i2 >>> 0 >= i14 >>> 0) {
      i20 = 9;
      break L18;
     }
    }
    d6 = +HEAPF64[i17 + (i2 << 3) >> 3];
   } while (0);
   if ((i20 | 0) == 9) {
    i20 = 0;
    d6 = d6 / d5;
   }
   if (i12) d5 = +Math_cos(+(d9 * 3.141592653589793 / d10)); else d5 = 1.0;
   HEAPF64[i24 + (i13 << 3) >> 3] = d6 * d5;
   i13 = i13 + 1 | 0;
  } while ((i13 | 0) != (i15 | 0));
 } while (0);
 do if ((i20 | 0) == 19) {
  if (!i2) {
   i11 = HEAP32[i13 >> 2] | 0;
   break;
  }
  switch (i22 | 0) {
  case 1:
   {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i1;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     STACKTOP = i26;
     return;
    } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
    if ((i1 - i2 | 0) >>> 0 < 73) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21093 | 0, 73) | 0;
     STACKTOP = i26;
     return;
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21093 | 0, 73) | 0) >>> 0 < 73) {
     STACKTOP = i26;
     return;
    } else {
     i1 = 0;
     i3 = gb + 21093 + 73 | 0;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i1 = 73;
     i3 = gb + 21093 | 0;
    } while (0);
    _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
    STACKTOP = i26;
    return;
   }
  case 0:
   {
    i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
    do if (!i1) {
     i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
     HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
     i1 = HEAP32[gb + 8728 >> 2] | 0;
     if (!(i1 & 8)) {
      HEAP32[gb + 8728 + 8 >> 2] = 0;
      HEAP32[gb + 8728 + 4 >> 2] = 0;
      i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
      HEAP32[gb + 8728 + 28 >> 2] = i2;
      HEAP32[gb + 8728 + 20 >> 2] = i2;
      i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
      HEAP32[gb + 8728 + 16 >> 2] = i1;
      break;
     }
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     STACKTOP = i26;
     return;
    } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
    if ((i1 - i2 | 0) >>> 0 < 73) {
     mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21093 | 0, 73) | 0;
     STACKTOP = i26;
     return;
    }
    do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21093 | 0, 73) | 0) >>> 0 < 73) {
     STACKTOP = i26;
     return;
    } else {
     i1 = 0;
     i3 = gb + 21093 + 73 | 0;
     i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     break;
    } else {
     i1 = 73;
     i3 = gb + 21093 | 0;
    } while (0);
    _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
    HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
    STACKTOP = i26;
    return;
   }
  default:
   {
    STACKTOP = i26;
    return;
   }
  }
 } while (0);
 if (!i11) {
  STACKTOP = i26;
  return;
 }
 d10 = +HEAPF64[i24 >> 3];
 d9 = +(i21 >>> 0);
 d7 = +((1 - i22 | 0) >>> 0) * .5;
 d8 = +(i11 >>> 0);
 if (i3 >>> 0 > 1) {
  i1 = 0;
  while (1) {
   d5 = (d7 + (+(i1 >>> 0) - d9)) / d8 * 6.283185307179586;
   i2 = 1;
   d6 = d10;
   do {
    d6 = d6 + +HEAPF64[i24 + (i2 << 3) >> 3] * 2.0 * +Math_cos(+(d5 * +(i2 >>> 0)));
    i2 = i2 + 1 | 0;
   } while (i2 >>> 0 < i3 >>> 0);
   HEAPF32[i25 + (i1 << 2) >> 2] = d6 / d8;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= i11 >>> 0) break;
   i3 = HEAP32[i23 >> 2] | 0;
  }
  STACKTOP = i26;
  return;
 }
 d5 = d10 / d8;
 if (i11 >>> 0 >= 4 ? (i1 = i11 & -4, (i1 | 0) != 0) : 0) {
  F44 = SIMD_Float32x4_splat(Math_fround(d5));
  i2 = 0;
  do {
   SIMD_Float32x4_store(HEAPU8, i25 + (i2 << 2) | 0, F44);
   i2 = i2 + 4 | 0;
  } while ((i2 | 0) != (i1 | 0));
  if ((i11 | 0) == (i1 | 0)) {
   STACKTOP = i26;
   return;
  }
 } else i1 = 0;
 do {
  HEAPF32[i25 + (i1 << 2) >> 2] = d5;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i11 >>> 0);
 STACKTOP = i26;
 return;
}

function _detector_cccf_create(i2, i7) {
 i2 = i2 | 0;
 i7 = i7 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0;
 i29 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i26 = i29 + 16 | 0;
 i27 = i29 + 8 | 0;
 i28 = i29;
 if (i7 | 0) {
  i22 = _malloc(80) | 0;
  i23 = i22 + 4 | 0;
  HEAP32[i23 >> 2] = i7;
  HEAPF32[i22 + 8 >> 2] = .5;
  d14 = +(i7 >>> 0);
  HEAPF32[i22 + 12 >> 2] = 1.0 / d14;
  d14 = 2.5132741603225375 / d14;
  i24 = i22 + 28 | 0;
  HEAPF32[i24 >> 2] = d14;
  i21 = ~~+Math_ceil(+(+Math_abs(+(.05000000074505806 / d14))));
  i25 = i22 + 24 | 0;
  i21 = i21 >>> 0 < 2 ? 2 : i21;
  HEAP32[i25 >> 2] = i21;
  HEAPF32[i22 + 32 >> 2] = d14 * +(i21 >>> 0);
  i21 = i7 << 3;
  i5 = _malloc(i21) | 0;
  HEAP32[i22 >> 2] = i5;
  _memcpy(i5 | 0, i2 | 0, i21 | 0) | 0;
  i21 = i22 + 16 | 0;
  HEAP32[i21 >> 2] = _windowcf_create(i7) | 0;
  i5 = HEAP32[i23 >> 2] | 0;
  i1 = _malloc(12) | 0;
  HEAP32[i1 + 4 >> 2] = i5;
  i5 = i5 << 2;
  i3 = _malloc(i5) | 0;
  HEAP32[i1 >> 2] = i3;
  HEAP32[i1 + 8 >> 2] = 0;
  _memset(i3 | 0, 0, i5 | 0) | 0;
  i5 = i22 + 60 | 0;
  HEAP32[i5 >> 2] = i1;
  i1 = HEAP32[i25 >> 2] | 0;
  i3 = i1 << 2;
  i6 = i22 + 20 | 0;
  HEAP32[i6 >> 2] = _malloc(i3) | 0;
  i2 = _malloc(i3) | 0;
  i7 = i22 + 36 | 0;
  HEAP32[i7 >> 2] = i2;
  i15 = i22 + 44 | 0;
  HEAP32[i15 >> 2] = _malloc(i3) | 0;
  i16 = i22 + 48 | 0;
  HEAP32[i16 >> 2] = _malloc(i3) | 0;
  HEAP32[i22 + 40 >> 2] = _malloc(i3) | 0;
  i3 = HEAP32[i23 >> 2] | 0;
  i17 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i3 << 3) | 0) + 15 & -16) | 0;
  if (!i1) {
   i27 = HEAP32[i21 >> 2] | 0;
   i28 = i27 + 24 | 0;
   HEAP32[i28 >> 2] = 0;
   i28 = HEAP32[i27 >> 2] | 0;
   i27 = i27 + 20 | 0;
   i27 = HEAP32[i27 >> 2] | 0;
   i27 = i27 << 3;
   _memset(i28 | 0, 0, i27 | 0) | 0;
   i27 = HEAP32[i5 >> 2] | 0;
   i28 = i27 + 8 | 0;
   HEAP32[i28 >> 2] = 0;
   i28 = HEAP32[i27 >> 2] | 0;
   i27 = i27 + 4 | 0;
   i27 = HEAP32[i27 >> 2] | 0;
   i27 = i27 << 2;
   _memset(i28 | 0, 0, i27 | 0) | 0;
   i27 = HEAP32[i23 >> 2] | 0;
   i28 = i22 + 76 | 0;
   HEAP32[i28 >> 2] = i27;
   i28 = i22 + 72 | 0;
   HEAP32[i28 >> 2] = 0;
   i28 = i22 + 52 | 0;
   HEAP32[i28 >> 2] = 0;
   i28 = i22 + 56 | 0;
   HEAP32[i28 >> 2] = 0;
   i28 = i22 + 64 | 0;
   HEAPF32[i28 >> 2] = 0.0;
   i28 = HEAP32[i15 >> 2] | 0;
   i27 = HEAP32[i25 >> 2] | 0;
   i27 = i27 << 2;
   _memset(i28 | 0, 0, i27 | 0) | 0;
   i27 = HEAP32[i16 >> 2] | 0;
   i28 = HEAP32[i25 >> 2] | 0;
   i28 = i28 << 2;
   _memset(i27 | 0, 0, i28 | 0) | 0;
   STACKTOP = i29;
   return i22 | 0;
  }
  i18 = i26 + 4 | 0;
  i19 = i27 + 4 | 0;
  i20 = i28 + 4 | 0;
  i4 = i3;
  i3 = 0;
  while (1) {
   HEAPF32[i2 + (i3 << 2) >> 2] = +HEAPF32[i24 >> 2] * (+(i3 >>> 0) - +((i1 + -1 | 0) >>> 0) * .5);
   if (!i4) i1 = 0; else {
    i2 = 0;
    do {
     i4 = HEAP32[i22 >> 2] | 0;
     d13 = +HEAPF32[i4 + (i2 << 3) >> 2];
     d14 = -+HEAPF32[i4 + (i2 << 3) + 4 >> 2];
     d11 = +HEAPF32[(HEAP32[i7 >> 2] | 0) + (i3 << 2) >> 2];
     d10 = d11 * -0.0;
     d11 = -d11;
     d12 = +(i2 >>> 0);
     d9 = d12 * d10 - d10;
     d8 = d12 * d11 + d10 * 0.0;
     if ((d9 != d9 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
      ___mulsc3(i26, d10, d11, d12, 0.0);
      d9 = +HEAPF32[i26 >> 2];
      d8 = +HEAPF32[i18 >> 2];
     }
     _cexpf(i27, d9, d8);
     d10 = +HEAPF32[i27 >> 2];
     d11 = +HEAPF32[i19 >> 2];
     d9 = d13 * d10 - d11 * d14;
     d8 = d10 * d14 + d13 * d11;
     if ((d9 != d9 | 0.0 != 0.0) & (d8 != d8 | 0.0 != 0.0)) {
      ___mulsc3(i28, d13, d14, d10, d11);
      d9 = +HEAPF32[i28 >> 2];
      d8 = +HEAPF32[i20 >> 2];
     }
     HEAPF32[i17 + (i2 << 3) >> 2] = d9;
     HEAPF32[i17 + (i2 << 3) + 4 >> 2] = d8;
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i23 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
   i4 = _malloc(8) | 0;
   HEAP32[i4 + 4 >> 2] = i1;
   i1 = i1 << 3;
   i2 = _malloc(i1) | 0;
   HEAP32[i4 >> 2] = i2;
   _memcpy(i2 | 0, i17 | 0, i1 | 0) | 0;
   HEAP32[(HEAP32[i6 >> 2] | 0) + (i3 << 2) >> 2] = i4;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i25 >> 2] | 0;
   if (i3 >>> 0 >= i1 >>> 0) break;
   i2 = HEAP32[i7 >> 2] | 0;
   i4 = HEAP32[i23 >> 2] | 0;
  }
  i27 = HEAP32[i21 >> 2] | 0;
  i28 = i27 + 24 | 0;
  HEAP32[i28 >> 2] = 0;
  i28 = HEAP32[i27 >> 2] | 0;
  i27 = i27 + 20 | 0;
  i27 = HEAP32[i27 >> 2] | 0;
  i27 = i27 << 3;
  _memset(i28 | 0, 0, i27 | 0) | 0;
  i27 = HEAP32[i5 >> 2] | 0;
  i28 = i27 + 8 | 0;
  HEAP32[i28 >> 2] = 0;
  i28 = HEAP32[i27 >> 2] | 0;
  i27 = i27 + 4 | 0;
  i27 = HEAP32[i27 >> 2] | 0;
  i27 = i27 << 2;
  _memset(i28 | 0, 0, i27 | 0) | 0;
  i27 = HEAP32[i23 >> 2] | 0;
  i28 = i22 + 76 | 0;
  HEAP32[i28 >> 2] = i27;
  i28 = i22 + 72 | 0;
  HEAP32[i28 >> 2] = 0;
  i28 = i22 + 52 | 0;
  HEAP32[i28 >> 2] = 0;
  i28 = i22 + 56 | 0;
  HEAP32[i28 >> 2] = 0;
  i28 = i22 + 64 | 0;
  HEAPF32[i28 >> 2] = 0.0;
  i28 = HEAP32[i15 >> 2] | 0;
  i27 = HEAP32[i25 >> 2] | 0;
  i27 = i27 << 2;
  _memset(i28 | 0, 0, i27 | 0) | 0;
  i27 = HEAP32[i16 >> 2] | 0;
  i28 = HEAP32[i25 >> 2] | 0;
  i28 = i28 << 2;
  _memset(i27 | 0, 0, i28 | 0) | 0;
  STACKTOP = i29;
  return i22 | 0;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 62) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37482 | 0, 62) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37482 | 0, 62) | 0) >>> 0 < 62) _exit(1); else {
  i4 = 0;
  i5 = gb + 37482 + 62 | 0;
  i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i4 = 62;
  i5 = gb + 37482 | 0;
  i6 = i1;
 } while (0);
 _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
 _exit(1);
 return 0;
}

function _packetizer_decode(i21, i2, i20) {
 i21 = i21 | 0;
 i2 = i2 | 0;
 i20 = i20 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0;
 i22 = i21 + 28 | 0;
 _memmove(HEAP32[i22 >> 2] | 0, i2 | 0, HEAP32[i21 + 4 >> 2] | 0) | 0;
 i2 = HEAP32[i21 + 20 >> 2] | 0;
 if (i2 | 0) {
  i14 = i21 + 16 | 0;
  i15 = i21 + 32 | 0;
  do {
   i2 = i2 + -1 | 0;
   i10 = HEAP32[(HEAP32[i14 >> 2] | 0) + (i2 * 20 | 0) + 16 >> 2] | 0;
   i13 = HEAP32[i15 >> 2] | 0;
   _memmove(i13 | 0, HEAP32[i22 >> 2] | 0, HEAP32[i10 >> 2] | 0) | 0;
   i11 = i10 + 12 | 0;
   i3 = HEAP32[i11 >> 2] | 0;
   if (i3 >>> 0 > 3) {
    i4 = HEAP32[i10 >> 2] | 0;
    i9 = HEAP32[i10 + 4 >> 2] | 0;
    i3 = HEAP32[i10 + 8 >> 2] | 0;
    i7 = i3 + 8 | 0;
    i8 = i4 >>> 1;
    if (!i8) i5 = 17; else {
     i6 = 0;
     i3 = 0;
     i4 = (i4 >>> 0) / 3 | 0;
     do {
      do {
       i5 = (Math_imul(i3, i7) | 0) + i4 | 0;
       i3 = i3 + 1 | 0;
       if ((i3 | 0) == (i9 | 0)) {
        i3 = 0;
        i4 = ((i4 + 1 | 0) >>> 0) % (i7 >>> 0) | 0;
       }
      } while (i5 >>> 0 >= i8 >>> 0);
      i29 = i13 + (i6 << 1) | 0;
      i27 = HEAP8[i29 >> 0] | 0;
      i5 = i13 + (i5 << 1 | 1) | 0;
      i28 = HEAP8[i5 >> 0] | 0;
      HEAP8[i29 >> 0] = i28 & 51 | i27 & 204;
      HEAP8[i5 >> 0] = i28 & 204 | i27 & 51;
      i6 = i6 + 1 | 0;
     } while ((i6 | 0) != (i8 | 0));
     i3 = HEAP32[i11 >> 2] | 0;
     i5 = 15;
    }
   } else i5 = 15;
   if ((i5 | 0) == 15) if (i3 >>> 0 > 2) {
    i3 = HEAP32[i10 + 8 >> 2] | 0;
    i4 = HEAP32[i10 >> 2] | 0;
    i9 = HEAP32[i10 + 4 >> 2] | 0;
    i5 = 17;
   } else i5 = 25;
   if ((i5 | 0) == 17) {
    i7 = i3 + 4 | 0;
    i8 = i4 >>> 1;
    if (!i8) i5 = 27; else {
     i6 = 0;
     i3 = 0;
     i4 = (i4 >>> 0) / 3 | 0;
     do {
      do {
       i5 = (Math_imul(i3, i7) | 0) + i4 | 0;
       i3 = i3 + 1 | 0;
       if ((i3 | 0) == (i9 | 0)) {
        i3 = 0;
        i4 = ((i4 + 1 | 0) >>> 0) % (i7 >>> 0) | 0;
       }
      } while (i5 >>> 0 >= i8 >>> 0);
      i30 = i13 + (i6 << 1) | 0;
      i28 = HEAP8[i30 >> 0] | 0;
      i29 = i13 + (i5 << 1 | 1) | 0;
      i27 = HEAP8[i29 >> 0] | 0;
      HEAP8[i30 >> 0] = i27 & 85 | i28 & 170;
      HEAP8[i29 >> 0] = i27 & 170 | i28 & 85;
      i6 = i6 + 1 | 0;
     } while ((i6 | 0) != (i8 | 0));
     i3 = HEAP32[i11 >> 2] | 0;
     i5 = 25;
    }
   }
   if ((i5 | 0) == 25) if (i3 >>> 0 > 1) {
    i4 = HEAP32[i10 >> 2] | 0;
    i9 = HEAP32[i10 + 4 >> 2] | 0;
    i3 = HEAP32[i10 + 8 >> 2] | 0;
    i5 = 27;
   } else {
    i12 = i3;
    i5 = 35;
   }
   if ((i5 | 0) == 27) {
    i8 = i3 + 2 | 0;
    i7 = i4 >>> 1;
    if (!i7) {
     i17 = i4;
     i18 = i3;
     i19 = i9;
     i5 = 37;
    } else {
     i6 = 0;
     i3 = 0;
     i4 = (i4 >>> 0) / 3 | 0;
     do {
      do {
       i5 = (Math_imul(i3, i8) | 0) + i4 | 0;
       i3 = i3 + 1 | 0;
       if ((i3 | 0) == (i9 | 0)) {
        i3 = 0;
        i4 = ((i4 + 1 | 0) >>> 0) % (i8 >>> 0) | 0;
       }
      } while (i5 >>> 0 >= i7 >>> 0);
      i27 = i13 + (i6 << 1) | 0;
      i29 = HEAP8[i27 >> 0] | 0;
      i30 = i13 + (i5 << 1 | 1) | 0;
      i28 = HEAP8[i30 >> 0] | 0;
      HEAP8[i27 >> 0] = i28 & 15 | i29 & 240;
      HEAP8[i30 >> 0] = i28 & 240 | i29 & 15;
      i6 = i6 + 1 | 0;
     } while ((i6 | 0) != (i7 | 0));
     i12 = HEAP32[i11 >> 2] | 0;
     i5 = 35;
    }
   }
   if ((i5 | 0) == 35 ? (i5 = 0, i12 | 0) : 0) {
    i17 = HEAP32[i10 >> 2] | 0;
    i18 = HEAP32[i10 + 8 >> 2] | 0;
    i19 = HEAP32[i10 + 4 >> 2] | 0;
    i5 = 37;
   }
   if ((i5 | 0) == 37 ? (0, i16 = i17 >>> 1, i16 | 0) : 0) {
    i6 = 0;
    i3 = 0;
    i4 = (i17 >>> 0) / 3 | 0;
    do {
     do {
      i5 = (Math_imul(i3, i18) | 0) + i4 | 0;
      i3 = i3 + 1 | 0;
      if ((i3 | 0) == (i19 | 0)) {
       i3 = 0;
       i4 = ((i4 + 1 | 0) >>> 0) % (i18 >>> 0) | 0;
      }
     } while (i5 >>> 0 >= i16 >>> 0);
     i28 = i13 + (i5 << 1 | 1) | 0;
     i29 = HEAP8[i28 >> 0] | 0;
     i30 = i13 + (i6 << 1) | 0;
     HEAP8[i28 >> 0] = HEAP8[i30 >> 0] | 0;
     HEAP8[i30 >> 0] = i29;
     i6 = i6 + 1 | 0;
    } while ((i6 | 0) != (i16 | 0));
   }
   i30 = HEAP32[i14 >> 2] | 0;
   i29 = HEAP32[i30 + (i2 * 20 | 0) + 12 >> 2] | 0;
   mftCall_viiii(HEAP32[i29 + 140 >> 2] | 0, i29 | 0, HEAP32[i30 + (i2 * 20 | 0) >> 2] | 0, HEAP32[i15 >> 2] | 0, HEAP32[i22 >> 2] | 0);
  } while ((i2 | 0) != 0);
 }
 i4 = HEAP32[i21 + 12 >> 2] | 0;
 if (!i4) {
  i5 = i21;
  i4 = HEAP32[i22 >> 2] | 0;
  i2 = HEAP32[i21 >> 2] | 0;
  i3 = 0;
 } else {
  i2 = HEAP32[i21 >> 2] | 0;
  i6 = HEAP32[i22 >> 2] | 0;
  i5 = 0;
  i3 = 0;
  do {
   i3 = HEAPU8[i6 + (i5 + i2) >> 0] | i3 << 8;
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i4 | 0));
  i5 = i21;
  i4 = i6;
 }
 _memmove(i20 | 0, i4 | 0, i2 | 0) | 0;
 i2 = HEAP32[i21 + 8 >> 2] | 0;
 switch (i2 | 0) {
 case 0:
  {
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i23 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i23;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(-1);
   } else {
    i23 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i23 - i1 | 0) >>> 0 < 71) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 10652 | 0, 71) | 0;
    _exit(-1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 10652 | 0, 71) | 0) >>> 0 < 71) _exit(-1); else {
    i24 = 0;
    i25 = gb + 10652 + 71 | 0;
    i26 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i24 = 71;
    i25 = gb + 10652 | 0;
    i26 = i1;
   } while (0);
   _memcpy(i26 | 0, i25 | 0, i24 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i24;
   _exit(-1);
   break;
  }
 case 1:
  {
   i30 = 1;
   return i30 | 0;
  }
 default:
  {
   i30 = (_crc_generate_key(i2, HEAP32[i22 >> 2] | 0, HEAP32[i5 >> 2] | 0) | 0) == (i3 | 0) & 1;
   return i30 | 0;
  }
 }
 return 0;
}

function ___divsc3(i15, d13, d14, d5, d6) {
 i15 = i15 | 0;
 d13 = +d13;
 d14 = +d14;
 d5 = +d5;
 d6 = +d6;
 var i1 = 0, d2 = 0.0, d3 = 0.0, i4 = 0, i7 = 0, i8 = 0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0;
 d2 = +Math_abs(+d5);
 d3 = +Math_abs(+d6);
 if ((HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0) >>> 0 <= 2139095040) {
  if ((HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0) >>> 0 <= 2139095040) d2 = d2 < d3 ? d3 : d2;
 } else d2 = d3;
 i4 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
 do if ((i4 & 2139095040) >>> 0 < 2139095040) {
  if (d2 == 0.0) {
   d11 = -1.0 / (d2 * d2);
   break;
  }
  i1 = i4 >>> 23 & 255;
  switch (i1 | 0) {
  case 0:
   {
    i4 = i4 << 9;
    if (i4) if ((i4 | 0) > -1) {
     i1 = -127;
     do {
      i1 = i1 + -1 | 0;
      i4 = i4 << 1;
     } while ((i4 | 0) > -1);
    } else i1 = -127; else i1 = -2147483648;
    break;
   }
  case 255:
   {
    i1 = i4 & 8388607 | 0 ? -2147483648 : 2147483647;
    break;
   }
  default:
   i1 = i1 + -127 | 0;
  }
  d11 = +(i1 | 0);
 } else d11 = d2 * d2; while (0);
 d12 = +Math_abs(+d11);
 if (d11 == d11 & 0.0 == 0.0 & d12 != inf) {
  i7 = ~~d11;
  i1 = 0 - i7 | 0;
  do if ((i7 | 0) < -127) {
   d2 = d5 * 1701411834604692317316873.0e14;
   i1 = -127 - i7 | 0;
   if ((i1 | 0) > 127) {
    i8 = -254 - i7 | 0;
    i8 = (i8 | 0) > 127 ? 127 : i8;
    i4 = i8;
    d3 = d2 * 1701411834604692317316873.0e14 * (HEAP32[tempDoublePtr >> 2] = (i8 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
    d2 = d6 * 1701411834604692317316873.0e14 * 1701411834604692317316873.0e14;
    break;
   } else {
    i4 = i1;
    d3 = d2 * (HEAP32[tempDoublePtr >> 2] = (i1 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
    d2 = d6 * 1701411834604692317316873.0e14;
    break;
   }
  } else {
   if ((i7 | 0) <= 126) {
    i4 = i1;
    d3 = (HEAP32[tempDoublePtr >> 2] = (i1 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]) * d5;
    d2 = d6;
    break;
   }
   d2 = d5 * 1.1754943508222875e-38;
   i1 = 126 - i7 | 0;
   if ((i1 | 0) < -126) {
    i8 = 252 - i7 | 0;
    i8 = (i8 | 0) < -126 ? -126 : i8;
    i4 = i8;
    d3 = d2 * 1.1754943508222875e-38 * (HEAP32[tempDoublePtr >> 2] = (i8 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
    d2 = d6 * 1.1754943508222875e-38 * 1.1754943508222875e-38;
    break;
   } else {
    i4 = i1;
    d3 = d2 * (HEAP32[tempDoublePtr >> 2] = (i1 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
    d2 = d6 * 1.1754943508222875e-38;
    break;
   }
  } while (0);
  d10 = d2 * (HEAP32[tempDoublePtr >> 2] = (i4 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
 } else {
  d10 = d6;
  d3 = d5;
  i7 = 0;
 }
 d5 = d3 * d3 + d10 * d10;
 d2 = (d3 * d13 + d10 * d14) / d5;
 i1 = 0 - i7 | 0;
 i8 = (i7 | 0) < -127;
 if (i8) {
  d2 = d2 * 1701411834604692317316873.0e14;
  i4 = -127 - i7 | 0;
  if ((i4 | 0) > 127) {
   i4 = -254 - i7 | 0;
   i4 = (i4 | 0) > 127 ? 127 : i4;
   d2 = d2 * 1701411834604692317316873.0e14;
  }
 } else if ((i7 | 0) > 126) {
  d2 = d2 * 1.1754943508222875e-38;
  i4 = 126 - i7 | 0;
  if ((i4 | 0) < -126) {
   i4 = 252 - i7 | 0;
   i4 = (i4 | 0) < -126 ? -126 : i4;
   d2 = d2 * 1.1754943508222875e-38;
  }
 } else i4 = i1;
 d9 = d2 * (HEAP32[tempDoublePtr >> 2] = (i4 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
 d2 = (d3 * d14 - d10 * d13) / d5;
 if (i8) {
  d2 = d2 * 1701411834604692317316873.0e14;
  i1 = -127 - i7 | 0;
  if ((i1 | 0) > 127) {
   i1 = -254 - i7 | 0;
   i1 = (i1 | 0) > 127 ? 127 : i1;
   d2 = d2 * 1701411834604692317316873.0e14;
  }
 } else if ((i7 | 0) > 126) {
  d2 = d2 * 1.1754943508222875e-38;
  i1 = 126 - i7 | 0;
  if ((i1 | 0) < -126) {
   i1 = 252 - i7 | 0;
   i1 = (i1 | 0) < -126 ? -126 : i1;
   d2 = d2 * 1.1754943508222875e-38;
  }
 }
 d6 = d2 * (HEAP32[tempDoublePtr >> 2] = (i1 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
 if (!((d9 != d9 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0))) {
  d13 = d9;
  d14 = d6;
  i8 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d13;
  HEAPF32[i8 >> 2] = d14;
  return;
 }
 if (d5 == 0.0 ? !((d13 != d13 | 0.0 != 0.0) & (d14 != d14 | 0.0 != 0.0)) : 0) {
  i8 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
  d12 = +Math_abs(inf);
  d12 = (HEAP32[tempDoublePtr >> 2] = i8 & -2147483648 | (HEAPF32[tempDoublePtr >> 2] = d12, HEAP32[tempDoublePtr >> 2] | 0), +HEAPF32[tempDoublePtr >> 2]);
  d13 = d12 * d13;
  d14 = d12 * d14;
  i8 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d13;
  HEAPF32[i8 >> 2] = d14;
  return;
 }
 d2 = +Math_abs(+d13);
 i1 = d2 == inf;
 d5 = +Math_abs(+d14);
 i4 = d5 == inf;
 if ((i1 | i4 ? d3 == d3 & 0.0 == 0.0 & +Math_abs(+d3) != inf : 0) ? d10 == d10 & 0.0 == 0.0 & +Math_abs(+d10) != inf : 0) {
  HEAPF32[tempDoublePtr >> 2] = d13, HEAP32[tempDoublePtr >> 2] | 0;
  d12 = +Math_abs(+(+(i1 & 1)));
  d12 = (HEAPF32[tempDoublePtr >> 2] = d12, +HEAPF32[tempDoublePtr >> 2]);
  HEAPF32[tempDoublePtr >> 2] = d14, HEAP32[tempDoublePtr >> 2] | 0;
  d14 = +Math_abs(+(+(i4 & 1)));
  d14 = (HEAPF32[tempDoublePtr >> 2] = d14, +HEAPF32[tempDoublePtr >> 2]);
  d13 = (d12 * d3 + d14 * d10) * inf;
  d14 = (d14 * d3 - d12 * d10) * inf;
  i8 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d13;
  HEAPF32[i8 >> 2] = d14;
  return;
 }
 if (!(d11 > 0.0 & d12 == inf)) {
  d13 = d9;
  d14 = d6;
  i8 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d13;
  HEAPF32[i8 >> 2] = d14;
  return;
 }
 if (!(d13 == d13 & 0.0 == 0.0 & d2 != inf)) {
  d13 = d9;
  d14 = d6;
  i8 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d13;
  HEAPF32[i8 >> 2] = d14;
  return;
 }
 if (!(d14 == d14 & 0.0 == 0.0 & d5 != inf)) {
  d13 = d9;
  d14 = d6;
  i8 = i15 + 4 | 0;
  HEAPF32[i15 >> 2] = d13;
  HEAPF32[i8 >> 2] = d14;
  return;
 }
 d9 = +(+Math_abs(+d3) == inf & 1);
 HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0;
 d9 = +Math_abs(+d9);
 d9 = (HEAPF32[tempDoublePtr >> 2] = d9, +HEAPF32[tempDoublePtr >> 2]);
 d11 = +(+Math_abs(+d10) == inf & 1);
 HEAPF32[tempDoublePtr >> 2] = d10, HEAP32[tempDoublePtr >> 2] | 0;
 d11 = +Math_abs(+d11);
 d11 = (HEAPF32[tempDoublePtr >> 2] = d11, +HEAPF32[tempDoublePtr >> 2]);
 d12 = (d9 * d13 + d11 * d14) * 0.0;
 d14 = (d9 * d14 - d11 * d13) * 0.0;
 i8 = i15 + 4 | 0;
 HEAPF32[i15 >> 2] = d12;
 HEAPF32[i8 >> 2] = d14;
 return;
}

function _flexframegen_set_header_len(i14, i2) {
 i14 = i14 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0, i16 = 0, d17 = 0.0, i18 = 0, i19 = 0, i20 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i13 = i15;
 if (HEAP32[i14 + 112 >> 2] | 0) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   STACKTOP = i15;
   return;
  } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i1 - i2 | 0) >>> 0 < 81) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23008 | 0, 81) | 0;
   STACKTOP = i15;
   return;
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23008 | 0, 81) | 0) >>> 0 < 81) {
   STACKTOP = i15;
   return;
  } else {
   i1 = 0;
   i3 = gb + 23008 + 81 | 0;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i1 = 81;
   i3 = gb + 23008 | 0;
  } while (0);
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  STACKTOP = i15;
  return;
 }
 HEAP32[i14 + 56 >> 2] = i2;
 i4 = i2 + 6 | 0;
 i2 = i14 + 60 | 0;
 HEAP32[i2 >> 2] = i4;
 i3 = i14 + 52 | 0;
 HEAP32[i3 >> 2] = _realloc(HEAP32[i3 >> 2] | 0, i4) | 0;
 i3 = i14 + 64 | 0;
 i4 = HEAP32[i3 >> 2] | 0;
 if (i4 | 0) {
  _packetizer_destroy(HEAP32[i4 + 4 >> 2] | 0);
  _modem_destroy(HEAP32[i4 >> 2] | 0);
  _free(HEAP32[i4 + 16 >> 2] | 0);
  _free(HEAP32[i4 + 20 >> 2] | 0);
  _free(i4);
 }
 i12 = _malloc(36) | 0;
 i10 = _malloc(252) | 0;
 HEAP32[i10 >> 2] = 48;
 HEAP32[i10 + 76 >> 2] = 0;
 HEAP32[i10 + 80 >> 2] = 0;
 HEAP32[i10 + 4 >> 2] = 2;
 HEAP32[i10 + 8 >> 2] = 4;
 i11 = i10 + 236 | 0;
 HEAP32[i11 >> 2] = 0;
 HEAP32[i11 + 4 >> 2] = 0;
 HEAP32[i11 + 8 >> 2] = 0;
 HEAP32[i11 + 12 >> 2] = 0;
 HEAP32[i11 >> 2] = fb + 1;
 HEAP32[i10 + 240 >> 2] = fb + 2;
 HEAPF32[i10 + 84 >> 2] = 1.0;
 HEAPF32[i10 + 88 >> 2] = 0.0;
 HEAP32[i10 + 92 >> 2] = 1065353216;
 HEAPF32[i10 + 96 >> 2] = 0.0;
 HEAP32[i12 >> 2] = i10;
 HEAP32[i12 + 8 >> 2] = 2;
 HEAP32[i12 + 12 >> 2] = 1;
 i10 = _packetizer_create(1, 1, 1, 1) | 0;
 HEAP32[i12 + 4 >> 2] = i10;
 i10 = HEAP32[i10 + 4 >> 2] | 0;
 HEAP32[i12 + 24 >> 2] = i10;
 i11 = i10 << 3;
 HEAP32[i12 + 28 >> 2] = i11;
 HEAP32[i12 + 16 >> 2] = _malloc(((i11 | 0) / 2 | 0) << 1) | 0;
 HEAP32[i12 + 32 >> 2] = i10 << 1;
 HEAP32[i12 + 20 >> 2] = _malloc(i11) | 0;
 HEAP32[i3 >> 2] = i12;
 _qpacketmodem_configure(i12, HEAP32[i2 >> 2] | 0, 6, 10, 5, 48);
 i3 = HEAP32[(HEAP32[i3 >> 2] | 0) + 32 >> 2] | 0;
 i2 = i14 + 68 | 0;
 HEAP32[i2 >> 2] = i3;
 i12 = i14 + 72 | 0;
 HEAP32[i12 >> 2] = _realloc(HEAP32[i12 >> 2] | 0, i3 << 3) | 0;
 i12 = i14 + 76 | 0;
 i3 = HEAP32[i12 >> 2] | 0;
 if (i3 | 0) {
  _free(HEAP32[i3 + 16 >> 2] | 0);
  _free(i3);
 }
 i2 = HEAP32[i2 >> 2] | 0;
 if (i2 | 0) {
  i9 = _malloc(20) | 0;
  HEAP32[i9 >> 2] = i2;
  HEAP32[i9 + 4 >> 2] = 16;
  i10 = (((i2 | 0) % 15 | 0 | 0) != 0 & 1) + ((i2 | 0) / 15 | 0) | 0;
  HEAP32[i9 + 8 >> 2] = i10;
  i11 = i9 + 12 | 0;
  HEAP32[i11 >> 2] = i10 + i2;
  i1 = _malloc(i10 << 3) | 0;
  HEAP32[i9 + 16 >> 2] = i1;
  i2 = _msequence_create_default(_liquid_nextpow2(i10) | 0) | 0;
  if (i10 | 0) {
   i3 = i13 + 4 | 0;
   i4 = i2 + 16 | 0;
   i5 = i2 + 4 | 0;
   i6 = i2 + 20 | 0;
   i7 = i2 + 12 | 0;
   i8 = 0;
   do {
    i20 = HEAP32[i4 >> 2] | 0;
    i18 = HEAP32[i5 >> 2] | 0;
    i19 = HEAP32[i7 >> 2] | 0;
    i16 = i20 & i18;
    i16 = (HEAPU8[(i16 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i16 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i16 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    i20 = (i16 | i20 << 1) & i19;
    i18 = i20 & i18;
    i18 = (HEAPU8[(i18 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i18 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i18 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i18 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    HEAP32[i6 >> 2] = i18;
    HEAP32[i4 >> 2] = (i18 | i20 << 1) & i19;
    d17 = +((i18 | i16 << 1) >>> 0) * 6.283185307179586 * .25 + .7853981633974483;
    _cexpf(i13, d17 * 0.0, d17);
    i16 = HEAP32[i3 >> 2] | 0;
    HEAP32[i1 + (i8 << 3) >> 2] = HEAP32[i13 >> 2];
    HEAP32[i1 + (i8 << 3) + 4 >> 2] = i16;
    i8 = i8 + 1 | 0;
   } while ((i8 | 0) != (i10 | 0));
  }
  _free(i2);
  HEAP32[i12 >> 2] = i9;
  i19 = HEAP32[i11 >> 2] | 0;
  HEAP32[i14 + 80 >> 2] = i19;
  i20 = i14 + 84 | 0;
  HEAP32[i20 >> 2] = _realloc(HEAP32[i20 >> 2] | 0, i19 << 3) | 0;
  STACKTOP = i15;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i5 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i5;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i5 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i5 - i1 | 0) >>> 0 < 66) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27516 | 0, 66) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27516 | 0, 66) | 0) >>> 0 < 66) _exit(1); else {
  i6 = 0;
  i7 = gb + 27516 + 66 | 0;
  i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i6 = 66;
  i7 = gb + 27516 | 0;
  i8 = i1;
 } while (0);
 _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
 _exit(1);
}

function _resamp_rrrf_execute_output_block(i1, i26, i2, i32, i27, i25, i33) {
 i1 = i1 | 0;
 i26 = i26 | 0;
 i2 = i2 | 0;
 i32 = i32 | 0;
 i27 = i27 | 0;
 i25 = i25 | 0;
 i33 = i33 | 0;
 var i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i34 = 0, d35 = 0.0;
 i34 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i29 = i34 + 24 | 0;
 i31 = i34 + 16 | 0;
 i30 = i34 + 8 | 0;
 i28 = i34;
 i16 = i1 + 28 | 0;
 if (!i25) {
  i30 = 0;
  i31 = 0;
  HEAP32[i32 >> 2] = i30;
  HEAP32[i33 >> 2] = i31;
  STACKTOP = i34;
  return;
 }
 i17 = i1 + 32 | 0;
 i18 = i1 + 48 | 0;
 i19 = i1 + 44 | 0;
 i20 = i1 + 52 | 0;
 i21 = i1 + 36 | 0;
 i22 = i1 + 20 | 0;
 i23 = i1 + 24 | 0;
 i24 = i1 + 40 | 0;
 i15 = i1 + 16 | 0;
 i3 = HEAP32[i16 >> 2] | 0;
 i4 = 0;
 i1 = 0;
 L4 : while (1) {
  L6 : while (1) {
   if (!i3) if (+HEAPF32[i17 >> 2] == 0.0) {
    if ((i4 | 0) == (i2 | 0)) {
     i7 = 36;
     break L4;
    }
    i10 = HEAP32[i26 + (i4 << 2) >> 2] | 0;
    i3 = HEAP32[(HEAP32[i18 >> 2] | 0) + 16 >> 2] | 0;
    i8 = i3 + 24 | 0;
    i7 = HEAP32[i3 + 16 >> 2] & (HEAP32[i8 >> 2] | 0) + 1;
    HEAP32[i8 >> 2] = i7;
    if (!i7) {
     i6 = HEAP32[i3 >> 2] | 0;
     i9 = i3 + 4 | 0;
     _memmove(i6 | 0, i6 + (HEAP32[i3 + 12 >> 2] << 2) | 0, (HEAP32[i9 >> 2] << 2) + -4 | 0) | 0;
     i6 = HEAP32[i16 >> 2] | 0;
     i7 = HEAP32[i8 >> 2] | 0;
    } else {
     i9 = i3 + 4 | 0;
     i6 = 0;
    }
    HEAP32[(HEAP32[i3 >> 2] | 0) + (i7 + -1 + (HEAP32[i9 >> 2] | 0) << 2) >> 2] = i10;
    i4 = i4 + 1 | 0;
   } else i6 = 0; else i6 = i3;
   i3 = HEAP32[i19 >> 2] | 0;
   if (i6 >>> 0 >= i3 >>> 0) do {
    if ((i4 | 0) == (i2 | 0)) {
     i7 = 36;
     break L4;
    }
    HEAPF32[i22 >> 2] = +HEAPF32[i22 >> 2] + -1.0;
    HEAPF32[i23 >> 2] = +HEAPF32[i23 >> 2] - +(i3 >>> 0);
    i6 = i6 - i3 | 0;
    HEAP32[i16 >> 2] = i6;
    i11 = HEAP32[i26 + (i4 << 2) >> 2] | 0;
    i7 = HEAP32[(HEAP32[i18 >> 2] | 0) + 16 >> 2] | 0;
    i8 = i7 + 24 | 0;
    i9 = HEAP32[i7 + 16 >> 2] & (HEAP32[i8 >> 2] | 0) + 1;
    HEAP32[i8 >> 2] = i9;
    if (!i9) {
     i9 = HEAP32[i7 >> 2] | 0;
     i10 = i7 + 4 | 0;
     _memmove(i9 | 0, i9 + (HEAP32[i7 + 12 >> 2] << 2) | 0, (HEAP32[i10 >> 2] << 2) + -4 | 0) | 0;
     i9 = HEAP32[i8 >> 2] | 0;
     i6 = HEAP32[i16 >> 2] | 0;
     i3 = HEAP32[i19 >> 2] | 0;
    } else i10 = i7 + 4 | 0;
    HEAP32[(HEAP32[i7 >> 2] | 0) + (i9 + -1 + (HEAP32[i10 >> 2] | 0) << 2) >> 2] = i11;
    i4 = i4 + 1 | 0;
   } while (i6 >>> 0 >= i3 >>> 0);
   switch (HEAP32[i20 >> 2] | 0) {
   case 0:
    {
     i7 = 23;
     break L6;
    }
   case 1:
    break;
   default:
    {
     i7 = 35;
     break L4;
    }
   }
   i10 = HEAP32[i18 >> 2] | 0;
   i11 = HEAP32[i10 + 12 >> 2] | 0;
   if (i11 >>> 0 <= i6 >>> 0) {
    i7 = 28;
    break L4;
   }
   i14 = HEAP32[i10 + 16 >> 2] | 0;
   i14 = (HEAP32[i14 >> 2] | 0) + (HEAP32[i14 + 24 >> 2] << 2) | 0;
   i13 = HEAP32[i10 + 20 >> 2] | 0;
   i8 = HEAP32[i13 + (i6 << 2) >> 2] | 0;
   i7 = HEAP32[i8 >> 2] | 0;
   i8 = HEAP32[i8 + 4 >> 2] | 0;
   if (!i8) d5 = 0.0; else {
    i9 = 0;
    d5 = 0.0;
    do {
     d5 = d5 + +HEAPF32[i7 + (i9 << 2) >> 2] * +HEAPF32[i14 + (i9 << 2) >> 2];
     i9 = i9 + 1 | 0;
    } while ((i9 | 0) != (i8 | 0));
   }
   HEAPF32[i21 >> 2] = d5;
   i9 = i10 + 24 | 0;
   d12 = d5 * +HEAPF32[i9 >> 2];
   HEAPF32[i21 >> 2] = d12;
   if ((i6 | 0) != (i3 + -1 | 0)) {
    i7 = 29;
    break;
   }
   HEAP32[i20 >> 2] = 0;
   HEAP32[i16 >> 2] = i3;
  }
  if ((i7 | 0) == 23) {
   i10 = HEAP32[i18 >> 2] | 0;
   if (!(HEAP32[i10 + 12 >> 2] | 0)) {
    i7 = 24;
    break;
   }
   i6 = HEAP32[i10 + 16 >> 2] | 0;
   i6 = (HEAP32[i6 >> 2] | 0) + (HEAP32[i6 + 24 >> 2] << 2) | 0;
   i8 = HEAP32[HEAP32[i10 + 20 >> 2] >> 2] | 0;
   i7 = HEAP32[i8 >> 2] | 0;
   i8 = HEAP32[i8 + 4 >> 2] | 0;
   if (!i8) d5 = 0.0; else {
    i9 = 0;
    d5 = 0.0;
    do {
     d5 = d5 + +HEAPF32[i7 + (i9 << 2) >> 2] * +HEAPF32[i6 + (i9 << 2) >> 2];
     i9 = i9 + 1 | 0;
    } while ((i9 | 0) != (i8 | 0));
   }
   HEAPF32[i24 >> 2] = d5;
   d5 = d5 * +HEAPF32[i10 + 24 >> 2];
   HEAPF32[i24 >> 2] = d5;
   d12 = +HEAPF32[i17 >> 2];
   HEAPF32[i27 + (i1 << 2) >> 2] = d5 * d12 + (1.0 - d12) * +HEAPF32[i21 >> 2];
   d12 = +HEAPF32[i15 >> 2] + +HEAPF32[i22 >> 2];
   HEAPF32[i22 >> 2] = d12;
   d12 = d12 * +(i3 >>> 0);
   HEAPF32[i23 >> 2] = d12;
   i3 = ~~+Math_floor(+d12);
   HEAP32[i16 >> 2] = i3;
   HEAPF32[i17 >> 2] = d12 - +(i3 | 0);
   HEAP32[i20 >> 2] = 1;
  } else if ((i7 | 0) == 29) {
   i6 = i6 + 1 | 0;
   if (i11 >>> 0 <= i6 >>> 0) {
    i7 = 30;
    break;
   }
   i7 = HEAP32[i13 + (i6 << 2) >> 2] | 0;
   i6 = HEAP32[i7 >> 2] | 0;
   i7 = HEAP32[i7 + 4 >> 2] | 0;
   if (!i7) d5 = 0.0; else {
    i8 = 0;
    d5 = 0.0;
    do {
     d5 = d5 + +HEAPF32[i6 + (i8 << 2) >> 2] * +HEAPF32[i14 + (i8 << 2) >> 2];
     i8 = i8 + 1 | 0;
    } while ((i8 | 0) != (i7 | 0));
   }
   HEAPF32[i24 >> 2] = d5;
   d35 = d5 * +HEAPF32[i9 >> 2];
   HEAPF32[i24 >> 2] = d35;
   d5 = +HEAPF32[i17 >> 2];
   HEAPF32[i27 + (i1 << 2) >> 2] = d35 * d5 + (1.0 - d5) * d12;
   d12 = +HEAPF32[i15 >> 2] + +HEAPF32[i22 >> 2];
   HEAPF32[i22 >> 2] = d12;
   d12 = d12 * +(i3 >>> 0);
   HEAPF32[i23 >> 2] = d12;
   i3 = ~~+Math_floor(+d12);
   HEAP32[i16 >> 2] = i3;
   HEAPF32[i17 >> 2] = d12 - +(i3 | 0);
  }
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i25 >>> 0) {
   i2 = i4;
   i7 = 36;
   break;
  }
 }
 if ((i7 | 0) == 24) {
  HEAP32[i28 >> 2] = 0;
  HEAP32[i28 + 4 >> 2] = 0;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i28);
  _exit(1);
 } else if ((i7 | 0) == 28) {
  HEAP32[i30 >> 2] = i6;
  HEAP32[i30 + 4 >> 2] = i11;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i30);
  _exit(1);
 } else if ((i7 | 0) == 30) {
  HEAP32[i31 >> 2] = i6;
  HEAP32[i31 + 4 >> 2] = i11;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i31);
  _exit(1);
 } else if ((i7 | 0) == 35) {
  HEAP32[i29 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 20341 | 0, i29);
  _exit(1);
 } else if ((i7 | 0) == 36) {
  HEAP32[i32 >> 2] = i2;
  HEAP32[i33 >> 2] = i1;
  STACKTOP = i34;
  return;
 }
}

function _gmskframesync_update_symsync(i15, d1, i16) {
 i15 = i15 | 0;
 d1 = +d1;
 i16 = i16 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i17 = 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i14 = i17 + 16 | 0;
 i12 = i17 + 8 | 0;
 i8 = i17;
 i9 = i15 + 76 | 0;
 i3 = HEAP32[(HEAP32[i9 >> 2] | 0) + 16 >> 2] | 0;
 i4 = i3 + 24 | 0;
 i2 = HEAP32[i3 + 16 >> 2] & (HEAP32[i4 >> 2] | 0) + 1;
 HEAP32[i4 >> 2] = i2;
 if (!i2) {
  i2 = HEAP32[i3 >> 2] | 0;
  i5 = i3 + 4 | 0;
  _memmove(i2 | 0, i2 + (HEAP32[i3 + 12 >> 2] << 2) | 0, (HEAP32[i5 >> 2] << 2) + -4 | 0) | 0;
  i2 = HEAP32[i4 >> 2] | 0;
 } else i5 = i3 + 4 | 0;
 HEAPF32[(HEAP32[i3 >> 2] | 0) + (i2 + -1 + (HEAP32[i5 >> 2] | 0) << 2) >> 2] = d1;
 i13 = i15 + 80 | 0;
 i3 = HEAP32[(HEAP32[i13 >> 2] | 0) + 16 >> 2] | 0;
 i4 = i3 + 24 | 0;
 i2 = HEAP32[i3 + 16 >> 2] & (HEAP32[i4 >> 2] | 0) + 1;
 HEAP32[i4 >> 2] = i2;
 if (!i2) {
  i2 = HEAP32[i3 >> 2] | 0;
  i5 = i3 + 4 | 0;
  _memmove(i2 | 0, i2 + (HEAP32[i3 + 12 >> 2] << 2) | 0, (HEAP32[i5 >> 2] << 2) + -4 | 0) | 0;
  i2 = HEAP32[i4 >> 2] | 0;
 } else i5 = i3 + 4 | 0;
 HEAPF32[(HEAP32[i3 >> 2] | 0) + (i2 + -1 + (HEAP32[i5 >> 2] | 0) << 2) >> 2] = d1;
 if (!(HEAP32[i15 + 232 >> 2] | 0)) i3 = 0; else {
  i3 = HEAP32[i15 + 244 >> 2] | 0;
  i7 = HEAP32[i15 + 72 >> 2] | 0;
  i4 = i3 + 24 | 0;
  i2 = HEAP32[i3 + 16 >> 2] & (HEAP32[i4 >> 2] | 0) + 1;
  HEAP32[i4 >> 2] = i2;
  if (!i2) {
   i2 = HEAP32[i3 >> 2] | 0;
   i5 = i3 + 4 | 0;
   _memmove(i2 | 0, i2 + (HEAP32[i3 + 12 >> 2] << 2) | 0, (HEAP32[i5 >> 2] << 2) + -4 | 0) | 0;
   i2 = HEAP32[i4 >> 2] | 0;
  } else i5 = i3 + 4 | 0;
  HEAP32[(HEAP32[i3 >> 2] | 0) + (i2 + -1 + (HEAP32[i5 >> 2] | 0) << 2) >> 2] = i7;
  i7 = HEAP32[i9 >> 2] | 0;
  i3 = HEAP32[i15 + 96 >> 2] | 0;
  i2 = HEAP32[i7 + 12 >> 2] | 0;
  if (i2 >>> 0 <= i3 >>> 0) {
   HEAP32[i8 >> 2] = i3;
   HEAP32[i8 + 4 >> 2] = i2;
   _fprintf(gb + 8728 | 0, gb + 19343 | 0, i8);
   _exit(1);
  }
  i5 = HEAP32[i7 + 16 >> 2] | 0;
  i5 = (HEAP32[i5 >> 2] | 0) + (HEAP32[i5 + 24 >> 2] << 2) | 0;
  i3 = HEAP32[(HEAP32[i7 + 20 >> 2] | 0) + (i3 << 2) >> 2] | 0;
  i2 = HEAP32[i3 >> 2] | 0;
  i3 = HEAP32[i3 + 4 >> 2] | 0;
  if (!i3) d1 = 0.0; else {
   i4 = 0;
   d1 = 0.0;
   do {
    d1 = d1 + +HEAPF32[i2 + (i4 << 2) >> 2] * +HEAPF32[i5 + (i4 << 2) >> 2];
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != (i3 | 0));
  }
  d1 = d1 * +HEAPF32[i7 + 24 >> 2];
  i3 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
  i4 = HEAP32[i15 + 248 >> 2] | 0;
  i5 = i4 + 24 | 0;
  i2 = HEAP32[i4 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
  HEAP32[i5 >> 2] = i2;
  if (!i2) {
   i2 = HEAP32[i4 >> 2] | 0;
   i7 = i4 + 4 | 0;
   _memmove(i2 | 0, i2 + (HEAP32[i4 + 12 >> 2] << 2) | 0, (HEAP32[i7 >> 2] << 2) + -4 | 0) | 0;
   i2 = HEAP32[i5 >> 2] | 0;
  } else i7 = i4 + 4 | 0;
  HEAPF32[(HEAP32[i4 >> 2] | 0) + (i2 + -1 + (HEAP32[i7 >> 2] | 0) << 2) >> 2] = d1;
 }
 i11 = i15 + 100 | 0;
 i2 = HEAP32[i11 >> 2] | 0;
 if ((i2 | 0) >= 1) {
  i12 = i2;
  i13 = i3;
  i14 = 0;
  i12 = i12 + -1 | 0;
  HEAP32[i11 >> 2] = i12;
  d1 = (HEAP32[tempDoublePtr >> 2] = i13, +HEAPF32[tempDoublePtr >> 2]);
  i15 = i15 + 4 | 0;
  i15 = HEAP32[i15 >> 2] | 0;
  d6 = +(i15 >>> 0);
  d6 = d1 / d6;
  HEAPF32[i16 >> 2] = d6;
  STACKTOP = i17;
  return i14 | 0;
 }
 HEAP32[i11 >> 2] = 2;
 i7 = HEAP32[i9 >> 2] | 0;
 i10 = i15 + 96 | 0;
 i8 = HEAP32[i10 >> 2] | 0;
 i2 = HEAP32[i7 + 12 >> 2] | 0;
 if (i2 >>> 0 <= i8 >>> 0) {
  HEAP32[i12 >> 2] = i8;
  HEAP32[i12 + 4 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i12);
  _exit(1);
 }
 i2 = HEAP32[i7 + 16 >> 2] | 0;
 i2 = (HEAP32[i2 >> 2] | 0) + (HEAP32[i2 + 24 >> 2] << 2) | 0;
 i4 = HEAP32[(HEAP32[i7 + 20 >> 2] | 0) + (i8 << 2) >> 2] | 0;
 i3 = HEAP32[i4 >> 2] | 0;
 i4 = HEAP32[i4 + 4 >> 2] | 0;
 if (!i4) d1 = 0.0; else {
  i5 = 0;
  d1 = 0.0;
  do {
   d1 = d1 + +HEAPF32[i3 + (i5 << 2) >> 2] * +HEAPF32[i2 + (i5 << 2) >> 2];
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i4 | 0));
 }
 d6 = d1 * +HEAPF32[i7 + 24 >> 2];
 i9 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
 i7 = HEAP32[i13 >> 2] | 0;
 i2 = HEAP32[i7 + 12 >> 2] | 0;
 if (i2 >>> 0 <= i8 >>> 0) {
  HEAP32[i14 >> 2] = i8;
  HEAP32[i14 + 4 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i14);
  _exit(1);
 }
 i5 = HEAP32[i7 + 16 >> 2] | 0;
 i5 = (HEAP32[i5 >> 2] | 0) + (HEAP32[i5 + 24 >> 2] << 2) | 0;
 i3 = HEAP32[(HEAP32[i7 + 20 >> 2] | 0) + (i8 << 2) >> 2] | 0;
 i2 = HEAP32[i3 >> 2] | 0;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 if (!i3) d1 = 0.0; else {
  i4 = 0;
  d1 = 0.0;
  do {
   d1 = d1 + +HEAPF32[i2 + (i4 << 2) >> 2] * +HEAPF32[i5 + (i4 << 2) >> 2];
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i3 | 0));
 }
 i5 = i15 + 88 | 0;
 d1 = +HEAPF32[i5 >> 2] * .9900000095367432 + d6 * (d1 * +HEAPF32[i7 + 24 >> 2]) * .05000000074505806;
 HEAPF32[i5 >> 2] = d1;
 i5 = i15 + 92 | 0;
 d1 = +HEAPF32[i5 >> 2] + d1;
 HEAPF32[i5 >> 2] = d1;
 i2 = ~~+_roundf(+d1);
 HEAP32[i10 >> 2] = i2;
 i7 = HEAP32[i15 + 84 >> 2] | 0;
 if ((i2 | 0) < 0) {
  d6 = +(i7 >>> 0);
  i3 = 2;
  do {
   i2 = i2 + i7 | 0;
   d1 = d6 + d1;
   i3 = i3 + -1 | 0;
  } while ((i2 | 0) < 0);
  HEAP32[i10 >> 2] = i2;
  HEAPF32[i5 >> 2] = d1;
  HEAP32[i11 >> 2] = i3;
 } else i3 = 2;
 i4 = i7 + -1 | 0;
 if (i2 >>> 0 <= i4 >>> 0) {
  i12 = i3;
  i13 = i9;
  i14 = 1;
  i12 = i12 + -1 | 0;
  HEAP32[i11 >> 2] = i12;
  d1 = (HEAP32[tempDoublePtr >> 2] = i13, +HEAPF32[tempDoublePtr >> 2]);
  i15 = i15 + 4 | 0;
  i15 = HEAP32[i15 >> 2] | 0;
  d6 = +(i15 >>> 0);
  d6 = d1 / d6;
  HEAPF32[i16 >> 2] = d6;
  STACKTOP = i17;
  return i14 | 0;
 }
 d6 = +(i7 >>> 0);
 do {
  i2 = i2 - i7 | 0;
  d1 = d1 - d6;
  i3 = i3 + 1 | 0;
 } while (i2 >>> 0 > i4 >>> 0);
 HEAP32[i10 >> 2] = i2;
 HEAPF32[i5 >> 2] = d1;
 HEAP32[i11 >> 2] = i3;
 i12 = i3;
 i13 = i9;
 i14 = 1;
 i12 = i12 + -1 | 0;
 HEAP32[i11 >> 2] = i12;
 d1 = (HEAP32[tempDoublePtr >> 2] = i13, +HEAPF32[tempDoublePtr >> 2]);
 i15 = i15 + 4 | 0;
 i15 = HEAP32[i15 >> 2] | 0;
 d6 = +(i15 >>> 0);
 d6 = d1 / d6;
 HEAPF32[i16 >> 2] = d6;
 STACKTOP = i17;
 return i14 | 0;
}

function _modem_arb_init(i18, i17, i16) {
 i18 = i18 | 0;
 i17 = i17 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i19 = 0, i20 = 0, i21 = 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i20 = i21;
 if ((HEAP32[i18 >> 2] | 0) != 59) {
  i5 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i5) {
   i5 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i5 + 255 | i5;
   i5 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i5 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i7 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i7;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i5 | 32;
   _exit(1);
  } else {
   i7 = i5;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i7 - i2 | 0) >>> 0 < 56) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29376 | 0, 56) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29376 | 0, 56) | 0) >>> 0 < 56) _exit(1); else {
   i8 = 0;
   i9 = gb + 29376 + 56 | 0;
   i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i8 = 56;
   i9 = gb + 29376 | 0;
   i10 = i2;
  } while (0);
  _memcpy(i10 | 0, i9 | 0, i8 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i8;
  _exit(1);
 }
 i19 = i18 + 8 | 0;
 if ((HEAP32[i19 >> 2] | 0) != (i16 | 0)) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i12 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i12;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i12 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i12 - i1 | 0) >>> 0 < 50) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29433 | 0, 50) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29433 | 0, 50) | 0) >>> 0 < 50) _exit(1); else {
   i13 = 0;
   i14 = gb + 29433 + 50 | 0;
   i15 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i13 = 50;
   i14 = gb + 29433 | 0;
   i15 = i1;
  } while (0);
  _memcpy(i15 | 0, i14 | 0, i13 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i13;
  _exit(1);
 }
 do if (i16 | 0) {
  i12 = i18 + 76 | 0;
  i1 = 0;
  do {
   i14 = HEAP32[i17 + (i1 << 3) + 4 >> 2] | 0;
   i15 = HEAP32[i12 >> 2] | 0;
   HEAP32[i15 + (i1 << 3) >> 2] = HEAP32[i17 + (i1 << 3) >> 2];
   HEAP32[i15 + (i1 << 3) + 4 >> 2] = i14;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i16 | 0));
  i1 = HEAP32[i19 >> 2] | 0;
  if ((HEAP32[i18 >> 2] | 0) == 59) {
   if (!i1) break;
   i5 = HEAP32[i12 >> 2] | 0;
   i2 = 0;
   d3 = 0.0;
   d4 = 0.0;
   do {
    d3 = d3 + +HEAPF32[i5 + (i2 << 3) >> 2];
    d4 = d4 + +HEAPF32[i5 + (i2 << 3) + 4 >> 2];
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i1 | 0));
   d11 = +(i1 >>> 0);
   d6 = d3 / d11;
   d3 = d4 / d11;
   i1 = i5 + 4 | 0;
   d11 = +HEAPF32[i1 >> 2] - d3;
   HEAPF32[i5 >> 2] = +HEAPF32[i5 >> 2] - d6;
   HEAPF32[i1 >> 2] = d11;
   i1 = HEAP32[i19 >> 2] | 0;
   if (i1 >>> 0 > 1) {
    i2 = 1;
    do {
     i1 = HEAP32[i12 >> 2] | 0;
     i18 = i1 + (i2 << 3) | 0;
     i1 = i1 + (i2 << 3) + 4 | 0;
     d11 = +HEAPF32[i1 >> 2] - d3;
     HEAPF32[i18 >> 2] = +HEAPF32[i18 >> 2] - d6;
     HEAPF32[i1 >> 2] = d11;
     i2 = i2 + 1 | 0;
     i1 = HEAP32[i19 >> 2] | 0;
    } while (i2 >>> 0 < i1 >>> 0);
   }
  }
  if (!i1) {
   STACKTOP = i21;
   return;
  }
  i2 = HEAP32[i12 >> 2] | 0;
  d11 = 0.0;
  i10 = 0;
  do {
   i8 = HEAP32[i2 + (i10 << 3) >> 2] | 0;
   i9 = HEAP32[i2 + (i10 << 3) + 4 >> 2] | 0;
   d3 = (HEAP32[tempDoublePtr >> 2] = i8, +HEAPF32[tempDoublePtr >> 2]);
   d4 = (HEAP32[tempDoublePtr >> 2] = i9, +HEAPF32[tempDoublePtr >> 2]);
   d3 = +Math_abs(+d3);
   i18 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
   d4 = +Math_abs(+d4);
   i7 = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0);
   i17 = i18 >>> 0 < i7 >>> 0;
   i5 = i17 ? i7 : i18;
   i7 = i17 ? i18 : i7;
   d4 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
   d3 = (HEAP32[tempDoublePtr >> 2] = i7, +HEAPF32[tempDoublePtr >> 2]);
   do if ((i7 | 0) != 2139095040) {
    if (i5 >>> 0 > 2139095039 | (i7 | 0) == 0 | (i5 - i7 | 0) >>> 0 > 209715199) {
     d3 = d4 + d3;
     break;
    }
    if (i5 >>> 0 <= 1568669695) if (i7 >>> 0 < 562036736) {
     d3 = d3 * 1237940039285380274899124.0e3;
     d4 = d4 * 1237940039285380274899124.0e3;
     d6 = 8.077935669463161e-28;
    } else d6 = 1.0; else {
     d3 = d3 * 8.077935669463161e-28;
     d4 = d4 * 8.077935669463161e-28;
     d6 = 1237940039285380274899124.0e3;
    }
    d3 = d6 * +Math_sqrt(+(d4 * d4 + d3 * d3));
   } while (0);
   d11 = d11 + d3 * d3;
   i10 = i10 + 1 | 0;
  } while ((i10 | 0) != (i1 | 0));
  HEAP32[i20 >> 2] = i8;
  HEAP32[i20 + 4 >> 2] = i9;
  d3 = +Math_sqrt(+(d11 / +(i1 >>> 0)));
  i1 = 0;
  while (1) {
   i17 = i2 + (i1 << 3) | 0;
   i18 = i2 + (i1 << 3) + 4 | 0;
   d11 = +HEAPF32[i18 >> 2] / d3;
   HEAPF32[i17 >> 2] = +HEAPF32[i17 >> 2] / d3;
   HEAPF32[i18 >> 2] = d11;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= (HEAP32[i19 >> 2] | 0) >>> 0) break;
   i2 = HEAP32[i12 >> 2] | 0;
  }
  STACKTOP = i21;
  return;
 } while (0);
 STACKTOP = i21;
 return;
}

function _json_loads(i7, i11) {
 i7 = i7 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i14 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 i12 = i14 + 88 | 0;
 i9 = i14 + 80 | 0;
 i8 = i14 + 72 | 0;
 i13 = i14;
 i6 = i14 + 96 | 0;
 i10 = (i11 | 0) == 0;
 do if (!i10) {
  HEAP8[i11 + 92 >> 0] = 0;
  HEAP32[i11 >> 2] = -1;
  HEAP32[i11 + 4 >> 2] = -1;
  HEAP32[i11 + 8 >> 2] = 0;
  L3 : do if (!(gb + 37674 & 3)) {
   i1 = gb + 37674 | 0;
   i5 = 5;
  } else {
   i1 = gb + 37674 | 0;
   i2 = gb + 37674 | 0;
   while (1) {
    if (!(HEAP8[i1 >> 0] | 0)) {
     i1 = i2;
     break L3;
    }
    i1 = i1 + 1 | 0;
    i2 = i1;
    if (!(i2 & 3)) {
     i5 = 5;
     break;
    }
   }
  } while (0);
  if ((i5 | 0) == 5) {
   while (1) {
    i2 = HEAP32[i1 >> 2] | 0;
    if (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009)) i1 = i1 + 4 | 0; else break;
   }
   if ((i2 & 255) << 24 >> 24) do i1 = i1 + 1 | 0; while ((HEAP8[i1 >> 0] | 0) != 0);
  }
  i1 = i1 - (gb + 37674) | 0;
  if (i1 >>> 0 < 80) {
   i2 = i11 + 12 | 0;
   i1 = i1 + 1 | 0;
   L19 : do if (!((i2 ^ gb + 37674) & 3)) {
    if (gb + 37674 & 3) {
     i4 = gb + 37674 | 0;
     do {
      i3 = HEAP8[i4 >> 0] | 0;
      HEAP8[i2 >> 0] = i3;
      if (!(i3 << 24 >> 24)) break L19;
      i1 = i1 + -1 | 0;
      i4 = i4 + 1 | 0;
      i2 = i2 + 1 | 0;
      i3 = (i1 | 0) != 0;
     } while (i3 & (i4 & 3 | 0) != 0);
     if (i3) i3 = i4; else {
      i1 = 0;
      break;
     }
    } else i3 = gb + 37674 | 0;
    if (HEAP8[i3 >> 0] | 0) if (i1 >>> 0 > 3) {
     i4 = i3;
     while (1) {
      i3 = HEAP32[i4 >> 2] | 0;
      if ((i3 & -2139062144 ^ -2139062144) & i3 + -16843009 | 0) {
       i5 = 20;
       break;
      }
      HEAP32[i2 >> 2] = i3;
      i1 = i1 + -4 | 0;
      i3 = i4 + 4 | 0;
      i2 = i2 + 4 | 0;
      if (i1 >>> 0 > 3) i4 = i3; else {
       i5 = 22;
       break;
      }
     }
     if ((i5 | 0) == 20) {
      i3 = i4;
      i5 = 23;
      break;
     } else if ((i5 | 0) == 22) if (!i1) {
      i1 = 0;
      break;
     } else {
      i5 = 23;
      break;
     }
    } else i5 = 23;
   } else {
    i3 = gb + 37674 | 0;
    i5 = 23;
   } while (0);
   L35 : do if ((i5 | 0) == 23) while (1) {
    i5 = HEAP8[i3 >> 0] | 0;
    HEAP8[i2 >> 0] = i5;
    if (!(i5 << 24 >> 24)) break L35;
    i1 = i1 + -1 | 0;
    i2 = i2 + 1 | 0;
    if (!i1) {
     i1 = 0;
     break;
    } else {
     i3 = i3 + 1 | 0;
     i5 = 23;
    }
   } while (0);
   _memset(i2 | 0, 0, i1 | 0) | 0;
   break;
  } else {
   i2 = i11 + 12 | 0;
   HEAP8[i2 >> 0] = HEAP8[gb + 38526 >> 0] | 0;
   HEAP8[i2 + 1 >> 0] = HEAP8[gb + 38526 + 1 >> 0] | 0;
   HEAP8[i2 + 2 >> 0] = HEAP8[gb + 38526 + 2 >> 0] | 0;
   i2 = i11 + 15 | 0;
   i3 = i1 + -76 + (gb + 37674) | 0;
   i1 = i3;
   L41 : do if (!((i1 ^ i2) & 3)) {
    if (i1 & 3) {
     i1 = 77;
     i4 = i3;
     do {
      i3 = HEAP8[i4 >> 0] | 0;
      HEAP8[i2 >> 0] = i3;
      if (!(i3 << 24 >> 24)) break L41;
      i1 = i1 + -1 | 0;
      i4 = i4 + 1 | 0;
      i2 = i2 + 1 | 0;
      i3 = (i1 | 0) != 0;
     } while (i3 & (i4 & 3 | 0) != 0);
     if (i3) i3 = i4; else {
      i1 = 0;
      break;
     }
    } else i1 = 77;
    if (HEAP8[i3 >> 0] | 0) if (i1 >>> 0 > 3) {
     i4 = i3;
     while (1) {
      i3 = HEAP32[i4 >> 2] | 0;
      if ((i3 & -2139062144 ^ -2139062144) & i3 + -16843009 | 0) {
       i5 = 35;
       break;
      }
      HEAP32[i2 >> 2] = i3;
      i1 = i1 + -4 | 0;
      i3 = i4 + 4 | 0;
      i2 = i2 + 4 | 0;
      if (i1 >>> 0 > 3) i4 = i3; else {
       i5 = 37;
       break;
      }
     }
     if ((i5 | 0) == 35) {
      i3 = i4;
      i5 = 38;
      break;
     } else if ((i5 | 0) == 37) if (!i1) {
      i1 = 0;
      break;
     } else {
      i5 = 38;
      break;
     }
    } else i5 = 38;
   } else {
    i1 = 77;
    i5 = 38;
   } while (0);
   L57 : do if ((i5 | 0) == 38) while (1) {
    i5 = HEAP8[i3 >> 0] | 0;
    HEAP8[i2 >> 0] = i5;
    if (!(i5 << 24 >> 24)) break L57;
    i1 = i1 + -1 | 0;
    i2 = i2 + 1 | 0;
    if (!i1) {
     i1 = 0;
     break;
    } else {
     i3 = i3 + 1 | 0;
     i5 = 38;
    }
   } while (0);
   _memset(i2 | 0, 0, i1 | 0) | 0;
   break;
  }
 } while (0);
 if (!i7) {
  _error_set(i11, 0, gb + 37683 | 0, i8);
  i13 = 0;
  STACKTOP = i14;
  return i13 | 0;
 }
 HEAP32[i6 >> 2] = i7;
 HEAP32[i6 + 4 >> 2] = 0;
 HEAP32[i13 >> 2] = fb + 6;
 HEAP32[i13 + 4 >> 2] = i6;
 HEAP8[i13 + 8 >> 0] = 0;
 SIMD_Int32x4_store(HEAPU8, i13 + 16 | 0, SIMD_Int32x4(0, 0, 1, 0));
 i2 = i13 + 36 | 0;
 HEAP32[i2 >> 2] = 0;
 i5 = i13 + 48 | 0;
 HEAP32[i5 >> 2] = 16;
 i6 = i13 + 44 | 0;
 HEAP32[i6 >> 2] = 0;
 i1 = _malloc(16) | 0;
 i7 = i13 + 40 | 0;
 HEAP32[i7 >> 2] = i1;
 if (!i1) {
  i13 = 0;
  STACKTOP = i14;
  return i13 | 0;
 }
 HEAP8[i1 >> 0] = 0;
 HEAP32[i13 + 52 >> 2] = 0;
 i4 = i13 + 56 | 0;
 HEAP32[i4 >> 2] = -1;
 _lex_scan(i13, i11);
 L70 : do switch (HEAP32[i4 >> 2] | 0) {
 case 123:
 case 91:
  {
   i3 = _parse_value(i13, i11) | 0;
   if (i3) {
    _lex_scan(i13, i11);
    if (!(HEAP32[i4 >> 2] | 0)) {
     if (i10) break L70;
     HEAP32[i11 + 8 >> 2] = HEAP32[i2 >> 2];
     break L70;
    }
    _error_set(i11, i13, gb + 38438 | 0, i12);
    i1 = i3 + 4 | 0;
    i2 = HEAP32[i1 >> 2] | 0;
    if ((i2 | 0) != -1 ? (i12 = i2 + -1 | 0, HEAP32[i1 >> 2] = i12, (i12 | 0) == 0) : 0) {
     _json_delete(i3);
     i3 = 0;
    } else i3 = 0;
   } else i3 = 0;
   break;
  }
 default:
  {
   _error_set(i11, i13, gb + 38243 | 0, i9);
   i3 = 0;
  }
 } while (0);
 if ((HEAP32[i4 >> 2] | 0) == 256) {
  i1 = i13 + 64 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  if (i2 | 0) _free(i2);
  HEAP32[i1 >> 2] = 0;
  HEAP32[i1 + 4 >> 2] = 0;
 }
 i1 = HEAP32[i7 >> 2] | 0;
 if (i1 | 0) _free(i1);
 HEAP32[i5 >> 2] = 0;
 HEAP32[i6 >> 2] = 0;
 HEAP32[i7 >> 2] = 0;
 i13 = i3;
 STACKTOP = i14;
 return i13 | 0;
}

function _realloc(i15, i4) {
 i15 = i15 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 if (!i15) {
  i15 = _malloc(i4) | 0;
  return i15 | 0;
 }
 if (i4 >>> 0 > 4294967231) {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i1 >> 2] = 12;
  i15 = 0;
  return i15 | 0;
 }
 i11 = i4 >>> 0 < 11 ? 16 : i4 + 11 & -8;
 i12 = i15 + -8 | 0;
 i14 = i15 + -4 | 0;
 i13 = HEAP32[i14 >> 2] | 0;
 i1 = i13 & -8;
 i8 = i12 + i1 | 0;
 i6 = HEAP32[gb + 41408 + 16 >> 2] | 0;
 i2 = i13 & 3;
 if (!((i2 | 0) != 1 & i12 >>> 0 >= i6 >>> 0 & (i1 | 0) > 0)) _abort();
 i3 = HEAP32[i8 + 4 >> 2] | 0;
 if (!(i3 & 1)) _abort();
 do if (!i2) {
  if (!(i11 >>> 0 < 256 | i1 >>> 0 < (i11 | 4) >>> 0) ? (i1 - i11 | 0) >>> 0 <= HEAP32[gb + 41880 + 8 >> 2] << 1 >>> 0 : 0) return i15 | 0;
 } else {
  if (i1 >>> 0 >= i11 >>> 0) {
   i1 = i1 - i11 | 0;
   if (i1 >>> 0 <= 15) return i15 | 0;
   i12 = i12 + i11 | 0;
   HEAP32[i14 >> 2] = i13 & 1 | i11 | 2;
   HEAP32[i12 + 4 >> 2] = i1 | 3;
   i14 = i12 + i1 + 4 | 0;
   HEAP32[i14 >> 2] = HEAP32[i14 >> 2] | 1;
   _dispose_chunk(i12, i1);
   return i15 | 0;
  }
  if ((i8 | 0) == (HEAP32[gb + 41408 + 24 >> 2] | 0)) {
   i1 = (HEAP32[gb + 41408 + 12 >> 2] | 0) + i1 | 0;
   if (i1 >>> 0 <= i11 >>> 0) break;
   i10 = i1 - i11 | 0;
   i12 = i12 + i11 | 0;
   HEAP32[i14 >> 2] = i13 & 1 | i11 | 2;
   HEAP32[i12 + 4 >> 2] = i10 | 1;
   HEAP32[gb + 41408 + 24 >> 2] = i12;
   HEAP32[gb + 41408 + 12 >> 2] = i10;
   return i15 | 0;
  }
  if ((i8 | 0) == (HEAP32[gb + 41408 + 20 >> 2] | 0)) {
   i2 = (HEAP32[gb + 41408 + 8 >> 2] | 0) + i1 | 0;
   if (i2 >>> 0 < i11 >>> 0) break;
   i1 = i2 - i11 | 0;
   if (i1 >>> 0 > 15) {
    i2 = i12 + i11 | 0;
    i12 = i2 + i1 | 0;
    HEAP32[i14 >> 2] = i13 & 1 | i11 | 2;
    HEAP32[i2 + 4 >> 2] = i1 | 1;
    HEAP32[i12 >> 2] = i1;
    i14 = i12 + 4 | 0;
    HEAP32[i14 >> 2] = HEAP32[i14 >> 2] & -2;
   } else {
    HEAP32[i14 >> 2] = i13 & 1 | i2 | 2;
    i2 = i12 + i2 + 4 | 0;
    HEAP32[i2 >> 2] = HEAP32[i2 >> 2] | 1;
    i2 = 0;
    i1 = 0;
   }
   HEAP32[gb + 41408 + 8 >> 2] = i1;
   HEAP32[gb + 41408 + 20 >> 2] = i2;
   return i15 | 0;
  }
  if ((i3 & 2 | 0) == 0 ? (i10 = (i3 & -8) + i1 | 0, i10 >>> 0 >= i11 >>> 0) : 0) {
   i9 = i10 - i11 | 0;
   i4 = i3 >>> 3;
   do if (i3 >>> 0 >= 256) {
    i5 = HEAP32[i8 + 24 >> 2] | 0;
    i3 = HEAP32[i8 + 12 >> 2] | 0;
    do if ((i3 | 0) == (i8 | 0)) {
     i3 = i8 + 16 | 0;
     i2 = i3 + 4 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (!i1) {
      i1 = HEAP32[i3 >> 2] | 0;
      if (!i1) {
       i7 = 0;
       break;
      } else i2 = i3;
     }
     while (1) {
      i3 = i1 + 20 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (i4 | 0) {
       i1 = i4;
       i2 = i3;
       continue;
      }
      i3 = i1 + 16 | 0;
      i4 = HEAP32[i3 >> 2] | 0;
      if (!i4) break; else {
       i1 = i4;
       i2 = i3;
      }
     }
     if (i2 >>> 0 < i6 >>> 0) _abort(); else {
      HEAP32[i2 >> 2] = 0;
      i7 = i1;
      break;
     }
    } else {
     i4 = HEAP32[i8 + 8 >> 2] | 0;
     if (i4 >>> 0 < i6 >>> 0) _abort();
     i1 = i4 + 12 | 0;
     if ((HEAP32[i1 >> 2] | 0) != (i8 | 0)) _abort();
     i2 = i3 + 8 | 0;
     if ((HEAP32[i2 >> 2] | 0) == (i8 | 0)) {
      HEAP32[i1 >> 2] = i3;
      HEAP32[i2 >> 2] = i4;
      i7 = i3;
      break;
     } else _abort();
    } while (0);
    if (i5 | 0) {
     i1 = HEAP32[i8 + 28 >> 2] | 0;
     i2 = gb + 41408 + 304 + (i1 << 2) | 0;
     if ((i8 | 0) == (HEAP32[i2 >> 2] | 0)) {
      HEAP32[i2 >> 2] = i7;
      if (!i7) {
       HEAP32[gb + 41408 + 4 >> 2] = HEAP32[gb + 41408 + 4 >> 2] & ~(1 << i1);
       break;
      }
     } else {
      if (i5 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort();
      i1 = i5 + 16 | 0;
      if ((HEAP32[i1 >> 2] | 0) == (i8 | 0)) HEAP32[i1 >> 2] = i7; else HEAP32[i5 + 20 >> 2] = i7;
      if (!i7) break;
     }
     i3 = HEAP32[gb + 41408 + 16 >> 2] | 0;
     if (i7 >>> 0 < i3 >>> 0) _abort();
     HEAP32[i7 + 24 >> 2] = i5;
     i1 = i8 + 16 | 0;
     i2 = HEAP32[i1 >> 2] | 0;
     do if (i2 | 0) if (i2 >>> 0 < i3 >>> 0) _abort(); else {
      HEAP32[i7 + 16 >> 2] = i2;
      HEAP32[i2 + 24 >> 2] = i7;
      break;
     } while (0);
     i1 = HEAP32[i1 + 4 >> 2] | 0;
     if (i1 | 0) if (i1 >>> 0 < (HEAP32[gb + 41408 + 16 >> 2] | 0) >>> 0) _abort(); else {
      HEAP32[i7 + 20 >> 2] = i1;
      HEAP32[i1 + 24 >> 2] = i7;
      break;
     }
    }
   } else {
    i2 = HEAP32[i8 + 8 >> 2] | 0;
    i3 = HEAP32[i8 + 12 >> 2] | 0;
    i1 = gb + 41408 + 40 + (i4 << 1 << 2) | 0;
    if ((i2 | 0) != (i1 | 0)) {
     if (i2 >>> 0 < i6 >>> 0) _abort();
     if ((HEAP32[i2 + 12 >> 2] | 0) != (i8 | 0)) _abort();
    }
    if ((i3 | 0) == (i2 | 0)) {
     HEAP32[gb + 41408 >> 2] = HEAP32[gb + 41408 >> 2] & ~(1 << i4);
     break;
    }
    if ((i3 | 0) != (i1 | 0)) {
     if (i3 >>> 0 < i6 >>> 0) _abort();
     i1 = i3 + 8 | 0;
     if ((HEAP32[i1 >> 2] | 0) == (i8 | 0)) i5 = i1; else _abort();
    } else i5 = i3 + 8 | 0;
    HEAP32[i2 + 12 >> 2] = i3;
    HEAP32[i5 >> 2] = i2;
   } while (0);
   if (i9 >>> 0 < 16) {
    HEAP32[i14 >> 2] = i13 & 1 | i10 | 2;
    i14 = i12 + i10 + 4 | 0;
    HEAP32[i14 >> 2] = HEAP32[i14 >> 2] | 1;
    return i15 | 0;
   } else {
    i12 = i12 + i11 | 0;
    HEAP32[i14 >> 2] = i13 & 1 | i11 | 2;
    HEAP32[i12 + 4 >> 2] = i9 | 3;
    i14 = i12 + i9 + 4 | 0;
    HEAP32[i14 >> 2] = HEAP32[i14 >> 2] | 1;
    _dispose_chunk(i12, i9);
    return i15 | 0;
   }
  }
 } while (0);
 i1 = _malloc(i4) | 0;
 if (!i1) {
  i15 = 0;
  return i15 | 0;
 }
 i14 = HEAP32[i14 >> 2] | 0;
 i14 = (i14 & -8) - ((i14 & 3 | 0) == 0 ? 8 : 4) | 0;
 _memcpy(i1 | 0, i15 | 0, (i14 >>> 0 < i4 >>> 0 ? i14 : i4) | 0) | 0;
 _free(i15);
 i15 = i1;
 return i15 | 0;
}

function _liquid_firdes_kaiser(i18, d9, d3, i17) {
 i18 = i18 | 0;
 d9 = +d9;
 d3 = +d3;
 i17 = i17 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, d15 = 0.0, d16 = 0.0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, d29 = 0.0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i19;
 if (d9 < 0.0 | d9 > .5) {
  HEAPF64[i4 >> 3] = d9;
  _fprintf(gb + 8728 | 0, gb + 20520 | 0, i4);
  _exit(1);
 }
 if (!i18) {
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i5 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i5;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i5 = i4;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i5 - i2 | 0) >>> 0 < 71) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 20600 | 0, 71) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 20600 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
   i6 = 0;
   i7 = gb + 20600 + 71 | 0;
   i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i6 = 71;
   i7 = gb + 20600 | 0;
   i8 = i2;
  } while (0);
  _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
  _exit(1);
 }
 d3 = +Math_abs(+d3);
 if (!(d3 > 50.0)) if (d3 > 21.0) {
  d16 = d3 + -21.0;
  d16 = d16 * .07885999977588654 + +Math_pow(+d16, .4000000059604645) * .5842;
 } else d16 = 0.0; else d16 = (d3 + -8.699999809265137) * .11020000278949738;
 d15 = +((i18 + -1 | 0) >>> 0) * .5;
 d12 = d9 * 2.0;
 i4 = d16 < 0.0;
 d13 = +(i18 >>> 0);
 i5 = d16 == 0.0;
 d14 = d16 * .5;
 i6 = 0;
 while (1) {
  d9 = +(i6 >>> 0) - d15 + 0.0;
  d11 = d12 * d9;
  d3 = d11 * 3.141592653589793;
  if (+Math_abs(+d11) < .009999999776482582) d11 = +Math_cos(+(d3 * .5)) * +Math_cos(+(d3 * .25)) * +Math_cos(+(d3 * .125)); else d11 = +Math_sin(+d3) / d3;
  if (i6 >>> 0 > i18 >>> 0) {
   i2 = 25;
   break;
  }
  if (i4) {
   i2 = 38;
   break;
  }
  d3 = d9 * 2.0 / d13;
  d3 = +Math_sqrt(+(1.0 - d3 * d3)) * d16;
  if (d3 == 0.0) d10 = 1.0; else {
   d9 = +Math_log(+(d3 * .5));
   i2 = 0;
   d3 = 0.0;
   do {
    d10 = +(i2 >>> 0);
    d3 = d3 + +Math_exp(+((d9 * d10 - +_liquid_lngammaf(d10 + 1.0)) * 2.0));
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != 32);
   d10 = d3;
  }
  if (i5) d3 = 1.0; else {
   d9 = +Math_log(+d14);
   i2 = 0;
   d3 = 0.0;
   do {
    d29 = +(i2 >>> 0);
    d3 = d3 + +Math_exp(+((d9 * d29 - +_liquid_lngammaf(d29 + 1.0)) * 2.0));
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != 32);
  }
  HEAPF32[i17 + (i6 << 2) >> 2] = d11 * (d10 / d3);
  i6 = i6 + 1 | 0;
  if ((i6 | 0) == (i18 | 0)) {
   i2 = 57;
   break;
  }
 }
 if ((i2 | 0) == 25) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i22 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i22;
    HEAP32[gb + 8728 + 20 >> 2] = i22;
    i21 = i22 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i21;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   _exit(1);
  } else {
   i21 = i1;
   i22 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i21 - i22 | 0) >>> 0 < 60) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27797 | 0, 60) | 0;
   _exit(1);
  }
  i1 = i22;
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27797 | 0, 60) | 0) >>> 0 < 60) _exit(1); else {
   i23 = 0;
   i25 = gb + 27797 + 60 | 0;
   i27 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i23 = 60;
   i25 = gb + 27797 | 0;
   i27 = i1;
  } while (0);
  _memcpy(i27 | 0, i25 | 0, i23 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i23;
  _exit(1);
 } else if ((i2 | 0) == 38) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i20 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i20;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i20 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i20 - i1 | 0) >>> 0 < 60) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27858 | 0, 60) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27858 | 0, 60) | 0) >>> 0 < 60) _exit(1); else {
   i24 = 0;
   i26 = gb + 27858 + 60 | 0;
   i28 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i24 = 60;
   i26 = gb + 27858 | 0;
   i28 = i1;
  } while (0);
  _memcpy(i28 | 0, i26 | 0, i24 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i24;
  _exit(1);
 } else if ((i2 | 0) == 57) {
  STACKTOP = i19;
  return;
 }
}

function _modem_demodsoft_gentab(i13, i22) {
 i13 = i13 | 0;
 i22 = i22 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i23 = 0, i24 = 0;
 i23 = STACKTOP;
 i12 = i13 + 8 | 0;
 i21 = HEAP32[i12 >> 2] | 0;
 if ((i21 + -1 | 0) >>> 0 < i22 >>> 0) {
  i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i3) {
   i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
   i3 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i3 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i4 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i4;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i3 | 32;
   _exit(1);
  } else {
   i4 = i3;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i4 - i2 | 0) >>> 0 < 63) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28596 | 0, 63) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28596 | 0, 63) | 0) >>> 0 < 63) _exit(1); else {
   i8 = 0;
   i9 = gb + 28596 + 63 | 0;
   i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i8 = 63;
   i9 = gb + 28596 | 0;
   i10 = i2;
  } while (0);
  _memcpy(i10 | 0, i9 | 0, i8 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i8;
  _exit(1);
 }
 HEAP32[i13 + 248 >> 2] = i22;
 i19 = i13 + 244 | 0;
 HEAP32[i19 >> 2] = _malloc(Math_imul(i21, i22) | 0) | 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
 if (!i21) {
  STACKTOP = i23;
  return;
 }
 i3 = i13 + 80 | 0;
 i4 = i13 + 236 | 0;
 i8 = i13 + 76 | 0;
 i9 = i20;
 i2 = 0;
 while (1) {
  if (!(HEAP32[i3 >> 2] | 0)) mftCall_viii(HEAP32[i4 >> 2] | 0, i13 | 0, i2 | 0, i9 | 0); else {
   i24 = HEAP32[i8 >> 2] | 0;
   i10 = HEAP32[i24 + (i2 << 3) + 4 >> 2] | 0;
   HEAP32[i9 >> 2] = HEAP32[i24 + (i2 << 3) >> 2];
   HEAP32[i20 + (i2 << 3) + 4 >> 2] = i10;
  }
  i2 = i2 + 1 | 0;
  if (i2 >>> 0 >= i21 >>> 0) break;
  if ((HEAP32[i12 >> 2] | 0) >>> 0 > i2 >>> 0) i9 = i20 + (i2 << 3) | 0; else {
   i14 = 20;
   break;
  }
 }
 if ((i14 | 0) == 20) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i15 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i15;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i15 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i15 - i1 | 0) >>> 0 < 65) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28660 | 0, 65) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28660 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
   i16 = 0;
   i17 = gb + 28660 + 65 | 0;
   i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i16 = 65;
   i17 = gb + 28660 | 0;
   i18 = i1;
  } while (0);
  _memcpy(i18 | 0, i17 | 0, i16 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i16;
  _exit(1);
 }
 i1 = i21 & 255;
 if (!i22) {
  STACKTOP = i23;
  return;
 } else i3 = 0;
 do {
  i2 = Math_imul(i3, i22) | 0;
  i4 = 0;
  do {
   HEAP8[(HEAP32[i19 >> 2] | 0) + (i4 + i2) >> 0] = i1;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i22 | 0));
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i21 | 0));
 i13 = 0;
 do {
  i8 = i20 + (i13 << 3) | 0;
  i9 = i20 + (i13 << 3) + 4 | 0;
  i10 = Math_imul(i13, i22) | 0;
  i15 = 0;
  do {
   i12 = i15 + i10 | 0;
   d11 = 1.0e9;
   i14 = 0;
   while (1) {
    i3 = HEAP32[i19 >> 2] | 0;
    i1 = 0;
    i4 = (i13 | 0) != (i14 | 0) & 1;
    do {
     i4 = (HEAPU8[i3 + (i1 + i10) >> 0] | 0) == (i14 | 0) ? 0 : i4;
     i1 = i1 + 1 | 0;
    } while ((i1 | 0) != (i22 | 0));
    d6 = +Math_abs(+(+HEAPF32[i8 >> 2] - +HEAPF32[i20 + (i14 << 3) >> 2]));
    i24 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
    d6 = +Math_abs(+(+HEAPF32[i9 >> 2] - +HEAPF32[i20 + (i14 << 3) + 4 >> 2]));
    i2 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
    i18 = i24 >>> 0 < i2 >>> 0;
    i1 = i18 ? i2 : i24;
    i2 = i18 ? i24 : i2;
    d6 = (HEAP32[tempDoublePtr >> 2] = i1, +HEAPF32[tempDoublePtr >> 2]);
    d5 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
    do if ((i2 | 0) != 2139095040) {
     if (i1 >>> 0 > 2139095039 | (i2 | 0) == 0 | (i1 - i2 | 0) >>> 0 > 209715199) {
      d5 = d6 + d5;
      break;
     }
     if (i1 >>> 0 <= 1568669695) if (i2 >>> 0 < 562036736) {
      d5 = d5 * 1237940039285380274899124.0e3;
      d6 = d6 * 1237940039285380274899124.0e3;
      d7 = 8.077935669463161e-28;
     } else d7 = 1.0; else {
      d5 = d5 * 8.077935669463161e-28;
      d6 = d6 * 8.077935669463161e-28;
      d7 = 1237940039285380274899124.0e3;
     }
     d5 = d7 * +Math_sqrt(+(d6 * d6 + d5 * d5));
    } while (0);
    if ((i4 | 0) != 0 & d5 < d11) HEAP8[i3 + i12 >> 0] = i14; else d5 = d11;
    i14 = i14 + 1 | 0;
    if ((i14 | 0) == (i21 | 0)) break; else d11 = d5;
   }
   i15 = i15 + 1 | 0;
  } while ((i15 | 0) != (i22 | 0));
  i13 = i13 + 1 | 0;
 } while ((i13 | 0) != (i21 | 0));
 STACKTOP = i23;
 return;
}

function _flexframesync_set_header_len(i15, i2) {
 i15 = i15 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, d18 = 0.0, i19 = 0, i20 = 0, i21 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i13 = i16;
 HEAP32[i15 + 148 >> 2] = i2;
 i4 = i2 + 6 | 0;
 i2 = i15 + 152 | 0;
 HEAP32[i2 >> 2] = i4;
 i3 = i15 + 156 | 0;
 HEAP32[i3 >> 2] = _realloc(HEAP32[i3 >> 2] | 0, i4) | 0;
 i3 = i15 + 144 | 0;
 i4 = HEAP32[i3 >> 2] | 0;
 if (i4 | 0) {
  _packetizer_destroy(HEAP32[i4 + 4 >> 2] | 0);
  _modem_destroy(HEAP32[i4 >> 2] | 0);
  _free(HEAP32[i4 + 16 >> 2] | 0);
  _free(HEAP32[i4 + 20 >> 2] | 0);
  _free(i4);
 }
 i14 = _malloc(36) | 0;
 i11 = _malloc(252) | 0;
 HEAP32[i11 >> 2] = 48;
 HEAP32[i11 + 76 >> 2] = 0;
 HEAP32[i11 + 80 >> 2] = 0;
 HEAP32[i11 + 4 >> 2] = 2;
 HEAP32[i11 + 8 >> 2] = 4;
 i12 = i11 + 236 | 0;
 HEAP32[i12 >> 2] = 0;
 HEAP32[i12 + 4 >> 2] = 0;
 HEAP32[i12 + 8 >> 2] = 0;
 HEAP32[i12 + 12 >> 2] = 0;
 HEAP32[i12 >> 2] = fb + 1;
 HEAP32[i11 + 240 >> 2] = fb + 2;
 HEAPF32[i11 + 84 >> 2] = 1.0;
 HEAPF32[i11 + 88 >> 2] = 0.0;
 HEAP32[i11 + 92 >> 2] = 1065353216;
 HEAPF32[i11 + 96 >> 2] = 0.0;
 HEAP32[i14 >> 2] = i11;
 HEAP32[i14 + 8 >> 2] = 2;
 HEAP32[i14 + 12 >> 2] = 1;
 i11 = _packetizer_create(1, 1, 1, 1) | 0;
 HEAP32[i14 + 4 >> 2] = i11;
 i11 = HEAP32[i11 + 4 >> 2] | 0;
 HEAP32[i14 + 24 >> 2] = i11;
 i12 = i11 << 3;
 HEAP32[i14 + 28 >> 2] = i12;
 HEAP32[i14 + 16 >> 2] = _malloc(((i12 | 0) / 2 | 0) << 1) | 0;
 HEAP32[i14 + 32 >> 2] = i11 << 1;
 HEAP32[i14 + 20 >> 2] = _malloc(i12) | 0;
 HEAP32[i3 >> 2] = i14;
 _qpacketmodem_configure(i14, HEAP32[i2 >> 2] | 0, 6, 10, 5, 48);
 i3 = HEAP32[(HEAP32[i3 >> 2] | 0) + 32 >> 2] | 0;
 i2 = i15 + 140 | 0;
 HEAP32[i2 >> 2] = i3;
 i14 = i15 + 136 | 0;
 HEAP32[i14 >> 2] = _realloc(HEAP32[i14 >> 2] | 0, i3 << 3) | 0;
 i14 = i15 + 132 | 0;
 i3 = HEAP32[i14 >> 2] | 0;
 if (i3 | 0) {
  _free(HEAP32[i3 + 16 >> 2] | 0);
  _free(HEAP32[i3 + 24 >> 2] | 0);
  _free(HEAP32[i3 + 28 >> 2] | 0);
  _fft_destroy_plan(HEAP32[i3 + 32 >> 2] | 0);
  _free(i3);
 }
 i2 = HEAP32[i2 >> 2] | 0;
 if (i2 | 0) {
  i12 = _malloc(48) | 0;
  HEAP32[i12 >> 2] = i2;
  HEAP32[i12 + 4 >> 2] = 16;
  i8 = (((i2 | 0) % 15 | 0 | 0) != 0 & 1) + ((i2 | 0) / 15 | 0) | 0;
  i9 = i12 + 8 | 0;
  HEAP32[i9 >> 2] = i8;
  i11 = i12 + 12 | 0;
  HEAP32[i11 >> 2] = i8 + i2;
  i1 = _malloc(i8 << 3) | 0;
  HEAP32[i12 + 16 >> 2] = i1;
  i10 = _msequence_create_default(_liquid_nextpow2(i8) | 0) | 0;
  if (!i8) i1 = 0; else {
   i2 = i13 + 4 | 0;
   i3 = i10 + 16 | 0;
   i4 = i10 + 4 | 0;
   i5 = i10 + 20 | 0;
   i6 = i10 + 12 | 0;
   i7 = 0;
   do {
    i21 = HEAP32[i3 >> 2] | 0;
    i19 = HEAP32[i4 >> 2] | 0;
    i20 = HEAP32[i6 >> 2] | 0;
    i17 = i21 & i19;
    i17 = (HEAPU8[(i17 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i17 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i17 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i17 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    i21 = (i17 | i21 << 1) & i20;
    i19 = i21 & i19;
    i19 = (HEAPU8[(i19 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i19 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i19 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i19 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
    HEAP32[i5 >> 2] = i19;
    HEAP32[i3 >> 2] = (i19 | i21 << 1) & i20;
    d18 = +((i19 | i17 << 1) >>> 0) * 6.283185307179586 * .25 + .7853981633974483;
    _cexpf(i13, d18 * 0.0, d18);
    i17 = HEAP32[i2 >> 2] | 0;
    HEAP32[i1 + (i7 << 3) >> 2] = HEAP32[i13 >> 2];
    HEAP32[i1 + (i7 << 3) + 4 >> 2] = i17;
    i7 = i7 + 1 | 0;
   } while ((i7 | 0) != (i8 | 0));
   i1 = HEAP32[i9 >> 2] | 0;
  }
  _free(i10);
  i1 = 1 << (_liquid_nextpow2((i1 >>> 1) + i1 | 0) | 0);
  HEAP32[i12 + 20 >> 2] = i1;
  i3 = i1 << 3;
  i2 = _malloc(i3) | 0;
  HEAP32[i12 + 24 >> 2] = i2;
  i3 = _malloc(i3) | 0;
  HEAP32[i12 + 28 >> 2] = i3;
  HEAP32[i12 + 32 >> 2] = _fft_create_plan(i1, i2, i3, 1, 0) | 0;
  i3 = 0;
  do {
   HEAPF32[i2 + (i3 << 3) >> 2] = 0.0;
   HEAPF32[i2 + (i3 << 3) + 4 >> 2] = 0.0;
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < i1 >>> 0);
  HEAPF32[i12 + 36 >> 2] = 0.0;
  HEAPF32[i12 + 40 >> 2] = 0.0;
  HEAPF32[i12 + 44 >> 2] = 1.0;
  HEAP32[i14 >> 2] = i12;
  i20 = HEAP32[i11 >> 2] | 0;
  HEAP32[i15 + 128 >> 2] = i20;
  i21 = i15 + 124 | 0;
  HEAP32[i21 >> 2] = _realloc(HEAP32[i21 >> 2] | 0, i20 << 3) | 0;
  STACKTOP = i16;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i5 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i5;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i5 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i5 - i1 | 0) >>> 0 < 67) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27670 | 0, 67) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27670 | 0, 67) | 0) >>> 0 < 67) _exit(1); else {
  i6 = 0;
  i7 = gb + 27670 + 67 | 0;
  i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i6 = 67;
  i7 = gb + 27670 | 0;
  i8 = i1;
 } while (0);
 _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
 _exit(1);
}

function _liquid_cplxpair(i16, i19) {
 i16 = i16 | 0;
 i19 = i19 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, d14 = 0.0, i15 = 0, i17 = 0, i18 = 0, i20 = 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i15 = i20;
 HEAP8[i15 >> 0] = 0;
 HEAP8[i15 + 1 >> 0] = 0;
 HEAP8[i15 + 2 >> 0] = 0;
 i9 = 0;
 i2 = 0;
 i7 = 0;
 i8 = 0;
 while (1) {
  i5 = i15 + i2 | 0;
  L3 : do if (i9 << 24 >> 24 == 0 ? (i13 = i16 + (i2 << 3) | 0, d14 = +HEAPF32[i16 + (i2 << 3) + 4 >> 2], !(+Math_abs(+d14) < 9.999999974752427e-07)) : 0) {
   i3 = 0;
   while (1) {
    if (((((i3 | 0) != (i2 | 0) ? (i10 = i15 + i3 | 0, (HEAP8[i10 >> 0] | 0) == 0) : 0) ? (i11 = i16 + (i3 << 3) | 0, i12 = i16 + (i3 << 3) + 4 | 0, d4 = +HEAPF32[i12 >> 2], !(+Math_abs(+d4) < 9.999999974752427e-07)) : 0) ? +Math_abs(+(d14 + d4)) < 9.999999974752427e-07 : 0) ? (d6 = +HEAPF32[i13 >> 2], +Math_abs(+(d6 - +HEAPF32[i11 >> 2])) < 9.999999974752427e-07) : 0) break;
    i3 = i3 + 1 | 0;
    if (i3 >>> 0 >= 3) {
     i3 = i7;
     i18 = i8;
     break L3;
    }
   }
   i3 = i7 + 1 | 0;
   HEAPF32[i19 + (i7 << 3) >> 2] = d6;
   HEAPF32[i19 + (i7 << 3) + 4 >> 2] = d14;
   i18 = HEAP32[i12 >> 2] | 0;
   HEAP32[i19 + (i3 << 3) >> 2] = HEAP32[i11 >> 2];
   HEAP32[i19 + (i3 << 3) + 4 >> 2] = i18;
   HEAP8[i5 >> 0] = 1;
   HEAP8[i10 >> 0] = 1;
   i3 = i7 + 2 | 0;
   i18 = i8 + 1 | 0;
  } else {
   i3 = i7;
   i18 = i8;
  } while (0);
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == 3) break;
  i9 = HEAP8[i15 + i2 >> 0] | 0;
  i7 = i3;
  i8 = i18;
 }
 if (i3 >>> 0 > 3) ___assert_fail(gb + 21948 | 0, gb + 21956 | 0, 102, gb + 21980 | 0); else {
  i17 = 0;
  i1 = i3;
 }
 do {
  i2 = i15 + i17 | 0;
  L21 : do if (!(HEAP8[i2 >> 0] | 0)) {
   d4 = +HEAPF32[i16 + (i17 << 3) + 4 >> 2];
   if (!(d4 > 9.999999974752427e-07)) {
    HEAP32[i19 + (i1 << 3) >> 2] = HEAP32[i16 + (i17 << 3) >> 2];
    HEAPF32[i19 + (i1 << 3) + 4 >> 2] = d4;
    HEAP8[i2 >> 0] = 1;
    i1 = i1 + 1 | 0;
    break;
   }
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i3;
     HEAP32[gb + 8728 + 20 >> 2] = i3;
     i2 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i2;
     break;
    } else {
     HEAP32[gb + 8728 >> 2] = i2 | 32;
     break L21;
    }
   } else i3 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
   if ((i2 - i3 | 0) >>> 0 < 61) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21996 | 0, 61) | 0;
    break;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21996 | 0, 61) | 0) >>> 0 < 61) break;
    i2 = 0;
    i5 = gb + 21996 + 61 | 0;
    i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i2 = 61;
    i5 = gb + 21996 | 0;
   }
   _memcpy(i3 | 0, i5 | 0, i2 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
  } while (0);
  i17 = i17 + 1 | 0;
 } while ((i17 | 0) != 3);
 if (i18) {
  i1 = 0;
  do {
   i17 = i1 << 1;
   i15 = i19 + (i17 << 3) + 4 | 0;
   d14 = +HEAPF32[i15 >> 2];
   i16 = HEAP32[i19 + (i17 << 3) >> 2] | 0;
   d14 = d14 < 0.0 ? d14 : -d14;
   HEAPF32[i15 >> 2] = d14;
   i17 = i17 | 1;
   HEAP32[i19 + (i17 << 3) >> 2] = i16;
   HEAPF32[i19 + (i17 << 3) + 4 >> 2] = -d14;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i18 | 0));
  i10 = i18 + -1 | 0;
  i8 = 0;
  do {
   if (i10 >>> 0 > i8 >>> 0) {
    i1 = i18;
    i9 = i10;
    while (1) {
     i2 = i1 << 1;
     i3 = i2 + -4 | 0;
     i5 = i19 + (i3 << 3) | 0;
     d6 = +HEAPF32[i5 >> 2];
     i7 = i9 << 1;
     i1 = i19 + (i7 << 3) | 0;
     d4 = +HEAPF32[i1 >> 2];
     if (d6 > d4) {
      i16 = i19 + (i3 << 3) + 4 | 0;
      i13 = HEAP32[i16 >> 2] | 0;
      i12 = i19 + (i7 << 3) + 4 | 0;
      i17 = HEAP32[i12 >> 2] | 0;
      HEAPF32[i5 >> 2] = d4;
      HEAP32[i16 >> 2] = i17;
      HEAPF32[i1 >> 2] = d6;
      HEAP32[i12 >> 2] = i13;
      i12 = i2 + -3 | 0;
      i5 = i19 + (i12 << 3) | 0;
      i13 = HEAP32[i5 >> 2] | 0;
      i12 = i19 + (i12 << 3) + 4 | 0;
      i16 = HEAP32[i12 >> 2] | 0;
      i17 = i7 | 1;
      i15 = i19 + (i17 << 3) | 0;
      i17 = i19 + (i17 << 3) + 4 | 0;
      i11 = HEAP32[i17 >> 2] | 0;
      HEAP32[i5 >> 2] = HEAP32[i15 >> 2];
      HEAP32[i12 >> 2] = i11;
      HEAP32[i15 >> 2] = i13;
      HEAP32[i17 >> 2] = i16;
     }
     i1 = i9 + -1 | 0;
     if (i1 >>> 0 > i8 >>> 0) {
      i17 = i9;
      i9 = i1;
      i1 = i17;
     } else break;
    }
   }
   i8 = i8 + 1 | 0;
  } while ((i8 | 0) != (i18 | 0));
  i1 = i18 << 1;
  if (i1 >>> 0 >= 3) {
   STACKTOP = i20;
   return;
  }
 } else i1 = 0;
 do {
  if (i1 >>> 0 < 2) {
   i2 = 3;
   i7 = 2;
   while (1) {
    i2 = i2 + -2 | 0;
    i3 = i19 + (i2 << 3) | 0;
    d4 = +HEAPF32[i3 >> 2];
    i5 = i19 + (i7 << 3) | 0;
    d6 = +HEAPF32[i5 >> 2];
    if (d4 > d6) {
     i16 = i19 + (i2 << 3) + 4 | 0;
     i17 = HEAP32[i16 >> 2] | 0;
     i18 = i19 + (i7 << 3) + 4 | 0;
     i15 = HEAP32[i18 >> 2] | 0;
     HEAPF32[i3 >> 2] = d6;
     HEAP32[i16 >> 2] = i15;
     HEAPF32[i5 >> 2] = d4;
     HEAP32[i18 >> 2] = i17;
    }
    i2 = i7 + -1 | 0;
    if (i2 >>> 0 > i1 >>> 0) {
     i18 = i7;
     i7 = i2;
     i2 = i18;
    } else break;
   }
  }
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != 3);
 STACKTOP = i20;
 return;
}

function _rkaiser_approximate_rho(i15, d16) {
 i15 = i15 | 0;
 d16 = +d16;
 var d1 = 0.0, d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 if (!i15) {
  i6 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i6) {
   i6 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i6 + 255 | i6;
   i6 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i6 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i5 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i5;
    HEAP32[gb + 8728 + 20 >> 2] = i5;
    i7 = i5 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i7;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i6 | 32;
   _exit(1);
  } else {
   i7 = i6;
   i5 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i7 - i5 | 0) >>> 0 < 59) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22448 | 0, 59) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22448 | 0, 59) | 0) >>> 0 < 59) _exit(1); else {
   i8 = 0;
   i9 = gb + 22448 + 59 | 0;
   i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i8 = 59;
   i9 = gb + 22448 | 0;
   i10 = i5;
  } while (0);
  _memcpy(i10 | 0, i9 | 0, i8 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i8;
  _exit(1);
 }
 if (d16 < 0.0 | d16 > 1.0) {
  i5 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i5) {
   i5 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i5 + 255 | i5;
   i5 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i5 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i4;
    HEAP32[gb + 8728 + 20 >> 2] = i4;
    i11 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i11;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i5 | 32;
   _exit(1);
  } else {
   i11 = i5;
   i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i11 - i4 | 0) >>> 0 < 56) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22508 | 0, 56) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22508 | 0, 56) | 0) >>> 0 < 56) _exit(1); else {
   i12 = 0;
   i13 = gb + 22508 + 56 | 0;
   i14 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i12 = 56;
   i13 = gb + 22508 | 0;
   i14 = i4;
  } while (0);
  _memcpy(i14 | 0, i13 | 0, i12 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i12;
  _exit(1);
 }
 do switch (i15 | 0) {
 case 1:
  {
   d1 = .7574973106384277;
   d2 = .061343029141426086;
   d3 = -.08729662746191025;
   break;
  }
 case 2:
  {
   d1 = .8115186095237732;
   d2 = .07437658309936523;
   d3 = -.01427088025957346;
   break;
  }
 case 3:
  {
   d1 = .8424953818321228;
   d2 = .07684185355901718;
   d3 = -.005368790123611689;
   break;
  }
 case 4:
  {
   d1 = .8614078164100647;
   d2 = .07144126296043396;
   d3 = -.005586519837379456;
   break;
  }
 case 5:
  {
   d1 = .8745774030685425;
   d2 = .0657869428396225;
   d3 = -.006504470016807318;
   break;
  }
 case 6:
  {
   d1 = .8843879699707031;
   d2 = .06074265018105507;
   d3 = -.007364050019532442;
   break;
  }
 case 7:
  {
   d1 = .8921661972999573;
   d2 = .05669236183166504;
   d3 = -.007912220433354378;
   break;
  }
 case 8:
  {
   d1 = .898749828338623;
   d2 = .0536169596016407;
   d3 = -.008153010159730911;
   break;
  }
 case 9:
  {
   d1 = .9046003222465515;
   d2 = .051679521799087524;
   d3 = -.008078929968178272;
   break;
  }
 case 10:
  {
   d1 = .9103443026542664;
   d2 = .05130752921104431;
   d3 = -.007461919914931059;
   break;
  }
 case 11:
  {
   d1 = .9158767461776733;
   d2 = .05180436000227928;
   d3 = -.006707109976559877;
   break;
  }
 case 12:
  {
   d1 = .921218752861023;
   d2 = .0527380108833313;
   d3 = -.00588351022452116;
   break;
  }
 case 13:
  {
   d1 = .9263819456100464;
   d2 = .054007638245821;
   d3 = -.00508452020585537;
   break;
  }
 case 14:
  {
   d1 = .9312355518341064;
   d2 = .05516162887215614;
   d3 = -4.3730600737035275e-03;
   break;
  }
 case 15:
  {
   d1 = .9356499314308167;
   d2 = .0559656098484993;
   d3 = -3.8815198931843042e-03;
   break;
  }
 case 16:
  {
   d1 = .9397674202919006;
   d2 = .056622739881277084;
   d3 = -3.4827999770641327e-03;
   break;
  }
 case 17:
  {
   d1 = .9435170292854309;
   d2 = .0569412000477314;
   d3 = -3.1882100738584995e-03;
   break;
  }
 case 18:
  {
   d1 = .9455727338790894;
   d2 = .05227591097354889;
   d3 = -.004006760194897652;
   break;
  }
 case 19:
  {
   d1 = .9500161409378052;
   d2 = .05681641027331352;
   d3 = -3.0062799341976643e-03;
   break;
  }
 case 20:
  {
   d1 = .9528170824050903;
   d2 = .05637606978416443;
   d3 = -.003047900041565299;
   break;
  }
 case 21:
  {
   d1 = .9553625583648682;
   d2 = .055758800357580185;
   d3 = -.00312987994402647;
   break;
  }
 case 22:
  {
   d1 = .9575420618057251;
   d2 = .05426060035824776;
   d3 = -3.8594501093029976e-03;
   break;
  }
 default:
  {
   d1 = +Math_log(+(+(i15 >>> 0) + 1.0000000474974513e-03)) * .056873 + .781388;
   d2 = .054260000586509705;
   d3 = -.003860000055283308;
  }
 } while (0);
 d16 = +Math_log(+d16);
 d1 = d1 + d2 * d16 + d16 * (d3 * d16);
 if (d1 < 0.0) {
  d16 = 0.0;
  return +d16;
 }
 if (!(d1 > 1.0)) {
  d16 = d1;
  return +d16;
 }
 d16 = 1.0;
 return +d16;
}

function _flexframegen_setprops(i10, i9) {
 i10 = i10 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0;
 if (HEAP32[i10 + 112 >> 2] | 0) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i1 | 32;
   return;
  } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i1 - i2 | 0) >>> 0 < 81) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23008 | 0, 81) | 0;
   return;
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23008 | 0, 81) | 0) >>> 0 < 81) return; else {
   i1 = 0;
   i3 = gb + 23008 + 81 | 0;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i1 = 81;
   i3 = gb + 23008 | 0;
  } while (0);
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  return;
 }
 if (!i9) {
  _flexframegen_setprops(i10, gb + 492 | 0);
  return;
 }
 if (((HEAP32[i9 >> 2] | 0) + -1 | 0) >>> 0 > 5) {
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i3;
    HEAP32[gb + 8728 + 20 >> 2] = i3;
    i5 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i5;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i5 = i4;
   i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i5 - i3 | 0) >>> 0 < 63) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23090 | 0, 63) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23090 | 0, 63) | 0) >>> 0 < 63) _exit(1); else {
   i6 = 0;
   i7 = gb + 23090 + 63 | 0;
   i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i6 = 63;
   i7 = gb + 23090 | 0;
   i8 = i3;
  } while (0);
  _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
  _exit(1);
 }
 if (HEAP32[i9 + 4 >> 2] | 0 ? HEAP32[i9 + 8 >> 2] | 0 : 0) {
  if (HEAP32[i9 + 12 >> 2] | 0) {
   _memmove(i10 + 32 | 0, i9 | 0, 16) | 0;
   _flexframegen_reconfigure(i10);
   return;
  }
  i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i3) {
   i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
   i3 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i3 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i11 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i11;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i3 | 32;
   _exit(1);
  } else {
   i11 = i3;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i11 - i2 | 0) >>> 0 < 70) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23218 | 0, 70) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23218 | 0, 70) | 0) >>> 0 < 70) _exit(1); else {
   i12 = 0;
   i13 = gb + 23218 + 70 | 0;
   i14 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i12 = 70;
   i13 = gb + 23218 | 0;
   i14 = i2;
  } while (0);
  _memcpy(i14 | 0, i13 | 0, i12 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i12;
  _exit(1);
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i15 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i15;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i15 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i15 - i1 | 0) >>> 0 < 63) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23154 | 0, 63) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23154 | 0, 63) | 0) >>> 0 < 63) _exit(1); else {
  i16 = 0;
  i17 = gb + 23154 + 63 | 0;
  i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i16 = 63;
  i17 = gb + 23154 | 0;
  i18 = i1;
 } while (0);
 _memcpy(i18 | 0, i17 | 0, i16 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i16;
 _exit(1);
}

function _fec_get_enc_msg_length(i3, i2) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5;
 do switch (i3 | 0) {
 case 1:
  {
   i9 = i2;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 2:
  {
   i9 = i2 * 3 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 3:
  {
   i9 = i2 * 5 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 4:
  {
   i9 = (i2 << 1 & 1073741822) * 7 | 0;
   i9 = ((i9 & 6 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 5:
  {
   i9 = i2 << 1 & 536870910;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 6:
  {
   i9 = (i2 & 536870911) * 12 | 0;
   i9 = (i9 >>> 2 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 7:
  {
   i9 = i2 << 3;
   i9 = (((((i9 >>> 0) % 12 | 0 | 0) != 0 & 1) + ((i9 >>> 0) / 12 | 0) | 0) * 24 | 0) >>> 3;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 8:
  {
   i9 = (i2 >>> 1) + i2 + (i2 & 1) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 9:
  {
   i9 = (i2 >>> 2) + i2 + ((i2 & 3 | 0) != 0 & 1) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 10:
  {
   i9 = (i2 >>> 3) + i2 + ((i2 & 7 | 0) != 0 & 1) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 11:
  {
   i9 = (i2 << 1) + 2 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 12:
  {
   i9 = (i2 << 1) + 2 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 13:
  {
   i9 = (i2 * 3 | 0) + 3 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 14:
  {
   i9 = (i2 * 6 | 0) + 11 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 15:
  {
   i9 = (((i2 << 2 & 2147483644 | 3) + (i2 << 3 | 6) | 0) >>> 3) + 1 | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 16:
  {
   i9 = i2 << 3 | 6;
   i9 = (((i9 + 2 | 0) >>> 0) / 3 | 0) + i9 | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 17:
  {
   i9 = i2 << 3 | 6;
   i9 = ((i9 + 3 | 0) >>> 2) + i9 | 0;
   i9 = ((i9 & 6 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 18:
  {
   i9 = i2 << 3 | 6;
   i9 = (((i9 + 4 | 0) >>> 0) / 5 | 0) + i9 | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 19:
  {
   i9 = i2 << 3 | 6;
   i9 = (((i9 + 5 | 0) >>> 0) / 6 | 0) + i9 | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 20:
  {
   i9 = i2 << 3 | 6;
   i9 = (((i9 + 6 | 0) >>> 0) / 7 | 0) + i9 | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 21:
  {
   i9 = i2 << 3;
   i9 = i9 + 8 + ((i9 + 9 | 0) >>> 1) | 0;
   i9 = (i9 >>> 2 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 22:
  {
   i9 = i2 << 3;
   i9 = i9 + 8 + (((i9 + 10 | 0) >>> 0) / 3 | 0) | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 23:
  {
   i9 = i2 << 3;
   i9 = i9 + 8 + ((i9 + 11 | 0) >>> 2) | 0;
   i9 = ((i9 & 6 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 24:
  {
   i9 = i2 << 3;
   i9 = i9 + 8 + (((i9 + 12 | 0) >>> 0) / 5 | 0) | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 25:
  {
   i9 = i2 << 3;
   i9 = i9 + 8 + (((i9 + 13 | 0) >>> 0) / 6 | 0) | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 26:
  {
   i9 = i2 << 3;
   i9 = i9 + 8 + (((i9 + 14 | 0) >>> 0) / 7 | 0) | 0;
   i9 = ((i9 & 7 | 0) != 0 & 1) + (i9 >>> 3) | 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 case 27:
  {
   if (i2 | 0) {
    i9 = (((i2 | 0) % 223 | 0 | 0) != 0 & 1) + ((i2 | 0) / 223 | 0) | 0;
    i9 = Math_imul(((i2 | 0) / (i9 | 0) | 0) + 32 + (((i2 | 0) % (i9 | 0) | 0 | 0) != 0 & 1) | 0, i9) | 0;
    STACKTOP = i5;
    return i9 | 0;
   }
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i6 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i6;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i6 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i6 - i1 | 0) >>> 0 < 69) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 11620 | 0, 69) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 11620 | 0, 69) | 0) >>> 0 < 69) _exit(1); else {
    i7 = 0;
    i8 = gb + 11620 + 69 | 0;
    i9 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i7 = 69;
    i8 = gb + 11620 | 0;
    i9 = i1;
   } while (0);
   _memcpy(i9 | 0, i8 | 0, i7 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i7;
   _exit(1);
   break;
  }
 case 0:
  {
   i9 = 0;
   STACKTOP = i5;
   return i9 | 0;
  }
 default:
  {
   HEAP32[i4 >> 2] = i3;
   _printf(gb + 11690 | 0, i4);
   _exit(-1);
  }
 } while (0);
 return 0;
}
function _liquid_firdes_gmsktx(i21, i22, d4, i24) {
 i21 = i21 | 0;
 i22 = i22 | 0;
 d4 = +d4;
 i24 = i24 | 0;
 var i1 = 0, i2 = 0, F43 = SIMD_Float32x4(0, 0, 0, 0), d5 = 0.0, i6 = 0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i23 = 0, d25 = 0.0, d26 = 0.0;
 if (!i21) {
  i8 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i8) {
   i8 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i8 + 255 | i8;
   i8 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i8 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i6 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i6;
    HEAP32[gb + 8728 + 20 >> 2] = i6;
    i9 = i6 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i9;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i8 | 32;
   _exit(1);
  } else {
   i9 = i8;
   i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i9 - i6 | 0) >>> 0 < 56) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21453 | 0, 56) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21453 | 0, 56) | 0) >>> 0 < 56) _exit(1); else {
   i10 = 0;
   i11 = gb + 21453 + 56 | 0;
   i12 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i10 = 56;
   i11 = gb + 21453 | 0;
   i12 = i6;
  } while (0);
  _memcpy(i12 | 0, i11 | 0, i10 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i10;
  _exit(1);
 }
 if (!i22) {
  i6 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i6) {
   i6 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i6 + 255 | i6;
   i6 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i6 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i13 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i13;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i6 | 32;
   _exit(1);
  } else {
   i13 = i6;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i13 - i2 | 0) >>> 0 < 56) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21510 | 0, 56) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21510 | 0, 56) | 0) >>> 0 < 56) _exit(1); else {
   i14 = 0;
   i15 = gb + 21510 + 56 | 0;
   i16 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i14 = 56;
   i15 = gb + 21510 | 0;
   i16 = i2;
  } while (0);
  _memcpy(i16 | 0, i15 | 0, i14 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i14;
  _exit(1);
 }
 if (!(d4 < 0.0 | d4 > 1.0)) {
  d7 = +(i21 >>> 0);
  d5 = +(i22 >>> 0);
  d4 = d4 * 6.283185307179586;
  i2 = Math_imul(i21 << 1, i22) | 0;
  i6 = i2 | 1;
  i1 = 0;
  do {
   d25 = +(i1 >>> 0) / d7 - d5 + 0.0;
   d26 = +_liquid_Qf(d4 * (d25 + -.5) * 1.2011224031448364);
   HEAPF32[i24 + (i1 << 2) >> 2] = d26 - +_liquid_Qf(d4 * (d25 + .5) * 1.2011224031448364);
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i6 | 0));
  d4 = 0.0;
  i1 = 0;
  do {
   d4 = d4 + +HEAPF32[i24 + (i1 << 2) >> 2];
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i6 | 0));
  d4 = 3.141592653589793 / (d4 * 2.0);
  i1 = 0;
  do {
   i22 = i24 + (i1 << 2) | 0;
   HEAPF32[i22 >> 2] = d4 * +HEAPF32[i22 >> 2];
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i6 | 0));
  if (i2 >>> 0 >= 4 ? (i23 = i2 & -4, (i23 | 0) != 0) : 0) {
   F43 = SIMD_Float32x4_splat(Math_fround(d7));
   i1 = 0;
   do {
    i22 = i24 + (i1 << 2) | 0;
    SIMD_Float32x4_store(HEAPU8, i22, SIMD_Float32x4_mul(F43, SIMD_Float32x4_load(HEAPU8, i22)));
    i1 = i1 + 4 | 0;
   } while ((i1 | 0) != (i23 | 0));
   i1 = i23;
  } else i1 = 0;
  do {
   i23 = i24 + (i1 << 2) | 0;
   HEAPF32[i23 >> 2] = d7 * +HEAPF32[i23 >> 2];
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i6 | 0));
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i17 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i17;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i17 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i17 - i1 | 0) >>> 0 < 53) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21567 | 0, 53) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 21567 | 0, 53) | 0) >>> 0 < 53) _exit(1); else {
  i18 = 0;
  i19 = gb + 21567 + 53 | 0;
  i20 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i18 = 53;
  i19 = gb + 21567 | 0;
  i20 = i1;
 } while (0);
 _memcpy(i20 | 0, i19 | 0, i18 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i18;
 _exit(1);
}

function _packetizer_destroy(i6) {
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i7 = i8;
 i13 = i8 + 4 | 0;
 i2 = i6 + 20 | 0;
 i5 = i6 + 16 | 0;
 if (!(HEAP32[i2 >> 2] | 0)) {
  i13 = HEAP32[i5 >> 2] | 0;
  _free(i13);
  i13 = i6 + 28 | 0;
  i13 = HEAP32[i13 >> 2] | 0;
  _free(i13);
  i13 = i6 + 32 | 0;
  i13 = HEAP32[i13 >> 2] | 0;
  _free(i13);
  _free(i6);
  STACKTOP = i8;
  return;
 } else i4 = 0;
 L3 : while (1) {
  i3 = HEAP32[(HEAP32[i5 >> 2] | 0) + (i4 * 20 | 0) + 12 >> 2] | 0;
  i1 = HEAP32[i3 >> 2] | 0;
  do switch (i1 | 0) {
  case 0:
   {
    i11 = 3;
    break L3;
   }
  case 1:
   {
    _free(i3);
    break;
   }
  case 2:
   {
    _free(i3);
    break;
   }
  case 3:
   {
    _free(i3);
    break;
   }
  case 4:
   {
    _free(i3);
    break;
   }
  case 5:
   {
    _free(i3);
    break;
   }
  case 6:
   {
    _free(i3);
    break;
   }
  case 7:
   {
    _free(i3);
    break;
   }
  case 8:
   {
    _free(i3);
    break;
   }
  case 9:
   {
    _free(i3);
    break;
   }
  case 10:
   {
    _free(i3);
    break;
   }
  case 14:
  case 13:
  case 12:
  case 11:
   {
    i1 = HEAP32[i3 + 20 >> 2] | 0;
    if (i1 | 0) mftCall_vi(HEAP32[i3 + 60 >> 2] | 0, i1 | 0);
    i1 = HEAP32[i3 + 16 >> 2] | 0;
    if (i1 | 0) _free(i1);
    _free(i3);
    break;
   }
  case 26:
  case 25:
  case 24:
  case 23:
  case 22:
  case 21:
  case 20:
  case 19:
  case 18:
  case 17:
  case 16:
  case 15:
   {
    i1 = HEAP32[i3 + 20 >> 2] | 0;
    if (i1 | 0) mftCall_vi(HEAP32[i3 + 60 >> 2] | 0, i1 | 0);
    i1 = HEAP32[i3 + 16 >> 2] | 0;
    if (i1 | 0) _free(i1);
    _free(i3);
    break;
   }
  case 27:
   {
    i1 = HEAP32[i3 + 96 >> 2] | 0;
    if (i1 | 0) _free_rs_char(i1 | 0);
    _free(HEAP32[i3 + 120 >> 2] | 0);
    _free(HEAP32[i3 + 124 >> 2] | 0);
    _free(HEAP32[i3 + 128 >> 2] | 0);
    _free(i3);
    break;
   }
  default:
   {
    i11 = 48;
    break L3;
   }
  } while (0);
  _free(HEAP32[(HEAP32[i5 >> 2] | 0) + (i4 * 20 | 0) + 16 >> 2] | 0);
  i4 = i4 + 1 | 0;
  if (i4 >>> 0 >= (HEAP32[i2 >> 2] | 0) >>> 0) {
   i11 = 50;
   break;
  }
 }
 if ((i11 | 0) == 3) {
  i1 = HEAP32[gb + 8840 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8840 + 74 >> 0] | 0;
   HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8840 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8840 + 8 >> 2] = 0;
    HEAP32[gb + 8840 + 4 >> 2] = 0;
    i10 = HEAP32[gb + 8840 + 44 >> 2] | 0;
    HEAP32[gb + 8840 + 28 >> 2] = i10;
    HEAP32[gb + 8840 + 20 >> 2] = i10;
    i9 = i10 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8840 + 16 >> 2] = i9;
    break;
   }
   HEAP32[gb + 8840 >> 2] = i1 | 32;
   _exit(-1);
  } else {
   i9 = i1;
   i10 = HEAP32[gb + 8840 + 20 >> 2] | 0;
  } while (0);
  if ((i9 - i10 | 0) >>> 0 < 65) {
   if ((mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, gb + 11927 | 0, 65) | 0) >>> 0 < 65) _exit(-1);
  } else {
   i1 = i10;
   i2 = gb + 11927 | 0;
   i3 = i1 + 65 | 0;
   do {
    HEAP8[i1 >> 0] = HEAP8[i2 >> 0] | 0;
    i1 = i1 + 1 | 0;
    i2 = i2 + 1 | 0;
   } while ((i1 | 0) < (i3 | 0));
   HEAP32[gb + 8840 + 20 >> 2] = (HEAP32[gb + 8840 + 20 >> 2] | 0) + 65;
  }
  i1 = HEAP8[gb + 8840 + 75 >> 0] | 0;
  if (i1 << 24 >> 24 != 10) {
   i2 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   i3 = HEAP32[gb + 8840 + 16 >> 2] | 0;
   if (i2 >>> 0 < i3 >>> 0) {
    HEAP32[gb + 8840 + 20 >> 2] = i2 + 1;
    HEAP8[i2 >> 0] = 10;
    _exit(-1);
   } else i12 = i3;
  } else i12 = HEAP32[gb + 8840 + 16 >> 2] | 0;
  HEAP8[i13 >> 0] = 10;
  do if (!i12) {
   i2 = HEAP16[gb + 8840 + 74 >> 1] | 0;
   i1 = (i2 & 65535) << 24 >> 24;
   HEAP8[gb + 8840 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8840 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8840 + 8 >> 2] = 0;
    HEAP32[gb + 8840 + 4 >> 2] = 0;
    i4 = HEAP32[gb + 8840 + 44 >> 2] | 0;
    HEAP32[gb + 8840 + 28 >> 2] = i4;
    HEAP32[gb + 8840 + 20 >> 2] = i4;
    i3 = i4 + (HEAP32[gb + 8840 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8840 + 16 >> 2] = i3;
    i1 = (i2 & 65535) >>> 8 & 255;
    i11 = 20;
    break;
   } else {
    HEAP32[gb + 8840 >> 2] = i1 | 32;
    break;
   }
  } else {
   i4 = HEAP32[gb + 8840 + 20 >> 2] | 0;
   i3 = i12;
   i11 = 20;
  } while (0);
  do if ((i11 | 0) == 20) if (i4 >>> 0 >= i3 >>> 0 | i1 << 24 >> 24 == 10) {
   mftCall_iiii(HEAP32[gb + 8840 + 36 >> 2] | 0, gb + 8840 | 0, i13 | 0, 1) | 0;
   break;
  } else {
   HEAP32[gb + 8840 + 20 >> 2] = i4 + 1;
   HEAP8[i4 >> 0] = 10;
   break;
  } while (0);
  _exit(-1);
 } else if ((i11 | 0) == 48) {
  HEAP32[i7 >> 2] = i1;
  _printf(gb + 11993 | 0, i7);
  _exit(-1);
 } else if ((i11 | 0) == 50) {
  i13 = HEAP32[i5 >> 2] | 0;
  _free(i13);
  i13 = i6 + 28 | 0;
  i13 = HEAP32[i13 >> 2] | 0;
  _free(i13);
  i13 = i6 + 32 | 0;
  i13 = HEAP32[i13 >> 2] | 0;
  _free(i13);
  _free(i6);
  STACKTOP = i8;
  return;
 }
}

function _fft_destroy_plan(i11) {
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 switch (HEAP32[i11 + 20 >> 2] | 0) {
 case -1:
 case 1:
  {
   switch (HEAP32[i11 + 24 >> 2] | 0) {
   case 5:
    {
     i1 = HEAP32[i11 + 40 >> 2] | 0;
     if (i1 | 0) _free(i1);
     i2 = i11 + 44 | 0;
     i1 = HEAP32[i2 >> 2] | 0;
     if (i1 | 0) {
      if (HEAP32[i11 >> 2] | 0) {
       i10 = HEAP32[i1 >> 2] | 0;
       _free(HEAP32[i10 >> 2] | 0);
       _free(i10);
       if ((HEAP32[i11 >> 2] | 0) >>> 0 > 1) {
        i1 = 1;
        do {
         i10 = HEAP32[(HEAP32[i2 >> 2] | 0) + (i1 << 2) >> 2] | 0;
         _free(HEAP32[i10 >> 2] | 0);
         _free(i10);
         i1 = i1 + 1 | 0;
        } while (i1 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0);
       }
       i1 = HEAP32[i2 >> 2] | 0;
      }
      _free(i1);
     }
     _free(i11);
     return;
    }
   case 1:
    {
     _free(HEAP32[i11 + 44 >> 2] | 0);
     _free(HEAP32[i11 + 48 >> 2] | 0);
     _free(i11);
     return;
    }
   case 2:
    {
     _fft_destroy_plan(HEAP32[i11 + 64 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i11 + 68 >> 2] | 0);
     _free(HEAP32[i11 + 52 >> 2] | 0);
     _free(HEAP32[i11 + 56 >> 2] | 0);
     _free(HEAP32[i11 + 48 >> 2] | 0);
     _free(HEAP32[i11 + 60 >> 2] | 0);
     _free(i11);
     return;
    }
   case 3:
    {
     _free(HEAP32[i11 + 40 >> 2] | 0);
     _free(HEAP32[i11 + 44 >> 2] | 0);
     _free(HEAP32[i11 + 48 >> 2] | 0);
     _free(HEAP32[i11 + 52 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i11 + 56 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i11 + 60 >> 2] | 0);
     _free(i11);
     return;
    }
   case 4:
    {
     _free(HEAP32[i11 + 44 >> 2] | 0);
     _free(HEAP32[i11 + 48 >> 2] | 0);
     _free(HEAP32[i11 + 52 >> 2] | 0);
     _free(HEAP32[i11 + 56 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i11 + 60 >> 2] | 0);
     _fft_destroy_plan(HEAP32[i11 + 64 >> 2] | 0);
     _free(i11);
     return;
    }
   default:
    {
     i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
     do if (!i1) {
      i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
      HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
      i1 = HEAP32[gb + 8728 >> 2] | 0;
      if (!(i1 & 8)) {
       HEAP32[gb + 8728 + 8 >> 2] = 0;
       HEAP32[gb + 8728 + 4 >> 2] = 0;
       i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
       HEAP32[gb + 8728 + 28 >> 2] = i4;
       HEAP32[gb + 8728 + 20 >> 2] = i4;
       i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
       HEAP32[gb + 8728 + 16 >> 2] = i2;
       break;
      }
      HEAP32[gb + 8728 >> 2] = i1 | 32;
      _exit(1);
     } else {
      i2 = i1;
      i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
     } while (0);
     if ((i2 - i4 | 0) >>> 0 < 54) {
      mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37315 | 0, 54) | 0;
      _exit(1);
     }
     i1 = i4;
     do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37315 | 0, 54) | 0) >>> 0 < 54) _exit(1); else {
      i6 = 0;
      i8 = gb + 37315 + 54 | 0;
      i10 = HEAP32[gb + 8728 + 20 >> 2] | 0;
      break;
     } else {
      i6 = 54;
      i8 = gb + 37315 | 0;
      i10 = i1;
     } while (0);
     _memcpy(i10 | 0, i8 | 0, i6 | 0) | 0;
     HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
     _exit(1);
    }
   }
   break;
  }
 case 23:
 case 22:
 case 21:
 case 20:
 case 13:
 case 12:
 case 11:
 case 10:
  {
   _free(i11);
   return;
  }
 case 31:
 case 30:
  return;
 default:
  {
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i3;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i3 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i3 - i1 | 0) >>> 0 < 52) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37370 | 0, 52) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 37370 | 0, 52) | 0) >>> 0 < 52) _exit(1); else {
    i5 = 0;
    i7 = gb + 37370 + 52 | 0;
    i9 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i5 = 52;
    i7 = gb + 37370 | 0;
    i9 = i1;
   } while (0);
   _memcpy(i9 | 0, i7 | 0, i5 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i5;
   _exit(1);
  }
 }
}

function _packetizer_encode(i22, i1, i23) {
 i22 = i22 | 0;
 i1 = i1 | 0;
 i23 = i23 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0;
 i17 = i22 + 28 | 0;
 _memmove(HEAP32[i17 >> 2] | 0, i1 | 0, HEAP32[i22 >> 2] | 0) | 0;
 i2 = _crc_generate_key(HEAP32[i22 + 8 >> 2] | 0, HEAP32[i17 >> 2] | 0, HEAP32[i22 >> 2] | 0) | 0;
 i4 = i22 + 12 | 0;
 i1 = HEAP32[i4 >> 2] | 0;
 if (i1 | 0) {
  i3 = 0;
  while (1) {
   HEAP8[(HEAP32[i17 >> 2] | 0) + (i1 + ~i3 + (HEAP32[i22 >> 2] | 0)) >> 0] = i2;
   i3 = i3 + 1 | 0;
   i1 = HEAP32[i4 >> 2] | 0;
   if (i3 >>> 0 >= i1 >>> 0) break; else i2 = i2 >>> 8;
  }
 }
 i12 = i22 + 20 | 0;
 if (!(HEAP32[i12 >> 2] | 0)) {
  i21 = HEAP32[i17 >> 2] | 0;
  i22 = i22 + 4 | 0;
  i22 = HEAP32[i22 >> 2] | 0;
  _memmove(i23 | 0, i21 | 0, i22 | 0) | 0;
  return;
 }
 i13 = i22 + 16 | 0;
 i14 = i22 + 32 | 0;
 i16 = 0;
 do {
  i9 = HEAP32[i13 >> 2] | 0;
  i15 = HEAP32[i9 + (i16 * 20 | 0) + 12 >> 2] | 0;
  mftCall_viiii(HEAP32[i15 + 136 >> 2] | 0, i15 | 0, HEAP32[i9 + (i16 * 20 | 0) >> 2] | 0, HEAP32[i17 >> 2] | 0, HEAP32[i14 >> 2] | 0);
  i9 = HEAP32[(HEAP32[i13 >> 2] | 0) + (i16 * 20 | 0) + 16 >> 2] | 0;
  i15 = HEAP32[i17 >> 2] | 0;
  _memmove(i15 | 0, HEAP32[i14 >> 2] | 0, HEAP32[i9 >> 2] | 0) | 0;
  i8 = i9 + 12 | 0;
  i1 = HEAP32[i8 >> 2] | 0;
  if (i1 | 0) {
   i2 = HEAP32[i9 >> 2] | 0;
   i10 = i9 + 4 | 0;
   i5 = HEAP32[i10 >> 2] | 0;
   i11 = i9 + 8 | 0;
   i6 = HEAP32[i11 >> 2] | 0;
   i7 = i2 >>> 1;
   if (i7) {
    i4 = 0;
    i1 = 0;
    i2 = (i2 >>> 0) / 3 | 0;
    do {
     do {
      i3 = (Math_imul(i1, i6) | 0) + i2 | 0;
      i1 = i1 + 1 | 0;
      if ((i1 | 0) == (i5 | 0)) {
       i1 = 0;
       i2 = ((i2 + 1 | 0) >>> 0) % (i6 >>> 0) | 0;
      }
     } while (i3 >>> 0 >= i7 >>> 0);
     i25 = i15 + (i3 << 1 | 1) | 0;
     i24 = HEAP8[i25 >> 0] | 0;
     i3 = i15 + (i4 << 1) | 0;
     HEAP8[i25 >> 0] = HEAP8[i3 >> 0] | 0;
     HEAP8[i3 >> 0] = i24;
     i4 = i4 + 1 | 0;
    } while ((i4 | 0) != (i7 | 0));
    i1 = HEAP32[i8 >> 2] | 0;
   }
   if (i1 >>> 0 > 1) {
    i2 = HEAP32[i9 >> 2] | 0;
    i5 = HEAP32[i10 >> 2] | 0;
    i6 = (HEAP32[i11 >> 2] | 0) + 2 | 0;
    i7 = i2 >>> 1;
    if (i7) {
     i4 = 0;
     i1 = 0;
     i2 = (i2 >>> 0) / 3 | 0;
     do {
      do {
       i3 = (Math_imul(i1, i6) | 0) + i2 | 0;
       i1 = i1 + 1 | 0;
       if ((i1 | 0) == (i5 | 0)) {
        i1 = 0;
        i2 = ((i2 + 1 | 0) >>> 0) % (i6 >>> 0) | 0;
       }
      } while (i3 >>> 0 >= i7 >>> 0);
      i26 = i15 + (i4 << 1) | 0;
      i24 = HEAP8[i26 >> 0] | 0;
      i25 = i15 + (i3 << 1 | 1) | 0;
      i3 = HEAP8[i25 >> 0] | 0;
      HEAP8[i26 >> 0] = i3 & 15 | i24 & 240;
      HEAP8[i25 >> 0] = i3 & 240 | i24 & 15;
      i4 = i4 + 1 | 0;
     } while ((i4 | 0) != (i7 | 0));
     i1 = HEAP32[i8 >> 2] | 0;
    }
    if (i1 >>> 0 > 2) {
     i2 = HEAP32[i9 >> 2] | 0;
     i5 = HEAP32[i10 >> 2] | 0;
     i6 = (HEAP32[i11 >> 2] | 0) + 4 | 0;
     i7 = i2 >>> 1;
     if (i7) {
      i4 = 0;
      i1 = 0;
      i2 = (i2 >>> 0) / 3 | 0;
      do {
       do {
        i3 = (Math_imul(i1, i6) | 0) + i2 | 0;
        i1 = i1 + 1 | 0;
        if ((i1 | 0) == (i5 | 0)) {
         i1 = 0;
         i2 = ((i2 + 1 | 0) >>> 0) % (i6 >>> 0) | 0;
        }
       } while (i3 >>> 0 >= i7 >>> 0);
       i27 = i15 + (i4 << 1) | 0;
       i25 = HEAP8[i27 >> 0] | 0;
       i26 = i15 + (i3 << 1 | 1) | 0;
       i24 = HEAP8[i26 >> 0] | 0;
       HEAP8[i27 >> 0] = i24 & 85 | i25 & 170;
       HEAP8[i26 >> 0] = i24 & 170 | i25 & 85;
       i4 = i4 + 1 | 0;
      } while ((i4 | 0) != (i7 | 0));
      i1 = HEAP32[i8 >> 2] | 0;
     }
     if (i1 >>> 0 > 3 ? (i18 = HEAP32[i9 >> 2] | 0, i19 = HEAP32[i10 >> 2] | 0, i20 = (HEAP32[i11 >> 2] | 0) + 8 | 0, i21 = i18 >>> 1, i21 | 0) : 0) {
      i4 = 0;
      i1 = 0;
      i2 = (i18 >>> 0) / 3 | 0;
      do {
       do {
        i3 = (Math_imul(i1, i20) | 0) + i2 | 0;
        i1 = i1 + 1 | 0;
        if ((i1 | 0) == (i19 | 0)) {
         i1 = 0;
         i2 = ((i2 + 1 | 0) >>> 0) % (i20 >>> 0) | 0;
        }
       } while (i3 >>> 0 >= i21 >>> 0);
       i24 = i15 + (i4 << 1) | 0;
       i26 = HEAP8[i24 >> 0] | 0;
       i27 = i15 + (i3 << 1 | 1) | 0;
       i25 = HEAP8[i27 >> 0] | 0;
       HEAP8[i24 >> 0] = i25 & 51 | i26 & 204;
       HEAP8[i27 >> 0] = i25 & 204 | i26 & 51;
       i4 = i4 + 1 | 0;
      } while ((i4 | 0) != (i21 | 0));
     }
    }
   }
  }
  i16 = i16 + 1 | 0;
 } while (i16 >>> 0 < (HEAP32[i12 >> 2] | 0) >>> 0);
 i26 = HEAP32[i17 >> 2] | 0;
 i27 = i22 + 4 | 0;
 i27 = HEAP32[i27 >> 2] | 0;
 _memmove(i23 | 0, i26 | 0, i27 | 0) | 0;
 return;
}

function _modem_demodulate_apsk(i16, i2, i14) {
 i16 = i16 | 0;
 i2 = i2 | 0;
 i14 = i14 | 0;
 var i1 = 0, d3 = 0.0, i4 = 0, I45 = SIMD_Int32x4(0, 0, 0, 0), i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, i10 = 0, d11 = 0.0, d12 = 0.0, i13 = 0, i15 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0;
 i15 = HEAP32[i2 >> 2] | 0;
 i13 = HEAP32[i2 + 4 >> 2] | 0;
 d11 = (HEAP32[tempDoublePtr >> 2] = i15, +HEAPF32[tempDoublePtr >> 2]);
 d12 = (HEAP32[tempDoublePtr >> 2] = i13, +HEAPF32[tempDoublePtr >> 2]);
 d8 = +Math_abs(+d11);
 i10 = (HEAPF32[tempDoublePtr >> 2] = d8, HEAP32[tempDoublePtr >> 2] | 0);
 d8 = +Math_abs(+d12);
 i4 = (HEAPF32[tempDoublePtr >> 2] = d8, HEAP32[tempDoublePtr >> 2] | 0);
 i6 = i10 >>> 0 < i4 >>> 0;
 i2 = i6 ? i4 : i10;
 i4 = i6 ? i10 : i4;
 d8 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
 d3 = (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]);
 do if ((i4 | 0) != 2139095040) {
  if (i2 >>> 0 > 2139095039 | (i4 | 0) == 0 | (i2 - i4 | 0) >>> 0 > 209715199) {
   d3 = d8 + d3;
   break;
  }
  if (i2 >>> 0 <= 1568669695) if (i4 >>> 0 < 562036736) {
   d3 = d3 * 1237940039285380274899124.0e3;
   d8 = d8 * 1237940039285380274899124.0e3;
   d9 = 8.077935669463161e-28;
  } else d9 = 1.0; else {
   d3 = d3 * 8.077935669463161e-28;
   d8 = d8 * 8.077935669463161e-28;
   d9 = 1237940039285380274899124.0e3;
  }
  d3 = d9 * +Math_sqrt(+(d8 * d8 + d3 * d3));
 } while (0);
 i2 = (HEAP32[i16 + 100 >> 2] | 0) + -1 | 0;
 L12 : do if (!i2) i6 = 0; else {
  i4 = 0;
  while (1) {
   if (d3 < +HEAPF32[i16 + 168 + (i4 << 2) >> 2]) {
    i6 = i4;
    break L12;
   }
   i4 = i4 + 1 | 0;
   if (i4 >>> 0 >= i2 >>> 0) {
    i6 = i2;
    break;
   }
  }
 } while (0);
 d3 = +Math_atan2(+d12, +d11);
 if (d3 < 0.0) d3 = d3 + 6.283185307179586;
 i2 = HEAP32[i16 + 104 + (i6 << 2) >> 2] | 0;
 i2 = (~~+_roundf(+((d3 - +HEAPF32[i16 + 200 + (i6 << 2) >> 2]) / (6.283185307179586 / +(i2 >>> 0)))) >>> 0 >>> 0) % (i2 >>> 0) | 0;
 do if (i6) {
  if (i6 >>> 0 >= 4 ? (i7 = i6 & -4, (i7 | 0) != 0) : 0) {
   i4 = 0;
   I45 = SIMD_Int32x4_replaceLane(SIMD_Int32x4_splat(0), 0, i2);
   do {
    I45 = SIMD_Int32x4_add(SIMD_Int32x4_load(HEAPU8, i16 + 104 + (i4 << 2) | 0), I45);
    i4 = i4 + 4 | 0;
   } while ((i4 | 0) != (i7 | 0));
   I45 = SIMD_Int32x4_add(SIMD_Int32x4_swizzle(I45, 2, 3, 0, 0), I45);
   i2 = SIMD_Int32x4_extractLane(SIMD_Int32x4_add(SIMD_Int32x4_swizzle(I45, 1, 0, 0, 0), I45), 0) | 0;
   if ((i6 | 0) == (i7 | 0)) break; else i4 = i7;
  } else i4 = 0;
  do {
   i2 = (HEAP32[i16 + 104 + (i4 << 2) >> 2] | 0) + i2 | 0;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i6 | 0));
 } while (0);
 i10 = i16 + 8 | 0;
 i6 = HEAP32[i10 >> 2] | 0;
 L31 : do if (!i6) i4 = 0; else {
  i7 = HEAP32[i16 + 232 >> 2] | 0;
  i4 = 0;
  while (1) {
   if ((HEAPU8[i7 + i4 >> 0] | 0) == (i2 | 0)) break L31;
   i4 = i4 + 1 | 0;
   if (i4 >>> 0 >= i6 >>> 0) {
    i4 = 0;
    break;
   }
  }
 } while (0);
 HEAP32[i14 >> 2] = i4;
 i2 = i16 + 92 | 0;
 if ((HEAP32[i10 >> 2] | 0) >>> 0 > i4 >>> 0) if (!(HEAP32[i16 + 80 >> 2] | 0)) {
  mftCall_viii(HEAP32[i16 + 236 >> 2] | 0, i16 | 0, i4 | 0, i2 | 0);
  i19 = i16 + 84 | 0;
  i20 = i16 + 88 | 0;
  HEAP32[i19 >> 2] = i15;
  HEAP32[i20 >> 2] = i13;
  return;
 } else {
  i20 = HEAP32[i16 + 76 >> 2] | 0;
  i19 = HEAP32[i20 + (i4 << 3) + 4 >> 2] | 0;
  HEAP32[i2 >> 2] = HEAP32[i20 + (i4 << 3) >> 2];
  HEAP32[i16 + 96 >> 2] = i19;
  i19 = i16 + 84 | 0;
  i20 = i16 + 88 | 0;
  HEAP32[i19 >> 2] = i15;
  HEAP32[i20 >> 2] = i13;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i17 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i17;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i17 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i17 - i1 | 0) >>> 0 < 65) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28660 | 0, 65) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28660 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
  i18 = 0;
  i19 = gb + 28660 + 65 | 0;
  i20 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i18 = 65;
  i19 = gb + 28660 | 0;
  i20 = i1;
 } while (0);
 _memcpy(i20 | 0, i19 | 0, i18 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i18;
 _exit(1);
}

function _crc_generate_key(i2, i8, i9) {
 i2 = i2 | 0;
 i8 = i8 | 0;
 i9 = i9 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i10;
 switch (i2 | 0) {
 case 0:
  {
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i4 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i4;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(-1);
   } else {
    i4 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i4 - i1 | 0) >>> 0 < 71) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 10521 | 0, 71) | 0;
    _exit(-1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 10521 | 0, 71) | 0) >>> 0 < 71) _exit(-1); else {
    i5 = 0;
    i6 = gb + 10521 + 71 | 0;
    i7 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i5 = 71;
    i6 = gb + 10521 | 0;
    i7 = i1;
   } while (0);
   _memcpy(i7 | 0, i6 | 0, i5 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i5;
   _exit(-1);
   break;
  }
 case 2:
  {
   if (!i9) {
    i9 = 0;
    STACKTOP = i10;
    return i9 | 0;
   } else {
    i1 = 0;
    i2 = 0;
   }
   do {
    i2 = (HEAPU8[i8 + i1 >> 0] | 0) + i2 | 0;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i9 | 0));
   i9 = (i2 ^ 255) + 1 & 255;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 3:
  {
   if (!i9) {
    i9 = 0;
    STACKTOP = i10;
    return i9 | 0;
   } else {
    i1 = 0;
    i2 = -1;
   }
   do {
    i6 = HEAPU8[i8 + i1 >> 0] ^ i2;
    i7 = i6 >>> 1;
    i6 = (0 - (i6 & 1) & 224 ^ i7) >>> 1;
    i7 = (i6 ^ 0 - (i7 & 1) & 224) >>> 1;
    i6 = (0 - (i6 & 1) & 224 ^ i7) >>> 1;
    i7 = (0 - (i7 & 1) & 224 ^ i6) >>> 1;
    i6 = (0 - (i6 & 1) & 224 ^ i7) >>> 1;
    i7 = (0 - (i7 & 1) & 224 ^ i6) >>> 1;
    i2 = 0 - (i7 & 1) & 224 ^ (0 - (i6 & 1) & 224 ^ i7) >>> 1;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i9 | 0));
   i9 = i2 & 255 ^ 255;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 4:
  {
   if (!i9) {
    i9 = 0;
    STACKTOP = i10;
    return i9 | 0;
   } else {
    i1 = 0;
    i2 = -1;
   }
   do {
    i7 = HEAPU8[i8 + i1 >> 0] ^ i2;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i7 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i2 = 0 - (i7 & 1) & 40961 ^ i7 >>> 1;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i9 | 0));
   i9 = i2 & 65535 ^ 65535;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 5:
  {
   if (!i9) {
    i9 = 0;
    STACKTOP = i10;
    return i9 | 0;
   } else {
    i1 = 0;
    i2 = -1;
   }
   do {
    i6 = HEAPU8[i8 + i1 >> 0] ^ i2;
    i7 = i6 >>> 1;
    i6 = (0 - (i6 & 1) & 13874874 ^ i7) >>> 1;
    i7 = (i6 ^ 0 - (i7 & 1) & 13874874) >>> 1;
    i6 = (0 - (i6 & 1) & 13874874 ^ i7) >>> 1;
    i7 = (0 - (i7 & 1) & 13874874 ^ i6) >>> 1;
    i6 = (0 - (i6 & 1) & 13874874 ^ i7) >>> 1;
    i7 = (0 - (i7 & 1) & 13874874 ^ i6) >>> 1;
    i2 = 0 - (i7 & 1) & 13874874 ^ (0 - (i6 & 1) & 13874874 ^ i7) >>> 1;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i9 | 0));
   i9 = i2 & 16777215 ^ 16777215;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 6:
  {
   if (!i9) {
    i9 = 0;
    STACKTOP = i10;
    return i9 | 0;
   } else {
    i1 = 0;
    i2 = -1;
   }
   do {
    i6 = HEAPU8[i8 + i1 >> 0] ^ i2;
    i7 = i6 >>> 1;
    i6 = (0 - (i6 & 1) & -306674912 ^ i7) >>> 1;
    i7 = (i6 ^ 0 - (i7 & 1) & -306674912) >>> 1;
    i6 = (0 - (i6 & 1) & -306674912 ^ i7) >>> 1;
    i7 = (0 - (i7 & 1) & -306674912 ^ i6) >>> 1;
    i6 = (0 - (i6 & 1) & -306674912 ^ i7) >>> 1;
    i7 = (0 - (i7 & 1) & -306674912 ^ i6) >>> 1;
    i2 = 0 - (i7 & 1) & -306674912 ^ (0 - (i6 & 1) & -306674912 ^ i7) >>> 1;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i9 | 0));
   i9 = ~i2;
   STACKTOP = i10;
   return i9 | 0;
  }
 case 1:
  {
   i9 = 0;
   STACKTOP = i10;
   return i9 | 0;
  }
 default:
  {
   HEAP32[i3 >> 2] = i2;
   _fprintf(gb + 8728 | 0, gb + 10593 | 0, i3);
   _exit(1);
  }
 }
 return 0;
}

function _modem_init_map(i15) {
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0;
 i14 = i15 + 76 | 0;
 i13 = HEAP32[i14 >> 2] | 0;
 if (!i13) {
  i4 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i4) {
   i4 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i4 + 255 | i4;
   i4 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i4 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i3 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i3;
    HEAP32[gb + 8728 + 20 >> 2] = i3;
    i5 = i3 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i5;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i4 | 32;
   _exit(1);
  } else {
   i5 = i4;
   i3 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i5 - i3 | 0) >>> 0 < 65) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28398 | 0, 65) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28398 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
   i6 = 0;
   i7 = gb + 28398 + 65 | 0;
   i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i6 = 65;
   i7 = gb + 28398 | 0;
   i8 = i3;
  } while (0);
  _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
  _exit(1);
 }
 i5 = i15 + 8 | 0;
 i4 = HEAP32[i5 >> 2] | 0;
 if ((i4 + -1 | 0) >>> 0 > 65535) {
  i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i3) {
   i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
   i3 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i3 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i9 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i9;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i3 | 32;
   _exit(1);
  } else {
   i9 = i3;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i9 - i2 | 0) >>> 0 < 60) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28464 | 0, 60) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28464 | 0, 60) | 0) >>> 0 < 60) _exit(1); else {
   i10 = 0;
   i11 = gb + 28464 + 60 | 0;
   i12 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i10 = 60;
   i11 = gb + 28464 | 0;
   i12 = i2;
  } while (0);
  _memcpy(i12 | 0, i11 | 0, i10 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i10;
  _exit(1);
 }
 i3 = i15 + 236 | 0;
 i2 = HEAP32[i3 >> 2] | 0;
 if (i2 | 0) {
  if (!i4) return;
  mftCall_viii(i2 | 0, i15 | 0, 0, i13 | 0);
  if ((HEAP32[i5 >> 2] | 0) >>> 0 > 1) i1 = 1; else return;
  do {
   mftCall_viii(HEAP32[i3 >> 2] | 0, i15 | 0, i1 | 0, (HEAP32[i14 >> 2] | 0) + (i1 << 3) | 0);
   i1 = i1 + 1 | 0;
  } while (i1 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i16 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i16;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i16 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i16 - i1 | 0) >>> 0 < 70) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28525 | 0, 70) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28525 | 0, 70) | 0) >>> 0 < 70) _exit(1); else {
  i17 = 0;
  i18 = gb + 28525 + 70 | 0;
  i19 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i17 = 70;
  i18 = gb + 28525 | 0;
  i19 = i1;
 } while (0);
 _memcpy(i19 | 0, i18 | 0, i17 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i17;
 _exit(1);
}

function _liquid_firdes_rkaiser_internal_isi(i19, i17, d12, d13, i18) {
 i19 = i19 | 0;
 i17 = i17 | 0;
 d12 = +d12;
 d13 = +d13;
 i18 = i18 | 0;
 var d1 = 0.0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, d7 = 0.0, d8 = 0.0, i9 = 0, d10 = 0.0, d11 = 0.0, i14 = 0, i15 = 0, i16 = 0, i20 = 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i15 = i20 + 8 | 0;
 i6 = i20;
 L1 : do if (!(d13 < 0.0)) {
  if (d13 > 1.0) {
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i4;
     HEAP32[gb + 8728 + 20 >> 2] = i4;
     i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i2;
     break;
    } else {
     HEAP32[gb + 8728 >> 2] = i2 | 32;
     break L1;
    }
   } else i4 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
   if ((i2 - i4 | 0) >>> 0 < 55) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22621 | 0, 55) | 0;
    break;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22621 | 0, 55) | 0) >>> 0 < 55) break;
    i2 = 0;
    i5 = gb + 22621 + 55 | 0;
    i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i2 = 55;
    i5 = gb + 22621 | 0;
   }
   _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
  }
 } else {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i4 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i4;
    HEAP32[gb + 8728 + 20 >> 2] = i4;
    i2 = i4 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i2;
    break;
   } else {
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    break L1;
   }
  } else i4 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i2 - i4 | 0) >>> 0 < 55) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22565 | 0, 55) | 0;
   break;
  }
  if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 22565 | 0, 55) | 0) >>> 0 < 55) break;
   i2 = 0;
   i5 = gb + 22565 + 55 | 0;
   i4 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } else {
   i2 = 55;
   i5 = gb + 22565 | 0;
  }
  _memcpy(i4 | 0, i5 | 0, i2 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i2;
 } while (0);
 i9 = Math_imul(i19 << 1, i17) | 0 | 1;
 d3 = +(i19 >>> 0);
 d1 = d12 * d13 / d3;
 d7 = d1 * 14.260000228881836;
 d8 = +(i9 >>> 0);
 if (d1 > .5 | d1 <= 0.0) {
  HEAPF64[i6 >> 3] = d1;
  _fprintf(gb + 8728 | 0, gb + 20455 | 0, i6);
  _exit(1);
 } else {
  d10 = .009999999776482582;
  d11 = 200.0;
  i14 = 0;
 }
 while (1) {
  d1 = (d10 + d11) * .5;
  if (d1 <= 0.0) {
   i16 = 28;
   break;
  }
  i2 = (d1 + -7.949999809265137) / d7 < d8;
  i14 = i14 + 1 | 0;
  if (i14 >>> 0 >= 20) break; else {
   d10 = i2 ? d1 : d10;
   d11 = i2 ? d11 : d1;
  }
 }
 if ((i16 | 0) == 28) {
  HEAPF64[i15 >> 3] = d1;
  _fprintf(gb + 8728 | 0, gb + 20392 | 0, i15);
  _exit(1);
 }
 _liquid_firdes_kaiser(i9, ((1.0 - d13) * d12 + 1.0) * .5 / d3, d1, i18);
 i2 = 0;
 d7 = 0.0;
 do {
  d13 = +HEAPF32[i18 + (i2 << 2) >> 2];
  d7 = d7 + d13 * d13;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i9 | 0));
 i6 = i17 << 1;
 if (!i6) {
  d12 = 0.0;
  d13 = +(i6 >>> 0);
  d13 = d12 / d13;
  d13 = +Math_sqrt(+d13);
  STACKTOP = i20;
  return +d13;
 } else {
  i5 = 1;
  d1 = 0.0;
 }
 do {
  i2 = Math_imul(i5, i19) | 0;
  i2 = (i2 | 0) > -1 ? i2 : 0 - i2 | 0;
  if (i2 >>> 0 < i9 >>> 0) {
   i4 = i2;
   d3 = 0.0;
   do {
    d3 = d3 + +HEAPF32[i18 + (i4 << 2) >> 2] * +HEAPF32[i18 + (i4 - i2 << 2) >> 2];
    i4 = i4 + 1 | 0;
   } while ((i4 | 0) != (i9 | 0));
  } else d3 = 0.0;
  d13 = +Math_abs(+(d3 / d7));
  d1 = d1 + d13 * d13;
  i5 = i5 + 1 | 0;
 } while (i5 >>> 0 <= i6 >>> 0);
 d13 = +(i6 >>> 0);
 d13 = d1 / d13;
 d13 = +Math_sqrt(+d13);
 STACKTOP = i20;
 return +d13;
}

function _demodulator_recv(i28, i30, i29, i31) {
 i28 = i28 | 0;
 i30 = i30 | 0;
 i29 = i29 | 0;
 i31 = i31 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i32 = 0, i33 = 0;
 i33 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i25 = i33 + 16 | 0;
 i26 = i33 + 8 | 0;
 if (!i28) {
  i32 = 0;
  STACKTOP = i33;
  return i32 | 0;
 }
 i1 = HEAP32[i28 >> 2] | 0;
 if ((i29 >>> 0) % (i1 >>> 0) | 0 | 0) {
  _printf(gb + 9612 | 0, i33);
  i32 = 0;
  STACKTOP = i33;
  return i32 | 0;
 }
 i32 = _llvm_stacksave() | 0;
 i27 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 3) | 0) + 15 & -16) | 0;
 if (!i29) i1 = 0; else {
  i23 = i28 + 20 | 0;
  i19 = i27 + 4 | 0;
  i20 = i26 + 4 | 0;
  i21 = i28 + 16 | 0;
  i22 = i25 + 4 | 0;
  i2 = HEAP32[i28 >> 2] | 0;
  i24 = 0;
  i1 = 0;
  do {
   if (!i2) i2 = 0; else {
    i5 = HEAP32[i21 >> 2] | 0;
    i9 = 0;
    do {
     d8 = +HEAPF32[i30 + (i9 + i24 << 2) >> 2];
     mftCall_vi(HEAP32[i5 + 1048 >> 2] | 0, i5 | 0);
     d7 = +HEAPF32[i5 + 1040 >> 2];
     d4 = d7 * 0.0;
     d6 = +HEAPF32[i5 + 1044 >> 2] - d4;
     d7 = -d7;
     d4 = d4 + d8 * d6;
     d3 = d8 * d7 + d6 * 0.0;
     if ((d4 != d4 | 0.0 != 0.0) & (d3 != d3 | 0.0 != 0.0)) {
      ___mulsc3(i25, d8, 0.0, d6, d7);
      d4 = +HEAPF32[i25 >> 2];
      d3 = +HEAPF32[i22 >> 2];
     }
     HEAPF32[i27 + (i9 << 3) >> 2] = d4;
     HEAPF32[i27 + (i9 << 3) + 4 >> 2] = d3;
     i5 = HEAP32[i21 >> 2] | 0;
     i2 = i5 + 4 | 0;
     d3 = +HEAPF32[i5 + 8 >> 2] + +HEAPF32[i2 >> 2];
     HEAPF32[i2 >> 2] = d3;
     if (!(d3 > 3.141592653589793)) {
      if (d3 < -3.141592653589793) HEAPF32[i2 >> 2] = d3 + 6.283185307179586;
     } else HEAPF32[i2 >> 2] = d3 + -6.283185307179586;
     i9 = i9 + 1 | 0;
     i2 = HEAP32[i28 >> 2] | 0;
    } while (i9 >>> 0 < i2 >>> 0);
   }
   i5 = HEAP32[i23 >> 2] | 0;
   if (!i5) {
    i18 = HEAP32[i19 >> 2] | 0;
    HEAP32[i31 + (i24 << 3) >> 2] = HEAP32[i27 >> 2];
    HEAP32[i31 + (i24 << 3) + 4 >> 2] = i18;
   } else {
    i9 = (i24 >>> 0) / (i2 >>> 0) | 0;
    i18 = i5 + 8 | 0;
    if (HEAP32[i18 >> 2] | 0) {
     i17 = i5 + 12 | 0;
     i15 = i5 + 16 | 0;
     i16 = i31 + (i9 << 3) | 0;
     i13 = i31 + (i9 << 3) + 4 | 0;
     i14 = 0;
     do {
      i5 = HEAP32[i17 >> 2] | 0;
      i11 = HEAP32[i27 + (i14 << 3) >> 2] | 0;
      i12 = HEAP32[i27 + (i14 << 3) + 4 >> 2] | 0;
      i9 = i5 + 24 | 0;
      i2 = HEAP32[i5 + 16 >> 2] & (HEAP32[i9 >> 2] | 0) + 1;
      HEAP32[i9 >> 2] = i2;
      if (!i2) {
       i2 = HEAP32[i5 >> 2] | 0;
       i10 = i5 + 4 | 0;
       _memmove(i2 | 0, i2 + (HEAP32[i5 + 12 >> 2] << 3) | 0, (HEAP32[i10 >> 2] << 3) + -8 | 0) | 0;
       i2 = HEAP32[i9 >> 2] | 0;
      } else i10 = i5 + 4 | 0;
      i10 = i2 + -1 + (HEAP32[i10 >> 2] | 0) | 0;
      i9 = HEAP32[i5 >> 2] | 0;
      HEAP32[i9 + (i10 << 3) >> 2] = i11;
      HEAP32[i9 + (i10 << 3) + 4 >> 2] = i12;
      if (!i14) {
       i2 = HEAP32[i17 >> 2] | 0;
       i2 = (HEAP32[i2 >> 2] | 0) + (HEAP32[i2 + 24 >> 2] << 3) | 0;
       i9 = HEAP32[i15 >> 2] | 0;
       i5 = HEAP32[i9 >> 2] | 0;
       i9 = HEAP32[i9 + 4 >> 2] | 0;
       if (!i9) {
        d4 = 0.0;
        d3 = 0.0;
       } else {
        i10 = 0;
        d4 = 0.0;
        d3 = 0.0;
        do {
         d8 = +HEAPF32[i5 + (i10 << 2) >> 2];
         d4 = d4 + d8 * +HEAPF32[i2 + (i10 << 3) >> 2];
         d3 = d3 + d8 * +HEAPF32[i2 + (i10 << 3) + 4 >> 2];
         i10 = i10 + 1 | 0;
        } while ((i10 | 0) != (i9 | 0));
       }
       HEAPF32[i16 >> 2] = d4;
       HEAPF32[i13 >> 2] = d3;
      }
      i14 = i14 + 1 | 0;
     } while (i14 >>> 0 < (HEAP32[i18 >> 2] | 0) >>> 0);
     i2 = HEAP32[i28 >> 2] | 0;
    }
    i18 = (i24 >>> 0) / (i2 >>> 0) | 0;
    i16 = i31 + (i18 << 3) | 0;
    i18 = i31 + (i18 << 3) + 4 | 0;
    ___divsc3(i26, +HEAPF32[i16 >> 2], +HEAPF32[i18 >> 2], +(i2 >>> 0), 0.0);
    i17 = HEAP32[i20 >> 2] | 0;
    HEAP32[i16 >> 2] = HEAP32[i26 >> 2];
    HEAP32[i18 >> 2] = i17;
   }
   i1 = i1 + 1 | 0;
   i2 = HEAP32[i28 >> 2] | 0;
   i24 = i2 + i24 | 0;
  } while (i24 >>> 0 < i29 >>> 0);
 }
 _llvm_stackrestore(i32 | 0);
 i32 = i1;
 STACKTOP = i33;
 return i32 | 0;
}

function ___muldc3(i14, d1, d2, d3, d4) {
 i14 = i14 | 0;
 d1 = +d1;
 d2 = +d2;
 d3 = +d3;
 d4 = +d4;
 var i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0;
 d8 = d1 * d3;
 d9 = d2 * d4;
 d10 = d1 * d4;
 d11 = d2 * d3;
 d12 = d8 - d9;
 d13 = d11 + d10;
 if (!((d12 != d12 | 0.0 != 0.0) & (d13 != d13 | 0.0 != 0.0))) {
  i7 = i14 + 8 | 0;
  HEAPF64[i14 >> 3] = d12;
  HEAPF64[i7 >> 3] = d13;
  return;
 }
 i5 = +Math_abs(+d1) == inf;
 i6 = +Math_abs(+d2) == inf;
 if (i5 | i6) {
  HEAPF64[tempDoublePtr >> 3] = d1;
  i7 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d1 = +Math_abs(+(+(i5 & 1)));
  HEAPF64[tempDoublePtr >> 3] = d1;
  i7 = HEAP32[tempDoublePtr + 4 >> 2] | i7 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i7;
  d1 = +HEAPF64[tempDoublePtr >> 3];
  HEAPF64[tempDoublePtr >> 3] = d2;
  i7 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d2 = +Math_abs(+(+(i6 & 1)));
  HEAPF64[tempDoublePtr >> 3] = d2;
  i7 = HEAP32[tempDoublePtr + 4 >> 2] | i7 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i7;
  d2 = +HEAPF64[tempDoublePtr >> 3];
  if (d3 != d3 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d3;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d3 = +HEAPF64[tempDoublePtr >> 3];
  }
  if (d4 != d4 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d4;
   i6 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i6;
   d4 = +HEAPF64[tempDoublePtr >> 3];
   i6 = 1;
  } else i6 = 1;
 } else i6 = 0;
 i5 = +Math_abs(+d3) == inf;
 i7 = +Math_abs(+d4) == inf;
 if (i7 | i5) {
  HEAPF64[tempDoublePtr >> 3] = d3;
  i6 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d3 = +Math_abs(+(+(i5 & 1)));
  HEAPF64[tempDoublePtr >> 3] = d3;
  i6 = HEAP32[tempDoublePtr + 4 >> 2] | i6 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i6;
  d3 = +HEAPF64[tempDoublePtr >> 3];
  HEAPF64[tempDoublePtr >> 3] = d4;
  i6 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  d4 = +Math_abs(+(+(i7 & 1)));
  HEAPF64[tempDoublePtr >> 3] = d4;
  i7 = HEAP32[tempDoublePtr + 4 >> 2] | i6 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
  HEAP32[tempDoublePtr + 4 >> 2] = i7;
  d4 = +HEAPF64[tempDoublePtr >> 3];
  if (d1 != d1 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d1;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d1 = +HEAPF64[tempDoublePtr >> 3];
  }
  if (d2 != d2 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d2;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d2 = +HEAPF64[tempDoublePtr >> 3];
  }
 } else if (!i6) {
  i7 = +Math_abs(+d8) == inf;
  i7 = i7 | +Math_abs(+d9) == inf;
  i7 = +Math_abs(+d10) == inf | i7;
  if (!(+Math_abs(+d11) == inf | i7)) {
   i7 = i14 + 8 | 0;
   HEAPF64[i14 >> 3] = d12;
   HEAPF64[i7 >> 3] = d13;
   return;
  }
  if (d1 != d1 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d1;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d1 = +HEAPF64[tempDoublePtr >> 3];
  }
  if (d2 != d2 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d2;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d2 = +HEAPF64[tempDoublePtr >> 3];
  }
  if (d3 != d3 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d3;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d3 = +HEAPF64[tempDoublePtr >> 3];
  }
  if (d4 != d4 | 0.0 != 0.0) {
   HEAPF64[tempDoublePtr >> 3] = d4;
   i7 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = i7;
   d4 = +HEAPF64[tempDoublePtr >> 3];
  }
 }
 d12 = (d3 * d1 - d4 * d2) * inf;
 d13 = (d3 * d2 + d4 * d1) * inf;
 i7 = i14 + 8 | 0;
 HEAPF64[i14 >> 3] = d12;
 HEAPF64[i7 >> 3] = d13;
 return;
}

function ___udivmoddi4(i5, i6, i8, i11, i13) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 i8 = i8 | 0;
 i11 = i11 | 0;
 i13 = i13 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0, i9 = 0, i10 = 0, i12 = 0, i14 = 0, i15 = 0;
 i9 = i5;
 i4 = i6;
 i7 = i4;
 i2 = i8;
 i12 = i11;
 i3 = i12;
 if (!i7) {
  i1 = (i13 | 0) != 0;
  if (!i3) {
   if (i1) {
    HEAP32[i13 >> 2] = (i9 >>> 0) % (i2 >>> 0);
    HEAP32[i13 + 4 >> 2] = 0;
   }
   i12 = 0;
   i13 = (i9 >>> 0) / (i2 >>> 0) >>> 0;
   return (setTempRet0(i12 | 0), i13) | 0;
  } else {
   if (!i1) {
    i12 = 0;
    i13 = 0;
    return (setTempRet0(i12 | 0), i13) | 0;
   }
   HEAP32[i13 >> 2] = i5 | 0;
   HEAP32[i13 + 4 >> 2] = i6 & 0;
   i12 = 0;
   i13 = 0;
   return (setTempRet0(i12 | 0), i13) | 0;
  }
 }
 i1 = (i3 | 0) == 0;
 do if (i2) {
  if (!i1) {
   i1 = (Math_clz32(i3 | 0) | 0) - (Math_clz32(i7 | 0) | 0) | 0;
   if (i1 >>> 0 <= 31) {
    i10 = i1 + 1 | 0;
    i3 = 31 - i1 | 0;
    i6 = i1 - 31 >> 31;
    i2 = i10;
    i5 = i9 >>> (i10 >>> 0) & i6 | i7 << i3;
    i6 = i7 >>> (i10 >>> 0) & i6;
    i1 = 0;
    i3 = i9 << i3;
    break;
   }
   if (!i13) {
    i12 = 0;
    i13 = 0;
    return (setTempRet0(i12 | 0), i13) | 0;
   }
   HEAP32[i13 >> 2] = i5 | 0;
   HEAP32[i13 + 4 >> 2] = i4 | i6 & 0;
   i12 = 0;
   i13 = 0;
   return (setTempRet0(i12 | 0), i13) | 0;
  }
  i1 = i2 - 1 | 0;
  if (i1 & i2 | 0) {
   i3 = (Math_clz32(i2 | 0) | 0) + 33 - (Math_clz32(i7 | 0) | 0) | 0;
   i15 = 64 - i3 | 0;
   i10 = 32 - i3 | 0;
   i4 = i10 >> 31;
   i14 = i3 - 32 | 0;
   i6 = i14 >> 31;
   i2 = i3;
   i5 = i10 - 1 >> 31 & i7 >>> (i14 >>> 0) | (i7 << i10 | i9 >>> (i3 >>> 0)) & i6;
   i6 = i6 & i7 >>> (i3 >>> 0);
   i1 = i9 << i15 & i4;
   i3 = (i7 << i15 | i9 >>> (i14 >>> 0)) & i4 | i9 << i10 & i3 - 33 >> 31;
   break;
  }
  if (i13 | 0) {
   HEAP32[i13 >> 2] = i1 & i9;
   HEAP32[i13 + 4 >> 2] = 0;
  }
  if ((i2 | 0) == 1) {
   i14 = i4 | i6 & 0;
   i15 = i5 | 0 | 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  } else {
   i15 = _llvm_cttz_i32(i2 | 0) | 0;
   i14 = i7 >>> (i15 >>> 0) | 0;
   i15 = i7 << 32 - i15 | i9 >>> (i15 >>> 0) | 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
 } else {
  if (i1) {
   if (i13 | 0) {
    HEAP32[i13 >> 2] = (i7 >>> 0) % (i2 >>> 0);
    HEAP32[i13 + 4 >> 2] = 0;
   }
   i14 = 0;
   i15 = (i7 >>> 0) / (i2 >>> 0) >>> 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  if (!i9) {
   if (i13 | 0) {
    HEAP32[i13 >> 2] = 0;
    HEAP32[i13 + 4 >> 2] = (i7 >>> 0) % (i3 >>> 0);
   }
   i14 = 0;
   i15 = (i7 >>> 0) / (i3 >>> 0) >>> 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  i1 = i3 - 1 | 0;
  if (!(i1 & i3)) {
   if (i13 | 0) {
    HEAP32[i13 >> 2] = i5 | 0;
    HEAP32[i13 + 4 >> 2] = i1 & i7 | i6 & 0;
   }
   i14 = 0;
   i15 = i7 >>> ((_llvm_cttz_i32(i3 | 0) | 0) >>> 0);
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  i1 = (Math_clz32(i3 | 0) | 0) - (Math_clz32(i7 | 0) | 0) | 0;
  if (i1 >>> 0 <= 30) {
   i6 = i1 + 1 | 0;
   i3 = 31 - i1 | 0;
   i2 = i6;
   i5 = i7 << i3 | i9 >>> (i6 >>> 0);
   i6 = i7 >>> (i6 >>> 0);
   i1 = 0;
   i3 = i9 << i3;
   break;
  }
  if (!i13) {
   i14 = 0;
   i15 = 0;
   return (setTempRet0(i14 | 0), i15) | 0;
  }
  HEAP32[i13 >> 2] = i5 | 0;
  HEAP32[i13 + 4 >> 2] = i4 | i6 & 0;
  i14 = 0;
  i15 = 0;
  return (setTempRet0(i14 | 0), i15) | 0;
 } while (0);
 if (!i2) {
  i7 = i3;
  i4 = 0;
  i3 = 0;
 } else {
  i10 = i8 | 0 | 0;
  i9 = i12 | i11 & 0;
  i7 = _i64Add(i10 | 0, i9 | 0, -1, -1) | 0;
  i8 = getTempRet0() | 0;
  i4 = i3;
  i3 = 0;
  do {
   i11 = i4;
   i4 = i1 >>> 31 | i4 << 1;
   i1 = i3 | i1 << 1;
   i11 = i5 << 1 | i11 >>> 31 | 0;
   i12 = i5 >>> 31 | i6 << 1 | 0;
   _i64Subtract(i7 | 0, i8 | 0, i11 | 0, i12 | 0) | 0;
   i15 = getTempRet0() | 0;
   i14 = i15 >> 31 | ((i15 | 0) < 0 ? -1 : 0) << 1;
   i3 = i14 & 1;
   i5 = _i64Subtract(i11 | 0, i12 | 0, i14 & i10 | 0, (((i15 | 0) < 0 ? -1 : 0) >> 31 | ((i15 | 0) < 0 ? -1 : 0) << 1) & i9 | 0) | 0;
   i6 = getTempRet0() | 0;
   i2 = i2 - 1 | 0;
  } while ((i2 | 0) != 0);
  i7 = i4;
  i4 = 0;
 }
 i2 = 0;
 if (i13 | 0) {
  HEAP32[i13 >> 2] = i5;
  HEAP32[i13 + 4 >> 2] = i6;
 }
 i14 = (i1 | 0) >>> 31 | (i7 | i2) << 1 | (i2 << 1 | i1 >>> 31) & 0 | i4;
 i15 = (i1 << 1 | 0 >>> 31) & -2 | i3;
 return (setTempRet0(i14 | 0), i15) | 0;
}

function _fec_secded7264_decode(i1, i29, i22, i26) {
 i1 = i1 | 0;
 i29 = i29 | 0;
 i22 = i22 | 0;
 i26 = i26 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i23 = 0, i24 = 0, i25 = 0, i27 = 0, i28 = 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i23 = i28 + 17 | 0;
 i25 = i28 + 8 | 0;
 i24 = i28;
 i27 = i29 & 7;
 i21 = i29 - i27 | 0;
 if ((i27 | 0) == (i29 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i13 = i23 + 1 | 0;
  i17 = i23 + 2 | 0;
  i18 = i23 + 3 | 0;
  i19 = i23 + 4 | 0;
  i20 = i23 + 5 | 0;
  i14 = i23 + 6 | 0;
  i15 = i23 + 7 | 0;
  i16 = i23 + 8 | 0;
  i2 = 0;
  i1 = 0;
  do {
   i11 = i22 + i1 | 0;
   i12 = i26 + i2 | 0;
   i3 = i23;
   i4 = i3 + 9 | 0;
   do {
    HEAP8[i3 >> 0] = 0;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) < (i4 | 0));
   i4 = _fec_secded7264_compute_syndrome(i11) | 0;
   L5 : do if (!(i4 << 24 >> 24)) {
    i3 = 0;
    i4 = 0;
    i5 = 0;
    i6 = 0;
    i7 = 0;
    i8 = 0;
    i9 = 0;
    i10 = 0;
   } else {
    i3 = 0;
    while (1) {
     if (i4 << 24 >> 24 == (HEAP8[gb + 18219 + i3 >> 0] | 0)) break;
     i3 = i3 + 1 | 0;
     if (i3 >>> 0 >= 72) {
      i3 = 0;
      i4 = 0;
      i5 = 0;
      i6 = 0;
      i7 = 0;
      i8 = 0;
      i9 = 0;
      i10 = 0;
      break L5;
     }
    }
    HEAP8[i23 + (8 - ((i3 | 0) / 8 | 0)) >> 0] = 1 << (i3 & 7);
    i3 = HEAP8[i13 >> 0] | 0;
    i4 = HEAP8[i17 >> 0] | 0;
    i5 = HEAP8[i18 >> 0] | 0;
    i6 = HEAP8[i19 >> 0] | 0;
    i7 = HEAP8[i20 >> 0] | 0;
    i8 = HEAP8[i14 >> 0] | 0;
    i9 = HEAP8[i15 >> 0] | 0;
    i10 = HEAP8[i16 >> 0] | 0;
   } while (0);
   HEAP8[i12 >> 0] = HEAP8[i11 + 1 >> 0] ^ i3;
   HEAP8[i12 + 1 >> 0] = HEAP8[i11 + 2 >> 0] ^ i4;
   HEAP8[i12 + 2 >> 0] = HEAP8[i11 + 3 >> 0] ^ i5;
   HEAP8[i12 + 3 >> 0] = HEAP8[i11 + 4 >> 0] ^ i6;
   HEAP8[i12 + 4 >> 0] = HEAP8[i11 + 5 >> 0] ^ i7;
   HEAP8[i12 + 5 >> 0] = HEAP8[i11 + 6 >> 0] ^ i8;
   HEAP8[i12 + 6 >> 0] = HEAP8[i11 + 7 >> 0] ^ i9;
   HEAP8[i12 + 7 >> 0] = HEAP8[i11 + 8 >> 0] ^ i10;
   i1 = i1 + 9 | 0;
   i2 = i2 + 8 | 0;
  } while (i2 >>> 0 < i21 >>> 0);
 }
 if (i27) {
  i11 = i24;
  HEAP32[i11 >> 2] = 0;
  HEAP32[i11 + 4 >> 2] = 0;
  i11 = i27 + 1 | 0;
  _memset(i25 + i11 | 0, 0, (i11 >>> 0 > 8 ? 0 : 8 - i27 | 0) | 0) | 0;
  _memcpy(i25 | 0, i22 + i1 | 0, i11 | 0) | 0;
  i3 = i23;
  i4 = i3 + 9 | 0;
  do {
   HEAP8[i3 >> 0] = 0;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) < (i4 | 0));
  i4 = _fec_secded7264_compute_syndrome(i25) | 0;
  L14 : do if (!(i4 << 24 >> 24)) {
   i4 = 0;
   i5 = 0;
   i6 = 0;
   i7 = 0;
   i8 = 0;
   i9 = 0;
   i10 = 0;
   i3 = 0;
  } else {
   i3 = 0;
   while (1) {
    if (i4 << 24 >> 24 == (HEAP8[gb + 18219 + i3 >> 0] | 0)) break;
    i3 = i3 + 1 | 0;
    if (i3 >>> 0 >= 72) {
     i4 = 0;
     i5 = 0;
     i6 = 0;
     i7 = 0;
     i8 = 0;
     i9 = 0;
     i10 = 0;
     i3 = 0;
     break L14;
    }
   }
   HEAP8[i23 + (8 - ((i3 | 0) / 8 | 0)) >> 0] = 1 << (i3 & 7);
   i4 = HEAP8[i23 + 4 >> 0] | 0;
   i5 = HEAP8[i23 + 5 >> 0] | 0;
   i6 = HEAP8[i23 + 6 >> 0] | 0;
   i7 = HEAP8[i23 + 7 >> 0] | 0;
   i8 = HEAP8[i23 + 8 >> 0] | 0;
   i9 = HEAP8[i23 + 1 >> 0] | 0;
   i10 = HEAP8[i23 + 2 >> 0] | 0;
   i3 = HEAP8[i23 + 3 >> 0] | 0;
  } while (0);
  HEAP8[i24 >> 0] = HEAP8[i25 + 1 >> 0] ^ i9;
  HEAP8[i24 + 1 >> 0] = HEAP8[i25 + 2 >> 0] ^ i10;
  HEAP8[i24 + 2 >> 0] = HEAP8[i25 + 3 >> 0] ^ i3;
  HEAP8[i24 + 3 >> 0] = HEAP8[i25 + 4 >> 0] ^ i4;
  HEAP8[i24 + 4 >> 0] = HEAP8[i25 + 5 >> 0] ^ i5;
  HEAP8[i24 + 5 >> 0] = HEAP8[i25 + 6 >> 0] ^ i6;
  HEAP8[i24 + 6 >> 0] = HEAP8[i25 + 7 >> 0] ^ i7;
  HEAP8[i24 + 7 >> 0] = HEAP8[i25 + 8 >> 0] ^ i8;
  _memcpy(i26 + i2 | 0, i24 | 0, i27 | 0) | 0;
  i2 = i2 | i27;
  i1 = i1 + i11 | 0;
 }
 if ((i1 | 0) != ((i29 >>> 3) + i29 + ((i27 | 0) != 0 & 1) | 0)) ___assert_fail(gb + 18291 | 0, gb + 18355 | 0, 338, gb + 18424 | 0);
 if ((i2 | 0) == (i29 | 0)) {
  STACKTOP = i28;
  return;
 } else ___assert_fail(gb + 18406 | 0, gb + 18355 | 0, 339, gb + 18424 | 0);
}

function _firdespm_iext_search(i17) {
 i17 = i17 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i18 = 0, i19 = 0, i20 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i9 = i19;
 i7 = HEAP32[i17 + 12 >> 2] | 0;
 i8 = (HEAP32[i17 + 16 >> 2] | 0) + i7 << 1;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i8 << 2) | 0) + 15 & -16) | 0;
 HEAP32[i18 >> 2] = 0;
 i4 = (HEAP32[i17 + 20 >> 2] | 0) + -1 | 0;
 L1 : do if (i4 >>> 0 > 1) {
  i2 = HEAP32[i17 + 60 >> 2] | 0;
  i3 = 1;
  i1 = 1;
  while (1) {
   d5 = +HEAPF64[i2 + (i3 << 3) >> 3];
   if ((d5 >= 0.0 ? +HEAPF64[i2 + (i3 + -1 << 3) >> 3] <= d5 : 0) ? +HEAPF64[i2 + (i3 + 1 << 3) >> 3] <= d5 : 0) i16 = 9; else if ((d5 < 0.0 ? +HEAPF64[i2 + (i3 + -1 << 3) >> 3] >= d5 : 0) ? +HEAPF64[i2 + (i3 + 1 << 3) >> 3] >= d5 : 0) i16 = 9;
   if ((i16 | 0) == 9) {
    i16 = 0;
    if (i1 >>> 0 >= i8 >>> 0) break;
    HEAP32[i18 + (i1 << 2) >> 2] = i3;
    i1 = i1 + 1 | 0;
   }
   i3 = i3 + 1 | 0;
   if (i3 >>> 0 >= i4 >>> 0) {
    i6 = i1;
    break L1;
   }
  }
  ___assert_fail(gb + 20910 | 0, gb + 20927 | 0, 544, gb + 20953 | 0);
 } else i6 = 1; while (0);
 if (i6 >>> 0 >= i8 >>> 0) ___assert_fail(gb + 20910 | 0, gb + 20927 | 0, 558, gb + 20953 | 0);
 i12 = i6 + 1 | 0;
 HEAP32[i18 + (i6 << 2) >> 2] = i4;
 i13 = i7 + 1 | 0;
 if (i12 >>> 0 < i13 >>> 0) {
  HEAP32[i9 >> 2] = i13;
  HEAP32[i9 + 4 >> 2] = i12;
  _fprintf(gb + 8728 | 0, gb + 20974 | 0, i9);
  HEAP32[i17 + 92 >> 2] = 0;
  STACKTOP = i19;
  return;
 }
 if (i12 >>> 0 > i8 >>> 0) ___assert_fail(gb + 21075 | 0, gb + 20927 | 0, 575, gb + 20953 | 0);
 i1 = i12 - i7 + -1 | 0;
 if (i1 | 0) {
  i7 = HEAP32[i17 + 60 >> 2] | 0;
  i8 = 0;
  i9 = i12;
  while (1) {
   i6 = i12 - i8 | 0;
   L32 : do if (i9 >>> 0 > 1) {
    d10 = +HEAPF64[i7 + (HEAP32[i18 >> 2] << 3) >> 3];
    d11 = d10;
    i3 = 1;
    i2 = 0;
    i4 = d10 > 0.0 & 1;
    while (1) {
     d5 = +HEAPF64[i7 + (HEAP32[i18 + (i3 << 2) >> 2] << 3) >> 3];
     d10 = +Math_abs(+d5);
     i20 = d10 < +Math_abs(+d11);
     i2 = i20 ? i3 : i2;
     if (!i4) if (!(d5 >= 0.0)) break; else i4 = 1; else if (d5 < 0.0) i4 = 0; else break;
     i3 = i3 + 1 | 0;
     if (i3 >>> 0 >= i9 >>> 0) {
      i16 = 29;
      break L32;
     }
     d11 = +HEAPF64[i7 + (HEAP32[i18 + (i2 << 2) >> 2] << 3) >> 3];
    }
    i2 = i3 + -1 | 0;
    i20 = d10 < +Math_abs(+(+HEAPF64[i7 + (HEAP32[i18 + (i2 << 2) >> 2] << 3) >> 3]));
    i2 = i20 ? i3 : i2;
   } else {
    i2 = 0;
    i16 = 29;
   } while (0);
   if ((i16 | 0) == 29) {
    i16 = 0;
    if ((i1 | 0) == 1) {
     d11 = +Math_abs(+(+HEAPF64[i7 + (HEAP32[i18 >> 2] << 3) >> 3]));
     i2 = i9 + -1 | 0;
     i20 = d11 < +Math_abs(+(+HEAPF64[i7 + (HEAP32[i18 + (i2 << 2) >> 2] << 3) >> 3]));
     i2 = i20 ? 0 : i2;
    }
   }
   do if (i2 >>> 0 < i9 >>> 0) {
    i3 = i6 - i2 | 0;
    if (i3 >>> 0 >= 4 ? (i15 = i3 & -4, i14 = i15 + i2 | 0, (i15 | 0) != 0) : 0) {
     i4 = 0;
     do {
      i20 = i4 + i2 | 0;
      SIMD_Int32x4_store(HEAPU8, i18 + (i20 << 2) | 0, SIMD_Int32x4_load(HEAPU8, i18 + (i20 + 1 << 2) | 0));
      i4 = i4 + 4 | 0;
     } while ((i4 | 0) != (i15 | 0));
     if ((i3 | 0) == (i15 | 0)) break; else i2 = i14;
    }
    do {
     i20 = i2;
     i2 = i2 + 1 | 0;
     HEAP32[i18 + (i20 << 2) >> 2] = HEAP32[i18 + (i2 << 2) >> 2];
    } while ((i2 | 0) != (i9 | 0));
   } while (0);
   i1 = i1 + -1 | 0;
   if (!i1) break; else {
    i8 = i8 + 1 | 0;
    i9 = i9 + -1 | 0;
   }
  }
 }
 i4 = i17 + 92 | 0;
 HEAP32[i4 >> 2] = 0;
 i1 = i17 + 88 | 0;
 if (!i13) {
  i2 = 0;
  i1 = HEAP32[i1 >> 2] | 0;
 } else {
  i1 = HEAP32[i1 >> 2] | 0;
  i2 = 0;
  i3 = 0;
  do {
   i2 = ((HEAP32[i1 + (i3 << 2) >> 2] | 0) != (HEAP32[i18 + (i3 << 2) >> 2] | 0) & 1) + i2 | 0;
   HEAP32[i4 >> 2] = i2;
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i13 | 0));
  i2 = i13 << 2;
 }
 _memcpy(i1 | 0, i18 | 0, i2 | 0) | 0;
 STACKTOP = i19;
 return;
}

function _fmod(d12, d1) {
 d12 = +d12;
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0, d15 = 0.0;
 HEAPF64[tempDoublePtr >> 3] = d12;
 i2 = HEAP32[tempDoublePtr >> 2] | 0;
 i9 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i10 = HEAP32[tempDoublePtr >> 2] | 0;
 i11 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i3 = _bitshift64Lshr(i2 | 0, i9 | 0, 52) | 0;
 getTempRet0() | 0;
 i3 = i3 & 2047;
 i7 = _bitshift64Lshr(i10 | 0, i11 | 0, 52) | 0;
 getTempRet0() | 0;
 i7 = i7 & 2047;
 i13 = i9 & -2147483648;
 i6 = _bitshift64Shl(i10 | 0, i11 | 0, 1) | 0;
 i8 = getTempRet0() | 0;
 L1 : do if (!((i6 | 0) == 0 & (i8 | 0) == 0) ? (d15 = +Math_abs(+d1), HEAPF64[tempDoublePtr >> 3] = d15, i5 = HEAP32[tempDoublePtr + 4 >> 2] | 0, !(i5 >>> 0 > 2146435072 | (i5 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0 | (i3 | 0) == 2047)) : 0) {
  i4 = _bitshift64Shl(i2 | 0, i9 | 0, 1) | 0;
  i5 = getTempRet0() | 0;
  if (!(i5 >>> 0 > i8 >>> 0 | (i5 | 0) == (i8 | 0) & i4 >>> 0 > i6 >>> 0)) return +((i4 | 0) == (i6 | 0) & (i5 | 0) == (i8 | 0) ? d12 * 0.0 : d12);
  if (!i3) {
   i3 = _bitshift64Shl(i2 | 0, i9 | 0, 12) | 0;
   i4 = getTempRet0() | 0;
   if ((i4 | 0) > -1 | (i4 | 0) == -1 & i3 >>> 0 > 4294967295) {
    i5 = i3;
    i3 = 0;
    do {
     i3 = i3 + -1 | 0;
     i5 = _bitshift64Shl(i5 | 0, i4 | 0, 1) | 0;
     i4 = getTempRet0() | 0;
    } while ((i4 | 0) > -1 | (i4 | 0) == -1 & i5 >>> 0 > 4294967295);
   } else i3 = 0;
   i2 = _bitshift64Shl(i2 | 0, i9 | 0, 1 - i3 | 0) | 0;
   i4 = getTempRet0() | 0;
  } else i4 = i9 & 1048575 | 1048576;
  if (!i7) {
   i5 = _bitshift64Shl(i10 | 0, i11 | 0, 12) | 0;
   i6 = getTempRet0() | 0;
   if ((i6 | 0) > -1 | (i6 | 0) == -1 & i5 >>> 0 > 4294967295) {
    i7 = 0;
    do {
     i7 = i7 + -1 | 0;
     i5 = _bitshift64Shl(i5 | 0, i6 | 0, 1) | 0;
     i6 = getTempRet0() | 0;
    } while ((i6 | 0) > -1 | (i6 | 0) == -1 & i5 >>> 0 > 4294967295);
   } else i7 = 0;
   i10 = _bitshift64Shl(i10 | 0, i11 | 0, 1 - i7 | 0) | 0;
   i9 = getTempRet0() | 0;
  } else i9 = i11 & 1048575 | 1048576;
  i8 = _i64Subtract(i2 | 0, i4 | 0, i10 | 0, i9 | 0) | 0;
  i6 = getTempRet0() | 0;
  i5 = (i6 | 0) > -1 | (i6 | 0) == -1 & i8 >>> 0 > 4294967295;
  L23 : do if ((i3 | 0) > (i7 | 0)) {
   while (1) {
    if (i5) if ((i2 | 0) == (i10 | 0) & (i4 | 0) == (i9 | 0)) break; else {
     i2 = i8;
     i4 = i6;
    }
    i2 = _bitshift64Shl(i2 | 0, i4 | 0, 1) | 0;
    i4 = getTempRet0() | 0;
    i3 = i3 + -1 | 0;
    i8 = _i64Subtract(i2 | 0, i4 | 0, i10 | 0, i9 | 0) | 0;
    i6 = getTempRet0() | 0;
    i5 = (i6 | 0) > -1 | (i6 | 0) == -1 & i8 >>> 0 > 4294967295;
    if ((i3 | 0) <= (i7 | 0)) break L23;
   }
   d1 = d12 * 0.0;
   break L1;
  } while (0);
  if (i5) if ((i2 | 0) == (i10 | 0) & (i4 | 0) == (i9 | 0)) {
   d1 = d12 * 0.0;
   break;
  } else {
   i4 = i6;
   i2 = i8;
  }
  if (i4 >>> 0 < 1048576 | (i4 | 0) == 1048576 & i2 >>> 0 < 0) do {
   i2 = _bitshift64Shl(i2 | 0, i4 | 0, 1) | 0;
   i4 = getTempRet0() | 0;
   i3 = i3 + -1 | 0;
  } while (i4 >>> 0 < 1048576 | (i4 | 0) == 1048576 & i2 >>> 0 < 0);
  if ((i3 | 0) > 0) {
   i11 = _i64Add(i2 | 0, i4 | 0, 0, -1048576) | 0;
   i2 = getTempRet0() | 0;
   i3 = _bitshift64Shl(i3 | 0, 0, 52) | 0;
   i2 = getTempRet0() | 0 | i2;
   i3 = i3 | i11;
  } else {
   i3 = _bitshift64Lshr(i2 | 0, i4 | 0, 1 - i3 | 0) | 0;
   i2 = getTempRet0() | 0;
  }
  HEAP32[tempDoublePtr >> 2] = i3;
  HEAP32[tempDoublePtr + 4 >> 2] = i2 | i13;
  d1 = +HEAPF64[tempDoublePtr >> 3];
 } else i14 = 3; while (0);
 if ((i14 | 0) == 3) {
  d1 = d12 * d1;
  d1 = d1 / d1;
 }
 return +d1;
}

function _fec_rs_decode(i16, i7, i15, i14) {
 i16 = i16 | 0;
 i7 = i7 | 0;
 i15 = i15 | 0;
 i14 = i14 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0;
 if (i7) {
  i13 = i16 + 8 | 0;
  if ((HEAP32[i13 >> 2] | 0) == (i7 | 0)) i8 = i16 + 100 | 0; else {
   HEAP32[i13 >> 2] = i7;
   i5 = HEAP32[i16 + 92 >> 2] | 0;
   i6 = (((i7 | 0) % (i5 | 0) | 0 | 0) != 0 & 1) + ((i7 | 0) / (i5 | 0) | 0) | 0;
   i8 = i16 + 100 | 0;
   HEAP32[i8 >> 2] = i6;
   i1 = (((i7 | 0) % (i6 | 0) | 0 | 0) != 0 & 1) + ((i7 | 0) / (i6 | 0) | 0) | 0;
   HEAP32[i16 + 104 >> 2] = i1;
   i4 = i16 + 80 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
   i3 = i1 + i2 | 0;
   HEAP32[i16 + 108 >> 2] = i3;
   HEAP32[i16 + 112 >> 2] = ((Math_imul(i1, i6) | 0) >>> 0) % (i7 >>> 0) | 0;
   i1 = i5 - i1 | 0;
   i5 = i16 + 116 | 0;
   HEAP32[i5 >> 2] = i1;
   HEAP32[i16 + 12 >> 2] = Math_imul(i3, i6) | 0;
   i6 = i16 + 96 | 0;
   i3 = HEAP32[i6 >> 2] | 0;
   if (i3) {
    _free_rs_char(i3 | 0);
    i2 = HEAP32[i4 >> 2] | 0;
    i1 = HEAP32[i5 >> 2] | 0;
   }
   HEAP32[i6 >> 2] = _init_rs_char(HEAP32[i16 + 64 >> 2] | 0, HEAP32[i16 + 68 >> 2] | 0, HEAP32[i16 + 72 >> 2] | 0, HEAP32[i16 + 76 >> 2] | 0, i2 | 0, i1 | 0) | 0;
  }
  i7 = i16 + 88 | 0;
  _memset(HEAP32[i16 + 124 >> 2] | 0, 0, HEAP32[i7 >> 2] | 0) | 0;
  i6 = i16 + 128 | 0;
  _memset(HEAP32[i6 >> 2] | 0, 0, HEAP32[i7 >> 2] | 0) | 0;
  i7 = i16 + 132 | 0;
  HEAP32[i7 >> 2] = 0;
  i1 = HEAP32[i8 >> 2] | 0;
  if (!i1) {
   i2 = 0;
   i1 = 0;
  } else {
   i9 = i16 + 112 | 0;
   i10 = i16 + 120 | 0;
   i11 = i16 + 108 | 0;
   i12 = i16 + 96 | 0;
   i4 = i1;
   i3 = HEAP32[i16 + 104 >> 2] | 0;
   i5 = 0;
   i2 = 0;
   i1 = 0;
   do {
    if ((i5 | 0) == (i4 + -1 | 0)) i3 = i3 - (HEAP32[i9 >> 2] | 0) | 0;
    _memmove(HEAP32[i10 >> 2] | 0, i15 + i2 | 0, HEAP32[i11 >> 2] | 0) | 0;
    _decode_rs_char(HEAP32[i12 >> 2] | 0, HEAP32[i10 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i7 >> 2] | 0) | 0;
    _memmove(i14 + i1 | 0, HEAP32[i10 >> 2] | 0, i3 | 0) | 0;
    i2 = (HEAP32[i11 >> 2] | 0) + i2 | 0;
    i1 = i3 + i1 | 0;
    i5 = i5 + 1 | 0;
    i4 = HEAP32[i8 >> 2] | 0;
   } while (i5 >>> 0 < i4 >>> 0);
  }
  if ((i2 | 0) != (HEAP32[i16 + 12 >> 2] | 0)) ___assert_fail(gb + 17740 | 0, gb + 17681 | 0, 185, gb + 17764 | 0);
  if ((i1 | 0) == (HEAP32[i13 >> 2] | 0)) return; else ___assert_fail(gb + 17778 | 0, gb + 17681 | 0, 186, gb + 17764 | 0);
 } else {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i3;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i3 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i3 - i1 | 0) >>> 0 < 49) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 17607 | 0, 49) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 17607 | 0, 49) | 0) >>> 0 < 49) _exit(1); else {
   i4 = 0;
   i5 = gb + 17607 + 49 | 0;
   i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i4 = 49;
   i5 = gb + 17607 | 0;
   i6 = i1;
  } while (0);
  _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
  _exit(1);
 }
}

function _fopen(i2, i5) {
 i2 = i2 | 0;
 i5 = i5 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i3 = i12 + 120 | 0;
 i11 = i12 + 104 | 0;
 i8 = i12 + 88 | 0;
 i7 = i12 + 80 | 0;
 i6 = i12 + 64 | 0;
 i10 = i12;
 i1 = HEAP8[i5 >> 0] | 0;
 do if (_memchr(gb + 41236 | 0, i1 << 24 >> 24, 4) | 0) {
  i9 = ___strchrnul(i5, 43) | 0;
  i9 = (i9 | 0) == 0 | (HEAP8[i9 >> 0] | 0) != 43 ? i1 << 24 >> 24 != 114 & 1 : 2;
  i4 = ___strchrnul(i5, 120) | 0;
  i9 = (i4 | 0) == 0 | (HEAP8[i4 >> 0] | 0) != 120 ? i9 : i9 | 128;
  i4 = ___strchrnul(i5, 101) | 0;
  i9 = (i4 | 0) == 0 | (HEAP8[i4 >> 0] | 0) != 101 ? i9 : i9 | 524288;
  i9 = i1 << 24 >> 24 == 114 ? i9 : i9 | 64;
  i9 = i1 << 24 >> 24 == 119 ? i9 | 512 : i9;
  HEAP32[i10 >> 2] = i2;
  HEAP32[i10 + 4 >> 2] = (i1 << 24 >> 24 == 97 ? i9 | 1024 : i9) | 32768;
  HEAP32[i10 + 8 >> 2] = 438;
  i9 = ___syscall5(5, i10 | 0) | 0;
  if (i9 >>> 0 > 4294963200) {
   if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
   HEAP32[i1 >> 2] = 0 - i9;
   i1 = 0;
   break;
  }
  if ((i9 | 0) < 0) i1 = 0; else {
   i2 = HEAP8[i5 >> 0] | 0;
   if (_memchr(gb + 41236 | 0, i2 << 24 >> 24, 4) | 0) {
    i1 = _malloc(1144) | 0;
    if (i1 | 0) {
     i3 = i1;
     i4 = i3 + 112 | 0;
     do {
      HEAP32[i3 >> 2] = 0;
      i3 = i3 + 4 | 0;
     } while ((i3 | 0) < (i4 | 0));
     i4 = ___strchrnul(i5, 43) | 0;
     if ((i4 | 0) == 0 | (HEAP8[i4 >> 0] | 0) != 43) HEAP32[i1 >> 2] = i2 << 24 >> 24 == 114 ? 8 : 4;
     i4 = ___strchrnul(i5, 101) | 0;
     if (!((i4 | 0) == 0 | (HEAP8[i4 >> 0] | 0) != 101)) {
      HEAP32[i6 >> 2] = i9;
      HEAP32[i6 + 4 >> 2] = 2;
      HEAP32[i6 + 8 >> 2] = 1;
      ___syscall221(221, i6 | 0) | 0;
      i2 = HEAP8[i5 >> 0] | 0;
     }
     if (i2 << 24 >> 24 == 97) {
      HEAP32[i7 >> 2] = i9;
      HEAP32[i7 + 4 >> 2] = 3;
      i2 = ___syscall221(221, i7 | 0) | 0;
      if (!(i2 & 1024)) {
       HEAP32[i8 >> 2] = i9;
       HEAP32[i8 + 4 >> 2] = 4;
       HEAP32[i8 + 8 >> 2] = i2 | 1024;
       ___syscall221(221, i8 | 0) | 0;
      }
      i3 = HEAP32[i1 >> 2] | 128;
      HEAP32[i1 >> 2] = i3;
     } else i3 = HEAP32[i1 >> 2] | 0;
     HEAP32[i1 + 60 >> 2] = i9;
     HEAP32[i1 + 44 >> 2] = i1 + 120;
     HEAP32[i1 + 48 >> 2] = 1024;
     i2 = i1 + 75 | 0;
     HEAP8[i2 >> 0] = -1;
     if ((i3 & 8 | 0) == 0 ? (HEAP32[i11 >> 2] = i9, HEAP32[i11 + 4 >> 2] = 21505, HEAP32[i11 + 8 >> 2] = i10, (___syscall54(54, i11 | 0) | 0) == 0) : 0) HEAP8[i2 >> 0] = 10;
     HEAP32[i1 + 32 >> 2] = fb + 9;
     HEAP32[i1 + 36 >> 2] = fb + 1;
     HEAP32[i1 + 40 >> 2] = fb + 2;
     HEAP32[i1 + 12 >> 2] = fb + 1;
     if (!(HEAP32[gb + 41360 + 4 >> 2] | 0)) HEAP32[i1 + 76 >> 2] = -1;
     ___lock(gb + 41360 + 28 | 0);
     i2 = HEAP32[gb + 41360 + 24 >> 2] | 0;
     HEAP32[i1 + 56 >> 2] = i2;
     if (i2 | 0) HEAP32[i2 + 52 >> 2] = i1;
     HEAP32[gb + 41360 + 24 >> 2] = i1;
     ___unlock(gb + 41360 + 28 | 0);
     break;
    }
   } else {
    if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
    HEAP32[i1 >> 2] = 22;
   }
   HEAP32[i3 >> 2] = i9;
   ___syscall6(6, i3 | 0) | 0;
   i1 = 0;
  }
 } else {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i1 >> 2] = 22;
  i1 = 0;
 } while (0);
 STACKTOP = i12;
 return i1 | 0;
}

function _fec_rs_encode(i15, i7, i13, i14) {
 i15 = i15 | 0;
 i7 = i7 | 0;
 i13 = i13 | 0;
 i14 = i14 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 if (i7) {
  i12 = i15 + 8 | 0;
  if ((HEAP32[i12 >> 2] | 0) == (i7 | 0)) {
   i8 = i15 + 100 | 0;
   i9 = i15 + 104 | 0;
  } else {
   HEAP32[i12 >> 2] = i7;
   i5 = HEAP32[i15 + 92 >> 2] | 0;
   i6 = (((i7 | 0) % (i5 | 0) | 0 | 0) != 0 & 1) + ((i7 | 0) / (i5 | 0) | 0) | 0;
   i8 = i15 + 100 | 0;
   HEAP32[i8 >> 2] = i6;
   i1 = (((i7 | 0) % (i6 | 0) | 0 | 0) != 0 & 1) + ((i7 | 0) / (i6 | 0) | 0) | 0;
   i9 = i15 + 104 | 0;
   HEAP32[i9 >> 2] = i1;
   i4 = i15 + 80 | 0;
   i2 = HEAP32[i4 >> 2] | 0;
   i3 = i1 + i2 | 0;
   HEAP32[i15 + 108 >> 2] = i3;
   HEAP32[i15 + 112 >> 2] = ((Math_imul(i1, i6) | 0) >>> 0) % (i7 >>> 0) | 0;
   i1 = i5 - i1 | 0;
   i5 = i15 + 116 | 0;
   HEAP32[i5 >> 2] = i1;
   HEAP32[i15 + 12 >> 2] = Math_imul(i3, i6) | 0;
   i6 = i15 + 96 | 0;
   i3 = HEAP32[i6 >> 2] | 0;
   if (i3) {
    _free_rs_char(i3 | 0);
    i2 = HEAP32[i4 >> 2] | 0;
    i1 = HEAP32[i5 >> 2] | 0;
   }
   HEAP32[i6 >> 2] = _init_rs_char(HEAP32[i15 + 64 >> 2] | 0, HEAP32[i15 + 68 >> 2] | 0, HEAP32[i15 + 72 >> 2] | 0, HEAP32[i15 + 76 >> 2] | 0, i2 | 0, i1 | 0) | 0;
  }
  i1 = HEAP32[i8 >> 2] | 0;
  if (!i1) {
   i2 = 0;
   i1 = 0;
  } else {
   i6 = i15 + 112 | 0;
   i7 = i15 + 120 | 0;
   i10 = i15 + 96 | 0;
   i11 = i15 + 108 | 0;
   i4 = i1;
   i3 = HEAP32[i9 >> 2] | 0;
   i5 = 0;
   i2 = 0;
   i1 = 0;
   do {
    if ((i5 | 0) == (i4 + -1 | 0)) i3 = i3 - (HEAP32[i6 >> 2] | 0) | 0;
    _memmove(HEAP32[i7 >> 2] | 0, i13 + i2 | 0, i3 | 0) | 0;
    i4 = HEAP32[i7 >> 2] | 0;
    _encode_rs_char(HEAP32[i10 >> 2] | 0, i4 | 0, i4 + (HEAP32[i9 >> 2] | 0) | 0);
    _memmove(i14 + i1 | 0, HEAP32[i7 >> 2] | 0, HEAP32[i11 >> 2] | 0) | 0;
    i2 = i3 + i2 | 0;
    i1 = (HEAP32[i11 >> 2] | 0) + i1 | 0;
    i5 = i5 + 1 | 0;
    i4 = HEAP32[i8 >> 2] | 0;
   } while (i5 >>> 0 < i4 >>> 0);
  }
  if ((i2 | 0) != (HEAP32[i12 >> 2] | 0)) ___assert_fail(gb + 17657 | 0, gb + 17681 | 0, 131, gb + 17702 | 0);
  if ((i1 | 0) == (HEAP32[i15 + 12 >> 2] | 0)) return; else ___assert_fail(gb + 17716 | 0, gb + 17681 | 0, 132, gb + 17702 | 0);
 } else {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i3;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i3 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i3 - i1 | 0) >>> 0 < 49) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 17607 | 0, 49) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 17607 | 0, 49) | 0) >>> 0 < 49) _exit(1); else {
   i4 = 0;
   i5 = gb + 17607 + 49 | 0;
   i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i4 = 49;
   i5 = gb + 17607 | 0;
   i6 = i1;
  } while (0);
  _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
  _exit(1);
 }
}

function _ofdmframe_init_S0(i11, i14, i10, i15, i9) {
 i11 = i11 | 0;
 i14 = i14 | 0;
 i10 = i10 | 0;
 i15 = i15 | 0;
 i9 = i9 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i12 = 0, i13 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, d20 = 0.0;
 i8 = _liquid_nextpow2(i14) | 0;
 i8 = _msequence_create_default(i8 >>> 0 < 4 ? 4 : i8 >>> 0 > 8 ? 8 : i8) | 0;
 if (i14) {
  i6 = HEAP32[i8 + 4 >> 2] | 0;
  i7 = HEAP32[i8 + 12 >> 2] | 0;
  i5 = HEAP32[i8 + 16 >> 2] | 0;
  i3 = 0;
  i12 = 0;
  do {
   i19 = i5 & i6;
   i19 = ((HEAPU8[(i19 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i19 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i19 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i19 >>> 24) + (gb + 36491) >> 0] | 0) & 1 | i5 << 1) & i7;
   i4 = i19 & i6;
   i19 = ((HEAPU8[(i4 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 24) + (gb + 36491) >> 0] | 0) & 1 | i19 << 1) & i7;
   i4 = i19 & i6;
   i4 = (HEAPU8[(i4 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
   i5 = (i4 | i19 << 1) & i7;
   do if (HEAP8[i11 + i12 >> 0] | 0) if (!(i12 & 1)) {
    HEAPF32[i10 + (i12 << 3) >> 2] = i4 | 0 ? 1.0 : -1.0;
    HEAPF32[i10 + (i12 << 3) + 4 >> 2] = 0.0;
    i3 = i3 + 1 | 0;
    break;
   } else {
    HEAPF32[i10 + (i12 << 3) >> 2] = 0.0;
    HEAPF32[i10 + (i12 << 3) + 4 >> 2] = 0.0;
    break;
   } else {
    HEAPF32[i10 + (i12 << 3) >> 2] = 0.0;
    HEAPF32[i10 + (i12 << 3) + 4 >> 2] = 0.0;
   } while (0);
   i12 = i12 + 1 | 0;
  } while ((i12 | 0) != (i14 | 0));
  _free(i8);
  if (i3 | 0) {
   HEAP32[i9 >> 2] = i3;
   i1 = _fft_create_plan(i14, i10, i15, -1, 0) | 0;
   mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
   _fft_destroy_plan(i1);
   d2 = 1.0 / +Math_sqrt(+(+(i3 >>> 0)));
   i1 = 0;
   do {
    i18 = i15 + (i1 << 3) | 0;
    i19 = i15 + (i1 << 3) + 4 | 0;
    d20 = d2 * +HEAPF32[i19 >> 2];
    HEAPF32[i18 >> 2] = d2 * +HEAPF32[i18 >> 2];
    HEAPF32[i19 >> 2] = d20;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i14 | 0));
   return;
  }
 } else _free(i8);
 i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i3) {
  i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
  i3 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i3 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i13 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i13;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i3 | 32;
  _exit(1);
 } else {
  i13 = i3;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i13 - i1 | 0) >>> 0 < 69) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32496 | 0, 69) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32496 | 0, 69) | 0) >>> 0 < 69) _exit(1); else {
  i16 = 0;
  i17 = gb + 32496 + 69 | 0;
  i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i16 = 69;
  i17 = gb + 32496 | 0;
  i18 = i1;
 } while (0);
 _memcpy(i18 | 0, i17 | 0, i16 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i16;
 _exit(1);
}

function _liquid_iirdes(i24, i23) {
 i24 = i24 | 0;
 i23 = i23 | 0;
 var d1 = 0.0, i2 = 0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, d18 = 0.0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i25 = 0, d26 = 0.0;
 i25 = STACKTOP;
 STACKTOP = STACKTOP + 208 | 0;
 i19 = i25 + 40 | 0;
 i20 = i25 + 24 | 0;
 i21 = i25;
 i22 = i25 + 176 | 0;
 i17 = i25 + 152 | 0;
 _cexpf(i19, 0.0, 2.094395160675049);
 i2 = HEAP32[i19 + 4 >> 2] | 0;
 HEAP32[i17 >> 2] = HEAP32[i19 >> 2];
 HEAP32[i17 + 4 >> 2] = i2;
 _cexpf(i20, -0.0, -2.094395160675049);
 i12 = HEAP32[i20 + 4 >> 2] | 0;
 HEAP32[i17 + 8 >> 2] = HEAP32[i20 >> 2];
 HEAP32[i17 + 12 >> 2] = i12;
 HEAPF32[i17 + 16 >> 2] = -1.0;
 HEAPF32[i17 + 20 >> 2] = 0.0;
 i12 = i25 + 104 | 0;
 i13 = i25 + 56 | 0;
 i14 = i19 + 8 | 0;
 i15 = i20 + 8 | 0;
 i16 = i21 + 8 | 0;
 d1 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
 d4 = 1.0;
 d3 = 0.0;
 i2 = 0;
 while (1) {
  HEAPF32[i12 + (i2 << 3) >> 2] = -1.0;
  HEAPF32[i12 + (i2 << 3) + 4 >> 2] = 0.0;
  d6 = +HEAPF32[i17 + (i2 << 3) >> 2] * 2.4142136573791504;
  d7 = d1 * 2.4142136573791504;
  ___divdc3(i19, d6 + 1.0, d7, 1.0 - d6, -d7);
  d7 = +HEAPF64[i19 >> 3];
  d6 = +HEAPF64[i14 >> 3];
  HEAPF32[i13 + (i2 << 3) >> 2] = d7;
  HEAPF32[i13 + (i2 << 3) + 4 >> 2] = d6;
  ___divdc3(i20, 1.0 - d7, -d6, 2.0, -0.0);
  d6 = +HEAPF64[i20 >> 3];
  d7 = +HEAPF64[i15 >> 3];
  d1 = d4 * d6 - d3 * d7;
  d5 = d3 * d6 + d4 * d7;
  if ((d1 != d1 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
   ___muldc3(i21, d4, d3, d6, d7);
   d1 = +HEAPF64[i21 >> 3];
   d3 = +HEAPF64[i16 >> 3];
  } else d3 = d5;
  d18 = d1;
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == 3) break;
  d1 = +HEAPF32[i17 + (i2 << 3) + 4 >> 2];
  d4 = d18;
 }
 _liquid_cplxpair(i12, i21);
 _liquid_cplxpair(i13, i22);
 d3 = +HEAPF32[i22 >> 2];
 d4 = +HEAPF32[i22 + 4 >> 2];
 d26 = +HEAPF32[i22 + 8 >> 2];
 d5 = +HEAPF32[i22 + 12 >> 2];
 d6 = -d26;
 d7 = +HEAPF32[i21 >> 2];
 d8 = +HEAPF32[i21 + 4 >> 2];
 d9 = +HEAPF32[i21 + 8 >> 2];
 d10 = +HEAPF32[i21 + 12 >> 2];
 d11 = -d9;
 HEAPF32[i23 >> 2] = 1.0;
 HEAPF32[i23 + 4 >> 2] = d6 - d3;
 d1 = d3 * d26 - d4 * d5;
 d26 = d4 * d26 + d3 * d5;
 if ((d1 != d1 | 0.0 != 0.0) & (d26 != d26 | 0.0 != 0.0)) {
  ___mulsc3(i19, -d3, -d4, d6, -d5);
  d1 = +HEAPF32[i19 >> 2];
 }
 HEAPF32[i23 + 8 >> 2] = d1;
 HEAPF32[i24 >> 2] = 1.0;
 HEAPF32[i24 + 4 >> 2] = d11 - d7;
 d1 = d7 * d9 - d8 * d10;
 d26 = d8 * d9 + d7 * d10;
 if ((d1 != d1 | 0.0 != 0.0) & (d26 != d26 | 0.0 != 0.0)) {
  ___mulsc3(i20, -d7, -d8, d11, -d10);
  d1 = +HEAPF32[i20 >> 2];
 }
 HEAPF32[i24 + 8 >> 2] = d1;
 d26 = -+HEAPF32[i22 + 16 >> 2];
 d1 = -+HEAPF32[i21 + 16 >> 2];
 HEAPF32[i23 + 12 >> 2] = 1.0;
 HEAPF32[i23 + 16 >> 2] = d26;
 HEAPF32[i23 + 20 >> 2] = 0.0;
 HEAPF32[i24 + 12 >> 2] = 1.0;
 HEAPF32[i24 + 16 >> 2] = d1;
 HEAPF32[i24 + 20 >> 2] = 0.0;
 d1 = +Math_abs(+(+Math_sqrt(+d18)));
 d1 = d18 == -inf ? inf : d1;
 i2 = 0;
 do {
  i23 = i2 * 3 | 0;
  i22 = i24 + (i23 << 2) | 0;
  HEAPF32[i22 >> 2] = d1 * +HEAPF32[i22 >> 2];
  i22 = i24 + (i23 + 1 << 2) | 0;
  HEAPF32[i22 >> 2] = d1 * +HEAPF32[i22 >> 2];
  i23 = i24 + (i23 + 2 << 2) | 0;
  HEAPF32[i23 >> 2] = d1 * +HEAPF32[i23 >> 2];
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 2);
 STACKTOP = i25;
 return;
}

function _fec_golay2412_decode_symbol(i7) {
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0;
 if (i7 >>> 0 > 16777215) {
  i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i2) {
   i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
   i2 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i2 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i1;
    HEAP32[gb + 8728 + 20 >> 2] = i1;
    i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i3;
    break;
   }
   HEAP32[gb + 8728 >> 2] = i2 | 32;
   _exit(1);
  } else {
   i3 = i2;
   i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } while (0);
  if ((i3 - i1 | 0) >>> 0 < 61) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 12290 | 0, 61) | 0;
   _exit(1);
  }
  do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 12290 | 0, 61) | 0) >>> 0 < 61) _exit(1); else {
   i4 = 0;
   i5 = gb + 12290 + 61 | 0;
   i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   break;
  } else {
   i4 = 61;
   i5 = gb + 12290 | 0;
   i6 = i1;
  } while (0);
  _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
  _exit(1);
 } else {
  i1 = 0;
  i2 = 0;
  while (1) {
   i5 = HEAP32[gb + 420 + (i1 << 2) >> 2] & i7;
   i5 = (HEAPU8[(i5 >>> 8 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i5 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i5 >>> 16 & 255) + (gb + 36235) >> 0] | 0) & 1 | i2 << 1;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == 12) break; else i2 = i5;
  }
  if (((HEAPU8[(i2 >>> 7 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i5 & 255) + (gb + 36235) >> 0] | 0) | 0) >>> 0 < 4) {
   i8 = 0;
   i8 = i8 ^ i7;
   i8 = i8 & 4095;
   return i8 | 0;
  } else i3 = 0;
  while (1) {
   i2 = HEAP32[gb + 276 + (i3 << 2) >> 2] ^ i5;
   i1 = i3 + 1 | 0;
   if (((HEAPU8[(i2 >>> 8 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 36235) >> 0] | 0) | 0) >>> 0 < 3) {
    i8 = 18;
    break;
   }
   if (i1 >>> 0 < 12) i3 = i1; else {
    i1 = 0;
    i2 = 0;
    break;
   }
  }
  if ((i8 | 0) == 18) {
   i8 = i2 << 12 | 1 << 11 - i3;
   i8 = i8 ^ i7;
   i8 = i8 & 4095;
   return i8 | 0;
  }
  while (1) {
   i4 = HEAP32[gb + 276 + (i1 << 2) >> 2] & i5;
   i4 = (HEAPU8[(i4 >>> 8 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i4 >>> 16 & 255) + (gb + 36235) >> 0] | 0) & 1 | i2 << 1;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == 12) break; else i2 = i4;
  }
  if (((HEAPU8[(i2 >>> 7 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36235) >> 0] | 0) | 1 | 0) == 3) {
   i8 = i4;
   i8 = i8 ^ i7;
   i8 = i8 & 4095;
   return i8 | 0;
  } else i3 = 0;
  while (1) {
   i2 = HEAP32[gb + 276 + (i3 << 2) >> 2] ^ i4;
   i1 = i3 + 1 | 0;
   if (((HEAPU8[(i2 >>> 8 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & 255) + (gb + 36235) >> 0] | 0) | 0) >>> 0 < 3) break;
   if (i1 >>> 0 < 12) i3 = i1; else {
    i1 = 0;
    i8 = 24;
    break;
   }
  }
  if ((i8 | 0) == 24) {
   i8 = i1 ^ i7;
   i8 = i8 & 4095;
   return i8 | 0;
  }
  i8 = i2 | 1 << 23 - i3;
  i8 = i8 ^ i7;
  i8 = i8 & 4095;
  return i8 | 0;
 }
 return 0;
}

function _modem_demodulate_arb(i15, i17, i16) {
 i15 = i15 | 0;
 i17 = i17 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, d9 = 0.0, d10 = 0.0, i11 = 0, d12 = 0.0, i13 = 0, i14 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i14 = i15 + 8 | 0;
 i8 = HEAP32[i14 >> 2] | 0;
 if (!i8) i2 = 0; else {
  d9 = +HEAPF32[i17 >> 2];
  d10 = +HEAPF32[i17 + 4 >> 2];
  i11 = HEAP32[i15 + 76 >> 2] | 0;
  d12 = 0.0;
  i13 = 0;
  i2 = 0;
  while (1) {
   d4 = +Math_abs(+(d9 - +HEAPF32[i11 + (i13 << 3) >> 2]));
   i22 = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0);
   d4 = +Math_abs(+(d10 - +HEAPF32[i11 + (i13 << 3) + 4 >> 2]));
   i7 = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0);
   i23 = i22 >>> 0 < i7 >>> 0;
   i5 = i23 ? i7 : i22;
   i7 = i23 ? i22 : i7;
   d4 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
   d3 = (HEAP32[tempDoublePtr >> 2] = i7, +HEAPF32[tempDoublePtr >> 2]);
   do if ((i7 | 0) != 2139095040) {
    if (i5 >>> 0 > 2139095039 | (i7 | 0) == 0 | (i5 - i7 | 0) >>> 0 > 209715199) {
     d3 = d4 + d3;
     break;
    }
    if (i5 >>> 0 <= 1568669695) if (i7 >>> 0 < 562036736) {
     d3 = d3 * 1237940039285380274899124.0e3;
     d4 = d4 * 1237940039285380274899124.0e3;
     d6 = 8.077935669463161e-28;
    } else d6 = 1.0; else {
     d3 = d3 * 8.077935669463161e-28;
     d4 = d4 * 8.077935669463161e-28;
     d6 = 1237940039285380274899124.0e3;
    }
    d3 = d6 * +Math_sqrt(+(d4 * d4 + d3 * d3));
   } while (0);
   i5 = (i13 | 0) == 0 | d3 < d12;
   i2 = i5 ? i13 : i2;
   i13 = i13 + 1 | 0;
   if ((i13 | 0) == (i8 | 0)) break; else d12 = i5 ? d3 : d12;
  }
 }
 HEAP32[i16 >> 2] = i2;
 if ((HEAP32[i14 >> 2] | 0) >>> 0 > i2 >>> 0) {
  i22 = HEAP32[i15 + 76 >> 2] | 0;
  i23 = HEAP32[i22 + (i2 << 3) + 4 >> 2] | 0;
  HEAP32[i15 + 92 >> 2] = HEAP32[i22 + (i2 << 3) >> 2];
  HEAP32[i15 + 96 >> 2] = i23;
  i23 = HEAP32[i17 + 4 >> 2] | 0;
  HEAP32[i15 + 84 >> 2] = HEAP32[i17 >> 2];
  HEAP32[i15 + 88 >> 2] = i23;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i18 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i18;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i18 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i18 - i1 | 0) >>> 0 < 52) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29323 | 0, 52) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29323 | 0, 52) | 0) >>> 0 < 52) _exit(1); else {
  i19 = 0;
  i20 = gb + 29323 + 52 | 0;
  i21 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i19 = 52;
  i20 = gb + 29323 | 0;
  i21 = i1;
 } while (0);
 _memcpy(i21 | 0, i20 | 0, i19 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i19;
 _exit(1);
}

function _ofdmframe_init_S1(i11, i14, i10, i15, i9) {
 i11 = i11 | 0;
 i14 = i14 | 0;
 i10 = i10 | 0;
 i15 = i15 | 0;
 i9 = i9 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i12 = 0, i13 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0;
 i8 = _liquid_nextpow2(i14) | 0;
 i8 = _msequence_create_default(i8 >>> 0 < 4 ? 5 : (i8 >>> 0 > 8 ? 8 : i8) + 1 | 0) | 0;
 if (i14) {
  i6 = HEAP32[i8 + 4 >> 2] | 0;
  i7 = HEAP32[i8 + 12 >> 2] | 0;
  i3 = HEAP32[i8 + 16 >> 2] | 0;
  i5 = 0;
  i12 = 0;
  while (1) {
   i4 = i3 & i6;
   i3 = ((HEAPU8[(i4 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 24) + (gb + 36491) >> 0] | 0) & 1 | i3 << 1) & i7;
   i4 = i3 & i6;
   i3 = ((HEAPU8[(i4 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 24) + (gb + 36491) >> 0] | 0) & 1 | i3 << 1) & i7;
   i4 = i3 & i6;
   i4 = (HEAPU8[(i4 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i4 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
   if (!(HEAP8[i11 + i12 >> 0] | 0)) d2 = 0.0; else {
    d2 = i4 | 0 ? 1.0 : -1.0;
    i5 = i5 + 1 | 0;
   }
   HEAPF32[i10 + (i12 << 3) >> 2] = d2;
   HEAPF32[i10 + (i12 << 3) + 4 >> 2] = 0.0;
   i12 = i12 + 1 | 0;
   if ((i12 | 0) == (i14 | 0)) break; else i3 = (i4 | i3 << 1) & i7;
  }
  _free(i8);
  if (i5 | 0) {
   HEAP32[i9 >> 2] = i5;
   i1 = _fft_create_plan(i14, i10, i15, -1, 0) | 0;
   mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
   _fft_destroy_plan(i1);
   d2 = 1.0 / +Math_sqrt(+(+(i5 >>> 0)));
   i1 = 0;
   do {
    i17 = i15 + (i1 << 3) | 0;
    i18 = i15 + (i1 << 3) + 4 | 0;
    d19 = d2 * +HEAPF32[i18 >> 2];
    HEAPF32[i17 >> 2] = d2 * +HEAPF32[i17 >> 2];
    HEAPF32[i18 >> 2] = d19;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i14 | 0));
   return;
  }
 } else _free(i8);
 i3 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i3) {
  i3 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i3 + 255 | i3;
  i3 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i3 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i13 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i13;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i3 | 32;
  _exit(1);
 } else {
  i13 = i3;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i13 - i1 | 0) >>> 0 < 69) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32566 | 0, 69) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32566 | 0, 69) | 0) >>> 0 < 69) _exit(1); else {
  i16 = 0;
  i17 = gb + 32566 + 69 | 0;
  i18 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i16 = 69;
  i17 = gb + 32566 | 0;
  i18 = i1;
 } while (0);
 _memcpy(i18 | 0, i17 | 0, i16 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i16;
 _exit(1);
}

function _quiet_encoder_set_payload(i7, i4, i5) {
 i7 = i7 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0, i8 = 0;
 i3 = i7 + 136 | 0;
 i6 = i7 + 60 | 0;
 do if (!(HEAP32[i3 >> 2] | 0)) {
  switch (HEAP32[i6 >> 2] | 0) {
  case 0:
   {
    i1 = (HEAP32[i7 + 96 >> 2] | 0) + 124 | 0;
    i2 = 6;
    break;
   }
  case 1:
   {
    i1 = (HEAP32[i7 + 96 >> 2] | 0) + 112 | 0;
    i2 = 6;
    break;
   }
  case 2:
   {
    i1 = (HEAP32[i7 + 96 >> 2] | 0) + 88 | 0;
    i2 = 6;
    break;
   }
  default:
   {}
  }
  if ((i2 | 0) == 6 ? HEAP32[i1 >> 2] | 0 : 0) {
   i1 = 1;
   break;
  }
  i1 = (HEAP32[i7 + 124 >> 2] | 0) != 0;
 } else i1 = 1; while (0);
 i8 = i1 & 1;
 HEAP32[i7 + 132 >> 2] = i4;
 HEAP32[i3 >> 2] = i5;
 HEAP32[i7 + 124 >> 2] = 0;
 HEAP32[i7 + 128 >> 2] = 0;
 HEAP8[i7 + 140 >> 0] = 0;
 i1 = HEAP32[i7 + 104 >> 2] | 0;
 i2 = HEAP32[i1 + 28 >> 2] | 0;
 if (i2 | 0) {
  i5 = HEAP32[(HEAP32[i2 + 16 >> 2] | 0) + 16 >> 2] | 0;
  HEAP32[i5 + 24 >> 2] = 0;
  _memset(HEAP32[i5 >> 2] | 0, 0, HEAP32[i5 + 20 >> 2] << 3 | 0) | 0;
 }
 i1 = HEAP32[i1 + 32 >> 2] | 0;
 do if (i1 | 0) if ((HEAP32[i1 + 24 >> 2] | 0) == 1) {
  i5 = i1 + 32 | 0;
  if (!(HEAP32[i5 >> 2] | 0)) break;
  i1 = i1 + 28 | 0;
  i2 = 0;
  do {
   i3 = (HEAP32[(HEAP32[i1 >> 2] | 0) + (i2 << 2) >> 2] | 0) + 24 | 0;
   i4 = i3 + 72 | 0;
   do {
    HEAP32[i3 >> 2] = 0;
    i3 = i3 + 4 | 0;
   } while ((i3 | 0) < (i4 | 0));
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
 } else {
  i3 = i1 + 12 | 0;
  if (!(HEAP32[i3 >> 2] | 0)) break;
  i1 = i1 + 8 | 0;
  i2 = 0;
  do {
   i5 = HEAP32[i1 >> 2] | 0;
   HEAPF32[i5 + (i2 << 3) >> 2] = 0.0;
   HEAPF32[i5 + (i2 << 3) + 4 >> 2] = 0.0;
   i2 = i2 + 1 | 0;
  } while (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
 } while (0);
 switch (HEAP32[i6 >> 2] | 0) {
 case 0:
  {
   i1 = HEAP32[i7 + 96 >> 2] | 0;
   i3 = i1 + 116 | 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i3 + 4 >> 2] = 0;
   HEAP32[i3 + 8 >> 2] = 0;
   HEAP32[i3 + 12 >> 2] = 0;
   HEAP32[i3 + 16 >> 2] = 0;
   HEAP32[i3 + 20 >> 2] = 0;
   i1 = HEAP32[i1 + 40 >> 2] | 0;
   i3 = HEAP32[i1 + 76 >> 2] | 0;
   HEAP32[i3 + 16 >> 2] = HEAP32[i3 + 8 >> 2];
   i3 = i1 + 12 | 0;
   if (!(HEAP32[i3 >> 2] | 0)) return i8 | 0;
   i1 = i1 + 20 | 0;
   i2 = 0;
   do {
    i7 = HEAP32[i1 >> 2] | 0;
    HEAPF32[i7 + (i2 << 3) >> 2] = 0.0;
    HEAPF32[i7 + (i2 << 3) + 4 >> 2] = 0.0;
    i2 = i2 + 1 | 0;
   } while (i2 >>> 0 < (HEAP32[i3 >> 2] | 0) >>> 0);
   return i8 | 0;
  }
 case 1:
  {
   i6 = (HEAP32[i7 + 96 >> 2] | 0) + 104 | 0;
   HEAP32[i6 >> 2] = 0;
   HEAP32[i6 + 4 >> 2] = 0;
   HEAP32[i6 + 8 >> 2] = 0;
   HEAP32[i6 + 12 >> 2] = 0;
   HEAP32[i6 + 16 >> 2] = 0;
   HEAP32[i7 + 100 >> 2] = 0;
   return i8 | 0;
  }
 case 2:
  {
   i7 = HEAP32[i7 + 96 >> 2] | 0;
   i6 = HEAP32[i7 >> 2] | 0;
   HEAPF32[i6 + 24 >> 2] = 0.0;
   i6 = HEAP32[(HEAP32[(HEAP32[i6 + 20 >> 2] | 0) + 16 >> 2] | 0) + 16 >> 2] | 0;
   HEAP32[i6 + 24 >> 2] = 0;
   _memset(HEAP32[i6 >> 2] | 0, 0, HEAP32[i6 + 20 >> 2] << 2 | 0) | 0;
   i6 = HEAP32[i7 + 32 >> 2] | 0;
   HEAP32[i6 + 16 >> 2] = HEAP32[i6 + 8 >> 2];
   SIMD_Int32x4_store(HEAPU8, i7 + 84 | 0, SIMD_Int32x4_splat(0));
   return i8 | 0;
  }
 default:
  return i8 | 0;
 }
 return 0;
}

function _fec_hamming128_decode_soft(i1, i34, i36, i35) {
 i1 = i1 | 0;
 i34 = i34 | 0;
 i36 = i36 | 0;
 i35 = i35 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i37 = 0;
 i32 = i34 & 1;
 i33 = ((i34 * 3 | 0) >>> 1) + i32 | 0;
 if (!i34) i1 = 0; else {
  i28 = 0;
  i30 = 0;
  while (1) {
   i17 = i36 + i30 | 0;
   i19 = i17 + 1 | 0;
   i21 = i17 + 2 | 0;
   i23 = i17 + 3 | 0;
   i25 = i17 + 4 | 0;
   i1 = i17 + 5 | 0;
   i3 = i17 + 6 | 0;
   i5 = i17 + 7 | 0;
   i7 = i17 + 8 | 0;
   i9 = i17 + 9 | 0;
   i11 = i17 + 10 | 0;
   i13 = i17 + 11 | 0;
   i31 = _fec_hamming128_decode_symbol(((HEAP8[i19 >> 0] | 0) < 0 ? 1024 : 0) | ((HEAP8[i17 >> 0] | 0) < 0 ? 2048 : 0) | ((HEAP8[i21 >> 0] | 0) < 0 ? 512 : 0) | ((HEAP8[i23 >> 0] | 0) < 0 ? 256 : 0) | ((HEAP8[i25 >> 0] | 0) < 0 ? 128 : 0) | ((HEAP8[i1 >> 0] | 0) < 0 ? 64 : 0) | ((HEAP8[i3 >> 0] | 0) < 0 ? 32 : 0) | ((HEAP8[i5 >> 0] | 0) < 0 ? 16 : 0) | ((HEAP8[i7 >> 0] | 0) < 0 ? 8 : 0) | ((HEAP8[i9 >> 0] | 0) < 0 ? 4 : 0) | ((HEAP8[i11 >> 0] | 0) < 0 ? 2 : 0) | (HEAPU8[i13 >> 0] | 0) >>> 7 & 255) | 0;
   i27 = HEAPU16[gb + 9100 + (i31 << 1) >> 1] | 0;
   i17 = HEAPU8[i17 >> 0] | 0;
   i18 = i17 ^ 255;
   i19 = HEAPU8[i19 >> 0] | 0;
   i20 = i19 ^ 255;
   i21 = HEAPU8[i21 >> 0] | 0;
   i22 = i21 ^ 255;
   i23 = HEAPU8[i23 >> 0] | 0;
   i24 = i23 ^ 255;
   i25 = HEAPU8[i25 >> 0] | 0;
   i26 = i25 ^ 255;
   i1 = HEAPU8[i1 >> 0] | 0;
   i2 = i1 ^ 255;
   i3 = HEAPU8[i3 >> 0] | 0;
   i4 = i3 ^ 255;
   i5 = HEAPU8[i5 >> 0] | 0;
   i6 = i5 ^ 255;
   i7 = HEAPU8[i7 >> 0] | 0;
   i8 = i7 ^ 255;
   i9 = HEAPU8[i9 >> 0] | 0;
   i10 = i9 ^ 255;
   i11 = HEAPU8[i11 >> 0] | 0;
   i12 = i11 ^ 255;
   i13 = HEAPU8[i13 >> 0] | 0;
   i14 = i13 ^ 255;
   i27 = (i27 & 1024 | 0 ? i20 : i19) + (i27 & 2048 | 0 ? i18 : i17) + (i27 & 512 | 0 ? i22 : i21) + (i27 & 256 | 0 ? i24 : i23) + (i27 & 128 | 0 ? i26 : i25) + (i27 & 64 | 0 ? i2 : i1) + (i27 & 32 | 0 ? i4 : i3) + (i27 & 16 | 0 ? i6 : i5) + (i27 & 8 | 0 ? i8 : i7) + (i27 & 4 | 0 ? i10 : i9) + (i27 & 2 | 0 ? i12 : i11) + (i27 & 1 | 0 ? i14 : i13) | 0;
   i29 = 0;
   while (1) {
    i37 = HEAPU8[gb + 13255 + (i31 * 17 | 0) + i29 >> 0] | 0;
    i15 = HEAPU16[gb + 9100 + (i37 << 1) >> 1] | 0;
    i15 = (i15 & 1024 | 0 ? i20 : i19) + (i15 & 2048 | 0 ? i18 : i17) + (i15 & 512 | 0 ? i22 : i21) + (i15 & 256 | 0 ? i24 : i23) + (i15 & 128 | 0 ? i26 : i25) + (i15 & 64 | 0 ? i2 : i1) + (i15 & 32 | 0 ? i4 : i3) + (i15 & 16 | 0 ? i6 : i5) + (i15 & 8 | 0 ? i8 : i7) + (i15 & 4 | 0 ? i10 : i9) + (i15 & 2 | 0 ? i12 : i11) + (i15 & 1 | 0 ? i14 : i13) | 0;
    i16 = i15 >>> 0 < i27 >>> 0;
    i31 = i16 ? i37 : i31;
    i29 = i29 + 1 | 0;
    if ((i29 | 0) == 17) break; else i27 = i16 ? i15 : i27;
   }
   HEAP8[i35 + i28 >> 0] = i31;
   i28 = i28 + 1 | 0;
   if ((i28 | 0) == (i34 | 0)) break; else i30 = i30 + 12 | 0;
  }
  i1 = i34 * 12 | 0;
 }
 if ((i1 + (i32 << 2) | 0) == (i33 << 3 | 0)) return; else ___assert_fail(gb + 13209 | 0, gb + 13136 | 0, 326, gb + 13228 | 0);
}

function _modem_create_psk(i11) {
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i12 = 0;
 i12 = _malloc(252) | 0;
 switch (i11 | 0) {
 case 1:
  {
   HEAP32[i12 >> 2] = 1;
   break;
  }
 case 2:
  {
   HEAP32[i12 >> 2] = 2;
   break;
  }
 case 3:
  {
   HEAP32[i12 >> 2] = 3;
   break;
  }
 case 4:
  {
   HEAP32[i12 >> 2] = 4;
   break;
  }
 case 5:
  {
   HEAP32[i12 >> 2] = 5;
   break;
  }
 case 6:
  {
   HEAP32[i12 >> 2] = 6;
   break;
  }
 case 7:
  {
   HEAP32[i12 >> 2] = 7;
   break;
  }
 case 8:
  {
   HEAP32[i12 >> 2] = 8;
   break;
  }
 default:
  {
   i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i2) {
    i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
    i2 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i2 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i1;
     HEAP32[gb + 8728 + 20 >> 2] = i1;
     i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i3;
     break;
    }
    HEAP32[gb + 8728 >> 2] = i2 | 32;
    _exit(1);
   } else {
    i3 = i2;
    i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } while (0);
   if ((i3 - i1 | 0) >>> 0 < 57) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28340 | 0, 57) | 0;
    _exit(1);
   }
   do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28340 | 0, 57) | 0) >>> 0 < 57) _exit(1); else {
    i4 = 0;
    i5 = gb + 28340 + 57 | 0;
    i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
    break;
   } else {
    i4 = 57;
    i5 = gb + 28340 | 0;
    i6 = i1;
   } while (0);
   _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
   _exit(1);
  }
 }
 i4 = i12 + 76 | 0;
 HEAP32[i4 >> 2] = 0;
 i5 = i12 + 80 | 0;
 HEAP32[i5 >> 2] = 0;
 i6 = i12 + 4 | 0;
 HEAP32[i6 >> 2] = i11;
 i1 = 1 << i11;
 i2 = i12 + 8 | 0;
 HEAP32[i2 >> 2] = i1;
 i8 = i12 + 236 | 0;
 HEAP32[i8 >> 2] = 0;
 HEAP32[i8 + 4 >> 2] = 0;
 HEAP32[i8 + 8 >> 2] = 0;
 HEAP32[i8 + 12 >> 2] = 0;
 d7 = 3.141592653589793 / +(i1 >>> 0);
 i9 = i12 + 100 | 0;
 i10 = i12 + 104 | 0;
 HEAPF32[i10 >> 2] = d7;
 i3 = i12 + 12 | 0;
 HEAPF32[i3 >> 2] = d7;
 if (i11 >>> 0 > 1 ? (HEAPF32[i12 + 16 >> 2] = d7 * 2.0, i11 >>> 0 > 2) : 0) {
  i1 = 2;
  while (1) {
   HEAPF32[i3 + (i1 << 2) >> 2] = d7 * +(1 << i1 | 0);
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= (HEAP32[i6 >> 2] | 0) >>> 0) break;
   d7 = +HEAPF32[i10 >> 2];
  }
  i1 = HEAP32[i2 >> 2] | 0;
 }
 HEAPF32[i9 >> 2] = (1.0 - 1.0 / +(i1 >>> 0)) * 3.141592653589793;
 HEAP32[i8 >> 2] = fb + 17;
 HEAP32[i12 + 240 >> 2] = fb + 18;
 HEAP32[i4 >> 2] = _malloc(i1 << 3) | 0;
 _modem_init_map(i12);
 HEAP32[i5 >> 2] = 1;
 if ((HEAP32[i6 >> 2] | 0) >>> 0 > 2) _modem_demodsoft_gentab(i12, 2);
 HEAPF32[i12 + 84 >> 2] = 1.0;
 HEAPF32[i12 + 88 >> 2] = 0.0;
 HEAP32[i12 + 92 >> 2] = 1065353216;
 HEAPF32[i12 + 96 >> 2] = 0.0;
 if (((HEAP32[i12 >> 2] | 0) + -9 | 0) >>> 0 >= 8) return i12 | 0;
 HEAPF32[i10 >> 2] = 0.0;
 return i12 | 0;
}

function _fft_execute_rader2(i18) {
 i18 = i18 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i11 = i19;
 i16 = HEAP32[i18 + 52 >> 2] | 0;
 i12 = HEAP32[i18 + 56 >> 2] | 0;
 i13 = HEAP32[i18 + 48 >> 2] | 0;
 i17 = HEAP32[i18 + 44 >> 2] | 0;
 i14 = HEAP32[i18 + 40 >> 2] | 0;
 i6 = HEAP32[i17 + ((HEAP32[i18 >> 2] | 0) + -2 << 2) >> 2] | 0;
 i15 = i18 + 4 | 0;
 i4 = HEAP32[i15 >> 2] | 0;
 i2 = HEAP32[i4 + (i6 << 3) + 4 >> 2] | 0;
 HEAP32[i16 >> 2] = HEAP32[i4 + (i6 << 3) >> 2];
 HEAP32[i16 + 4 >> 2] = i2;
 i2 = HEAP32[i18 >> 2] | 0;
 i6 = i14 + 1 | 0;
 if ((i6 | 0) != (i2 | 0)) {
  i3 = 0;
  do {
   i3 = i3 + 1 | 0;
   HEAPF32[i16 + (i3 << 3) >> 2] = 0.0;
   HEAPF32[i16 + (i3 << 3) + 4 >> 2] = 0.0;
   i2 = HEAP32[i18 >> 2] | 0;
  } while (i3 >>> 0 < (i6 - i2 | 0) >>> 0);
 }
 i3 = i2 + -1 | 0;
 if (i3 >>> 0 > 1) {
  i4 = 1;
  do {
   i22 = HEAP32[i17 + (i3 + ~i4 << 2) >> 2] | 0;
   i23 = HEAP32[i15 >> 2] | 0;
   i21 = HEAP32[i23 + (i22 << 3) + 4 >> 2] | 0;
   i20 = i6 - i2 + i4 | 0;
   HEAP32[i16 + (i20 << 3) >> 2] = HEAP32[i23 + (i22 << 3) >> 2];
   HEAP32[i16 + (i20 << 3) + 4 >> 2] = i21;
   i4 = i4 + 1 | 0;
   i2 = HEAP32[i18 >> 2] | 0;
   i3 = i2 + -1 | 0;
  } while (i3 >>> 0 > i4 >>> 0);
 }
 i23 = HEAP32[i18 + 60 >> 2] | 0;
 mftCall_vi(HEAP32[i23 + 28 >> 2] | 0, i23 | 0);
 if (i14 | 0) {
  i2 = i11 + 4 | 0;
  i6 = 0;
  do {
   d7 = +HEAPF32[i13 + (i6 << 3) >> 2];
   d8 = +HEAPF32[i13 + (i6 << 3) + 4 >> 2];
   i3 = i12 + (i6 << 3) | 0;
   d9 = +HEAPF32[i3 >> 2];
   i4 = i12 + (i6 << 3) + 4 | 0;
   d10 = +HEAPF32[i4 >> 2];
   d5 = d7 * d9 - d8 * d10;
   d1 = d8 * d9 + d7 * d10;
   if ((d5 != d5 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
    ___mulsc3(i11, d9, d10, d7, d8);
    d5 = +HEAPF32[i11 >> 2];
    d1 = +HEAPF32[i2 >> 2];
   }
   HEAPF32[i3 >> 2] = d5;
   HEAPF32[i4 >> 2] = d1;
   i6 = i6 + 1 | 0;
  } while ((i6 | 0) != (i14 | 0));
 }
 i4 = HEAP32[i18 + 64 >> 2] | 0;
 mftCall_vi(HEAP32[i4 + 28 >> 2] | 0, i4 | 0);
 i4 = i18 + 8 | 0;
 i23 = HEAP32[i4 >> 2] | 0;
 HEAPF32[i23 >> 2] = 0.0;
 HEAPF32[i23 + 4 >> 2] = 0.0;
 if (HEAP32[i18 >> 2] | 0) {
  i3 = 0;
  do {
   i22 = HEAP32[i15 >> 2] | 0;
   i23 = HEAP32[i4 >> 2] | 0;
   i2 = i23 + 4 | 0;
   d10 = +HEAPF32[i22 + (i3 << 3) + 4 >> 2] + +HEAPF32[i2 >> 2];
   HEAPF32[i23 >> 2] = +HEAPF32[i22 + (i3 << 3) >> 2] + +HEAPF32[i23 >> 2];
   HEAPF32[i2 >> 2] = d10;
   i3 = i3 + 1 | 0;
   i2 = HEAP32[i18 >> 2] | 0;
  } while (i3 >>> 0 < i2 >>> 0);
  if ((i2 | 0) == 1) {
   STACKTOP = i19;
   return;
  }
 }
 d1 = +(i14 >>> 0);
 i2 = 0;
 do {
  i23 = HEAP32[i17 + (i2 << 2) >> 2] | 0;
  i21 = HEAP32[i15 >> 2] | 0;
  d10 = +HEAPF32[i16 + (i2 << 3) + 4 >> 2] / d1 + +HEAPF32[i21 + 4 >> 2];
  i22 = HEAP32[i4 >> 2] | 0;
  HEAPF32[i22 + (i23 << 3) >> 2] = +HEAPF32[i16 + (i2 << 3) >> 2] / d1 + +HEAPF32[i21 >> 2];
  HEAPF32[i22 + (i23 << 3) + 4 >> 2] = d10;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < ((HEAP32[i18 >> 2] | 0) + -1 | 0) >>> 0);
 STACKTOP = i19;
 return;
}

function ___mulsc3(i14, d1, d2, d3, d4) {
 i14 = i14 | 0;
 d1 = +d1;
 d2 = +d2;
 d3 = +d3;
 d4 = +d4;
 var i5 = 0, i6 = 0, i7 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0;
 d8 = d1 * d3;
 d9 = d2 * d4;
 d10 = d1 * d4;
 d11 = d2 * d3;
 d12 = d8 - d9;
 d13 = d11 + d10;
 if (!((d12 != d12 | 0.0 != 0.0) & (d13 != d13 | 0.0 != 0.0))) {
  i7 = i14 + 4 | 0;
  HEAPF32[i14 >> 2] = d12;
  HEAPF32[i7 >> 2] = d13;
  return;
 }
 i5 = +Math_abs(+d1) == inf;
 i6 = +Math_abs(+d2) == inf;
 if (i5 | i6) {
  HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0;
  d1 = +Math_abs(+(+(i5 & 1)));
  d1 = (HEAPF32[tempDoublePtr >> 2] = d1, +HEAPF32[tempDoublePtr >> 2]);
  HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0;
  d2 = +Math_abs(+(+(i6 & 1)));
  d2 = (HEAPF32[tempDoublePtr >> 2] = d2, +HEAPF32[tempDoublePtr >> 2]);
  if (d3 != d3 | 0.0 != 0.0) d3 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
  if (d4 != d4 | 0.0 != 0.0) {
   d4 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
   i6 = 1;
  } else i6 = 1;
 } else i6 = 0;
 i5 = +Math_abs(+d3) == inf;
 i7 = +Math_abs(+d4) == inf;
 if (i7 | i5) {
  HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0;
  d3 = +Math_abs(+(+(i5 & 1)));
  d3 = (HEAPF32[tempDoublePtr >> 2] = d3, +HEAPF32[tempDoublePtr >> 2]);
  HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0;
  d4 = +Math_abs(+(+(i7 & 1)));
  d4 = (HEAPF32[tempDoublePtr >> 2] = d4, +HEAPF32[tempDoublePtr >> 2]);
  if (d1 != d1 | 0.0 != 0.0) d1 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
  if (d2 != d2 | 0.0 != 0.0) d2 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
 } else if (!i6) {
  i7 = +Math_abs(+d8) == inf;
  i7 = i7 | +Math_abs(+d9) == inf;
  i7 = +Math_abs(+d10) == inf | i7;
  if (!(+Math_abs(+d11) == inf | i7)) {
   i7 = i14 + 4 | 0;
   HEAPF32[i14 >> 2] = d12;
   HEAPF32[i7 >> 2] = d13;
   return;
  }
  if (d1 != d1 | 0.0 != 0.0) d1 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
  if (d2 != d2 | 0.0 != 0.0) d2 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
  if (d3 != d3 | 0.0 != 0.0) d3 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
  if (d4 != d4 | 0.0 != 0.0) d4 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0) & -2147483648, +HEAPF32[tempDoublePtr >> 2]);
 }
 d12 = (d3 * d1 - d4 * d2) * inf;
 d13 = (d3 * d2 + d4 * d1) * inf;
 i7 = i14 + 4 | 0;
 HEAPF32[i14 >> 2] = d12;
 HEAPF32[i7 >> 2] = d13;
 return;
}

function _gmskframesync_execute_rxpreamble(i13, d7, d8) {
 i13 = i13 | 0;
 d7 = +d7;
 d8 = +d8;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i14 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i10 = i14;
 i11 = i13 + 220 | 0;
 i12 = i13 + 132 | 0;
 if ((HEAP32[i11 >> 2] | 0) != (HEAP32[i12 >> 2] | 0)) {
  i1 = i13 + 128 | 0;
  i3 = HEAP32[i1 >> 2] | 0;
  mftCall_vi(HEAP32[i3 + 1048 >> 2] | 0, i3 | 0);
  d5 = +HEAPF32[i3 + 1040 >> 2];
  d4 = +HEAPF32[i3 + 1044 >> 2] - d5 * 0.0;
  d5 = -d5;
  d6 = d4 * d7 - d8 * d5;
  d9 = d7 * d5 + d4 * d8;
  if ((d6 != d6 | 0.0 != 0.0) & (d9 != d9 | 0.0 != 0.0)) {
   ___mulsc3(i10, d7, d8, d4, d5);
   d6 = +HEAPF32[i10 >> 2];
   d9 = +HEAPF32[i10 + 4 >> 2];
  }
  i3 = HEAP32[i1 >> 2] | 0;
  i1 = i3 + 4 | 0;
  d4 = +HEAPF32[i3 + 8 >> 2] + +HEAPF32[i1 >> 2];
  HEAPF32[i1 >> 2] = d4;
  if (!(d4 > 3.141592653589793)) {
   if (d4 < -3.141592653589793) HEAPF32[i1 >> 2] = d4 + 6.283185307179586;
  } else HEAPF32[i1 >> 2] = d4 + -6.283185307179586;
  i2 = i13 + 64 | 0;
  d7 = +HEAPF32[i2 >> 2];
  i3 = i13 + 68 | 0;
  d8 = -+HEAPF32[i3 >> 2];
  d4 = d6 * d7 - d9 * d8;
  d5 = d9 * d7 + d6 * d8;
  if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
   ___mulsc3(i10, d7, d8, d6, d9);
   d5 = +HEAPF32[i10 + 4 >> 2];
   d4 = +HEAPF32[i10 >> 2];
  }
  d8 = +Math_atan2(+d5, +d4);
  i1 = i13 + 4 | 0;
  d8 = d8 * +((HEAP32[i1 >> 2] | 0) >>> 0);
  HEAPF32[i13 + 72 >> 2] = d8;
  HEAPF32[i2 >> 2] = d6;
  HEAPF32[i3 >> 2] = d9;
  HEAPF32[i10 >> 2] = 0.0;
  if (_gmskframesync_update_symsync(i13, d8, i10) | 0 ? (i3 = HEAP32[i11 >> 2] | 0, HEAPF32[(HEAP32[i13 + 140 >> 2] | 0) + (i3 << 2) >> 2] = +HEAPF32[i10 >> 2] / +((HEAP32[i1 >> 2] | 0) >>> 0), i10 = i3 + 1 | 0, HEAP32[i11 >> 2] = i10, (i10 | 0) == (HEAP32[i12 >> 2] | 0)) : 0) HEAP32[i13 + 216 >> 2] = 2;
  STACKTOP = i14;
  return;
 }
 i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i1) {
  i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
  i1 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i2;
   HEAP32[gb + 8728 + 20 >> 2] = i2;
   i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i1;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i1 | 32;
  STACKTOP = i14;
  return;
 } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
 if ((i1 - i2 | 0) >>> 0 < 64) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25080 | 0, 64) | 0;
  STACKTOP = i14;
  return;
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 25080 | 0, 64) | 0) >>> 0 < 64) {
  STACKTOP = i14;
  return;
 } else {
  i1 = 0;
  i3 = gb + 25080 + 64 | 0;
  i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i1 = 64;
  i3 = gb + 25080 | 0;
 } while (0);
 _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
 STACKTOP = i14;
 return;
}

function _iirfilt_crcf_execute(i8, d4, d2, i9) {
 i8 = i8 | 0;
 d4 = +d4;
 d2 = +d2;
 i9 = i9 | 0;
 var i1 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, d14 = 0.0, d15 = 0.0, d16 = 0.0, d17 = 0.0, d18 = 0.0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 if (HEAP32[i8 + 24 >> 2] | 0) {
  i5 = i8 + 32 | 0;
  if (!(HEAP32[i5 >> 2] | 0)) {
   i3 = 0;
   i1 = 0;
  } else {
   i1 = i8 + 28 | 0;
   i3 = 0;
   do {
    i8 = HEAP32[(HEAP32[i1 >> 2] | 0) + (i3 << 2) >> 2] | 0;
    i23 = i8 + 80 | 0;
    i20 = HEAP32[i23 >> 2] | 0;
    i22 = i8 + 84 | 0;
    i19 = HEAP32[i22 >> 2] | 0;
    HEAP32[i8 + 88 >> 2] = i20;
    HEAP32[i8 + 92 >> 2] = i19;
    i6 = i8 + 72 | 0;
    i21 = HEAP32[i6 >> 2] | 0;
    i7 = i8 + 76 | 0;
    d13 = +HEAPF32[i7 >> 2];
    HEAP32[i23 >> 2] = i21;
    HEAPF32[i22 >> 2] = d13;
    d14 = +HEAPF32[i8 + 16 >> 2];
    d17 = (HEAP32[tempDoublePtr >> 2] = i21, +HEAPF32[tempDoublePtr >> 2]);
    d15 = +HEAPF32[i8 + 20 >> 2];
    d16 = (HEAP32[tempDoublePtr >> 2] = i20, +HEAPF32[tempDoublePtr >> 2]);
    d11 = (HEAP32[tempDoublePtr >> 2] = i19, +HEAPF32[tempDoublePtr >> 2]);
    d18 = d4 - d17 * d14 - d16 * d15;
    d15 = d2 - d13 * d14 - d11 * d15;
    HEAPF32[i6 >> 2] = d18;
    HEAPF32[i7 >> 2] = d15;
    d14 = +HEAPF32[i8 >> 2];
    d12 = +HEAPF32[i8 + 4 >> 2];
    d10 = +HEAPF32[i8 + 8 >> 2];
    d4 = d18 * d14 + d17 * d12 + d16 * d10;
    d2 = d15 * d14 + d13 * d12 + d11 * d10;
    i3 = i3 + 1 | 0;
   } while (i3 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
   i3 = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0);
   i1 = (HEAPF32[tempDoublePtr >> 2] = d2, HEAP32[tempDoublePtr >> 2] | 0);
  }
  HEAP32[i9 >> 2] = i3;
  HEAP32[i9 + 4 >> 2] = i1;
  return;
 }
 i1 = HEAP32[i8 + 12 >> 2] | 0;
 i3 = i1 + -1 | 0;
 if (i3 | 0) {
  i5 = i8 + 8 | 0;
  while (1) {
   i22 = i1 + -2 | 0;
   i1 = HEAP32[i5 >> 2] | 0;
   i23 = HEAP32[i1 + (i22 << 3) + 4 >> 2] | 0;
   HEAP32[i1 + (i3 << 3) >> 2] = HEAP32[i1 + (i22 << 3) >> 2];
   HEAP32[i1 + (i3 << 3) + 4 >> 2] = i23;
   i1 = i3 + -1 | 0;
   if (!i1) break; else {
    i23 = i3;
    i3 = i1;
    i1 = i23;
   }
  }
 }
 i5 = HEAP32[i8 + 20 >> 2] | 0;
 if (i5 >>> 0 > 1) {
  i6 = HEAP32[i8 + 4 >> 2] | 0;
  i3 = i8 + 8 | 0;
  i1 = HEAP32[i3 >> 2] | 0;
  i7 = 1;
  do {
   d18 = +HEAPF32[i6 + (i7 << 2) >> 2];
   d4 = d4 - d18 * +HEAPF32[i1 + (i7 << 3) >> 2];
   d2 = d2 - d18 * +HEAPF32[i1 + (i7 << 3) + 4 >> 2];
   i7 = i7 + 1 | 0;
  } while ((i7 | 0) != (i5 | 0));
 } else {
  i1 = i8 + 8 | 0;
  i3 = i1;
  i1 = HEAP32[i1 >> 2] | 0;
 }
 HEAPF32[i1 >> 2] = d4;
 HEAPF32[i1 + 4 >> 2] = d2;
 i6 = HEAP32[i8 + 16 >> 2] | 0;
 if (!i6) {
  d4 = 0.0;
  d2 = 0.0;
 } else {
  i5 = HEAP32[i8 >> 2] | 0;
  i1 = HEAP32[i3 >> 2] | 0;
  i3 = 0;
  d4 = 0.0;
  d2 = 0.0;
  do {
   d18 = +HEAPF32[i5 + (i3 << 2) >> 2];
   d4 = d4 + d18 * +HEAPF32[i1 + (i3 << 3) >> 2];
   d2 = d2 + d18 * +HEAPF32[i1 + (i3 << 3) + 4 >> 2];
   i3 = i3 + 1 | 0;
  } while ((i3 | 0) != (i6 | 0));
 }
 HEAPF32[i9 >> 2] = d4;
 HEAPF32[i9 + 4 >> 2] = d2;
 return;
}

function _modem_create_apsk(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i18;
 switch (i2 | 0) {
 case 2:
  {
   i17 = gb + 1488 | 0;
   break;
  }
 case 3:
  {
   i17 = gb + 1536 | 0;
   break;
  }
 case 4:
  {
   i17 = gb + 1584 | 0;
   break;
  }
 case 5:
  {
   i17 = gb + 1644 | 0;
   break;
  }
 case 6:
  {
   i17 = gb + 1716 | 0;
   break;
  }
 case 7:
  {
   i17 = gb + 1800 | 0;
   break;
  }
 case 8:
  {
   i17 = gb + 1908 | 0;
   break;
  }
 default:
  {
   HEAP32[i1 >> 2] = i2;
   _fprintf(gb + 8728 | 0, gb + 29044 | 0, i1);
   _exit(1);
  }
 }
 i12 = _malloc(252) | 0;
 HEAP32[i12 >> 2] = HEAP32[i17 >> 2];
 i13 = i12 + 76 | 0;
 HEAP32[i13 >> 2] = 0;
 i14 = i12 + 80 | 0;
 HEAP32[i14 >> 2] = 0;
 i15 = i12 + 4 | 0;
 HEAP32[i15 >> 2] = i2;
 i16 = i12 + 8 | 0;
 HEAP32[i16 >> 2] = 1 << i2;
 i11 = i12 + 236 | 0;
 HEAP32[i11 >> 2] = 0;
 HEAP32[i11 + 4 >> 2] = 0;
 HEAP32[i11 + 8 >> 2] = 0;
 HEAP32[i11 + 12 >> 2] = 0;
 i8 = HEAP32[i17 + 4 >> 2] | 0;
 i10 = i12 + 100 | 0;
 HEAP32[i10 >> 2] = i8;
 if (i8) {
  i1 = HEAP32[i17 + 8 >> 2] | 0;
  i2 = i12 + 104 | 0;
  i3 = HEAP32[i17 + 12 >> 2] | 0;
  i4 = i12 + 136 | 0;
  i5 = HEAP32[i17 + 16 >> 2] | 0;
  i6 = i12 + 200 | 0;
  i8 = 0;
  do {
   HEAP32[i2 + (i8 << 2) >> 2] = HEAP32[i1 + (i8 << 2) >> 2];
   HEAP32[i4 + (i8 << 2) >> 2] = HEAP32[i3 + (i8 << 2) >> 2];
   HEAP32[i6 + (i8 << 2) >> 2] = HEAP32[i5 + (i8 << 2) >> 2];
   i8 = i8 + 1 | 0;
   i7 = HEAP32[i10 >> 2] | 0;
  } while (i8 >>> 0 < i7 >>> 0);
  if ((i7 | 0) != 1) i9 = 12;
 } else i9 = 12;
 if ((i9 | 0) == 12) {
  i1 = HEAP32[i17 + 20 >> 2] | 0;
  i2 = i12 + 168 | 0;
  i3 = 0;
  do {
   HEAP32[i2 + (i3 << 2) >> 2] = HEAP32[i1 + (i3 << 2) >> 2];
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < ((HEAP32[i10 >> 2] | 0) + -1 | 0) >>> 0);
 }
 i10 = HEAP32[i16 >> 2] | 0;
 i9 = _malloc(i10) | 0;
 HEAP32[i12 + 232 >> 2] = i9;
 _memmove(i9 | 0, HEAP32[i17 + 24 >> 2] | 0, i10 | 0) | 0;
 HEAP32[i11 >> 2] = fb + 21;
 HEAP32[i12 + 240 >> 2] = fb + 22;
 switch (HEAP32[i15 >> 2] | 0) {
 case 2:
  {
   _modem_demodsoft_gentab(i12, 3);
   break;
  }
 case 3:
  {
   _modem_demodsoft_gentab(i12, 3);
   break;
  }
 case 4:
  {
   _modem_demodsoft_gentab(i12, 4);
   break;
  }
 case 5:
  {
   _modem_demodsoft_gentab(i12, 4);
   break;
  }
 case 6:
  {
   _modem_demodsoft_gentab(i12, 4);
   break;
  }
 case 7:
  {
   _modem_demodsoft_gentab(i12, 5);
   break;
  }
 case 8:
  {
   _modem_demodsoft_gentab(i12, 5);
   break;
  }
 default:
  {}
 }
 HEAP32[i13 >> 2] = _malloc(HEAP32[i16 >> 2] << 3) | 0;
 _modem_init_map(i12);
 HEAP32[i14 >> 2] = 1;
 HEAPF32[i12 + 84 >> 2] = 1.0;
 HEAPF32[i12 + 88 >> 2] = 0.0;
 HEAP32[i12 + 92 >> 2] = 1065353216;
 HEAPF32[i12 + 96 >> 2] = 0.0;
 if (((HEAP32[i12 >> 2] | 0) + -9 | 0) >>> 0 >= 8) {
  STACKTOP = i18;
  return i12 | 0;
 }
 HEAPF32[i12 + 104 >> 2] = 0.0;
 STACKTOP = i18;
 return i12 | 0;
}

function _quiet_decoder_flush(i9) {
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i12 + 4 | 0;
 i5 = i12;
 if (!i9) {
  i11 = 0;
  STACKTOP = i12;
  return i11 | 0;
 }
 i2 = HEAP32[i9 + 96 >> 2] | 0;
 if (!i2) {
  i1 = i9 + 104 | 0;
  i6 = i9 + 64 | 0;
  i4 = 0;
 } else {
  i3 = HEAP32[i9 + 36 >> 2] | 0;
  if (i3) {
   i1 = i3 << 2;
   if (i3 >>> 0 > 65535) i1 = ((i1 >>> 0) / (i3 >>> 0) | 0 | 0) == 4 ? i1 : -1;
  } else i1 = 0;
  i8 = _malloc(i1) | 0;
  if (i8 | 0 ? HEAP32[i8 + -4 >> 2] & 3 | 0 : 0) _memset(i8 | 0, 0, i1 | 0) | 0;
  i6 = i9 + 64 | 0;
  i14 = Math_imul(HEAP32[HEAP32[i6 >> 2] >> 2] | 0, HEAP32[i9 + 84 >> 2] | 0) | 0;
  i7 = i9 + 100 | 0;
  i1 = i9 + 104 | 0;
  i13 = HEAP32[i1 >> 2] | 0;
  _resamp_rrrf_execute_output_block(i2, i8, i3, i4, (HEAP32[i7 >> 2] | 0) + (i13 << 2) | 0, i14 - i13 | 0, i5);
  i2 = (HEAP32[i5 >> 2] | 0) + (HEAP32[i1 >> 2] | 0) | 0;
  HEAP32[i5 >> 2] = i2;
  i4 = HEAP32[i6 >> 2] | 0;
  i3 = (i2 >>> 0) % ((HEAP32[i4 >> 2] | 0) >>> 0) | 0;
  if (!i3) i3 = 0; else {
   i2 = i2 - i3 | 0;
   HEAP32[i5 >> 2] = i2;
  }
  i4 = _demodulator_recv(i4, HEAP32[i7 >> 2] | 0, i2, HEAP32[i9 + 80 >> 2] | 0) | 0;
  if (i3 | 0) {
   i14 = HEAP32[i7 >> 2] | 0;
   _memmove(i14 | 0, i14 + (i2 << 2) | 0, i3 << 2 | 0) | 0;
  }
  HEAP32[i1 >> 2] = i3;
  _free(i8);
 }
 i1 = HEAP32[i1 >> 2] | 0;
 if (i1) {
  i2 = HEAP32[i6 >> 2] | 0;
  i3 = HEAP32[i2 >> 2] | 0;
  i5 = i9 + 100 | 0;
  if ((i3 | 0) != (i1 | 0)) {
   _memset(HEAP32[i5 >> 2] | 0, 0, i3 - i1 << 2 | 0) | 0;
   i1 = HEAP32[i6 >> 2] | 0;
   i2 = i1;
   i1 = HEAP32[i1 >> 2] | 0;
  }
  i4 = (_demodulator_recv(i2, HEAP32[i5 >> 2] | 0, i1, (HEAP32[i9 + 80 >> 2] | 0) + (i4 << 3) | 0) | 0) + i4 | 0;
 }
 i2 = HEAP32[i6 >> 2] | 0;
 if (!i2) i1 = 0; else i1 = HEAP32[i2 + 4 >> 2] << 1;
 i5 = i9 + 84 | 0;
 if (i1 >>> 0 >= (HEAP32[i5 >> 2] | 0) >>> 0) ___assert_fail(gb + 9681 | 0, gb + 9739 | 0, 318, gb + 9777 | 0);
 i3 = i9 + 80 | 0;
 i1 = (_demodulator_flush(i2, (HEAP32[i3 >> 2] | 0) + (i4 << 3) | 0) | 0) + i4 | 0;
 switch (HEAP32[i9 + 52 >> 2] | 0) {
 case 0:
  {
   _ofdmframesync_execute(HEAP32[(HEAP32[i9 + 60 >> 2] | 0) + 184 >> 2] | 0, HEAP32[i3 >> 2] | 0, i1);
   break;
  }
 case 1:
  {
   i2 = i1 + 60 | 0;
   if (i2 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0) {
    i10 = 0;
    i11 = i1;
   } else ___assert_fail(gb + 9797 | 0, gb + 9739 | 0, 332, gb + 9777 | 0);
   while (1) {
    i14 = i11 + i10 | 0;
    i13 = HEAP32[i3 >> 2] | 0;
    HEAPF32[i13 + (i14 << 3) >> 2] = 0.0;
    HEAPF32[i13 + (i14 << 3) + 4 >> 2] = 0.0;
    i10 = i10 + 1 | 0;
    if ((i10 | 0) == 60) break; else i11 = i11 + 1 | 0;
   }
   _flexframesync_execute(HEAP32[i9 + 60 >> 2] | 0, HEAP32[i3 >> 2] | 0, i2);
   break;
  }
 case 2:
  {
   _gmskframesync_execute(HEAP32[i9 + 60 >> 2] | 0, HEAP32[i3 >> 2] | 0, i1);
   break;
  }
 default:
  {}
 }
 i14 = HEAP32[i9 + 76 >> 2] | 0;
 STACKTOP = i12;
 return i14 | 0;
}

function _modem_demodulate_sqam128(i15, i2, i9) {
 i15 = i15 | 0;
 i2 = i2 | 0;
 i9 = i9 | 0;
 var d1 = 0.0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, d10 = 0.0, d11 = 0.0, i12 = 0, d13 = 0.0, d14 = 0.0, i16 = 0, i17 = 0;
 d14 = +HEAPF32[i2 >> 2];
 d13 = +HEAPF32[i2 + 4 >> 2];
 i7 = (d14 < 0.0 & 1) << 1 | d13 < 0.0;
 switch (i7 | 0) {
 case 0:
  {
   d10 = d14;
   d11 = d13;
   break;
  }
 case 1:
  {
   d10 = d14;
   d11 = -d13;
   break;
  }
 case 2:
  {
   d10 = -d14;
   d11 = d13;
   break;
  }
 case 3:
  {
   d10 = -d14;
   d11 = -d13;
   break;
  }
 default:
  {}
 }
 if (!(d10 >= 0.0)) ___assert_fail(gb + 29167 | 0, gb + 29268 | 0, 99, gb + 29298 | 0);
 if (!(d11 >= 0.0)) ___assert_fail(gb + 29244 | 0, gb + 29268 | 0, 100, gb + 29298 | 0);
 i12 = HEAP32[i15 + 100 >> 2] | 0;
 d6 = 0.0;
 i8 = 0;
 while (1) {
  d3 = +Math_abs(+(d10 - +HEAPF32[i12 + (i8 << 3) >> 2]));
  i16 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
  d3 = +Math_abs(+(d11 - +HEAPF32[i12 + (i8 << 3) + 4 >> 2]));
  i5 = (HEAPF32[tempDoublePtr >> 2] = d3, HEAP32[tempDoublePtr >> 2] | 0);
  i17 = i16 >>> 0 < i5 >>> 0;
  i2 = i17 ? i5 : i16;
  i5 = i17 ? i16 : i5;
  d3 = (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]);
  d1 = (HEAP32[tempDoublePtr >> 2] = i5, +HEAPF32[tempDoublePtr >> 2]);
  do if ((i5 | 0) != 2139095040) {
   if (i2 >>> 0 > 2139095039 | (i5 | 0) == 0 | (i2 - i5 | 0) >>> 0 > 209715199) {
    d1 = d3 + d1;
    break;
   }
   if (i2 >>> 0 <= 1568669695) if (i5 >>> 0 < 562036736) {
    d1 = d1 * 1237940039285380274899124.0e3;
    d3 = d3 * 1237940039285380274899124.0e3;
    d4 = 8.077935669463161e-28;
   } else d4 = 1.0; else {
    d1 = d1 * 8.077935669463161e-28;
    d3 = d3 * 8.077935669463161e-28;
    d4 = 1237940039285380274899124.0e3;
   }
   d1 = d4 * +Math_sqrt(+(d3 * d3 + d1 * d1));
  } while (0);
  if ((i8 | 0) == 0 | d1 < d6) HEAP32[i9 >> 2] = i8; else d1 = d6;
  i8 = i8 + 1 | 0;
  if ((i8 | 0) == 32) break; else d6 = d1;
 }
 i16 = HEAP32[i9 >> 2] | 0;
 i17 = i16 | i7 << 5;
 HEAP32[i9 >> 2] = i17;
 i2 = i15 + 92 | 0;
 i16 = i16 & 31;
 d3 = +HEAPF32[i12 + (i16 << 3) >> 2];
 d1 = +HEAPF32[i12 + (i16 << 3) + 4 >> 2];
 switch (i17 >>> 5 & 3 | 0) {
 case 0:
  {
   HEAPF32[i2 >> 2] = d3;
   HEAPF32[i15 + 96 >> 2] = d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 case 1:
  {
   HEAPF32[i2 >> 2] = d3;
   HEAPF32[i15 + 96 >> 2] = -d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 case 2:
  {
   HEAPF32[i2 >> 2] = -d3;
   HEAPF32[i15 + 96 >> 2] = d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 case 3:
  {
   HEAPF32[i2 >> 2] = -d3;
   HEAPF32[i15 + 96 >> 2] = -d1;
   i17 = i15 + 88 | 0;
   i16 = i15 + 84 | 0;
   HEAPF32[i16 >> 2] = d14;
   HEAPF32[i17 >> 2] = d13;
   return;
  }
 default:
  {}
 }
}

function _firdespm_execute(i30, i29) {
 i30 = i30 | 0;
 i29 = i29 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, i6 = 0, d7 = 0.0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, d31 = 0.0;
 i28 = i30 + 12 | 0;
 i1 = HEAP32[i28 >> 2] | 0;
 i26 = i30 + 20 | 0;
 i27 = i30 + 88 | 0;
 if ((i1 | 0) != -1) {
  i3 = HEAP32[i27 >> 2] | 0;
  i2 = 0;
  do {
   HEAP32[i3 + (i2 << 2) >> 2] = ((Math_imul((HEAP32[i26 >> 2] | 0) + -1 | 0, i2) | 0) >>> 0) / (i1 >>> 0) | 0;
   i2 = i2 + 1 | 0;
   i1 = HEAP32[i28 >> 2] | 0;
  } while (i2 >>> 0 < (i1 + 1 | 0) >>> 0);
 }
 i19 = i30 + 92 | 0;
 i20 = i30 + 60 | 0;
 i21 = i30 + 48 | 0;
 i22 = i30 + 64 | 0;
 i23 = i30 + 72 | 0;
 i24 = i30 + 68 | 0;
 i17 = i30 + 56 | 0;
 i18 = i30 + 52 | 0;
 i25 = 0;
 while (1) {
  _firdespm_compute_interp(i30);
  i13 = HEAP32[i26 >> 2] | 0;
  L8 : do if (i13 | 0) {
   i3 = HEAP32[i21 >> 2] | 0;
   i6 = HEAP32[i22 >> 2] | 0;
   i9 = HEAP32[i23 >> 2] | 0;
   i10 = HEAP32[i24 >> 2] | 0;
   i11 = (HEAP32[i28 >> 2] | 0) + 1 | 0;
   i14 = HEAP32[i17 >> 2] | 0;
   i15 = HEAP32[i18 >> 2] | 0;
   i16 = HEAP32[i20 >> 2] | 0;
   if (!i11) {
    i1 = 0;
    while (1) {
     HEAPF64[i16 + (i1 << 3) >> 3] = +HEAPF64[i14 + (i1 << 3) >> 3] * (+HEAPF64[i15 + (i1 << 3) >> 3] + nan);
     i1 = i1 + 1 | 0;
     if ((i1 | 0) == (i13 | 0)) break L8;
    }
   } else i12 = 0;
   do {
    d5 = +Math_cos(+(+HEAPF64[i3 + (i12 << 3) >> 3] * 6.283185307179586));
    i1 = 0;
    d7 = 0.0;
    d8 = 0.0;
    while (1) {
     d4 = d5 - +HEAPF64[i6 + (i1 << 3) >> 3];
     if (+Math_abs(+d4) < 9.999999974752427e-07) {
      i2 = 10;
      break;
     }
     d31 = +HEAPF64[i10 + (i1 << 3) >> 3];
     d7 = d7 + d31 * +HEAPF64[i9 + (i1 << 3) >> 3] / d4;
     d8 = d8 + d31 / d4;
     i1 = i1 + 1 | 0;
     if (i1 >>> 0 >= i11 >>> 0) {
      i2 = 12;
      break;
     }
    }
    if ((i2 | 0) == 10) d4 = +HEAPF64[i9 + (i1 << 3) >> 3]; else if ((i2 | 0) == 12) d4 = d7 / d8;
    HEAPF64[i16 + (i12 << 3) >> 3] = +HEAPF64[i14 + (i12 << 3) >> 3] * (+HEAPF64[i15 + (i12 << 3) >> 3] - d4);
    i12 = i12 + 1 | 0;
   } while ((i12 | 0) != (i13 | 0));
  } while (0);
  _firdespm_iext_search(i30);
  if (!(HEAP32[i19 >> 2] | 0)) {
   i2 = 19;
   break;
  }
  i1 = HEAP32[i28 >> 2] | 0;
  if ((i1 | 0) == -1) {
   d5 = 0.0;
   d4 = 0.0;
  } else {
   i2 = HEAP32[i27 >> 2] | 0;
   i3 = HEAP32[i20 >> 2] | 0;
   d5 = 0.0;
   d4 = 0.0;
   i6 = 0;
   while (1) {
    d31 = +Math_abs(+(+HEAPF64[i3 + (HEAP32[i2 + (i6 << 2) >> 2] << 3) >> 3]));
    i16 = (i6 | 0) == 0;
    d4 = i16 | d31 < d4 ? d31 : d4;
    d5 = i16 | d31 > d5 ? d31 : d5;
    if ((i6 | 0) == (i1 | 0)) break; else i6 = i6 + 1 | 0;
   }
  }
  i25 = i25 + 1 | 0;
  if (!(i25 >>> 0 < 40 ? !((d5 - d4) / d5 < 1.0000000474974513e-03) : 0)) {
   i2 = 19;
   break;
  }
 }
 if ((i2 | 0) == 19) {
  _firdespm_compute_taps(i30, i29);
  return;
 }
}

function _fft_execute_mixed_radix(i13) {
 i13 = i13 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0;
 i20 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i20;
 i19 = HEAP32[i13 + 40 >> 2] | 0;
 i16 = HEAP32[i13 + 44 >> 2] | 0;
 i17 = HEAP32[i13 + 52 >> 2] | 0;
 i18 = HEAP32[i13 + 56 >> 2] | 0;
 i15 = HEAP32[i13 + 48 >> 2] | 0;
 i3 = HEAP32[i13 + 60 >> 2] | 0;
 _memmove(i15 | 0, HEAP32[i13 + 4 >> 2] | 0, HEAP32[i13 >> 2] << 3 | 0) | 0;
 i14 = (i16 | 0) == 0;
 L1 : do if (!i14) {
  i12 = i13 + 64 | 0;
  i4 = i2 + 4 | 0;
  if (!i19) {
   i1 = 0;
   while (1) {
    i5 = HEAP32[i12 >> 2] | 0;
    mftCall_vi(HEAP32[i5 + 28 >> 2] | 0, i5 | 0);
    i1 = i1 + 1 | 0;
    if ((i1 | 0) == (i16 | 0)) break L1;
   }
  } else i5 = 0;
  do {
   i1 = 0;
   do {
    i22 = (Math_imul(i1, i16) | 0) + i5 | 0;
    i21 = HEAP32[i15 + (i22 << 3) + 4 >> 2] | 0;
    HEAP32[i17 + (i1 << 3) >> 2] = HEAP32[i15 + (i22 << 3) >> 2];
    HEAP32[i17 + (i1 << 3) + 4 >> 2] = i21;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i19 | 0));
   i1 = HEAP32[i12 >> 2] | 0;
   mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
   i1 = 0;
   do {
    d8 = +HEAPF32[i18 + (i1 << 3) >> 2];
    d9 = +HEAPF32[i18 + (i1 << 3) + 4 >> 2];
    i22 = Math_imul(i1, i5) | 0;
    d10 = +HEAPF32[i3 + (i22 << 3) >> 2];
    d11 = +HEAPF32[i3 + (i22 << 3) + 4 >> 2];
    d7 = d8 * d10 - d9 * d11;
    d6 = d9 * d10 + d8 * d11;
    if ((d7 != d7 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
     ___mulsc3(i2, d8, d9, d10, d11);
     d7 = +HEAPF32[i2 >> 2];
     d6 = +HEAPF32[i4 >> 2];
    }
    i22 = (Math_imul(i1, i16) | 0) + i5 | 0;
    HEAPF32[i15 + (i22 << 3) >> 2] = d7;
    HEAPF32[i15 + (i22 << 3) + 4 >> 2] = d6;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i19 | 0));
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i16 | 0));
 } while (0);
 if (!i19) {
  STACKTOP = i20;
  return;
 }
 i5 = i13 + 68 | 0;
 i4 = i13 + 8 | 0;
 if (i14) {
  i1 = 0;
  do {
   i22 = HEAP32[i5 >> 2] | 0;
   mftCall_vi(HEAP32[i22 + 28 >> 2] | 0, i22 | 0);
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i19 | 0));
  STACKTOP = i20;
  return;
 } else i3 = 0;
 do {
  i1 = Math_imul(i3, i16) | 0;
  i2 = 0;
  do {
   i21 = i2 + i1 | 0;
   i22 = HEAP32[i15 + (i21 << 3) + 4 >> 2] | 0;
   HEAP32[i17 + (i2 << 3) >> 2] = HEAP32[i15 + (i21 << 3) >> 2];
   HEAP32[i17 + (i2 << 3) + 4 >> 2] = i22;
   i2 = i2 + 1 | 0;
  } while ((i2 | 0) != (i16 | 0));
  i1 = HEAP32[i5 >> 2] | 0;
  mftCall_vi(HEAP32[i1 + 28 >> 2] | 0, i1 | 0);
  i1 = 0;
  do {
   i14 = HEAP32[i18 + (i1 << 3) + 4 >> 2] | 0;
   i22 = (Math_imul(i1, i19) | 0) + i3 | 0;
   i21 = HEAP32[i4 >> 2] | 0;
   HEAP32[i21 + (i22 << 3) >> 2] = HEAP32[i18 + (i1 << 3) >> 2];
   HEAP32[i21 + (i22 << 3) + 4 >> 2] = i14;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i16 | 0));
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != (i19 | 0));
 STACKTOP = i20;
 return;
}

function _stream_get(i12, i10) {
 i12 = i12 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i13 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i11 = i13;
 i8 = i12 + 20 | 0;
 i1 = HEAP32[i8 >> 2] | 0;
 if (i1 | 0) {
  i12 = i1;
  STACKTOP = i13;
  return i12 | 0;
 }
 i9 = i12 + 16 | 0;
 i1 = HEAP32[i9 >> 2] | 0;
 L4 : do if (!(HEAP8[i12 + 8 + i1 >> 0] | 0)) {
  i3 = i12 + 4 | 0;
  i7 = mftCall_ii(HEAP32[i12 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
  if ((i7 | 0) == -1) {
   HEAP32[i8 >> 2] = -1;
   i12 = -1;
   STACKTOP = i13;
   return i12 | 0;
  }
  i1 = i7 & 255;
  i2 = i12 + 8 | 0;
  HEAP8[i2 >> 0] = i1;
  HEAP32[i9 >> 2] = 0;
  if ((i7 & -128 | 0) != 128) {
   HEAP8[i12 + 9 >> 0] = 0;
   i1 = 0;
   break;
  }
  if (i1 << 24 >> 24 > -1) ___assert_fail(gb + 37732 | 0, gb + 37743 | 0, 179, gb + 37750 | 0);
  L16 : do if (!((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64)) {
   if ((i1 + 62 & 255) >= 30) if ((i1 & -16) << 24 >> 24 != -32) if ((i1 + 16 & 255) < 5) i6 = 4; else break; else i6 = 3; else i6 = 2;
   i1 = 1;
   do {
    HEAP8[i12 + 8 + i1 >> 0] = mftCall_ii(HEAP32[i12 >> 2] | 0, HEAP32[i3 >> 2] | 0) | 0;
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < i6 >>> 0);
   i1 = HEAP8[i2 >> 0] | 0;
   i4 = (i6 | 0) == 2;
   L25 : do if (i4) {
    i5 = 1;
    i3 = i1 & 31;
   } else switch (i6 | 0) {
   case 3:
    {
     i5 = 1;
     i3 = i1 & 15;
     break L25;
    }
   case 4:
    {
     i5 = 1;
     i3 = i1 & 7;
     break L25;
    }
   default:
    break L16;
   } while (0);
   do {
    i1 = HEAP8[i12 + 8 + i5 >> 0] | 0;
    if (i1 << 24 >> 24 > -1 | (i1 & 255) > 191) break L16;
    i2 = i3 << 6;
    i3 = i1 & 63 | i2;
    i5 = i5 + 1 | 0;
   } while (i5 >>> 0 < i6 >>> 0);
   if ((!(i4 & (i3 | 0) < 128 | ((i2 & -2048 | 0) == 55296 | (i3 | 0) > 1114111)) ? !((i6 | 0) == 3 & (i3 | 0) < 2048) : 0) ? !((i6 | 0) == 4 & (i3 | 0) < 65536) : 0) {
    HEAP8[i12 + 8 + i6 >> 0] = 0;
    i1 = HEAP32[i9 >> 2] | 0;
    break L4;
   }
  } while (0);
  HEAP32[i8 >> 2] = -2;
  HEAP32[i11 >> 2] = i7;
  _error_set(i10, i12, gb + 37761 | 0, i11);
  i12 = -2;
  STACKTOP = i13;
  return i12 | 0;
 } while (0);
 HEAP32[i9 >> 2] = i1 + 1;
 i1 = HEAP8[i12 + 8 + i1 >> 0] | 0;
 i2 = i1 << 24 >> 24;
 i11 = i12 + 36 | 0;
 HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + 1;
 if (i1 << 24 >> 24 == 10) {
  i11 = i12 + 24 | 0;
  HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) + 1;
  i11 = i12 + 28 | 0;
  HEAP32[i12 + 32 >> 2] = HEAP32[i11 >> 2];
  HEAP32[i11 >> 2] = 0;
  i12 = i2;
  STACKTOP = i13;
  return i12 | 0;
 }
 if (i1 << 24 >> 24 <= -1) {
  if ((i1 & 255) < 192 | (i1 & -2) << 24 >> 24 == -64) {
   i12 = i2;
   STACKTOP = i13;
   return i12 | 0;
  }
  if (!((i1 + 16 & 255) < 5 | ((i1 + 62 & 255) < 30 | (i1 & -16) << 24 >> 24 == -32))) {
   i12 = i2;
   STACKTOP = i13;
   return i12 | 0;
  }
 }
 i12 = i12 + 28 | 0;
 HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + 1;
 i12 = i2;
 STACKTOP = i13;
 return i12 | 0;
}

function _ofdmframegen_writesymbol(i8, i7, i9) {
 i8 = i8 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, d14 = 0.0, d15 = 0.0, d16 = 0.0;
 i1 = HEAP32[i8 >> 2] | 0;
 L1 : do if (i1 | 0) {
  i3 = i8 + 8 | 0;
  i4 = i8 + 44 | 0;
  i5 = i8 + 52 | 0;
  i6 = i8 + 76 | 0;
  i2 = 0;
  while (1) {
   i1 = (((i1 >>> 1) + i2 | 0) >>> 0) % (i1 >>> 0) | 0;
   switch (HEAP8[(HEAP32[i3 >> 2] | 0) + i1 >> 0] | 0) {
   case 0:
    {
     i10 = HEAP32[i5 >> 2] | 0;
     HEAPF32[i10 + (i1 << 3) >> 2] = 0.0;
     HEAPF32[i10 + (i1 << 3) + 4 >> 2] = 0.0;
     break;
    }
   case 1:
    {
     i12 = HEAP32[i6 >> 2] | 0;
     i10 = i12 + 16 | 0;
     i13 = HEAP32[i10 >> 2] | 0;
     i11 = HEAP32[i12 + 4 >> 2] & i13;
     i11 = (HEAPU8[(i11 >>> 8 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i11 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i11 >>> 16 & 255) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i11 >>> 24) + (gb + 36491) >> 0] | 0) & 1;
     HEAP32[i12 + 20 >> 2] = i11;
     HEAP32[i10 >> 2] = (i11 | i13 << 1) & HEAP32[i12 + 12 >> 2];
     i10 = HEAP32[i5 >> 2] | 0;
     HEAPF32[i10 + (i1 << 3) >> 2] = +HEAPF32[i4 >> 2] * (i11 | 0 ? 1.0 : -1.0);
     HEAPF32[i10 + (i1 << 3) + 4 >> 2] = 0.0;
     break;
    }
   default:
    {
     d15 = +HEAPF32[i4 >> 2];
     d14 = +HEAPF32[i7 + (i1 << 3) + 4 >> 2] * d15;
     i13 = HEAP32[i5 >> 2] | 0;
     HEAPF32[i13 + (i1 << 3) >> 2] = +HEAPF32[i7 + (i1 << 3) >> 2] * d15;
     HEAPF32[i13 + (i1 << 3) + 4 >> 2] = d14;
    }
   }
   i2 = i2 + 1 | 0;
   i1 = HEAP32[i8 >> 2] | 0;
   if (i2 >>> 0 >= i1 >>> 0) break L1;
  }
 } while (0);
 i5 = HEAP32[i8 + 48 >> 2] | 0;
 mftCall_vi(HEAP32[i5 + 28 >> 2] | 0, i5 | 0);
 i5 = i8 + 4 | 0;
 i13 = HEAP32[i5 >> 2] | 0;
 i4 = i8 + 56 | 0;
 _memmove(i9 | 0, (HEAP32[i4 >> 2] | 0) + ((HEAP32[i8 >> 2] | 0) - i13 << 3) | 0, i13 << 3 | 0) | 0;
 _memmove(i9 + (HEAP32[i5 >> 2] << 3) | 0, HEAP32[i4 >> 2] | 0, HEAP32[i8 >> 2] << 3 | 0) | 0;
 i5 = i8 + 12 | 0;
 if (!(HEAP32[i5 >> 2] | 0)) {
  i13 = 0;
  i11 = i8 + 20 | 0;
  i11 = HEAP32[i11 >> 2] | 0;
  i12 = HEAP32[i4 >> 2] | 0;
  _memmove(i11 | 0, i12 | 0, i13 | 0) | 0;
  return;
 }
 i6 = i8 + 16 | 0;
 i2 = i8 + 20 | 0;
 i3 = 0;
 do {
  d15 = +HEAPF32[(HEAP32[i6 >> 2] | 0) + (i3 << 2) >> 2];
  i13 = i9 + (i3 << 3) | 0;
  i1 = i9 + (i3 << 3) + 4 | 0;
  d16 = d15 * +HEAPF32[i13 >> 2];
  d15 = d15 * +HEAPF32[i1 >> 2];
  HEAPF32[i13 >> 2] = d16;
  HEAPF32[i1 >> 2] = d15;
  i12 = HEAP32[i2 >> 2] | 0;
  d14 = +HEAPF32[(HEAP32[i6 >> 2] | 0) + ((HEAP32[i5 >> 2] | 0) + ~i3 << 2) >> 2];
  d15 = d15 + +HEAPF32[i12 + (i3 << 3) + 4 >> 2] * d14;
  HEAPF32[i13 >> 2] = d16 + +HEAPF32[i12 + (i3 << 3) >> 2] * d14;
  HEAPF32[i1 >> 2] = d15;
  i3 = i3 + 1 | 0;
  i1 = HEAP32[i5 >> 2] | 0;
 } while (i3 >>> 0 < i1 >>> 0);
 i13 = i1 << 3;
 i11 = i2;
 i11 = HEAP32[i11 >> 2] | 0;
 i12 = HEAP32[i4 >> 2] | 0;
 _memmove(i11 | 0, i12 | 0, i13 | 0) | 0;
 return;
}

function _fec_conv_punctured_encode(i20, i19, i14, i18) {
 i20 = i20 | 0;
 i19 = i19 | 0;
 i14 = i14 | 0;
 i18 = i18 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0, i16 = 0, i17 = 0;
 i16 = g$_P_init() | 0;
 i17 = g$_Partab() | 0;
 if (!i19) {
  i2 = 0;
  i1 = 0;
  i4 = 0;
  i5 = 0;
 } else {
  i9 = i20 + 28 | 0;
  i11 = i20 + 36 | 0;
  i12 = i20 + 40 | 0;
  i13 = i20 + 24 | 0;
  i3 = HEAP32[i9 >> 2] | 0;
  i2 = 0;
  i15 = 0;
  i1 = 0;
  i4 = 0;
  i5 = 0;
  do {
   i10 = HEAPU8[i14 + i15 >> 0] | 0;
   i6 = i3;
   i7 = i3;
   i8 = 0;
   while (1) {
    i5 = i5 << 1 | i10 >>> (7 - i8 | 0) & 1;
    if (!i7) {
     i3 = i6;
     i7 = 0;
    } else {
     i7 = 0;
     do {
      i3 = (Math_imul(HEAP32[i11 >> 2] | 0, i7) | 0) + i4 | 0;
      if (HEAP32[(HEAP32[i12 >> 2] | 0) + (i3 << 2) >> 2] | 0) {
       i3 = HEAP32[(HEAP32[i13 >> 2] | 0) + (i7 << 2) >> 2] & i5;
       i3 = i3 >> 16 ^ i3;
       if (!(HEAP32[i16 >> 2] | 0)) _partab_init();
       i2 = (HEAPU8[i17 + ((i3 >>> 8 ^ i3) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
       HEAP8[i18 + (i1 >>> 3) >> 0] = i2;
       i6 = HEAP32[i9 >> 2] | 0;
       i1 = i1 + 1 | 0;
      }
      i7 = i7 + 1 | 0;
     } while (i7 >>> 0 < i6 >>> 0);
     i3 = i6;
     i7 = i6;
    }
    i4 = ((i4 + 1 | 0) >>> 0) % ((HEAP32[i11 >> 2] | 0) >>> 0) | 0;
    i8 = i8 + 1 | 0;
    if ((i8 | 0) == 8) break; else i6 = i3;
   }
   i15 = i15 + 1 | 0;
  } while ((i15 | 0) != (i19 | 0));
 }
 i11 = i20 + 32 | 0;
 if ((HEAP32[i11 >> 2] | 0) != 1) {
  i12 = i20 + 28 | 0;
  i13 = i20 + 36 | 0;
  i9 = i20 + 40 | 0;
  i10 = i20 + 24 | 0;
  i7 = HEAP32[i12 >> 2] | 0;
  i3 = i7;
  i8 = 0;
  while (1) {
   i5 = i5 << 1;
   if (!i7) {
    i6 = i3;
    i7 = 0;
   } else {
    i6 = 0;
    do {
     i15 = (Math_imul(HEAP32[i13 >> 2] | 0, i6) | 0) + i4 | 0;
     if (HEAP32[(HEAP32[i9 >> 2] | 0) + (i15 << 2) >> 2] | 0) {
      i3 = HEAP32[(HEAP32[i10 >> 2] | 0) + (i6 << 2) >> 2] & i5;
      i3 = i3 >> 16 ^ i3;
      if (!(HEAP32[i16 >> 2] | 0)) _partab_init();
      i2 = (HEAPU8[i17 + ((i3 >>> 8 ^ i3) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
      HEAP8[i18 + (i1 >>> 3) >> 0] = i2;
      i3 = HEAP32[i12 >> 2] | 0;
      i1 = i1 + 1 | 0;
     }
     i6 = i6 + 1 | 0;
    } while (i6 >>> 0 < i3 >>> 0);
    i6 = i3;
    i7 = i3;
   }
   i8 = i8 + 1 | 0;
   if (i8 >>> 0 >= ((HEAP32[i11 >> 2] | 0) + -1 | 0) >>> 0) break; else {
    i3 = i6;
    i4 = ((i4 + 1 | 0) >>> 0) % ((HEAP32[i13 >> 2] | 0) >>> 0) | 0;
   }
  }
 }
 if (i1 & 7) do {
  i2 = (i2 & 255) << 1 & 255;
  HEAP8[i18 + (i1 >>> 3) >> 0] = i2;
  i1 = i1 + 1 | 0;
 } while ((i1 & 7 | 0) != 0);
 if ((i1 | 0) == ((_fec_get_enc_msg_length(HEAP32[i20 >> 2] | 0, i19) | 0) << 3 | 0)) return; else ___assert_fail(gb + 12126 | 0, gb + 12181 | 0, 157, gb + 12214 | 0);
}

function _ofdmflexframegen_assemble(i5, i2, i3, i4) {
 i5 = i5 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i5 + 92 | 0;
 if ((HEAP32[i1 >> 2] | 0) != (i4 | 0)) {
  HEAP32[i1 >> 2] = i4;
  _ofdmflexframegen_reconfigure(i5);
 }
 HEAP32[i5 + 124 >> 2] = 1;
 i15 = i5 + 60 | 0;
 i12 = i5 + 72 | 0;
 _memmove(HEAP32[i15 >> 2] | 0, i2 | 0, HEAP32[i12 >> 2] | 0) | 0;
 i12 = HEAP32[i12 >> 2] | 0;
 HEAP8[(HEAP32[i15 >> 2] | 0) + i12 >> 0] = 104;
 HEAP8[(HEAP32[i15 >> 2] | 0) + (i12 + 1) >> 0] = (HEAP32[i1 >> 2] | 0) >>> 8;
 HEAP8[(HEAP32[i15 >> 2] | 0) + (i12 + 2) >> 0] = HEAP32[i1 >> 2];
 i1 = i5 + 152 | 0;
 HEAP8[(HEAP32[i15 >> 2] | 0) + (i12 + 3) >> 0] = HEAP32[i1 >> 2];
 i11 = i12 + 4 | 0;
 HEAP8[(HEAP32[i15 >> 2] | 0) + i11 >> 0] = HEAP32[i5 + 140 >> 2] << 5;
 i11 = (HEAP32[i15 >> 2] | 0) + i11 | 0;
 HEAP8[i11 >> 0] = HEAPU8[i11 >> 0] | 0 | HEAP32[i5 + 144 >> 2] & 31;
 HEAP8[(HEAP32[i15 >> 2] | 0) + (i12 + 5) >> 0] = HEAP32[i5 + 148 >> 2] & 31;
 i12 = i5 + 64 | 0;
 _packetizer_encode(HEAP32[i5 + 56 >> 2] | 0, HEAP32[i15 >> 2] | 0, HEAP32[i12 >> 2] | 0);
 i15 = i5 + 80 | 0;
 _scramble_data(HEAP32[i12 >> 2] | 0, HEAP32[i15 >> 2] | 0);
 _liquid_repack_bytes(HEAP32[i12 >> 2] | 0, 8, HEAP32[i15 >> 2] | 0, HEAP32[i5 + 68 >> 2] | 0, 1, HEAP32[i5 + 84 >> 2] | 0, i16);
 i15 = i5 + 100 | 0;
 _packetizer_encode(HEAP32[i5 + 88 >> 2] | 0, i3, HEAP32[i15 >> 2] | 0);
 i12 = i5 + 104 | 0;
 i11 = i5 + 112 | 0;
 _memset(HEAP32[i12 >> 2] | 0, 0, HEAP32[i11 >> 2] << 2 | 0) | 0;
 i1 = HEAP32[i1 >> 2] | 0;
 i14 = HEAP32[gb + 508 + (i1 << 4) + 12 >> 2] | 0;
 i15 = HEAP32[i15 >> 2] | 0;
 i10 = HEAP32[i5 + 108 >> 2] | 0;
 i11 = HEAP32[i11 >> 2] | 0;
 i12 = HEAP32[i12 >> 2] | 0;
 i13 = i10 << 3;
 if (!((i13 | 0) != 0 & (i11 | 0) != 0)) {
  STACKTOP = i16;
  return;
 }
 switch (i1 | 0) {
 case 0:
 case 59:
  {
   _memset(i12 | 0, 0, i11 << 2 | 0) | 0;
   STACKTOP = i16;
   return;
  }
 default:
  {
   i8 = 0;
   i9 = 0;
  }
 }
 do {
  i7 = i12 + (i8 << 2) | 0;
  i1 = i9 >>> 3;
  if (i1 >>> 0 < i10 >>> 0) {
   i6 = i14;
   i2 = i9 - (i1 << 3) | 0;
   i5 = i1;
   i1 = 0;
   while (1) {
    i3 = 8 - i2 | 0;
    i17 = i6 >>> 0 < i3 >>> 0 ? i6 : i3;
    i1 = 255 >>> (8 - i17 | 0) & 255 & (HEAPU8[i15 + i5 >> 0] | 0) >>> (i3 - i17 | 0) | i1 << i17;
    i3 = i17 + i2 | 0;
    i4 = i3 >>> 0 > 7;
    i5 = (i4 & 1) + i5 | 0;
    i2 = i6 - i17 | 0;
    if (!((i6 | 0) != (i17 | 0) & i5 >>> 0 < i10 >>> 0)) break; else {
     i6 = i2;
     i2 = i4 ? i3 & 7 : i3;
    }
   }
  } else {
   i2 = i14;
   i1 = 0;
  }
  HEAP32[i7 >> 2] = i1 << i2;
  i8 = i8 + 1 | 0;
  i9 = i9 + i14 | 0;
 } while (i9 >>> 0 < i13 >>> 0 & i8 >>> 0 < i11 >>> 0);
 STACKTOP = i16;
 return;
}
function _liquid_repack_bytes(i12, i13, i4, i17, i15, i5, i16) {
 i12 = i12 | 0;
 i13 = i13 | 0;
 i4 = i4 | 0;
 i17 = i17 | 0;
 i15 = i15 | 0;
 i5 = i5 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i14 = 0, i18 = 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i18;
 i11 = Math_imul(i4, i13) | 0;
 i14 = (((i11 | 0) % (i15 | 0) | 0 | 0) > 0 & 1) + ((i11 | 0) / (i15 | 0) | 0) | 0;
 if (i14 >>> 0 > i5 >>> 0) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    i3 = 9;
    break;
   } else {
    HEAP32[gb + 8728 >> 2] = i1 | 32;
    break;
   }
  } else {
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   i3 = 9;
  } while (0);
  do if ((i3 | 0) == 9) {
   if ((i1 - i2 | 0) >>> 0 < 40) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36908 | 0, 40) | 0;
    break;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36908 | 0, 40) | 0) >>> 0 < 40) break;
    i1 = 0;
    i3 = gb + 36908 + 40 | 0;
    i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i1 = 40;
    i3 = gb + 36908 | 0;
   }
   _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
  } while (0);
  HEAP32[i6 >> 2] = i4;
  HEAP32[i6 + 4 >> 2] = i13;
  HEAP32[i6 + 8 >> 2] = i5;
  HEAP32[i6 + 12 >> 2] = i15;
  _fprintf(gb + 8728 | 0, gb + 36949 | 0, i6);
  _exit(-1);
 }
 if (!i11) {
  i3 = 0;
  i2 = 0;
  i1 = 0;
 } else {
  i6 = i13 + -1 | 0;
  i7 = i15 + -1 | 0;
  i8 = 0;
  i5 = 0;
  i3 = 0;
  i10 = 0;
  i2 = 0;
  i4 = 0;
  i1 = 0;
  while (1) {
   if (!i10) {
    i9 = i5 + 1 | 0;
    i4 = HEAP8[i12 + i5 >> 0] | 0;
   } else i9 = i5;
   i1 = ((i4 & 255) >>> (i6 - i10 | 0) & 1 | (i1 & 255) << 1) & 255;
   if ((i2 | 0) == (i7 | 0)) {
    HEAP8[i17 + i3 >> 0] = i1;
    i3 = i3 + 1 | 0;
    i1 = 0;
   }
   i2 = ((i2 + 1 | 0) >>> 0) % (i15 >>> 0) | 0;
   i8 = i8 + 1 | 0;
   if ((i8 | 0) == (i11 | 0)) break; else {
    i5 = i9;
    i10 = ((i10 + 1 | 0) >>> 0) % (i13 >>> 0) | 0;
   }
  }
 }
 if ((i3 | 0) == (i14 | 0)) {
  i17 = i14;
  HEAP32[i16 >> 2] = i17;
  STACKTOP = i18;
  return;
 }
 if (i2 >>> 0 < i15 >>> 0) do {
  i1 = (i1 & 255) << 1 & 255;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i15 | 0));
 HEAP8[i17 + i3 >> 0] = i1;
 i17 = i3 + 1 | 0;
 HEAP32[i16 >> 2] = i17;
 STACKTOP = i18;
 return;
}

function _packetizer_create(i6, i3, i8, i10) {
 i6 = i6 | 0;
 i3 = i3 | 0;
 i8 = i8 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i7 = 0, i9 = 0, i11 = 0, i12 = 0;
 i12 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i12 + 8 | 0;
 i2 = i12;
 i11 = _malloc(36) | 0;
 HEAP32[i11 >> 2] = i6;
 switch (i3 | 0) {
 case 1:
 case 0:
  {
   i1 = 0;
   break;
  }
 case 2:
  {
   i1 = 1;
   break;
  }
 case 3:
  {
   i1 = 1;
   break;
  }
 case 4:
  {
   i1 = 2;
   break;
  }
 case 5:
  {
   i1 = 3;
   break;
  }
 case 6:
  {
   i1 = 4;
   break;
  }
 default:
  {
   HEAP32[i2 >> 2] = i3;
   _fprintf(gb + 8728 | 0, gb + 10464 | 0, i2);
   _exit(1);
  }
 }
 i1 = _fec_get_enc_msg_length(i10, _fec_get_enc_msg_length(i8, i1 + i6 | 0) | 0) | 0;
 HEAP32[i11 + 4 >> 2] = i1;
 HEAP32[i11 + 8 >> 2] = i3;
 switch (i3 | 0) {
 case 1:
 case 0:
  {
   i5 = 0;
   break;
  }
 case 2:
  {
   i5 = 1;
   break;
  }
 case 3:
  {
   i5 = 1;
   break;
  }
 case 4:
  {
   i5 = 2;
   break;
  }
 case 5:
  {
   i5 = 3;
   break;
  }
 case 6:
  {
   i5 = 4;
   break;
  }
 default:
  {
   HEAP32[i4 >> 2] = i3;
   _fprintf(gb + 8728 | 0, gb + 10464 | 0, i4);
   _exit(1);
  }
 }
 HEAP32[i11 + 12 >> 2] = i5;
 HEAP32[i11 + 24 >> 2] = i1;
 i9 = i1 << 3;
 HEAP32[i11 + 28 >> 2] = _malloc(i9) | 0;
 HEAP32[i11 + 32 >> 2] = _malloc(i9) | 0;
 HEAP32[i11 + 20 >> 2] = 2;
 i9 = _malloc(40) | 0;
 HEAP32[i11 + 16 >> 2] = i9;
 i1 = i5 + i6 | 0;
 i6 = i9 + 8 | 0;
 HEAP32[i6 >> 2] = i8;
 HEAP32[i9 >> 2] = i1;
 i7 = i9 + 4 | 0;
 HEAP32[i7 >> 2] = _fec_get_enc_msg_length(i8, i1) | 0;
 HEAP32[i9 + 12 >> 2] = _fec_create(HEAP32[i6 >> 2] | 0) | 0;
 i1 = HEAP32[i7 >> 2] | 0;
 i2 = _malloc(16) | 0;
 HEAP32[i2 >> 2] = i1;
 i3 = i2 + 12 | 0;
 HEAP32[i3 >> 2] = 4;
 i4 = (~~+Math_floor(+(+Math_sqrt(+(+(i1 >>> 0))))) >>> 0) + 1 | 0;
 HEAP32[i2 + 4 >> 2] = i4;
 i5 = (i1 >>> 0) / (i4 >>> 0) | 0;
 while (1) if ((Math_imul(i5, i4) | 0) >>> 0 > i1 >>> 0) break; else i5 = i5 + 1 | 0;
 HEAP32[i2 + 8 >> 2] = i5;
 HEAP32[i9 + 16 >> 2] = i2;
 if ((HEAP32[i6 >> 2] | 0) == 1) HEAP32[i3 >> 2] = 0;
 i2 = HEAP32[i7 >> 2] | 0;
 i6 = i9 + 28 | 0;
 HEAP32[i6 >> 2] = i10;
 HEAP32[i9 + 20 >> 2] = i2;
 i1 = i9 + 24 | 0;
 HEAP32[i1 >> 2] = _fec_get_enc_msg_length(i10, i2) | 0;
 HEAP32[i9 + 32 >> 2] = _fec_create(HEAP32[i6 >> 2] | 0) | 0;
 i1 = HEAP32[i1 >> 2] | 0;
 i2 = _malloc(16) | 0;
 HEAP32[i2 >> 2] = i1;
 i3 = i2 + 12 | 0;
 HEAP32[i3 >> 2] = 4;
 i4 = (~~+Math_floor(+(+Math_sqrt(+(+(i1 >>> 0))))) >>> 0) + 1 | 0;
 HEAP32[i2 + 4 >> 2] = i4;
 i5 = (i1 >>> 0) / (i4 >>> 0) | 0;
 while (1) if ((Math_imul(i5, i4) | 0) >>> 0 > i1 >>> 0) break; else i5 = i5 + 1 | 0;
 HEAP32[i2 + 8 >> 2] = i5;
 HEAP32[i9 + 36 >> 2] = i2;
 if ((HEAP32[i6 >> 2] | 0) != 1) {
  STACKTOP = i12;
  return i11 | 0;
 }
 HEAP32[i3 >> 2] = 0;
 STACKTOP = i12;
 return i11 | 0;
}

function _fft_execute_rader(i15) {
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, i6 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, d11 = 0.0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, i18 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i13 = i16;
 i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
 i14 = i15 + 40 | 0;
 if (i1 | 0) {
  i3 = i15 + 4 | 0;
  i4 = i15 + 48 | 0;
  i2 = 0;
  do {
   i17 = HEAP32[(HEAP32[i14 >> 2] | 0) + (i1 + ~i2 << 2) >> 2] | 0;
   i18 = HEAP32[i3 >> 2] | 0;
   i6 = HEAP32[i18 + (i17 << 3) + 4 >> 2] | 0;
   i12 = HEAP32[i4 >> 2] | 0;
   HEAP32[i12 + (i2 << 3) >> 2] = HEAP32[i18 + (i17 << 3) >> 2];
   HEAP32[i12 + (i2 << 3) + 4 >> 2] = i6;
   i2 = i2 + 1 | 0;
   i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
  } while (i1 >>> 0 > i2 >>> 0);
 }
 i18 = HEAP32[i15 + 56 >> 2] | 0;
 mftCall_vi(HEAP32[i18 + 28 >> 2] | 0, i18 | 0);
 if ((HEAP32[i15 >> 2] | 0) != 1) {
  i1 = i15 + 44 | 0;
  i2 = i15 + 52 | 0;
  i3 = i13 + 4 | 0;
  i12 = 0;
  do {
   i6 = HEAP32[i1 >> 2] | 0;
   d8 = +HEAPF32[i6 + (i12 << 3) >> 2];
   d9 = +HEAPF32[i6 + (i12 << 3) + 4 >> 2];
   i6 = HEAP32[i2 >> 2] | 0;
   i4 = i6 + (i12 << 3) | 0;
   d10 = +HEAPF32[i4 >> 2];
   i6 = i6 + (i12 << 3) + 4 | 0;
   d11 = +HEAPF32[i6 >> 2];
   d7 = d8 * d10 - d9 * d11;
   d5 = d9 * d10 + d8 * d11;
   if ((d7 != d7 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
    ___mulsc3(i13, d10, d11, d8, d9);
    d7 = +HEAPF32[i13 >> 2];
    d5 = +HEAPF32[i3 >> 2];
   }
   HEAPF32[i4 >> 2] = d7;
   HEAPF32[i6 >> 2] = d5;
   i12 = i12 + 1 | 0;
  } while (i12 >>> 0 < ((HEAP32[i15 >> 2] | 0) + -1 | 0) >>> 0);
 }
 i6 = HEAP32[i15 + 60 >> 2] | 0;
 mftCall_vi(HEAP32[i6 + 28 >> 2] | 0, i6 | 0);
 i6 = i15 + 8 | 0;
 i4 = HEAP32[i6 >> 2] | 0;
 HEAPF32[i4 >> 2] = 0.0;
 HEAPF32[i4 + 4 >> 2] = 0.0;
 i4 = i15 + 4 | 0;
 if (HEAP32[i15 >> 2] | 0) {
  i2 = 0;
  do {
   i17 = HEAP32[i4 >> 2] | 0;
   i18 = HEAP32[i6 >> 2] | 0;
   i1 = i18 + 4 | 0;
   d11 = +HEAPF32[i17 + (i2 << 3) + 4 >> 2] + +HEAPF32[i1 >> 2];
   HEAPF32[i18 >> 2] = +HEAPF32[i17 + (i2 << 3) >> 2] + +HEAPF32[i18 >> 2];
   HEAPF32[i1 >> 2] = d11;
   i2 = i2 + 1 | 0;
   i1 = HEAP32[i15 >> 2] | 0;
  } while (i2 >>> 0 < i1 >>> 0);
  i1 = i1 + -1 | 0;
  if (!i1) {
   STACKTOP = i16;
   return;
  }
 } else i1 = -1;
 i3 = i15 + 48 | 0;
 i2 = 0;
 do {
  i18 = HEAP32[(HEAP32[i14 >> 2] | 0) + (i2 << 2) >> 2] | 0;
  i12 = HEAP32[i3 >> 2] | 0;
  d10 = +(i1 >>> 0);
  i13 = HEAP32[i4 >> 2] | 0;
  d11 = +HEAPF32[i12 + (i2 << 3) + 4 >> 2] / d10 + +HEAPF32[i13 + 4 >> 2];
  i17 = HEAP32[i6 >> 2] | 0;
  HEAPF32[i17 + (i18 << 3) >> 2] = +HEAPF32[i12 + (i2 << 3) >> 2] / d10 + +HEAPF32[i13 >> 2];
  HEAPF32[i17 + (i18 << 3) + 4 >> 2] = d11;
  i2 = i2 + 1 | 0;
  i1 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
 } while (i2 >>> 0 < i1 >>> 0);
 STACKTOP = i16;
 return;
}

function _quiet_encoder_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0;
 if (!i3) return;
 switch (HEAP32[i3 + 60 >> 2] | 0) {
 case 0:
  {
   i2 = HEAP32[i3 + 96 >> 2] | 0;
   i1 = HEAP32[i2 + 40 >> 2] | 0;
   _free(HEAP32[i1 + 8 >> 2] | 0);
   _free(HEAP32[i1 + 52 >> 2] | 0);
   _free(HEAP32[i1 + 56 >> 2] | 0);
   _fft_destroy_plan(HEAP32[i1 + 48 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 20 >> 2] | 0);
   _free(HEAP32[i1 + 60 >> 2] | 0);
   _free(HEAP32[i1 + 64 >> 2] | 0);
   _free(HEAP32[i1 + 68 >> 2] | 0);
   _free(HEAP32[i1 + 72 >> 2] | 0);
   _free(HEAP32[i1 + 76 >> 2] | 0);
   _free(i1);
   _packetizer_destroy(HEAP32[i2 + 56 >> 2] | 0);
   _modem_destroy(HEAP32[i2 + 52 >> 2] | 0);
   _packetizer_destroy(HEAP32[i2 + 88 >> 2] | 0);
   _modem_destroy(HEAP32[i2 + 96 >> 2] | 0);
   _free(HEAP32[i2 + 100 >> 2] | 0);
   _free(HEAP32[i2 + 104 >> 2] | 0);
   _free(HEAP32[i2 + 36 >> 2] | 0);
   _free(HEAP32[i2 + 12 >> 2] | 0);
   _free(HEAP32[i2 + 60 >> 2] | 0);
   _free(HEAP32[i2 + 64 >> 2] | 0);
   _free(HEAP32[i2 + 68 >> 2] | 0);
   _free(i2);
   break;
  }
 case 1:
  {
   i2 = HEAP32[i3 + 96 >> 2] | 0;
   _firinterp_crcf_destroy(HEAP32[i2 + 12 >> 2] | 0);
   i1 = HEAP32[i2 + 64 >> 2] | 0;
   _packetizer_destroy(HEAP32[i1 + 4 >> 2] | 0);
   _modem_destroy(HEAP32[i1 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 20 >> 2] | 0);
   _free(i1);
   i1 = HEAP32[i2 + 76 >> 2] | 0;
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(i1);
   i1 = HEAP32[i2 + 92 >> 2] | 0;
   _packetizer_destroy(HEAP32[i1 + 4 >> 2] | 0);
   _modem_destroy(HEAP32[i1 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(HEAP32[i1 + 20 >> 2] | 0);
   _free(i1);
   _free(HEAP32[i2 + 48 >> 2] | 0);
   _free(HEAP32[i2 + 52 >> 2] | 0);
   _free(HEAP32[i2 + 72 >> 2] | 0);
   _free(HEAP32[i2 + 84 >> 2] | 0);
   _free(HEAP32[i2 + 100 >> 2] | 0);
   _free(i2);
   break;
  }
 case 2:
  {
   i2 = HEAP32[i3 + 96 >> 2] | 0;
   i1 = HEAP32[i2 >> 2] | 0;
   _firinterp_rrrf_destroy(HEAP32[i1 + 20 >> 2] | 0);
   _free(HEAP32[i1 + 16 >> 2] | 0);
   _free(i1);
   _free(HEAP32[i2 + 32 >> 2] | 0);
   _free(HEAP32[i2 + 44 >> 2] | 0);
   _free(HEAP32[i2 + 48 >> 2] | 0);
   _packetizer_destroy(HEAP32[i2 + 52 >> 2] | 0);
   _free(HEAP32[i2 + 80 >> 2] | 0);
   _packetizer_destroy(HEAP32[i2 + 56 >> 2] | 0);
   _free(i2);
   break;
  }
 default:
  {}
 }
 i1 = HEAP32[i3 + 152 >> 2] | 0;
 if (i1 | 0) _resamp_rrrf_destroy(i1);
 i2 = HEAP32[i3 + 104 >> 2] | 0;
 if (i2 | 0) {
  _free(HEAP32[i2 + 24 >> 2] | 0);
  i1 = HEAP32[i2 + 28 >> 2] | 0;
  if (i1 | 0) _firinterp_crcf_destroy(i1);
  i1 = HEAP32[i2 + 32 >> 2] | 0;
  if (i1 | 0) _iirfilt_crcf_destroy(i1);
  _free(i2);
 }
 _free(HEAP32[i3 + 108 >> 2] | 0);
 _free(HEAP32[i3 + 116 >> 2] | 0);
 _free(i3);
 return;
}

function _liquid_Qf(d1) {
 d1 = +d1;
 var i2 = 0, d3 = 0.0, d4 = 0.0, d5 = 0.0, i6 = 0, d7 = 0.0;
 d1 = d1 * .7071067811865476;
 i6 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0) >>> 31;
 d5 = +Math_abs(+d1);
 i2 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
 if (i2 >>> 0 > 2139095039) {
  d5 = 1.0 / d1 + +(1 - (i6 << 1) | 0);
  d5 = 1.0 - d5;
  d5 = d5 * .5;
  return +d5;
 }
 if (i2 >>> 0 < 1062731776) if (i2 >>> 0 < 830472192) {
  d5 = (d1 * 8.0 + d1 * 1.0270333290100098) * .125;
  d5 = 1.0 - d5;
  d5 = d5 * .5;
  return +d5;
 } else {
  d5 = d1 * d1;
  d5 = d1 + d1 * ((d5 * (d5 * (d5 * (-.005770270247012377 - d5 * 2.3763017452438362e-05) + -.028481749817728996) + -.32504209876060486) + .12837916612625122) / (d5 * (d5 * (d5 * (d5 * (1.324947370449081e-04 - d5 * 3.9602282413397916e-06) + 5.0813062116503716e-03) + .06502225250005722) + .3979172110557556) + 1.0));
  d5 = 1.0 - d5;
  d5 = d5 * .5;
  return +d5;
 }
 if (i2 >>> 0 < 1086324736) {
  d4 = +Math_abs(+d1);
  if (i2 >>> 0 < 1067450368) {
   d1 = d4 + -1.0;
   d1 = .15493708848953247 - (d1 * (d1 * (d1 * (d1 * (d1 * (.03547830507159233 - d1 * .002166375517845154) + -.11089469492435455) + .31834661960601807) + -.3722078800201416) + .41485610604286194) + -2.3621185682713985e-03) / (d1 * (d1 * (d1 * (d1 * (d1 * (d1 * .011984500102698803 + .01363708358258009) + .12617121636867523) + .07182865589857101) + .5403979420661926) + .10642088204622269) + 1.0);
  } else {
   d5 = 1.0 / (d4 * d4);
   if (i2 >>> 0 < 1077336941) {
    d1 = d5 * (d5 * (d5 * (d5 * (d5 * (d5 * (6.570249557495117 - d5 * .06042441353201866) + 108.63500213623047) + 429.0081481933594) + 645.3872680664062) + 434.5658874511719) + 137.6577606201172) + 19.65127182006836;
    d3 = d5 * (d5 * (d5 * (d5 * (d5 * (d5 * (-81.28743743896484 - d5 * 9.814329147338867) + -184.60508728027344) + -162.39666748046875) + -62.37533187866211) + -10.558626174926758) + -.6938585638999939) + -.009864944033324718;
   } else {
    d1 = d5 * (d5 * (d5 * (d5 * (d5 * (474.5285339355469 - d5 * 22.44095230102539) + 2553.05029296875) + 3199.858154296875) + 1536.7296142578125) + 325.7925109863281) + 30.33806037902832;
    d3 = d5 * (d5 * (d5 * (d5 * (d5 * (-1025.0950927734375 - d5 * 483.5191955566406) + -637.5664672851562) + -160.63638305664062) + -17.75795555114746) + -.7992832660675049) + -.009864943102002144;
   }
   d7 = (HEAP32[tempDoublePtr >> 2] = (HEAPF32[tempDoublePtr >> 2] = d4, HEAP32[tempDoublePtr >> 2] | 0) & -8192, +HEAPF32[tempDoublePtr >> 2]);
   d1 = +Math_exp(+(-.5625 - d7 * d7)) * +Math_exp(+((d7 - d4) * (d4 + d7) + d3 / (d5 * d1 + 1.0))) / d4;
  }
  d1 = 1.0 - d1;
 } else d1 = 1.0;
 d7 = i6 | 0 ? -d1 : d1;
 d7 = 1.0 - d7;
 d7 = d7 * .5;
 return +d7;
}

function _fft_execute_dft_3(i18) {
 i18 = i18 | 0;
 var d1 = 0.0, i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, i9 = 0, d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i19 = 0, i20 = 0;
 i19 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i3 = i19 + 24 | 0;
 i9 = i19 + 16 | 0;
 i14 = i19 + 8 | 0;
 i16 = i19;
 i15 = i18 + 4 | 0;
 i20 = HEAP32[i15 >> 2] | 0;
 d10 = +HEAPF32[i20 + 4 >> 2] + +HEAPF32[i20 + 12 >> 2] + +HEAPF32[i20 + 20 >> 2];
 i17 = i18 + 8 | 0;
 i2 = HEAP32[i17 >> 2] | 0;
 HEAPF32[i2 >> 2] = +HEAPF32[i20 >> 2] + +HEAPF32[i20 + 8 >> 2] + +HEAPF32[i20 + 16 >> 2];
 HEAPF32[i2 + 4 >> 2] = d10;
 i2 = HEAP32[i15 >> 2] | 0;
 d10 = +HEAPF32[i2 >> 2];
 d11 = +HEAPF32[i2 + 4 >> 2];
 d1 = +HEAPF32[i2 + 8 >> 2];
 d4 = +HEAPF32[i2 + 12 >> 2];
 d5 = d4 * .8660253882408142 - d1 * .5;
 d6 = d4 * -.5 - d1 * .8660253882408142;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i3, d1, d4, -.5, -.8660253882408142);
  d5 = +HEAPF32[i3 >> 2];
  d6 = +HEAPF32[i3 + 4 >> 2];
  i2 = HEAP32[i15 >> 2] | 0;
 }
 d4 = +HEAPF32[i2 + 16 >> 2];
 d7 = +HEAPF32[i2 + 20 >> 2];
 d8 = d4 * -.5 - d7 * .8660253882408142;
 d1 = d4 * .8660253882408142 - d7 * .5;
 if ((d8 != d8 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i9, d4, d7, -.5, .8660253882408142);
  d8 = +HEAPF32[i9 >> 2];
  d1 = +HEAPF32[i9 + 4 >> 2];
  i2 = HEAP32[i15 >> 2] | 0;
 }
 d13 = d10 + d5 + d8;
 d12 = d11 + d6 + d1;
 d10 = +HEAPF32[i2 >> 2];
 d11 = +HEAPF32[i2 + 4 >> 2];
 d1 = +HEAPF32[i2 + 8 >> 2];
 d4 = +HEAPF32[i2 + 12 >> 2];
 d5 = d1 * -.5 - d4 * .8660253882408142;
 d6 = d1 * .8660253882408142 - d4 * .5;
 if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
  ___mulsc3(i14, d1, d4, -.5, .8660253882408142);
  d8 = +HEAPF32[i14 >> 2];
  d7 = +HEAPF32[i14 + 4 >> 2];
  i2 = HEAP32[i15 >> 2] | 0;
 } else {
  d8 = d5;
  d7 = d6;
 }
 d6 = +HEAPF32[i2 + 16 >> 2];
 d5 = +HEAPF32[i2 + 20 >> 2];
 d4 = d5 * .8660253882408142 - d6 * .5;
 d1 = d5 * -.5 - d6 * .8660253882408142;
 if ((d4 != d4 | 0.0 != 0.0) & (d1 != d1 | 0.0 != 0.0)) {
  ___mulsc3(i16, d6, d5, -.5, -.8660253882408142);
  d4 = +HEAPF32[i16 >> 2];
  d1 = +HEAPF32[i16 + 4 >> 2];
 }
 d4 = d10 + d8 + d4;
 d1 = d11 + d7 + d1;
 i3 = HEAP32[i17 >> 2] | 0;
 i2 = i3 + 8 | 0;
 i3 = i3 + 12 | 0;
 if ((HEAP32[i18 + 12 >> 2] | 0) == 1) {
  HEAPF32[i2 >> 2] = d13;
  HEAPF32[i3 >> 2] = d12;
  i20 = HEAP32[i17 >> 2] | 0;
  HEAPF32[i20 + 16 >> 2] = d4;
  HEAPF32[i20 + 20 >> 2] = d1;
  STACKTOP = i19;
  return;
 } else {
  HEAPF32[i2 >> 2] = d4;
  HEAPF32[i3 >> 2] = d1;
  i20 = HEAP32[i17 >> 2] | 0;
  HEAPF32[i20 + 16 >> 2] = d13;
  HEAPF32[i20 + 20 >> 2] = d12;
  STACKTOP = i19;
  return;
 }
}

function _quiet_encoder_sample_len(i5, i1) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i6;
 i4 = _malloc(i1) | 0;
 if (i4 | 0 ? HEAP32[i4 + -4 >> 2] & 3 | 0 : 0) _memset(i4 | 0, 0, i1 | 0) | 0;
 L5 : do switch (HEAP32[i5 + 60 >> 2] | 0) {
 case 0:
  {
   i3 = i5 + 96 | 0;
   _ofdmflexframegen_assemble(HEAP32[i3 >> 2] | 0, i2, i4, i1);
   i2 = HEAP32[i3 >> 2] | 0;
   i2 = Math_imul(HEAP32[i5 + 112 >> 2] | 0, (HEAP32[i2 + 44 >> 2] | 0) + 3 + (HEAP32[i2 + 48 >> 2] | 0) | 0) | 0;
   break;
  }
 case 1:
  {
   i3 = i5 + 96 | 0;
   _flexframegen_assemble(HEAP32[i3 >> 2] | 0, i2, i4, i1);
   i2 = _flexframegen_getframelen(HEAP32[i3 >> 2] | 0) | 0;
   break;
  }
 case 2:
  {
   i3 = i5 + 96 | 0;
   _gmskframegen_assemble(HEAP32[i3 >> 2] | 0, i2, i4, i1, HEAP32[i5 + 64 >> 2] | 0, HEAP32[i5 + 68 >> 2] | 0, HEAP32[i5 + 72 >> 2] | 0);
   i1 = HEAP32[i3 >> 2] | 0;
   if (HEAP32[i1 + 88 >> 2] | 0) {
    i2 = Math_imul((HEAP32[i1 + 20 >> 2] | 0) + (HEAP32[i1 + 16 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] | 0) + (HEAP32[i1 + 8 >> 2] << 1) | 0, HEAP32[i1 + 4 >> 2] | 0) | 0;
    break L5;
   }
   i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
   do if (!i1) {
    i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
    HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
    i1 = HEAP32[gb + 8728 >> 2] | 0;
    if (!(i1 & 8)) {
     HEAP32[gb + 8728 + 8 >> 2] = 0;
     HEAP32[gb + 8728 + 4 >> 2] = 0;
     i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
     HEAP32[gb + 8728 + 28 >> 2] = i2;
     HEAP32[gb + 8728 + 20 >> 2] = i2;
     i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
     HEAP32[gb + 8728 + 16 >> 2] = i1;
     break;
    } else {
     HEAP32[gb + 8728 >> 2] = i1 | 32;
     i2 = 0;
     break L5;
    }
   } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
   if ((i1 - i2 | 0) >>> 0 < 58) {
    mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24855 | 0, 58) | 0;
    i2 = 0;
    break L5;
   }
   if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
    if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24855 | 0, 58) | 0) >>> 0 < 58) {
     i2 = 0;
     break L5;
    }
    i1 = 0;
    i3 = gb + 24855 + 58 | 0;
    i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
   } else {
    i1 = 58;
    i3 = gb + 24855 | 0;
   }
   _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
   HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
   i2 = 0;
   break;
  }
 default:
  i2 = 0;
 } while (0);
 _free(i4);
 i1 = HEAP32[i5 + 104 >> 2] | 0;
 if (!i1) {
  i5 = 0;
  STACKTOP = i6;
  return i5 | 0;
 }
 i5 = Math_imul(HEAP32[i1 >> 2] | 0, i2) | 0;
 STACKTOP = i6;
 return i5 | 0;
}

function _firpfb_rrrf_create(i11, i10, i3) {
 i11 = i11 | 0;
 i10 = i10 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i12 = i16 + 16 | 0;
 i2 = i16 + 8 | 0;
 i1 = i16;
 if (!i11) {
  HEAP32[i1 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 18810 | 0, i1);
  _exit(1);
 }
 if (!i3) {
  HEAP32[i2 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 18882 | 0, i2);
  _exit(1);
 }
 i14 = _malloc(28) | 0;
 i8 = i14 + 12 | 0;
 HEAP32[i8 >> 2] = i11;
 HEAP32[i14 + 4 >> 2] = i3;
 i9 = _malloc(i11 << 2) | 0;
 HEAP32[i14 + 20 >> 2] = i9;
 i13 = (i3 >>> 0) / (i11 >>> 0) | 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i13 << 2) | 0) + 15 & -16) | 0;
 i7 = (i13 | 0) == 0;
 i3 = i13 + -1 | 0;
 L7 : do if (i7) {
  i1 = 0;
  do {
   i10 = _malloc(8) | 0;
   HEAP32[i10 + 4 >> 2] = 0;
   HEAP32[i10 >> 2] = _malloc(0) | 0;
   HEAP32[i9 + (i1 << 2) >> 2] = i10;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i11 | 0));
 } else {
  i4 = i13 << 2;
  i5 = i11;
  i1 = 0;
  while (1) {
   i2 = 0;
   do {
    HEAP32[i6 + (i3 - i2 << 2) >> 2] = HEAP32[i10 + ((Math_imul(i2, i5) | 0) + i1 << 2) >> 2];
    i2 = i2 + 1 | 0;
   } while (i13 >>> 0 > i2 >>> 0);
   i5 = _malloc(8) | 0;
   HEAP32[i5 + 4 >> 2] = i13;
   i2 = _malloc(i4) | 0;
   HEAP32[i5 >> 2] = i2;
   _memcpy(i2 | 0, i6 | 0, i4 | 0) | 0;
   HEAP32[i9 + (i1 << 2) >> 2] = i5;
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= i11 >>> 0) break L7;
   i5 = HEAP32[i8 >> 2] | 0;
  }
 } while (0);
 HEAP32[i14 + 8 >> 2] = i13;
 if (i7) {
  HEAP32[i12 >> 2] = gb + 37011;
  _fprintf(gb + 8728 | 0, gb + 37016 | 0, i12);
  _exit(1);
 }
 i3 = _malloc(28) | 0;
 HEAP32[i3 + 4 >> 2] = i13;
 i1 = i13 >>> 24;
 if (!i1) {
  i1 = i13 >>> 16 & 255;
  if (!i1) {
   i1 = i13 >>> 8 & 255;
   if (!i1) {
    i1 = i13 & 255;
    if (!i1) i1 = 0; else {
     i2 = 8;
     i15 = 15;
    }
   } else {
    i2 = 16;
    i15 = 15;
   }
  } else {
   i2 = 24;
   i15 = 15;
  }
 } else {
  i2 = 32;
  i15 = 15;
 }
 if ((i15 | 0) == 15) i1 = i2 - (HEAP32[gb + 7248 + (i1 << 2) >> 2] | 0) | 0;
 HEAP32[i3 + 8 >> 2] = i1;
 i15 = 1 << i1;
 HEAP32[i3 + 12 >> 2] = i15;
 i15 = i15 + -1 | 0;
 HEAP32[i3 + 16 >> 2] = i15;
 i13 = i15 + i13 | 0;
 i15 = i3 + 20 | 0;
 HEAP32[i15 >> 2] = i13;
 i13 = i13 << 2;
 i12 = _malloc(i13) | 0;
 HEAP32[i3 >> 2] = i12;
 _memset(i12 | 0, 0, i13 | 0) | 0;
 HEAP32[i14 + 16 >> 2] = i3;
 HEAPF32[i14 + 24 >> 2] = 1.0;
 HEAP32[i3 + 24 >> 2] = 0;
 _memset(HEAP32[i3 >> 2] | 0, 0, HEAP32[i15 >> 2] << 2 | 0) | 0;
 STACKTOP = i16;
 return i14 | 0;
}

function _fec_secded3932_encode(i1, i17, i11, i14) {
 i1 = i1 | 0;
 i17 = i17 | 0;
 i11 = i11 | 0;
 i14 = i14 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i15 = 0, i16 = 0, i18 = 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i12 = i16 + 4 | 0;
 i13 = i16;
 i15 = i17 & 3;
 i10 = i17 - i15 | 0;
 if ((i15 | 0) == (i17 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i4 = i11 + i2 | 0;
   i5 = HEAP8[i4 >> 0] | 0;
   i6 = HEAP8[i4 + 1 >> 0] | 0;
   i7 = HEAP8[i4 + 2 >> 0] | 0;
   i3 = HEAP8[i4 + 3 >> 0] | 0;
   i8 = 0;
   i9 = 0;
   do {
    i18 = i8 << 2;
    i9 = (HEAPU8[(HEAP8[(i18 | 1) + (gb + 17951) >> 0] & i6 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[gb + 17951 + i18 >> 0] & i5 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 2) + (gb + 17951) >> 0] & i7 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 3) + (gb + 17951) >> 0] & i3 & 255) + (gb + 36235) >> 0] | 0) & 1 | i9 << 1 & 510;
    i8 = i8 + 1 | 0;
   } while ((i8 | 0) != 7);
   HEAP8[i14 + i1 >> 0] = i9;
   HEAP8[i14 + (i1 + 1) >> 0] = HEAP8[i4 >> 0] | 0;
   HEAP8[i14 + (i1 + 2) >> 0] = HEAP8[i11 + (i2 | 1) >> 0] | 0;
   HEAP8[i14 + (i1 + 3) >> 0] = HEAP8[i11 + (i2 | 2) >> 0] | 0;
   HEAP8[i14 + (i1 + 4) >> 0] = HEAP8[i11 + (i2 | 3) >> 0] | 0;
   i1 = i1 + 5 | 0;
   i2 = i2 + 4 | 0;
  } while (i2 >>> 0 < i10 >>> 0);
 }
 if (i15) {
  HEAP32[i12 >> 2] = 0;
  _memcpy(i12 | 0, i11 + i2 | 0, i15 | 0) | 0;
  i9 = HEAP16[i12 >> 1] | 0;
  i6 = HEAP32[i12 >> 2] | 0;
  i3 = i6 & 255;
  i4 = (i6 & 65535) >>> 8 & 255;
  i5 = i6 >>> 16 & 255;
  i6 = i6 >>> 24 & 255;
  i7 = 0;
  i8 = 0;
  do {
   i18 = i7 << 2;
   i8 = (HEAPU8[(HEAP8[(i18 | 1) + (gb + 17951) >> 0] & i4 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[gb + 17951 + i18 >> 0] & i3 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 2) + (gb + 17951) >> 0] & i5 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i18 | 3) + (gb + 17951) >> 0] & i6 & 255) + (gb + 36235) >> 0] | 0) & 1 | i8 << 1 & 510;
   i7 = i7 + 1 | 0;
  } while ((i7 | 0) != 7);
  HEAP8[i13 >> 0] = i3;
  HEAP8[i13 + 1 >> 0] = (i9 & 65535) >>> 8;
  HEAP8[i13 + 2 >> 0] = i5;
  HEAP8[i13 + 3 >> 0] = i6;
  HEAP8[i14 + i1 >> 0] = i8;
  _memcpy(i14 + (i1 + 1) | 0, i13 | 0, i15 | 0) | 0;
  i2 = i2 | i15;
  i1 = i15 + 1 + i1 | 0;
 }
 if ((i1 | 0) != ((i17 >>> 2) + i17 + ((i15 | 0) != 0 & 1) | 0)) ___assert_fail(gb + 18018 | 0, gb + 18082 | 0, 296, gb + 18111 | 0);
 if ((i2 | 0) == (i17 | 0)) {
  STACKTOP = i16;
  return;
 } else ___assert_fail(gb + 18406 | 0, gb + 18082 | 0, 297, gb + 18111 | 0);
}

function _modulator_emit(i22, i26, i25, i24) {
 i22 = i22 | 0;
 i26 = i26 | 0;
 i25 = i25 | 0;
 i24 = i24 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i23 = 0, i27 = 0, i28 = 0;
 i28 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i12 = i28 + 8 | 0;
 i23 = i28;
 if (!i22) {
  i27 = 0;
  STACKTOP = i28;
  return i27 | 0;
 }
 i21 = HEAP32[i22 >> 2] | 0;
 i27 = _llvm_stacksave() | 0;
 i16 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i21 << 3) | 0) + 15 & -16) | 0;
 if (!i25) i1 = 0; else {
  i17 = i22 + 28 | 0;
  i18 = i16 + 4 | 0;
  i19 = i22 + 24 | 0;
  i20 = i22 + 32 | 0;
  i13 = i22 + 16 | 0;
  i14 = i23 + 4 | 0;
  i15 = i12 + 4 | 0;
  i21 = 0;
  i1 = 0;
  do {
   i2 = HEAP32[i17 >> 2] | 0;
   i3 = HEAP32[i26 + (i21 << 3) >> 2] | 0;
   i4 = HEAP32[i26 + (i21 << 3) + 4 >> 2] | 0;
   if (!i2) {
    HEAP32[i16 >> 2] = i3;
    HEAP32[i18 >> 2] = i4;
   } else {
    d10 = (HEAP32[tempDoublePtr >> 2] = i3, +HEAPF32[tempDoublePtr >> 2]);
    _firinterp_crcf_execute(i2, d10, (HEAP32[tempDoublePtr >> 2] = i4, +HEAPF32[tempDoublePtr >> 2]), i16);
   }
   if (HEAP32[i22 >> 2] | 0) {
    i4 = HEAP32[i19 >> 2] | 0;
    i11 = 0;
    do {
     d8 = +HEAPF32[i16 + (i11 << 3) >> 2];
     d9 = +HEAPF32[i16 + (i11 << 3) + 4 >> 2];
     mftCall_vi(HEAP32[i4 + 1048 >> 2] | 0, i4 | 0);
     d10 = +HEAPF32[i4 + 1040 >> 2];
     d7 = +HEAPF32[i4 + 1044 >> 2] + d10 * 0.0;
     d5 = d8 * d7 - d9 * d10;
     d6 = d8 * d10 + d9 * d7;
     if ((d5 != d5 | 0.0 != 0.0) & (d6 != d6 | 0.0 != 0.0)) {
      ___mulsc3(i12, d8, d9, d7, d10);
      d5 = +HEAPF32[i12 >> 2];
      d6 = +HEAPF32[i15 >> 2];
     }
     HEAPF32[i23 >> 2] = d5;
     HEAPF32[i14 >> 2] = d6;
     i2 = HEAP32[i20 >> 2] | 0;
     if (i2) {
      _iirfilt_crcf_execute(i2, d5, d6, i23);
      d5 = +HEAPF32[i23 >> 2];
     }
     i3 = HEAP32[i22 >> 2] | 0;
     HEAPF32[i24 + ((Math_imul(i3, i21) | 0) + i11 << 2) >> 2] = d5 * +HEAPF32[i13 >> 2];
     i1 = i1 + 1 | 0;
     i4 = HEAP32[i19 >> 2] | 0;
     i2 = i4 + 4 | 0;
     d5 = +HEAPF32[i4 + 8 >> 2] + +HEAPF32[i2 >> 2];
     HEAPF32[i2 >> 2] = d5;
     if (!(d5 > 3.141592653589793)) {
      if (d5 < -3.141592653589793) HEAPF32[i2 >> 2] = d5 + 6.283185307179586;
     } else HEAPF32[i2 >> 2] = d5 + -6.283185307179586;
     i11 = i11 + 1 | 0;
    } while (i11 >>> 0 < i3 >>> 0);
   }
   i21 = i21 + 1 | 0;
  } while ((i21 | 0) != (i25 | 0));
 }
 _llvm_stackrestore(i27 | 0);
 i27 = i1;
 STACKTOP = i28;
 return i27 | 0;
}

function _resamp_rrrf_create(d3, i10, d12, d11, i14) {
 d3 = +d3;
 i10 = i10 | 0;
 d12 = +d12;
 d11 = +d11;
 i14 = i14 | 0;
 var i1 = 0, F42 = SIMD_Float32x4(0, 0, 0, 0), i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, d9 = 0.0, i13 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i6 = i15 + 32 | 0;
 i8 = i15 + 24 | 0;
 i7 = i15 + 16 | 0;
 i5 = i15 + 8 | 0;
 i4 = i15;
 if (d3 <= 0.0) {
  HEAP32[i4 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19977 | 0, i4);
  _exit(1);
 }
 if (!i10) {
  HEAP32[i5 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 20047 | 0, i5);
  _exit(1);
 }
 if (!i14) {
  HEAP32[i7 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 20120 | 0, i7);
  _exit(1);
 }
 if (d12 <= 0.0 | d12 >= .5) {
  HEAP32[i8 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 20197 | 0, i8);
  _exit(1);
 }
 if (d11 <= 0.0) {
  HEAP32[i6 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 20258 | 0, i6);
  _exit(1);
 }
 i13 = _malloc(56) | 0;
 HEAPF32[i13 + 12 >> 2] = d3;
 HEAPF32[i13 + 16 >> 2] = 1.0 / d3;
 HEAP32[i13 >> 2] = i10;
 HEAPF32[i13 + 8 >> 2] = d12;
 HEAPF32[i13 + 4 >> 2] = d11;
 HEAP32[i13 + 44 >> 2] = i14;
 i5 = Math_imul(i10 << 1, i14) | 0;
 i6 = i5 | 1;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i6 << 2) | 0) + 15 & -16) | 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i6 << 2) | 0) + 15 & -16) | 0;
 d9 = +(i14 >>> 0);
 _liquid_firdes_kaiser(i6, d12 / d9, d11, i7);
 d3 = 0.0;
 i4 = 0;
 do {
  d3 = d3 + +HEAPF32[i7 + (i4 << 2) >> 2];
  i4 = i4 + 1 | 0;
 } while ((i4 | 0) != (i6 | 0));
 d3 = d9 / d3;
 if (i5 >>> 0 >= 4 ? (i1 = i5 & -4, (i1 | 0) != 0) : 0) {
  F42 = SIMD_Float32x4_splat(Math_fround(d3));
  i4 = 0;
  do {
   SIMD_Float32x4_store(HEAPU8, i8 + (i4 << 2) | 0, SIMD_Float32x4_mul(F42, SIMD_Float32x4_load(HEAPU8, i7 + (i4 << 2) | 0)));
   i4 = i4 + 4 | 0;
  } while ((i4 | 0) != (i1 | 0));
 } else i1 = 0;
 do {
  HEAPF32[i8 + (i1 << 2) >> 2] = d3 * +HEAPF32[i7 + (i1 << 2) >> 2];
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i6 | 0));
 i14 = _firpfb_rrrf_create(i14, i8, i5) | 0;
 HEAP32[i13 + 48 >> 2] = i14;
 i14 = HEAP32[i14 + 16 >> 2] | 0;
 HEAP32[i14 + 24 >> 2] = 0;
 _memset(HEAP32[i14 >> 2] | 0, 0, HEAP32[i14 + 20 >> 2] << 2 | 0) | 0;
 HEAP32[i13 + 52 >> 2] = 1;
 i14 = i13 + 20 | 0;
 HEAP32[i14 >> 2] = 0;
 HEAP32[i14 + 4 >> 2] = 0;
 HEAP32[i14 + 8 >> 2] = 0;
 HEAP32[i14 + 12 >> 2] = 0;
 HEAP32[i14 + 16 >> 2] = 0;
 HEAP32[i14 + 20 >> 2] = 0;
 STACKTOP = i15;
 return i13 | 0;
}

function ___stdio_write(i14, i2, i1) {
 i14 = i14 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i11 = i15 + 16 | 0;
 i10 = i15;
 i8 = i15 + 32 | 0;
 i12 = i14 + 28 | 0;
 i5 = HEAP32[i12 >> 2] | 0;
 HEAP32[i8 >> 2] = i5;
 i13 = i14 + 20 | 0;
 i5 = (HEAP32[i13 >> 2] | 0) - i5 | 0;
 HEAP32[i8 + 4 >> 2] = i5;
 HEAP32[i8 + 8 >> 2] = i2;
 HEAP32[i8 + 12 >> 2] = i1;
 i7 = i14 + 60 | 0;
 i9 = i14 + 44 | 0;
 i4 = 2;
 i5 = i5 + i1 | 0;
 while (1) {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) {
   HEAP32[i11 >> 2] = HEAP32[i7 >> 2];
   HEAP32[i11 + 4 >> 2] = i8;
   HEAP32[i11 + 8 >> 2] = i4;
   i2 = ___syscall146(146, i11 | 0) | 0;
   if (i2 >>> 0 > 4294963200) {
    if (!(HEAP32[gb + 41360 >> 2] | 0)) i3 = gb + 41404 | 0; else i3 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
    HEAP32[i3 >> 2] = 0 - i2;
    i2 = -1;
   }
  } else {
   _pthread_cleanup_push(fb + 19 | 0, i14 | 0);
   HEAP32[i10 >> 2] = HEAP32[i7 >> 2];
   HEAP32[i10 + 4 >> 2] = i8;
   HEAP32[i10 + 8 >> 2] = i4;
   i2 = ___syscall146(146, i10 | 0) | 0;
   if (i2 >>> 0 > 4294963200) {
    if (!(HEAP32[gb + 41360 >> 2] | 0)) i3 = gb + 41404 | 0; else i3 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
    HEAP32[i3 >> 2] = 0 - i2;
    i2 = -1;
   }
   _pthread_cleanup_pop(0);
  }
  if ((i5 | 0) == (i2 | 0)) {
   i2 = 13;
   break;
  }
  if ((i2 | 0) < 0) {
   i2 = 15;
   break;
  }
  i5 = i5 - i2 | 0;
  i3 = HEAP32[i8 + 4 >> 2] | 0;
  if (i2 >>> 0 <= i3 >>> 0) if ((i4 | 0) == 2) {
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + i2;
   i6 = i3;
   i3 = i8;
   i4 = 2;
  } else {
   i6 = i3;
   i3 = i8;
  } else {
   i6 = HEAP32[i9 >> 2] | 0;
   HEAP32[i12 >> 2] = i6;
   HEAP32[i13 >> 2] = i6;
   i6 = HEAP32[i8 + 12 >> 2] | 0;
   i2 = i2 - i3 | 0;
   i3 = i8 + 8 | 0;
   i4 = i4 + -1 | 0;
  }
  HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i2;
  HEAP32[i3 + 4 >> 2] = i6 - i2;
  i8 = i3;
 }
 if ((i2 | 0) == 13) {
  i11 = HEAP32[i9 >> 2] | 0;
  HEAP32[i14 + 16 >> 2] = i11 + (HEAP32[i14 + 48 >> 2] | 0);
  i14 = i11;
  HEAP32[i12 >> 2] = i14;
  HEAP32[i13 >> 2] = i14;
 } else if ((i2 | 0) == 15) {
  HEAP32[i14 + 16 >> 2] = 0;
  HEAP32[i12 >> 2] = 0;
  HEAP32[i13 >> 2] = 0;
  HEAP32[i14 >> 2] = HEAP32[i14 >> 2] | 32;
  if ((i4 | 0) == 2) i1 = 0; else i1 = i1 - (HEAP32[i8 + 4 >> 2] | 0) | 0;
 }
 STACKTOP = i15;
 return i1 | 0;
}
function _gmskmod_modulate(i15, i7, i16) {
 i15 = i15 | 0;
 i7 = i7 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i17 = 0, d18 = 0.0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i13 = i17;
 d3 = +HEAPF32[i15 + 28 >> 2];
 i14 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[i15 >> 2] << 2) | 0) + 15 & -16) | 0;
 i6 = HEAP32[i15 + 20 >> 2] | 0;
 i8 = i6 + 16 | 0;
 i2 = HEAP32[(HEAP32[i8 >> 2] | 0) + 16 >> 2] | 0;
 i4 = i2 + 24 | 0;
 i1 = HEAP32[i2 + 16 >> 2] & (HEAP32[i4 >> 2] | 0) + 1;
 HEAP32[i4 >> 2] = i1;
 if (!i1) {
  i1 = HEAP32[i2 >> 2] | 0;
  i5 = i2 + 4 | 0;
  _memmove(i1 | 0, i1 + (HEAP32[i2 + 12 >> 2] << 2) | 0, (HEAP32[i5 >> 2] << 2) + -4 | 0) | 0;
  i1 = HEAP32[i4 >> 2] | 0;
 } else i5 = i2 + 4 | 0;
 HEAPF32[(HEAP32[i2 >> 2] | 0) + (i1 + -1 + (HEAP32[i5 >> 2] | 0) << 2) >> 2] = (i7 | 0) == 0 ? -d3 : d3;
 i12 = HEAP32[i6 + 12 >> 2] | 0;
 L5 : do if (i12 | 0) {
  i11 = HEAP32[i8 >> 2] | 0;
  i8 = HEAP32[i11 + 12 >> 2] | 0;
  i9 = i11 + 16 | 0;
  i10 = i11 + 20 | 0;
  i11 = i11 + 24 | 0;
  i1 = 0;
  while (1) {
   i7 = i14 + (i1 << 2) | 0;
   if (i8 >>> 0 <= i1 >>> 0) break;
   i2 = HEAP32[i9 >> 2] | 0;
   i2 = (HEAP32[i2 >> 2] | 0) + (HEAP32[i2 + 24 >> 2] << 2) | 0;
   i5 = HEAP32[(HEAP32[i10 >> 2] | 0) + (i1 << 2) >> 2] | 0;
   i4 = HEAP32[i5 >> 2] | 0;
   i5 = HEAP32[i5 + 4 >> 2] | 0;
   if (!i5) d3 = 0.0; else {
    i6 = 0;
    d3 = 0.0;
    do {
     d3 = d3 + +HEAPF32[i4 + (i6 << 2) >> 2] * +HEAPF32[i2 + (i6 << 2) >> 2];
     i6 = i6 + 1 | 0;
    } while ((i6 | 0) != (i5 | 0));
   }
   HEAPF32[i7 >> 2] = d3 * +HEAPF32[i11 >> 2];
   i1 = i1 + 1 | 0;
   if (i1 >>> 0 >= i12 >>> 0) break L5;
  }
  HEAP32[i13 >> 2] = i1;
  HEAP32[i13 + 4 >> 2] = i8;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i13);
  _exit(1);
 } while (0);
 if (!(HEAP32[i15 >> 2] | 0)) {
  STACKTOP = i17;
  return;
 }
 i1 = i15 + 24 | 0;
 i2 = 0;
 do {
  d18 = +HEAPF32[i14 + (i2 << 2) >> 2] + +HEAPF32[i1 >> 2];
  d3 = d18;
  d18 = d3 > 3.141592653589793 ? d3 + -6.283185307179586 : d18;
  d3 = d18;
  d18 = d3 < -3.141592653589793 ? d3 + 6.283185307179586 : d18;
  HEAPF32[i1 >> 2] = d18;
  d3 = +Math_sin(+d18);
  HEAPF32[i16 + (i2 << 3) >> 2] = +Math_cos(+d18) + d3 * 0.0;
  HEAPF32[i16 + (i2 << 3) + 4 >> 2] = d3;
  i2 = i2 + 1 | 0;
 } while (i2 >>> 0 < (HEAP32[i15 >> 2] | 0) >>> 0);
 STACKTOP = i17;
 return;
}

function _fec_conv_punctured_decode_hard(i17, i1, i14, i16) {
 i17 = i17 | 0;
 i1 = i1 | 0;
 i14 = i14 | 0;
 i16 = i16 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0;
 i15 = i17 + 8 | 0;
 if ((HEAP32[i15 >> 2] | 0) == (i1 | 0)) {
  i3 = i17 + 28 | 0;
  i6 = i17 + 32 | 0;
 } else {
  HEAP32[i15 >> 2] = i1;
  HEAP32[i17 + 12 >> 2] = _fec_get_enc_msg_length(HEAP32[i17 >> 2] | 0, i1) | 0;
  i1 = HEAP32[i15 >> 2] | 0;
  i6 = i17 + 32 | 0;
  i3 = i17 + 28 | 0;
  i4 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, HEAP32[i3 >> 2] | 0) | 0;
  i5 = i17 + 20 | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  if (i2) {
   mftCall_vi(HEAP32[i17 + 60 >> 2] | 0, i2 | 0);
   i1 = HEAP32[i15 >> 2] | 0;
  }
  HEAP32[i5 >> 2] = mftCall_ii(HEAP32[i17 + 44 >> 2] | 0, i1 << 3 | 0) | 0;
  i1 = i17 + 16 | 0;
  HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i4) | 0;
  i1 = HEAP32[i15 >> 2] | 0;
 }
 i2 = HEAP32[i3 >> 2] | 0;
 i11 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, i2) | 0;
 if (!i11) i1 = i17 + 16 | 0; else {
  i12 = i17 + 36 | 0;
  i13 = i17 + 40 | 0;
  i1 = i17 + 16 | 0;
  i4 = HEAP8[i14 >> 0] | 0;
  i9 = 0;
  i7 = 0;
  i5 = 0;
  i10 = 0;
  while (1) {
   if (!i2) i2 = 0; else {
    i2 = i7;
    i8 = 0;
    while (1) {
     i7 = (Math_imul(HEAP32[i12 >> 2] | 0, i8) | 0) + i10 | 0;
     if (HEAP32[(HEAP32[i13 >> 2] | 0) + (i7 << 2) >> 2] | 0) {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i8 + i9) >> 0] = ((1 << 7 - i2 & (i4 & 255) | 0) != 0) << 31 >> 31;
      i2 = i2 + 1 | 0;
      if ((i2 | 0) == 8) {
       i5 = i5 + 1 | 0;
       i4 = HEAP8[i14 + i5 >> 0] | 0;
       i7 = 0;
      } else i7 = i2;
     } else {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i8 + i9) >> 0] = 127;
      i7 = i2;
     }
     i8 = i8 + 1 | 0;
     i2 = HEAP32[i3 >> 2] | 0;
     if (i8 >>> 0 >= i2 >>> 0) break; else i2 = i7;
    }
   }
   i9 = i2 + i9 | 0;
   if (i9 >>> 0 >= i11 >>> 0) break; else i10 = ((i10 + 1 | 0) >>> 0) % ((HEAP32[i12 >> 2] | 0) >>> 0) | 0;
  }
 }
 i14 = i17 + 20 | 0;
 mftCall_iii(HEAP32[i17 + 48 >> 2] | 0, HEAP32[i14 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i17 + 52 >> 2] | 0, HEAP32[i14 >> 2] | 0, HEAP32[i1 >> 2] | 0, (HEAP32[i6 >> 2] | 0) + -1 + (HEAP32[i15 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i17 + 56 >> 2] | 0, HEAP32[i14 >> 2] | 0, i16 | 0, HEAP32[i15 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _pop_arg(i2, i3, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0, d6 = 0.0;
 L1 : do if (i3 >>> 0 <= 20) do switch (i3 | 0) {
 case 9:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i3 = HEAP32[i4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 4;
   HEAP32[i2 >> 2] = i3;
   break L1;
  }
 case 10:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i3 = HEAP32[i4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 4;
   i4 = i2;
   HEAP32[i4 >> 2] = i3;
   HEAP32[i4 + 4 >> 2] = ((i3 | 0) < 0) << 31 >> 31;
   break L1;
  }
 case 11:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i3 = HEAP32[i4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 4;
   i4 = i2;
   HEAP32[i4 >> 2] = i3;
   HEAP32[i4 + 4 >> 2] = 0;
   break L1;
  }
 case 12:
  {
   i4 = (HEAP32[i1 >> 2] | 0) + (8 - 1) & ~(8 - 1);
   i3 = i4;
   i5 = HEAP32[i3 >> 2] | 0;
   i3 = HEAP32[i3 + 4 >> 2] | 0;
   HEAP32[i1 >> 2] = i4 + 8;
   i4 = i2;
   HEAP32[i4 >> 2] = i5;
   HEAP32[i4 + 4 >> 2] = i3;
   break L1;
  }
 case 13:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i4 = (i4 & 65535) << 16 >> 16;
   i5 = i2;
   HEAP32[i5 >> 2] = i4;
   HEAP32[i5 + 4 >> 2] = ((i4 | 0) < 0) << 31 >> 31;
   break L1;
  }
 case 14:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i5 = i2;
   HEAP32[i5 >> 2] = i4 & 65535;
   HEAP32[i5 + 4 >> 2] = 0;
   break L1;
  }
 case 15:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i4 = (i4 & 255) << 24 >> 24;
   i5 = i2;
   HEAP32[i5 >> 2] = i4;
   HEAP32[i5 + 4 >> 2] = ((i4 | 0) < 0) << 31 >> 31;
   break L1;
  }
 case 16:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (4 - 1) & ~(4 - 1);
   i4 = HEAP32[i5 >> 2] | 0;
   HEAP32[i1 >> 2] = i5 + 4;
   i5 = i2;
   HEAP32[i5 >> 2] = i4 & 255;
   HEAP32[i5 + 4 >> 2] = 0;
   break L1;
  }
 case 17:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (8 - 1) & ~(8 - 1);
   d6 = +HEAPF64[i5 >> 3];
   HEAP32[i1 >> 2] = i5 + 8;
   HEAPF64[i2 >> 3] = d6;
   break L1;
  }
 case 18:
  {
   i5 = (HEAP32[i1 >> 2] | 0) + (8 - 1) & ~(8 - 1);
   d6 = +HEAPF64[i5 >> 3];
   HEAP32[i1 >> 2] = i5 + 8;
   HEAPF64[i2 >> 3] = d6;
   break L1;
  }
 default:
  break L1;
 } while (0); while (0);
 return;
}

function _flexframegen_assemble(i11, i1, i10, i2) {
 i11 = i11 | 0;
 i1 = i1 | 0;
 i10 = i10 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i12 = 0, i13 = 0;
 i4 = i11 + 104 | 0;
 HEAP32[i4 >> 2] = 0;
 HEAP32[i4 + 4 >> 2] = 0;
 HEAP32[i4 + 8 >> 2] = 0;
 HEAP32[i4 + 12 >> 2] = 0;
 HEAP32[i4 + 16 >> 2] = 0;
 i4 = i11 + 88 | 0;
 HEAP32[i4 >> 2] = i2;
 i9 = i11 + 52 | 0;
 i3 = i11 + 56 | 0;
 _memmove(HEAP32[i9 >> 2] | 0, i1 | 0, HEAP32[i3 >> 2] | 0) | 0;
 i3 = HEAP32[i3 >> 2] | 0;
 HEAP8[(HEAP32[i9 >> 2] | 0) + i3 >> 0] = 101;
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i3 + 1) >> 0] = (HEAP32[i4 >> 2] | 0) >>> 8;
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i3 + 2) >> 0] = HEAP32[i4 >> 2];
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i3 + 3) >> 0] = HEAP32[i11 + 44 >> 2];
 i4 = i3 + 4 | 0;
 HEAP8[(HEAP32[i9 >> 2] | 0) + i4 >> 0] = HEAP32[i11 + 32 >> 2] << 5;
 i4 = (HEAP32[i9 >> 2] | 0) + i4 | 0;
 HEAP8[i4 >> 0] = HEAPU8[i4 >> 0] | 0 | HEAP32[i11 + 36 >> 2] & 31;
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i3 + 5) >> 0] = HEAP32[i11 + 40 >> 2] & 31;
 i3 = i11 + 72 | 0;
 _qpacketmodem_encode(HEAP32[i11 + 64 >> 2] | 0, HEAP32[i9 >> 2] | 0, HEAP32[i3 >> 2] | 0);
 i9 = HEAP32[i11 + 76 >> 2] | 0;
 i3 = HEAP32[i3 >> 2] | 0;
 i4 = HEAP32[i11 + 84 >> 2] | 0;
 i5 = i9 + 12 | 0;
 if (!(HEAP32[i5 >> 2] | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i6 = i9 + 4 | 0;
  i7 = i9 + 16 | 0;
  i8 = 0;
  i2 = 0;
  i1 = 0;
  do {
   if (!((i8 >>> 0) % ((HEAP32[i6 >> 2] | 0) >>> 0) | 0)) {
    i13 = HEAP32[i7 >> 2] | 0;
    i12 = HEAP32[i13 + (i1 << 3) + 4 >> 2] | 0;
    HEAP32[i4 + (i8 << 3) >> 2] = HEAP32[i13 + (i1 << 3) >> 2];
    HEAP32[i4 + (i8 << 3) + 4 >> 2] = i12;
    i1 = i1 + 1 | 0;
   } else {
    i13 = HEAP32[i3 + (i2 << 3) + 4 >> 2] | 0;
    HEAP32[i4 + (i8 << 3) >> 2] = HEAP32[i3 + (i2 << 3) >> 2];
    HEAP32[i4 + (i8 << 3) + 4 >> 2] = i13;
    i2 = i2 + 1 | 0;
   }
   i8 = i8 + 1 | 0;
  } while (i8 >>> 0 < (HEAP32[i5 >> 2] | 0) >>> 0);
 }
 if ((i2 | 0) != (HEAP32[i9 >> 2] | 0)) ___assert_fail(gb + 27583 | 0, gb + 27604 | 0, 157, gb + 27632 | 0);
 if ((i1 | 0) == (HEAP32[i9 + 8 >> 2] | 0)) {
  _flexframegen_reconfigure(i11);
  _qpacketmodem_encode(HEAP32[i11 + 92 >> 2] | 0, i10, HEAP32[i11 + 100 >> 2] | 0);
  HEAP32[i11 + 112 >> 2] = 1;
  return;
 } else ___assert_fail(gb + 27650 | 0, gb + 27604 | 0, 158, gb + 27632 | 0);
}

function _scanexp(i8, i3) {
 i8 = i8 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i6 = i8 + 4 | 0;
 i1 = HEAP32[i6 >> 2] | 0;
 i7 = i8 + 100 | 0;
 if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
  HEAP32[i6 >> 2] = i1 + 1;
  i1 = HEAPU8[i1 >> 0] | 0;
 } else i1 = ___shgetc(i8) | 0;
 switch (i1 | 0) {
 case 43:
 case 45:
  {
   i2 = (i1 | 0) == 45 & 1;
   i1 = HEAP32[i6 >> 2] | 0;
   if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
    HEAP32[i6 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i8) | 0;
   if ((i3 | 0) != 0 & (i1 + -48 | 0) >>> 0 > 9 ? (HEAP32[i7 >> 2] | 0) != 0 : 0) HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + -1;
   break;
  }
 default:
  i2 = 0;
 }
 if ((i1 + -48 | 0) >>> 0 > 9) if (!(HEAP32[i7 >> 2] | 0)) {
  i2 = -2147483648;
  i1 = 0;
 } else {
  HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + -1;
  i2 = -2147483648;
  i1 = 0;
 } else {
  i5 = 0;
  do {
   i5 = i1 + -48 + (i5 * 10 | 0) | 0;
   i1 = HEAP32[i6 >> 2] | 0;
   if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
    HEAP32[i6 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i8) | 0;
   i3 = (i1 + -48 | 0) >>> 0 < 10;
  } while ((i5 | 0) < 214748364 & i3);
  i4 = ((i5 | 0) < 0) << 31 >> 31;
  if (i3) {
   i3 = i5;
   do {
    i3 = ___muldi3(i3 | 0, i4 | 0, 10, 0) | 0;
    i3 = _i64Add(i3 | 0, getTempRet0() | 0, -48, -1) | 0;
    i3 = _i64Add(i3 | 0, getTempRet0() | 0, i1 | 0, ((i1 | 0) < 0) << 31 >> 31 | 0) | 0;
    i4 = getTempRet0() | 0;
    i1 = HEAP32[i6 >> 2] | 0;
    if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
     HEAP32[i6 >> 2] = i1 + 1;
     i1 = HEAPU8[i1 >> 0] | 0;
    } else i1 = ___shgetc(i8) | 0;
   } while (((i4 | 0) < 21474836 | (i4 | 0) == 21474836 & i3 >>> 0 < 2061584302) & (i1 + -48 | 0) >>> 0 < 10);
  } else i3 = i5;
  if ((i1 + -48 | 0) >>> 0 < 10) do {
   i1 = HEAP32[i6 >> 2] | 0;
   if (i1 >>> 0 < (HEAP32[i7 >> 2] | 0) >>> 0) {
    HEAP32[i6 >> 2] = i1 + 1;
    i1 = HEAPU8[i1 >> 0] | 0;
   } else i1 = ___shgetc(i8) | 0;
  } while ((i1 + -48 | 0) >>> 0 < 10);
  if (HEAP32[i7 >> 2] | 0) HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + -1;
  i8 = (i2 | 0) != 0;
  i1 = _i64Subtract(0, 0, i3 | 0, i4 | 0) | 0;
  i2 = getTempRet0() | 0;
  i2 = i8 ? i2 : i4;
  i1 = i8 ? i1 : i3;
 }
 setTempRet0(i2 | 0);
 return i1 | 0;
}

function _firdespm_compute_interp(i13) {
 i13 = i13 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, d15 = 0.0;
 i14 = HEAP32[i13 + 12 >> 2] | 0;
 i12 = i14 + 1 | 0;
 if (i12) {
  i2 = i13 + 88 | 0;
  i1 = HEAP32[i2 >> 2] | 0;
  i4 = HEAP32[i13 + 48 >> 2] | 0;
  i10 = HEAP32[i13 + 64 >> 2] | 0;
  i5 = 0;
  do {
   HEAPF64[i10 + (i5 << 3) >> 3] = +Math_cos(+(+HEAPF64[i4 + (HEAP32[i1 + (i5 << 2) >> 2] << 3) >> 3] * 6.283185307179586));
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i12 | 0));
  i1 = i13 + 68 | 0;
  i9 = HEAP32[i1 >> 2] | 0;
  i7 = 0;
  do {
   i4 = i9 + (i7 << 3) | 0;
   HEAPF64[i4 >> 3] = 1.0;
   i5 = i10 + (i7 << 3) | 0;
   d3 = 1.0;
   i8 = 0;
   do {
    if ((i7 | 0) != (i8 | 0)) {
     d3 = d3 * (+HEAPF64[i5 >> 3] - +HEAPF64[i10 + (i8 << 3) >> 3]);
     HEAPF64[i4 >> 3] = d3;
    }
    i8 = i8 + 1 | 0;
   } while ((i8 | 0) != (i12 | 0));
   HEAPF64[i4 >> 3] = 1.0 / d3;
   i7 = i7 + 1 | 0;
  } while ((i7 | 0) != (i12 | 0));
  d3 = +HEAPF64[i9 >> 3];
  HEAPF64[i9 >> 3] = d3 / d3;
  if (i14) {
   i2 = 1;
   do {
    i11 = i9 + (i2 << 3) | 0;
    HEAPF64[i11 >> 3] = +HEAPF64[i11 >> 3] / d3;
    i2 = i2 + 1 | 0;
   } while ((i2 | 0) != (i12 | 0));
   i11 = 13;
  }
 } else {
  i1 = i13 + 68 | 0;
  i11 = 13;
 }
 do if ((i11 | 0) == 13) {
  if ((i14 | 0) != -1) {
   i2 = i13 + 88 | 0;
   break;
  }
  HEAPF64[i13 + 80 >> 3] = nan;
  return;
 } while (0);
 i4 = HEAP32[i1 >> 2] | 0;
 i5 = HEAP32[i2 >> 2] | 0;
 i7 = HEAP32[i13 + 52 >> 2] | 0;
 i8 = HEAP32[i13 + 56 >> 2] | 0;
 i1 = 0;
 d3 = 0.0;
 d6 = 0.0;
 do {
  d15 = +HEAPF64[i4 + (i1 << 3) >> 3];
  i11 = HEAP32[i5 + (i1 << 2) >> 2] | 0;
  d3 = d3 + d15 * +HEAPF64[i7 + (i11 << 3) >> 3];
  d6 = d6 + (i1 & 1 | 0 ? -1.0 : 1.0) * (d15 / +HEAPF64[i8 + (i11 << 3) >> 3]);
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i12 | 0));
 d3 = d3 / d6;
 i4 = i13 + 80 | 0;
 HEAPF64[i4 >> 3] = d3;
 i1 = HEAP32[i13 + 72 >> 2] | 0;
 i2 = 0;
 while (1) {
  i13 = HEAP32[i5 + (i2 << 2) >> 2] | 0;
  HEAPF64[i1 + (i2 << 3) >> 3] = +HEAPF64[i7 + (i13 << 3) >> 3] - d3 * +((i2 << 1 & 2 ^ 2) + -1 | 0) / +HEAPF64[i8 + (i13 << 3) >> 3];
  if ((i2 | 0) == (i14 | 0)) break;
  d3 = +HEAPF64[i4 >> 3];
  i2 = i2 + 1 | 0;
 }
 return;
}

function _matrixf_mul(i10, i2, i11, i12, i4, i3, i13, i15, i14) {
 i10 = i10 | 0;
 i2 = i2 | 0;
 i11 = i11 | 0;
 i12 = i12 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 i13 = i13 | 0;
 i15 = i15 | 0;
 i14 = i14 | 0;
 var i1 = 0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0, i9 = 0;
 if ((i11 | 0) == (i4 | 0) & ((i15 | 0) == (i2 | 0) & (i14 | 0) == (i3 | 0))) {
  if ((i15 | 0) == 0 | (i14 | 0) == 0) return;
  i2 = i14 << 2;
  if (!i11) {
   i1 = 0;
   do {
    _memset(i13 + ((Math_imul(i1, i14) | 0) << 2) | 0, 0, i2 | 0) | 0;
    i1 = i1 + 1 | 0;
   } while ((i1 | 0) != (i15 | 0));
   return;
  } else i5 = 0;
  do {
   i2 = Math_imul(i5, i14) | 0;
   i1 = Math_imul(i5, i11) | 0;
   i3 = 0;
   do {
    i4 = 0;
    d6 = 0.0;
    do {
     d6 = d6 + +HEAPF32[i10 + (i4 + i1 << 2) >> 2] * +HEAPF32[i12 + ((Math_imul(i4, i14) | 0) + i3 << 2) >> 2];
     i4 = i4 + 1 | 0;
    } while ((i4 | 0) != (i11 | 0));
    HEAPF32[i13 + (i3 + i2 << 2) >> 2] = d6;
    i3 = i3 + 1 | 0;
   } while ((i3 | 0) != (i14 | 0));
   i5 = i5 + 1 | 0;
  } while ((i5 | 0) != (i15 | 0));
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i5 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i5;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i5 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i5 - i1 | 0) >>> 0 < 40) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27967 | 0, 40) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27967 | 0, 40) | 0) >>> 0 < 40) _exit(1); else {
  i7 = 0;
  i8 = gb + 27967 + 40 | 0;
  i9 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i7 = 40;
  i8 = gb + 27967 | 0;
  i9 = i1;
 } while (0);
 _memcpy(i9 | 0, i8 | 0, i7 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i7;
 _exit(1);
}

function _expm1f(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, i7 = 0, d8 = 0.0;
 i3 = (HEAPF32[tempDoublePtr >> 2] = d1, HEAP32[tempDoublePtr >> 2] | 0);
 d6 = +Math_abs(+d1);
 i2 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
 i3 = i3 >>> 31;
 do if (i2 >>> 0 > 1100331075) {
  if (i2 >>> 0 <= 2139095040) if (!i3) if (d1 > 88.7216796875) d1 = d1 * 1701411834604692317316873.0e14; else i7 = 11; else d1 = -1.0;
 } else {
  if (i2 >>> 0 <= 1051816472) if (i2 >>> 0 < 855638016) break; else {
   d6 = 0.0;
   i3 = 0;
   i7 = 14;
   break;
  }
  if (i2 >>> 0 < 1065686418) if (!i3) {
   d4 = d1 + -.6931381225585938;
   i2 = 1;
   d5 = 9.05800061445916e-06;
   i7 = 12;
   break;
  } else {
   d4 = d1 + .6931381225585938;
   i2 = -1;
   d5 = -9.05800061445916e-06;
   i7 = 12;
   break;
  } else i7 = 11;
 } while (0);
 if ((i7 | 0) == 11) {
  i2 = ~~(d1 * 1.4426950216293335 + (i3 | 0 ? -.5 : .5));
  d5 = +(i2 | 0);
  d4 = d1 - d5 * .6931381225585938;
  d5 = d5 * 9.05800061445916e-06;
  i7 = 12;
 }
 if ((i7 | 0) == 12) {
  d6 = d4 - d5;
  d1 = d6;
  d6 = d4 - d6 - d5;
  i3 = i2;
  i7 = 14;
 }
 L18 : do if ((i7 | 0) == 14) {
  d5 = d1 * .5;
  d4 = d1 * d5;
  d8 = d4 * (d4 * 1.5807170420885086e-03 + -.03333321213722229) + 1.0;
  d5 = 3.0 - d5 * d8;
  d5 = d4 * ((d8 - d5) / (6.0 - d1 * d5));
  if (!i3) {
   d1 = d1 - (d1 * d5 - d4);
   break;
  }
  d4 = d1 * (d5 - d6) - d6 - d4;
  switch (i3 | 0) {
  case -1:
   {
    d1 = (d1 - d4) * .5 + -.5;
    break L18;
   }
  case 1:
   if (d1 < -.25) {
    d1 = (d4 - (d1 + .5)) * -2.0;
    break L18;
   } else {
    d1 = (d1 - d4) * 2.0 + 1.0;
    break L18;
   }
  default:
   {
    d5 = (HEAP32[tempDoublePtr >> 2] = (i3 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
    if (i3 >>> 0 > 56) {
     d1 = d1 - d4 + 1.0;
     d1 = ((i3 | 0) == 128 ? d1 * 2.0 * 1701411834604692317316873.0e14 : d5 * d1) + -1.0;
     break L18;
    }
    i2 = 127 - i3 << 23;
    if ((i3 | 0) < 23) d1 = 1.0 - (HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]) + (d1 - d4); else d1 = d1 - ((HEAP32[tempDoublePtr >> 2] = i2, +HEAPF32[tempDoublePtr >> 2]) + d4) + 1.0;
    d1 = d5 * d1;
    break L18;
   }
  }
 } while (0);
 return +d1;
}

function _firpfb_crcf_create(i12, i11, i3) {
 i12 = i12 | 0;
 i11 = i11 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i13 = 0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i13 + 8 | 0;
 i1 = i13;
 if (!i12) {
  HEAP32[i1 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18810 | 0, i1);
  _exit(1);
 }
 if (!i3) {
  HEAP32[i2 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18882 | 0, i2);
  _exit(1);
 }
 i9 = _malloc(28) | 0;
 i7 = i9 + 12 | 0;
 HEAP32[i7 >> 2] = i12;
 HEAP32[i9 + 4 >> 2] = i3;
 i10 = _malloc(i12 << 2) | 0;
 HEAP32[i9 + 20 >> 2] = i10;
 i8 = (i3 >>> 0) / (i12 >>> 0) | 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i8 << 2) | 0) + 15 & -16) | 0;
 i3 = i8 + -1 | 0;
 if (!i8) {
  i1 = 0;
  do {
   i11 = _malloc(8) | 0;
   HEAP32[i11 + 4 >> 2] = 0;
   HEAP32[i11 >> 2] = _malloc(0) | 0;
   HEAP32[i10 + (i1 << 2) >> 2] = i11;
   i1 = i1 + 1 | 0;
  } while ((i1 | 0) != (i12 | 0));
  i12 = i9 + 8 | 0;
  HEAP32[i12 >> 2] = i8;
  i12 = _windowcf_create(i8) | 0;
  i11 = i9 + 16 | 0;
  HEAP32[i11 >> 2] = i12;
  i11 = i9 + 24 | 0;
  HEAPF32[i11 >> 2] = 1.0;
  i11 = i12 + 24 | 0;
  HEAP32[i11 >> 2] = 0;
  i11 = HEAP32[i12 >> 2] | 0;
  i12 = i12 + 20 | 0;
  i12 = HEAP32[i12 >> 2] | 0;
  i12 = i12 << 3;
  _memset(i11 | 0, 0, i12 | 0) | 0;
  STACKTOP = i13;
  return i9 | 0;
 }
 i4 = i8 << 2;
 i5 = i12;
 i1 = 0;
 while (1) {
  i2 = 0;
  do {
   HEAP32[i6 + (i3 - i2 << 2) >> 2] = HEAP32[i11 + ((Math_imul(i2, i5) | 0) + i1 << 2) >> 2];
   i2 = i2 + 1 | 0;
  } while (i8 >>> 0 > i2 >>> 0);
  i5 = _malloc(8) | 0;
  HEAP32[i5 + 4 >> 2] = i8;
  i2 = _malloc(i4) | 0;
  HEAP32[i5 >> 2] = i2;
  _memcpy(i2 | 0, i6 | 0, i4 | 0) | 0;
  HEAP32[i10 + (i1 << 2) >> 2] = i5;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= i12 >>> 0) break;
  i5 = HEAP32[i7 >> 2] | 0;
 }
 i12 = i9 + 8 | 0;
 HEAP32[i12 >> 2] = i8;
 i12 = _windowcf_create(i8) | 0;
 i11 = i9 + 16 | 0;
 HEAP32[i11 >> 2] = i12;
 i11 = i9 + 24 | 0;
 HEAPF32[i11 >> 2] = 1.0;
 i11 = i12 + 24 | 0;
 HEAP32[i11 >> 2] = 0;
 i11 = HEAP32[i12 >> 2] | 0;
 i12 = i12 + 20 | 0;
 i12 = HEAP32[i12 >> 2] | 0;
 i12 = i12 << 3;
 _memset(i11 | 0, 0, i12 | 0) | 0;
 STACKTOP = i13;
 return i9 | 0;
}

function _gmskframegen_assemble(i14, i12, i13, i8, i5, i6, i7) {
 i14 = i14 | 0;
 i12 = i12 | 0;
 i13 = i13 | 0;
 i8 = i8 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i9 = 0, i10 = 0, i11 = 0;
 i10 = i14 + 72 | 0;
 i11 = i14 + 60 | 0;
 if ((((HEAP32[i10 >> 2] | 0) == (i8 | 0) ? (HEAP32[i11 >> 2] | 0) == (i5 | 0) : 0) ? (i4 = i14 + 64 | 0, (HEAP32[i4 >> 2] | 0) == (i6 | 0)) : 0) ? (i3 = i14 + 68 | 0, (HEAP32[i3 >> 2] | 0) == (i7 | 0)) : 0) {
  i1 = i14 + 56 | 0;
  i2 = i14 + 80 | 0;
 } else {
  HEAP32[i10 >> 2] = i8;
  HEAP32[i11 >> 2] = i5;
  i4 = i14 + 64 | 0;
  HEAP32[i4 >> 2] = i6;
  i3 = i14 + 68 | 0;
  HEAP32[i3 >> 2] = i7;
  i9 = i14 + 56 | 0;
  i1 = HEAP32[i9 >> 2] | 0;
  do if (!i1) i1 = _packetizer_create(i8, i5, i6, i7) | 0; else {
   if ((((HEAP32[i1 >> 2] | 0) == (i8 | 0) ? (HEAP32[i1 + 8 >> 2] | 0) == (i5 | 0) : 0) ? (i2 = HEAP32[i1 + 16 >> 2] | 0, (HEAP32[i2 + 8 >> 2] | 0) == (i6 | 0)) : 0) ? (HEAP32[i2 + 28 >> 2] | 0) == (i7 | 0) : 0) break;
   _packetizer_destroy(i1);
   i1 = _packetizer_create(i8, i5, i6, i7) | 0;
  } while (0);
  HEAP32[i9 >> 2] = i1;
  i1 = HEAP32[i1 + 4 >> 2] | 0;
  HEAP32[i14 + 76 >> 2] = i1;
  HEAP32[i14 + 24 >> 2] = i1 << 3;
  i2 = i14 + 80 | 0;
  HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i1) | 0;
  i1 = i9;
 }
 HEAP32[i14 + 88 >> 2] = 1;
 i9 = i14 + 44 | 0;
 i8 = i14 + 36 | 0;
 _memmove(HEAP32[i9 >> 2] | 0, i12 | 0, HEAP32[i8 >> 2] | 0) | 0;
 i12 = HEAP32[i8 >> 2] | 0;
 HEAP8[(HEAP32[i9 >> 2] | 0) + i12 >> 0] = 3;
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i12 + 1) >> 0] = (HEAP32[i10 >> 2] | 0) >>> 8;
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i12 + 2) >> 0] = HEAP32[i10 >> 2];
 i10 = i12 + 3 | 0;
 HEAP8[(HEAP32[i9 >> 2] | 0) + i10 >> 0] = HEAP32[i11 >> 2] << 5;
 i11 = (HEAP32[i9 >> 2] | 0) + i10 | 0;
 HEAP8[i11 >> 0] = HEAPU8[i11 >> 0] | 0 | HEAP32[i4 >> 2] & 31;
 HEAP8[(HEAP32[i9 >> 2] | 0) + (i12 + 4) >> 0] = HEAP32[i3 >> 2] & 31;
 i12 = i14 + 48 | 0;
 _packetizer_encode(HEAP32[i14 + 52 >> 2] | 0, HEAP32[i9 >> 2] | 0, HEAP32[i12 >> 2] | 0);
 _scramble_data(HEAP32[i12 >> 2] | 0, HEAP32[i14 + 40 >> 2] | 0);
 _packetizer_encode(HEAP32[i1 >> 2] | 0, i13, HEAP32[i2 >> 2] | 0);
 return;
}

function _fec_golay2412_encode(i1, i13, i11, i12) {
 i1 = i1 | 0;
 i13 = i13 | 0;
 i11 = i11 | 0;
 i12 = i12 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = (i13 >>> 0) % 3 | 0;
 i2 = i13 - i10 | 0;
 if ((i10 | 0) == (i13 | 0)) i1 = 0; else {
  i9 = 0;
  i1 = 0;
  do {
   i3 = HEAPU8[i11 + (i9 + 1) >> 0] | 0;
   i4 = HEAP8[i11 + (i9 + 2) >> 0] | 0;
   i5 = i3 >>> 4 | (HEAPU8[i11 + i9 >> 0] | 0) << 4;
   i6 = 0;
   i8 = 0;
   while (1) {
    i7 = HEAP32[gb + 324 + (i6 << 2) >> 2] & i5;
    i7 = (HEAPU8[(i7 >>> 8) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i7 & 255) + (gb + 36235) >> 0] | 0) & 1 | i8 << 1;
    i6 = i6 + 1 | 0;
    if ((i6 | 0) == 24) break; else i8 = i7;
   }
   i3 = i3 << 8 & 3840 | i4 & 255;
   i5 = 0;
   i6 = 0;
   while (1) {
    i4 = HEAP32[gb + 324 + (i5 << 2) >> 2] & i3;
    i4 = (HEAPU8[(i4 >>> 8) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i4 & 255) + (gb + 36235) >> 0] | 0) & 1 | i6 << 1;
    i5 = i5 + 1 | 0;
    if ((i5 | 0) == 24) break; else i6 = i4;
   }
   HEAP8[i12 + i1 >> 0] = i8 >>> 15;
   HEAP8[i12 + (i1 | 1) >> 0] = i8 >>> 7;
   HEAP8[i12 + (i1 + 2) >> 0] = i7;
   HEAP8[i12 + (i1 + 3) >> 0] = i6 >>> 15;
   HEAP8[i12 + (i1 + 4) >> 0] = i6 >>> 7;
   HEAP8[i12 + (i1 + 5) >> 0] = i4;
   i1 = i1 + 6 | 0;
   i9 = i9 + 3 | 0;
  } while (i9 >>> 0 < i2 >>> 0);
 }
 if (i2 >>> 0 < i13 >>> 0) {
  i6 = i1;
  while (1) {
   i3 = HEAPU8[i11 + i2 >> 0] | 0;
   i5 = 0;
   i7 = 0;
   while (1) {
    i4 = (HEAPU8[(HEAP32[gb + 324 + (i5 << 2) >> 2] & i3) + (gb + 36235) >> 0] | 0) & 1 | i7 << 1;
    i5 = i5 + 1 | 0;
    if ((i5 | 0) == 24) break; else i7 = i4;
   }
   HEAP8[i12 + i6 >> 0] = i7 >>> 15;
   HEAP8[i12 + (i6 + 1) >> 0] = i7 >>> 7;
   HEAP8[i12 + (i6 + 2) >> 0] = i4;
   i2 = i2 + 1 | 0;
   if ((i2 | 0) == (i13 | 0)) break; else i6 = i6 + 3 | 0;
  }
  i2 = i13;
  i1 = i1 + (i10 * 3 | 0) | 0;
 }
 i12 = i13 << 3;
 if ((i1 | 0) != ((((((i12 >>> 0) % 12 | 0 | 0) != 0 & 1) + ((i12 >>> 0) / 12 | 0) | 0) * 24 | 0) >>> 3 | 0)) ___assert_fail(gb + 12352 | 0, gb + 12415 | 0, 326, gb + 12443 | 0);
 if ((i2 | 0) == (i13 | 0)) return; else ___assert_fail(gb + 18406 | 0, gb + 12415 | 0, 327, gb + 12443 | 0);
}

function _fec_conv_punctured_decode_soft(i15, i1, i12, i14) {
 i15 = i15 | 0;
 i1 = i1 | 0;
 i12 = i12 | 0;
 i14 = i14 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0;
 i13 = i15 + 8 | 0;
 if ((HEAP32[i13 >> 2] | 0) == (i1 | 0)) {
  i3 = i15 + 28 | 0;
  i6 = i15 + 32 | 0;
 } else {
  HEAP32[i13 >> 2] = i1;
  HEAP32[i15 + 12 >> 2] = _fec_get_enc_msg_length(HEAP32[i15 >> 2] | 0, i1) | 0;
  i1 = HEAP32[i13 >> 2] | 0;
  i6 = i15 + 32 | 0;
  i3 = i15 + 28 | 0;
  i4 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, HEAP32[i3 >> 2] | 0) | 0;
  i5 = i15 + 20 | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  if (i2) {
   mftCall_vi(HEAP32[i15 + 60 >> 2] | 0, i2 | 0);
   i1 = HEAP32[i13 >> 2] | 0;
  }
  HEAP32[i5 >> 2] = mftCall_ii(HEAP32[i15 + 44 >> 2] | 0, i1 << 3 | 0) | 0;
  i1 = i15 + 16 | 0;
  HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i4) | 0;
  i1 = HEAP32[i13 >> 2] | 0;
 }
 i2 = HEAP32[i3 >> 2] | 0;
 i9 = Math_imul((HEAP32[i6 >> 2] | 0) + -1 + (i1 << 3) | 0, i2) | 0;
 if (!i9) i1 = i15 + 16 | 0; else {
  i10 = i15 + 36 | 0;
  i11 = i15 + 40 | 0;
  i1 = i15 + 16 | 0;
  i7 = 0;
  i4 = 0;
  i8 = 0;
  while (1) {
   if (!i2) i2 = 0; else {
    i2 = i4;
    i5 = 0;
    while (1) {
     i4 = (Math_imul(HEAP32[i10 >> 2] | 0, i5) | 0) + i8 | 0;
     if (!(HEAP32[(HEAP32[i11 >> 2] | 0) + (i4 << 2) >> 2] | 0)) {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i5 + i7) >> 0] = 127;
      i4 = i2;
     } else {
      HEAP8[(HEAP32[i1 >> 2] | 0) + (i5 + i7) >> 0] = HEAP8[i12 + i2 >> 0] | 0;
      i4 = i2 + 1 | 0;
     }
     i5 = i5 + 1 | 0;
     i2 = HEAP32[i3 >> 2] | 0;
     if (i5 >>> 0 >= i2 >>> 0) break; else i2 = i4;
    }
   }
   i7 = i2 + i7 | 0;
   if (i7 >>> 0 >= i9 >>> 0) break; else i8 = ((i8 + 1 | 0) >>> 0) % ((HEAP32[i10 >> 2] | 0) >>> 0) | 0;
  }
 }
 i12 = i15 + 20 | 0;
 mftCall_iii(HEAP32[i15 + 48 >> 2] | 0, HEAP32[i12 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i15 + 52 >> 2] | 0, HEAP32[i12 >> 2] | 0, HEAP32[i1 >> 2] | 0, (HEAP32[i6 >> 2] | 0) + -1 + (HEAP32[i13 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i15 + 56 >> 2] | 0, HEAP32[i12 >> 2] | 0, i14 | 0, HEAP32[i13 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _fec_secded3932_decode(i1, i15, i12, i11) {
 i1 = i1 | 0;
 i15 = i15 | 0;
 i12 = i12 | 0;
 i11 = i11 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i14 + 9 | 0;
 i10 = i14 + 4 | 0;
 i9 = i14;
 i13 = i15 & 3;
 i3 = i15 - i13 | 0;
 if ((i13 | 0) == (i15 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i4 = i8 + 1 | 0;
  i5 = i8 + 2 | 0;
  i6 = i8 + 3 | 0;
  i7 = i8 + 4 | 0;
  i2 = 0;
  i1 = 0;
  do {
   i17 = i12 + i1 | 0;
   i16 = i11 + i2 | 0;
   HEAP8[i8 >> 0] = 0;
   HEAP8[i8 + 1 >> 0] = 0;
   HEAP8[i8 + 2 >> 0] = 0;
   HEAP8[i8 + 3 >> 0] = 0;
   HEAP8[i8 + 4 >> 0] = 0;
   _fec_secded3932_estimate_ehat(i17, i8);
   HEAP8[i16 >> 0] = HEAP8[i4 >> 0] ^ HEAP8[i17 + 1 >> 0];
   HEAP8[i16 + 1 >> 0] = HEAP8[i5 >> 0] ^ HEAP8[i17 + 2 >> 0];
   HEAP8[i16 + 2 >> 0] = HEAP8[i6 >> 0] ^ HEAP8[i17 + 3 >> 0];
   HEAP8[i16 + 3 >> 0] = HEAP8[i7 >> 0] ^ HEAP8[i17 + 4 >> 0];
   i1 = i1 + 5 | 0;
   i2 = i2 + 4 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i13) {
  HEAP8[i10 >> 0] = HEAP8[i12 + i1 >> 0] | 0;
  i7 = i10 + 1 | 0;
  HEAP8[i7 >> 0] = 0;
  HEAP8[i7 + 1 >> 0] = 0;
  HEAP8[i7 + 2 >> 0] = 0;
  HEAP8[i7 + 3 >> 0] = 0;
  _memcpy(i7 | 0, i12 + (i1 + 1) | 0, i13 | 0) | 0;
  i7 = HEAP8[i7 >> 0] | 0;
  i12 = HEAP8[i10 + 2 >> 0] | 0;
  i16 = HEAP8[i10 + 3 >> 0] | 0;
  i17 = HEAP8[i10 + 4 >> 0] | 0;
  HEAP8[i8 >> 0] = 0;
  HEAP8[i8 + 1 >> 0] = 0;
  HEAP8[i8 + 2 >> 0] = 0;
  HEAP8[i8 + 3 >> 0] = 0;
  HEAP8[i8 + 4 >> 0] = 0;
  _fec_secded3932_estimate_ehat(i10, i8);
  HEAP8[i9 >> 0] = HEAP8[i8 + 1 >> 0] ^ i7;
  HEAP8[i9 + 1 >> 0] = HEAP8[i8 + 2 >> 0] ^ i12;
  HEAP8[i9 + 2 >> 0] = HEAP8[i8 + 3 >> 0] ^ i16;
  HEAP8[i9 + 3 >> 0] = HEAP8[i8 + 4 >> 0] ^ i17;
  _memcpy(i11 + i2 | 0, i9 | 0, i13 | 0) | 0;
  i2 = i2 | i13;
  i1 = i13 + 1 + i1 | 0;
 }
 if ((i1 | 0) != ((i15 >>> 2) + i15 + ((i13 | 0) != 0 & 1) | 0)) ___assert_fail(gb + 18018 | 0, gb + 18082 | 0, 349, gb + 18133 | 0);
 if ((i2 | 0) == (i15 | 0)) {
  STACKTOP = i14;
  return;
 } else ___assert_fail(gb + 18406 | 0, gb + 18082 | 0, 350, gb + 18133 | 0);
}

function _fec_conv_encode(i16, i15, i10, i14) {
 i16 = i16 | 0;
 i15 = i15 | 0;
 i10 = i10 | 0;
 i14 = i14 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i12 = 0, i13 = 0;
 i12 = g$_P_init() | 0;
 i13 = g$_Partab() | 0;
 if (!i15) {
  i2 = 0;
  i1 = 0;
  i5 = 0;
 } else {
  i7 = i16 + 28 | 0;
  i9 = i16 + 24 | 0;
  i3 = HEAP32[i7 >> 2] | 0;
  i2 = 0;
  i11 = 0;
  i1 = 0;
  i5 = 0;
  while (1) {
   i8 = HEAPU8[i10 + i11 >> 0] | 0;
   i4 = i3;
   i6 = 0;
   do {
    i5 = i8 >>> (7 - i6 | 0) & 1 | i5 << 1;
    if (!i3) i3 = 0; else {
     i4 = 0;
     do {
      i3 = HEAP32[(HEAP32[i9 >> 2] | 0) + (i4 << 2) >> 2] & i5;
      i3 = i3 >> 16 ^ i3;
      if (!(HEAP32[i12 >> 2] | 0)) _partab_init();
      i2 = (HEAPU8[i13 + ((i3 >>> 8 ^ i3) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
      HEAP8[i14 + (i1 >>> 3) >> 0] = i2;
      i1 = i1 + 1 | 0;
      i4 = i4 + 1 | 0;
      i3 = HEAP32[i7 >> 2] | 0;
     } while (i4 >>> 0 < i3 >>> 0);
     i4 = i3;
    }
    i6 = i6 + 1 | 0;
   } while ((i6 | 0) != 8);
   i11 = i11 + 1 | 0;
   if ((i11 | 0) == (i15 | 0)) break; else i3 = i4;
  }
 }
 i8 = i16 + 32 | 0;
 i3 = HEAP32[i8 >> 2] | 0;
 if ((i3 | 0) != 1) {
  i9 = i16 + 28 | 0;
  i10 = i16 + 24 | 0;
  i4 = HEAP32[i9 >> 2] | 0;
  i7 = 0;
  i6 = i5;
  do {
   i6 = i6 << 1;
   if (!i4) i4 = 0; else {
    i5 = 0;
    do {
     i3 = HEAP32[(HEAP32[i10 >> 2] | 0) + (i5 << 2) >> 2] & i6;
     i3 = i3 >> 16 ^ i3;
     if (!(HEAP32[i12 >> 2] | 0)) _partab_init();
     i2 = (HEAPU8[i13 + ((i3 >>> 8 ^ i3) & 255) >> 0] | 0 | (i2 & 255) << 1) & 255;
     HEAP8[i14 + (i1 >>> 3) >> 0] = i2;
     i1 = i1 + 1 | 0;
     i5 = i5 + 1 | 0;
     i4 = HEAP32[i9 >> 2] | 0;
    } while (i5 >>> 0 < i4 >>> 0);
    i3 = HEAP32[i8 >> 2] | 0;
   }
   i7 = i7 + 1 | 0;
  } while (i7 >>> 0 < (i3 + -1 | 0) >>> 0);
 }
 if (i1 & 7) do {
  i2 = (i2 & 255) << 1 & 255;
  HEAP8[i14 + (i1 >>> 3) >> 0] = i2;
  i1 = i1 + 1 | 0;
 } while ((i1 & 7 | 0) != 0);
 if ((i1 | 0) == ((_fec_get_enc_msg_length(HEAP32[i16 >> 2] | 0, i15) | 0) << 3 | 0)) return; else ___assert_fail(gb + 12126 | 0, gb + 12047 | 0, 131, gb + 12070 | 0);
}

function _modem_modulate_apsk(i6, i1, i7) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 if ((HEAP32[i6 + 8 >> 2] | 0) >>> 0 > i1 >>> 0) {
  i5 = HEAPU8[(HEAP32[i6 + 232 >> 2] | 0) + i1 >> 0] | 0;
  i2 = HEAP32[i6 + 100 >> 2] | 0;
  L3 : do if (!i2) {
   i3 = 0;
   i1 = 0;
  } else {
   i3 = 0;
   i4 = 0;
   while (1) {
    i1 = (HEAP32[i6 + 104 + (i3 << 2) >> 2] | 0) + i4 | 0;
    if (i5 >>> 0 < i1 >>> 0) {
     i1 = i4;
     break L3;
    }
    i3 = i3 + 1 | 0;
    if (i3 >>> 0 >= i2 >>> 0) {
     i3 = 0;
     break;
    } else i4 = i1;
   }
  } while (0);
  d9 = +HEAPF32[i6 + 136 + (i3 << 2) >> 2];
  d10 = +HEAPF32[i6 + 200 + (i3 << 2) >> 2] + +((i5 - i1 | 0) >>> 0) * 2.0 * 3.141592653589793 / +((HEAP32[i6 + 104 + (i3 << 2) >> 2] | 0) >>> 0);
  d8 = +Math_sin(+d10);
  HEAPF32[i7 >> 2] = d9 * (+Math_cos(+d10) + d8 * 0.0);
  HEAPF32[i7 + 4 >> 2] = d9 * d8;
  return;
 }
 i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i1) {
  i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
  i1 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i2;
   HEAP32[gb + 8728 + 20 >> 2] = i2;
   i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i1;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i1 | 32;
  return;
 } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
 if ((i1 - i2 | 0) >>> 0 < 59) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29107 | 0, 59) | 0;
  return;
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29107 | 0, 59) | 0) >>> 0 < 59) return; else {
  i1 = 0;
  i3 = gb + 29107 + 59 | 0;
  i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i1 = 59;
  i3 = gb + 29107 | 0;
 } while (0);
 _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
 return;
}

function _fec_hamming128_decode_symbol(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 if (i2 >>> 0 <= 4095) {
  i1 = i2 >>> 8;
  i1 = (HEAPU8[(i1 & 6) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i2 & 102) + (gb + 36491) >> 0] | 0) << 1 & 2 | (HEAPU8[(i1 & 10) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i2 & 170) + (gb + 36491) >> 0] | 0) & 1 | (HEAPU8[(i1 & 1) + (gb + 36491) >> 0] | 0) + (HEAPU8[(i2 & 225) + (gb + 36491) >> 0] | 0) << 2 & 4 | HEAPU8[(i2 & 31) + (gb + 36491) >> 0] << 3 & 8;
  if ((i1 + -1 | 0) >>> 0 > 11) {
   i6 = i2;
   i5 = i6 & 15;
   i4 = i6 >>> 1;
   i4 = i4 & 112;
   i5 = i4 | i5;
   i6 = i6 >>> 2;
   i6 = i6 & 128;
   i6 = i5 | i6;
   return i6 | 0;
  }
  i6 = 1 << 12 - i1 ^ i2;
  i5 = i6 & 15;
  i4 = i6 >>> 1;
  i4 = i4 & 112;
  i5 = i4 | i5;
  i6 = i6 >>> 2;
  i6 = i6 & 128;
  i6 = i5 | i6;
  return i6 | 0;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 55) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 13017 | 0, 55) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 13017 | 0, 55) | 0) >>> 0 < 55) _exit(1); else {
  i4 = 0;
  i5 = gb + 13017 + 55 | 0;
  i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i4 = 55;
  i5 = gb + 13017 | 0;
  i6 = i1;
 } while (0);
 _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
 _exit(1);
 return 0;
}

function _firinterp_crcf_execute(i7, d3, d4, i11) {
 i7 = i7 | 0;
 d3 = +d3;
 d4 = +d4;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, d14 = 0.0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i12 = i13;
 i10 = i7 + 16 | 0;
 i2 = HEAP32[(HEAP32[i10 >> 2] | 0) + 16 >> 2] | 0;
 i5 = i2 + 24 | 0;
 i1 = HEAP32[i2 + 16 >> 2] & (HEAP32[i5 >> 2] | 0) + 1;
 HEAP32[i5 >> 2] = i1;
 if (!i1) {
  i1 = HEAP32[i2 >> 2] | 0;
  i6 = i2 + 4 | 0;
  _memmove(i1 | 0, i1 + (HEAP32[i2 + 12 >> 2] << 3) | 0, (HEAP32[i6 >> 2] << 3) + -8 | 0) | 0;
  i1 = HEAP32[i5 >> 2] | 0;
 } else i6 = i2 + 4 | 0;
 i8 = i1 + -1 + (HEAP32[i6 >> 2] | 0) | 0;
 i9 = HEAP32[i2 >> 2] | 0;
 HEAPF32[i9 + (i8 << 3) >> 2] = d3;
 HEAPF32[i9 + (i8 << 3) + 4 >> 2] = d4;
 i8 = i7 + 12 | 0;
 if (!(HEAP32[i8 >> 2] | 0)) {
  STACKTOP = i13;
  return;
 } else i9 = 0;
 while (1) {
  i7 = HEAP32[i10 >> 2] | 0;
  i2 = HEAP32[i7 + 12 >> 2] | 0;
  if (i2 >>> 0 <= i9 >>> 0) {
   i1 = 6;
   break;
  }
  i1 = HEAP32[i7 + 16 >> 2] | 0;
  i1 = (HEAP32[i1 >> 2] | 0) + (HEAP32[i1 + 24 >> 2] << 3) | 0;
  i5 = HEAP32[(HEAP32[i7 + 20 >> 2] | 0) + (i9 << 2) >> 2] | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  i5 = HEAP32[i5 + 4 >> 2] | 0;
  if (!i5) {
   d4 = 0.0;
   d3 = 0.0;
  } else {
   i6 = 0;
   d4 = 0.0;
   d3 = 0.0;
   do {
    d14 = +HEAPF32[i2 + (i6 << 2) >> 2];
    d4 = d4 + d14 * +HEAPF32[i1 + (i6 << 3) >> 2];
    d3 = d3 + d14 * +HEAPF32[i1 + (i6 << 3) + 4 >> 2];
    i6 = i6 + 1 | 0;
   } while ((i6 | 0) != (i5 | 0));
  }
  i6 = i11 + (i9 << 3) | 0;
  i1 = i11 + (i9 << 3) + 4 | 0;
  HEAPF32[i6 >> 2] = d4;
  HEAPF32[i1 >> 2] = d3;
  d14 = +HEAPF32[i7 + 24 >> 2];
  HEAPF32[i6 >> 2] = d4 * d14;
  HEAPF32[i1 >> 2] = d3 * d14;
  i1 = i9 + 1 | 0;
  if (i1 >>> 0 < (HEAP32[i8 >> 2] | 0) >>> 0) i9 = i1; else {
   i1 = 10;
   break;
  }
 }
 if ((i1 | 0) == 6) {
  HEAP32[i12 >> 2] = i9;
  HEAP32[i12 + 4 >> 2] = i2;
  _fprintf(gb + 8728 | 0, gb + 19343 | 0, i12);
  _exit(1);
 } else if ((i1 | 0) == 10) {
  STACKTOP = i13;
  return;
 }
}

function _firpfb_rrrf_create_drnyquist(i12, i6, i7, d5) {
 i12 = i12 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 d5 = +d5;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, d8 = 0.0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, d14 = 0.0;
 i13 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i4 = i13 + 24 | 0;
 i3 = i13 + 16 | 0;
 i2 = i13 + 8 | 0;
 i1 = i13;
 if (!i12) {
  HEAP32[i1 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19652 | 0, i1);
  _exit(1);
 }
 if (i6 >>> 0 < 2) {
  HEAP32[i2 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19734 | 0, i2);
  _exit(1);
 }
 if (!i7) {
  HEAP32[i3 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19817 | 0, i3);
  _exit(1);
 }
 if (d5 < 0.0 | d5 > 1.0) {
  HEAP32[i4 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19891 | 0, i4);
  _exit(1);
 }
 i9 = Math_imul(Math_imul(i12 << 1, i6) | 0, i7) | 0;
 i11 = i9 | 1;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
 _liquid_firdes_prototype(12, Math_imul(i6, i12) | 0, i7, d5, i10);
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
 i1 = i10 + (i9 << 2) | 0;
 d5 = +HEAPF32[i10 >> 2];
 i2 = i10 + 4 | 0;
 i3 = i10 + (i9 + -1 << 2) | 0;
 i4 = i7 + (i9 << 2) | 0;
 d8 = 0.0;
 i6 = 0;
 do {
  do if (i6) if ((i6 | 0) == (i9 | 0)) {
   HEAPF32[i4 >> 2] = d5 - +HEAPF32[i3 >> 2];
   break;
  } else {
   HEAPF32[i7 + (i6 << 2) >> 2] = +HEAPF32[i10 + (i6 + 1 << 2) >> 2] - +HEAPF32[i10 + (i6 + -1 << 2) >> 2];
   break;
  } else HEAPF32[i7 >> 2] = +HEAPF32[i2 >> 2] - +HEAPF32[i1 >> 2]; while (0);
  d14 = +Math_abs(+(+HEAPF32[i10 + (i6 << 2) >> 2] * +HEAPF32[i7 + (i6 << 2) >> 2]));
  d8 = d14 > d8 ? d14 : d8;
  i6 = i6 + 1 | 0;
 } while ((i6 | 0) != (i11 | 0));
 i1 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i11 << 2) | 0) + 15 & -16) | 0;
 i2 = 0;
 do {
  HEAPF32[i1 + (i2 << 2) >> 2] = +HEAPF32[i7 + (i2 << 2) >> 2] * .05999999865889549 / d8;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i11 | 0));
 i12 = _firpfb_rrrf_create(i12, i1, i11) | 0;
 STACKTOP = i13;
 return i12 | 0;
}

function _liquid_unpack_array(i8, i7, i2, i9) {
 i8 = i8 | 0;
 i7 = i7 | 0;
 i2 = i2 | 0;
 i9 = i9 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i10 = 0;
 if (i7 << 3 >>> 0 > i2 >>> 0) {
  i1 = i2 >>> 3;
  if (i1 >>> 0 >= i7 >>> 0) {
   i8 = 7;
   i7 = 0;
   i8 = i7 << i8;
   HEAP32[i9 >> 2] = i8;
   return;
  }
  i6 = 7;
  i2 = i2 - (i1 << 3) | 0;
  i5 = i1;
  i1 = 0;
  while (1) {
   i3 = 8 - i2 | 0;
   i10 = i6 >>> 0 < i3 >>> 0 ? i6 : i3;
   i1 = 255 >>> (8 - i10 | 0) & 255 & (HEAPU8[i8 + i5 >> 0] | 0) >>> (i3 - i10 | 0) | i1 << i10;
   i3 = i10 + i2 | 0;
   i4 = i3 >>> 0 > 7;
   i5 = (i4 & 1) + i5 | 0;
   i2 = i6 - i10 | 0;
   if (!((i6 | 0) != (i10 | 0) & i5 >>> 0 < i7 >>> 0)) break; else {
    i6 = i2;
    i2 = i4 ? i3 & 7 : i3;
   }
  }
  i10 = i1 << i2;
  HEAP32[i9 >> 2] = i10;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 61) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36807 | 0, 61) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36807 | 0, 61) | 0) >>> 0 < 61) _exit(1); else {
  i4 = 0;
  i5 = gb + 36807 + 61 | 0;
  i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i4 = 61;
  i5 = gb + 36807 | 0;
  i6 = i1;
 } while (0);
 _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
 _exit(1);
}

function _liquid_pack_array(i9, i10, i5, i4, i11) {
 i9 = i9 | 0;
 i10 = i10 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0, i7 = 0, i8 = 0;
 if (i10 << 3 >>> 0 > i5 >>> 0) {
  i2 = i5 >>> 3;
  if (!(i2 >>> 0 < i10 >>> 0 & (i4 | 0) != 0)) return;
  i1 = i5 - (i2 << 3) | 0;
  i3 = i2;
  while (1) {
   i8 = 8 - i1 | 0;
   i8 = i4 >>> 0 < i8 >>> 0 ? i4 : i8;
   i6 = 8 - i8 | 0;
   i7 = i4;
   i4 = i4 - i8 | 0;
   i5 = 255 >>> i6 & 255;
   i6 = i6 - i1 | 0;
   i2 = i9 + i3 | 0;
   HEAP8[i2 >> 0] = (i5 << i6 ^ 255) & HEAPU8[i2 >> 0] | (i5 & i11 >>> i4) << i6;
   i1 = i8 + i1 | 0;
   i2 = i1 >>> 0 > 7;
   i3 = (i2 & 1) + i3 | 0;
   if (!((i7 | 0) != (i8 | 0) & i3 >>> 0 < i10 >>> 0)) break; else i1 = i2 ? i1 & 7 : i1;
  }
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 59) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36747 | 0, 59) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36747 | 0, 59) | 0) >>> 0 < 59) _exit(1); else {
  i6 = 0;
  i7 = gb + 36747 + 59 | 0;
  i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i6 = 59;
  i7 = gb + 36747 | 0;
  i8 = i1;
 } while (0);
 _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
 _exit(1);
}

function _fec_conv_decode_hard(i10, i1, i7, i9) {
 i10 = i10 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i11 = 0, i12 = 0;
 i8 = i10 + 8 | 0;
 if ((HEAP32[i8 >> 2] | 0) == (i1 | 0)) {
  i2 = i10 + 16 | 0;
  i6 = i2;
  i3 = i10 + 12 | 0;
  i2 = HEAP32[i2 >> 2] | 0;
 } else {
  HEAP32[i8 >> 2] = i1;
  i3 = i10 + 12 | 0;
  HEAP32[i3 >> 2] = _fec_get_enc_msg_length(HEAP32[i10 >> 2] | 0, i1) | 0;
  i1 = i10 + 20 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  if (i2 | 0) mftCall_vi(HEAP32[i10 + 60 >> 2] | 0, i2 | 0);
  HEAP32[i1 >> 2] = mftCall_ii(HEAP32[i10 + 44 >> 2] | 0, HEAP32[i8 >> 2] << 3 | 0) | 0;
  i6 = i10 + 16 | 0;
  i2 = _realloc(HEAP32[i6 >> 2] | 0, HEAP32[i3 >> 2] << 3) | 0;
  HEAP32[i6 >> 2] = i2;
 }
 i1 = HEAP32[i3 >> 2] | 0;
 if (i1 | 0) {
  i4 = 0;
  i5 = 0;
  while (1) {
   i12 = HEAP8[i7 + i4 >> 0] | 0;
   i11 = i12 & 255;
   HEAP8[i2 + i5 >> 0] = (i12 & 255) >>> 7;
   HEAP8[i2 + (i5 | 1) >> 0] = i11 >>> 6 & 1;
   HEAP8[i2 + (i5 | 2) >> 0] = i11 >>> 5 & 1;
   HEAP8[i2 + (i5 | 3) >> 0] = i11 >>> 4 & 1;
   HEAP8[i2 + (i5 | 4) >> 0] = i11 >>> 3 & 1;
   HEAP8[i2 + (i5 | 5) >> 0] = i11 >>> 2 & 1;
   HEAP8[i2 + (i5 | 6) >> 0] = i11 >>> 1 & 1;
   HEAP8[i2 + (i5 | 7) >> 0] = i11 & 1;
   i4 = i4 + 1 | 0;
   if ((i4 | 0) == (i1 | 0)) break; else i5 = i5 + 8 | 0;
  }
  if (HEAP32[i3 >> 2] & 536870911 | 0) {
   i1 = 0;
   do {
    i12 = (HEAP32[i6 >> 2] | 0) + i1 | 0;
    HEAP8[i12 >> 0] = ((HEAP8[i12 >> 0] | 0) != 0) << 31 >> 31;
    i1 = i1 + 1 | 0;
   } while (i1 >>> 0 < HEAP32[i3 >> 2] << 3 >>> 0);
  }
 }
 i12 = i10 + 20 | 0;
 mftCall_iii(HEAP32[i10 + 48 >> 2] | 0, HEAP32[i12 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i10 + 52 >> 2] | 0, HEAP32[i12 >> 2] | 0, HEAP32[i6 >> 2] | 0, (HEAP32[i10 + 32 >> 2] | 0) + -1 + (HEAP32[i8 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i10 + 56 >> 2] | 0, HEAP32[i12 >> 2] | 0, i9 | 0, HEAP32[i8 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _fft_execute_dft_4(i1) {
 i1 = i1 | 0;
 var i2 = 0, d3 = 0.0, d4 = 0.0, i5 = 0, d6 = 0.0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, d11 = 0.0, d12 = 0.0, i13 = 0, d14 = 0.0, d15 = 0.0, i16 = 0, i17 = 0, d18 = 0.0, d19 = 0.0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0;
 i9 = HEAP32[i1 + 4 >> 2] | 0;
 i13 = HEAP32[i1 + 8 >> 2] | 0;
 i23 = HEAP32[i9 >> 2] | 0;
 i22 = HEAP32[i9 + 4 >> 2] | 0;
 i10 = i13 + 4 | 0;
 HEAP32[i13 >> 2] = i23;
 HEAP32[i10 >> 2] = i22;
 i25 = HEAP32[i9 + 16 >> 2] | 0;
 i24 = HEAP32[i9 + 20 >> 2] | 0;
 i5 = i13 + 8 | 0;
 i2 = i13 + 12 | 0;
 HEAP32[i5 >> 2] = i25;
 HEAP32[i2 >> 2] = i24;
 i21 = HEAP32[i9 + 8 >> 2] | 0;
 i20 = HEAP32[i9 + 12 >> 2] | 0;
 i17 = i13 + 16 | 0;
 i16 = i13 + 20 | 0;
 HEAP32[i17 >> 2] = i21;
 HEAP32[i16 >> 2] = i20;
 d14 = +HEAPF32[i9 + 24 >> 2];
 d11 = +HEAPF32[i9 + 28 >> 2];
 i9 = i13 + 24 | 0;
 i8 = i13 + 28 | 0;
 d15 = (HEAP32[tempDoublePtr >> 2] = i25, +HEAPF32[tempDoublePtr >> 2]);
 d12 = (HEAP32[tempDoublePtr >> 2] = i24, +HEAPF32[tempDoublePtr >> 2]);
 d18 = (HEAP32[tempDoublePtr >> 2] = i23, +HEAPF32[tempDoublePtr >> 2]);
 d19 = (HEAP32[tempDoublePtr >> 2] = i22, +HEAPF32[tempDoublePtr >> 2]);
 d7 = d18 - d15;
 d4 = d19 - d12;
 HEAPF32[i5 >> 2] = d7;
 HEAPF32[i2 >> 2] = d4;
 d15 = d18 + d15;
 d12 = d19 + d12;
 d19 = (HEAP32[tempDoublePtr >> 2] = i21, +HEAPF32[tempDoublePtr >> 2]);
 d18 = (HEAP32[tempDoublePtr >> 2] = i20, +HEAPF32[tempDoublePtr >> 2]);
 d3 = d19 - d14;
 d6 = d18 - d11;
 HEAPF32[i9 >> 2] = d3;
 HEAPF32[i8 >> 2] = d6;
 d14 = d19 + d14;
 d11 = d18 + d11;
 HEAPF32[i17 >> 2] = d15 - d14;
 HEAPF32[i16 >> 2] = d12 - d11;
 HEAPF32[i13 >> 2] = d15 + d14;
 HEAPF32[i10 >> 2] = d12 + d11;
 d6 = d6 - d3 * 0.0;
 i1 = (HEAP32[i1 + 12 >> 2] | 0) == -1;
 d6 = i1 ? -d6 : d6;
 d3 = i1 ? d3 : -d3;
 HEAPF32[i9 >> 2] = d7 - d6;
 HEAPF32[i8 >> 2] = d4 - d3;
 HEAPF32[i5 >> 2] = d7 + d6;
 HEAPF32[i2 >> 2] = d4 + d3;
 return;
}

function ___shgetc(i8) {
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i3 = i10;
 i4 = i8 + 104 | 0;
 i9 = HEAP32[i4 >> 2] | 0;
 if ((i9 | 0) != 0 ? (HEAP32[i8 + 108 >> 2] | 0) >= (i9 | 0) : 0) i9 = 13; else i9 = 3;
 do if ((i9 | 0) == 3) {
  i5 = i8 + 8 | 0;
  do if (!(HEAP32[i5 >> 2] | 0)) {
   i1 = i8 + 74 | 0;
   i2 = HEAP8[i1 >> 0] | 0;
   HEAP8[i1 >> 0] = i2 + 255 | i2;
   i1 = i8 + 20 | 0;
   i2 = i8 + 44 | 0;
   if ((HEAP32[i1 >> 2] | 0) >>> 0 > (HEAP32[i2 >> 2] | 0) >>> 0) mftCall_iiii(HEAP32[i8 + 36 >> 2] | 0, i8 | 0, 0, 0) | 0;
   HEAP32[i8 + 16 >> 2] = 0;
   HEAP32[i8 + 28 >> 2] = 0;
   HEAP32[i1 >> 2] = 0;
   i1 = HEAP32[i8 >> 2] | 0;
   if (!(i1 & 20)) {
    i9 = HEAP32[i2 >> 2] | 0;
    HEAP32[i5 >> 2] = i9;
    HEAP32[i8 + 4 >> 2] = i9;
    i9 = 10;
    break;
   }
   if (i1 & 4 | 0) HEAP32[i8 >> 2] = i1 | 32;
  } else i9 = 10; while (0);
  if ((i9 | 0) == 10 ? (mftCall_iiii(HEAP32[i8 + 32 >> 2] | 0, i8 | 0, i3 | 0, 1) | 0) == 1 : 0) {
   i7 = HEAP8[i3 >> 0] | 0;
   i1 = i7 & 255;
   i2 = HEAP32[i4 >> 2] | 0;
   i6 = HEAP32[i5 >> 2] | 0;
   if (i2) {
    i3 = i8 + 4 | 0;
    i5 = HEAP32[i3 >> 2] | 0;
    i4 = i2 - (HEAP32[i8 + 108 >> 2] | 0) | 0;
    i2 = i6;
    if ((i6 - i5 | 0) < (i4 | 0)) i9 = 17; else HEAP32[i8 + 100 >> 2] = i5 + (i4 + -1);
   } else {
    i3 = i8 + 4 | 0;
    i2 = i6;
    i9 = 17;
   }
   if ((i9 | 0) == 17) HEAP32[i8 + 100 >> 2] = i6;
   if (!i2) i2 = HEAP32[i3 >> 2] | 0; else {
    i6 = HEAP32[i3 >> 2] | 0;
    i8 = i8 + 108 | 0;
    HEAP32[i8 >> 2] = i2 + 1 - i6 + (HEAP32[i8 >> 2] | 0);
    i2 = i6;
   }
   i2 = i2 + -1 | 0;
   if ((HEAP8[i2 >> 0] | 0) == i7 << 24 >> 24) break;
   HEAP8[i2 >> 0] = i7;
   break;
  }
  i9 = 13;
 } while (0);
 if ((i9 | 0) == 13) {
  HEAP32[i8 + 100 >> 2] = 0;
  i1 = -1;
 }
 STACKTOP = i10;
 return i1 | 0;
}

function ___stdio_read(i10, i8, i9) {
 i10 = i10 | 0;
 i8 = i8 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i11 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 i3 = i11 + 16 | 0;
 i2 = i11;
 i1 = i11 + 32 | 0;
 HEAP32[i1 >> 2] = i8;
 i4 = i1 + 4 | 0;
 i7 = i10 + 48 | 0;
 i5 = HEAP32[i7 >> 2] | 0;
 HEAP32[i4 >> 2] = i9 - ((i5 | 0) != 0 & 1);
 i6 = i10 + 44 | 0;
 HEAP32[i1 + 8 >> 2] = HEAP32[i6 >> 2];
 HEAP32[i1 + 12 >> 2] = i5;
 if (!(HEAP32[gb + 41360 >> 2] | 0)) {
  HEAP32[i3 >> 2] = HEAP32[i10 + 60 >> 2];
  HEAP32[i3 + 4 >> 2] = i1;
  HEAP32[i3 + 8 >> 2] = 2;
  i1 = ___syscall145(145, i3 | 0) | 0;
  if (i1 >>> 0 > 4294963200) {
   if (!(HEAP32[gb + 41360 >> 2] | 0)) i2 = gb + 41404 | 0; else i2 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
   HEAP32[i2 >> 2] = 0 - i1;
   i1 = -1;
   i5 = 12;
  } else i5 = 11;
 } else {
  _pthread_cleanup_push(fb + 20 | 0, i10 | 0);
  HEAP32[i2 >> 2] = HEAP32[i10 + 60 >> 2];
  HEAP32[i2 + 4 >> 2] = i1;
  HEAP32[i2 + 8 >> 2] = 2;
  i1 = ___syscall145(145, i2 | 0) | 0;
  if (i1 >>> 0 > 4294963200) {
   if (!(HEAP32[gb + 41360 >> 2] | 0)) i2 = gb + 41404 | 0; else i2 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
   HEAP32[i2 >> 2] = 0 - i1;
   i1 = -1;
  }
  _pthread_cleanup_pop(0);
  i5 = 11;
 }
 if ((i5 | 0) == 11) if ((i1 | 0) >= 1) {
  i4 = HEAP32[i4 >> 2] | 0;
  if (i1 >>> 0 > i4 >>> 0) {
   i2 = HEAP32[i6 >> 2] | 0;
   i3 = i10 + 4 | 0;
   HEAP32[i3 >> 2] = i2;
   HEAP32[i10 + 8 >> 2] = i2 + (i1 - i4);
   if (!(HEAP32[i7 >> 2] | 0)) i1 = i9; else {
    HEAP32[i3 >> 2] = i2 + 1;
    HEAP8[i8 + (i9 + -1) >> 0] = HEAP8[i2 >> 0] | 0;
    i1 = i9;
   }
  }
 } else i5 = 12;
 if ((i5 | 0) == 12) {
  HEAP32[i10 >> 2] = i1 & 48 ^ 16 | HEAP32[i10 >> 2];
  HEAP32[i10 + 8 >> 2] = 0;
  HEAP32[i10 + 4 >> 2] = 0;
 }
 STACKTOP = i11;
 return i1 | 0;
}

function _log10(d1) {
 d1 = +d1;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, d10 = 0.0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i3 = HEAP32[tempDoublePtr >> 2] | 0;
 i2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i4 = (i2 | 0) < 0;
 do if (i4 | i2 >>> 0 < 1048576) {
  d6 = +Math_abs(+d1);
  HEAPF64[tempDoublePtr >> 3] = d6;
  if ((HEAP32[tempDoublePtr >> 2] | 0) == 0 & (HEAP32[tempDoublePtr + 4 >> 2] | 0) == 0) {
   d1 = -1.0 / (d1 * d1);
   break;
  }
  if (i4) {
   d1 = (d1 - d1) / 0.0;
   break;
  } else {
   HEAPF64[tempDoublePtr >> 3] = d1 * 18014398509481984.0;
   i2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   i4 = HEAP32[tempDoublePtr >> 2] | 0;
   i3 = -1077;
   i5 = 9;
   break;
  }
 } else if (i2 >>> 0 <= 2146435071) if ((i3 | 0) == 0 & 0 == 0 & (i2 | 0) == 1072693248) d1 = 0.0; else {
  i4 = i3;
  i3 = -1023;
  i5 = 9;
 } while (0);
 if ((i5 | 0) == 9) {
  i5 = i2 + 614242 | 0;
  HEAP32[tempDoublePtr >> 2] = i4;
  HEAP32[tempDoublePtr + 4 >> 2] = (i5 & 1048575) + 1072079006;
  d8 = +HEAPF64[tempDoublePtr >> 3] + -1.0;
  d7 = d8 * (d8 * .5);
  d9 = d8 / (d8 + 2.0);
  d10 = d9 * d9;
  d1 = d10 * d10;
  HEAPF64[tempDoublePtr >> 3] = d8 - d7;
  i4 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = i4;
  d6 = +HEAPF64[tempDoublePtr >> 3];
  d1 = d8 - d6 - d7 + d9 * (d7 + (d1 * (d1 * (d1 * .15313837699209373 + .22222198432149784) + .3999999999940942) + d10 * (d1 * (d1 * (d1 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735)));
  d10 = d6 * .4342944818781689;
  d7 = +((i5 >>> 20) + i3 | 0);
  d9 = d7 * .30102999566361177;
  d8 = d9 + d10;
  d1 = d8 + (d10 + (d9 - d8) + (d1 * .4342944818781689 + (d7 * 3.694239077158931e-13 + (d6 + d1) * 2.5082946711645275e-11)));
 }
 return +d1;
}

function _firinterp_rrrf_create_prototype(i9, i5, d4) {
 i9 = i9 | 0;
 i5 = i5 | 0;
 d4 = +d4;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0;
 i10 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i10 + 24 | 0;
 i3 = i10 + 16 | 0;
 i2 = i10 + 8 | 0;
 i1 = i10;
 if (i9 >>> 0 < 2) {
  HEAP32[i1 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19099 | 0, i1);
  _exit(1);
 }
 if (!i5) {
  HEAP32[i2 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19177 | 0, i2);
  _exit(1);
 }
 if (d4 < 0.0 | d4 > 1.0) {
  HEAP32[i3 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19254 | 0, i3);
  _exit(1);
 }
 i8 = Math_imul(i9 << 1, i5) | 0 | 1;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i8 << 2) | 0) + 15 & -16) | 0;
 _liquid_firdes_prototype(11, i9, i5, d4, i3);
 i7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i8 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i7 | 0, i3 | 0, Math_imul(i9 << 3, i5) | 0 | 4 | 0) | 0;
 if (i8 >>> 0 < i9 >>> 0) {
  HEAP32[i6 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 18731 | 0, i6);
  _exit(1);
 }
 i5 = _malloc(20) | 0;
 HEAP32[i5 + 12 >> 2] = i9;
 i2 = i5 + 4 | 0;
 HEAP32[i2 >> 2] = i8;
 i3 = 0;
 while (1) {
  i1 = Math_imul(i3, i9) | 0;
  if (i1 >>> 0 < i8 >>> 0) i3 = i3 + 1 | 0; else break;
 }
 HEAP32[i5 + 8 >> 2] = i3;
 HEAP32[i2 >> 2] = i1;
 i3 = _malloc(i1 << 2) | 0;
 HEAP32[i5 >> 2] = i3;
 if (!i1) {
  i8 = 0;
  i8 = _firpfb_rrrf_create(i9, i3, i8) | 0;
  i9 = i5 + 16 | 0;
  HEAP32[i9 >> 2] = i8;
  STACKTOP = i10;
  return i5 | 0;
 } else i2 = 0;
 do {
  if (i2 >>> 0 < i8 >>> 0) d4 = +HEAPF32[i7 + (i2 << 2) >> 2]; else d4 = 0.0;
  HEAPF32[i3 + (i2 << 2) >> 2] = d4;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i1 | 0));
 i8 = _firpfb_rrrf_create(i9, i3, i1) | 0;
 i9 = i5 + 16 | 0;
 HEAP32[i9 >> 2] = i8;
 STACKTOP = i10;
 return i5 | 0;
}

function _ofdmframe_init_default_sctype(i5, i6) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0;
 L1 : do if (i5 >>> 0 < 6) {
  i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
  do if (!i1) {
   i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
   HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
   i1 = HEAP32[gb + 8728 >> 2] | 0;
   if (!(i1 & 8)) {
    HEAP32[gb + 8728 + 8 >> 2] = 0;
    HEAP32[gb + 8728 + 4 >> 2] = 0;
    i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
    HEAP32[gb + 8728 + 28 >> 2] = i2;
    HEAP32[gb + 8728 + 20 >> 2] = i2;
    i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
    HEAP32[gb + 8728 + 16 >> 2] = i1;
    break;
   } else {
    HEAP32[gb + 8728 >> 2] = i1 | 32;
    break L1;
   }
  } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
  if ((i1 - i2 | 0) >>> 0 < 66) {
   mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32636 | 0, 66) | 0;
   break;
  }
  if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) {
   if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 32636 | 0, 66) | 0) >>> 0 < 66) break;
   i1 = 0;
   i3 = gb + 32636 + 66 | 0;
   i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  } else {
   i1 = 66;
   i3 = gb + 32636 | 0;
  }
  _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
  HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
 } while (0);
 i1 = (i5 >>> 0) / 10 | 0;
 i2 = i5 >>> 0 > 34 ? 8 : 4;
 i4 = i2 >>> 1;
 if (i5 | 0) _memset(i6 | 0, 0, i5 | 0) | 0;
 i3 = (i5 >>> 1) - (i1 >>> 0 < 2 ? 2 : i1) | 0;
 if (i3 >>> 0 <= 1) return;
 i2 = i2 + -1 | 0;
 i1 = 1;
 do {
  HEAP8[i6 + i1 >> 0] = (i1 + i4 & i2 | 0) == 0 ? 1 : 2;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i3 >>> 0);
 i1 = 1;
 do {
  HEAP8[i6 + (i5 - i1) >> 0] = (i1 + i4 & i2 | 0) == 0 ? 1 : 2;
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < i3 >>> 0);
 return;
}

function _gmskframegen_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 if (!(HEAP32[i4 + 88 >> 2] | 0)) {
  HEAP32[i4 + 36 >> 2] = i1;
  i1 = i1 + 5 | 0;
  i2 = i4 + 44 | 0;
  HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i1) | 0;
  i2 = i4 + 52 | 0;
  i3 = HEAP32[i2 >> 2] | 0;
  if (i3 | 0) _packetizer_destroy(i3);
  i1 = _packetizer_create(i1, 6, 6, 1) | 0;
  HEAP32[i2 >> 2] = i1;
  i1 = HEAP32[i1 + 4 >> 2] | 0;
  i3 = i4 + 40 | 0;
  HEAP32[i3 >> 2] = i1;
  i2 = i4 + 48 | 0;
  HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i1) | 0;
  HEAP32[i4 + 20 >> 2] = HEAP32[i3 >> 2] << 3;
  return;
 }
 i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i1) {
  i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
  i1 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i2;
   HEAP32[gb + 8728 + 20 >> 2] = i2;
   i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i1;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i1 | 32;
  return;
 } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
 if ((i1 - i2 | 0) >>> 0 < 87) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24767 | 0, 87) | 0;
  return;
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 24767 | 0, 87) | 0) >>> 0 < 87) return; else {
  i1 = 0;
  i3 = gb + 24767 + 87 | 0;
  i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i1 = 87;
  i3 = gb + 24767 | 0;
 } while (0);
 _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
 return;
}

function _qpacketmodem_encode(i19, i1, i18) {
 i19 = i19 | 0;
 i1 = i1 | 0;
 i18 = i18 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i20 = 0;
 i17 = i19 + 20 | 0;
 i15 = HEAP32[i17 >> 2] | 0;
 i8 = i19 + 16 | 0;
 _packetizer_encode(HEAP32[i19 + 4 >> 2] | 0, i1, HEAP32[i8 >> 2] | 0);
 i16 = i19 + 32 | 0;
 _memset(HEAP32[i17 >> 2] | 0, 0, HEAP32[i16 >> 2] << 2 | 0) | 0;
 i7 = HEAP32[i19 + 8 >> 2] | 0;
 i8 = HEAP32[i8 >> 2] | 0;
 i9 = HEAP32[i19 + 24 >> 2] | 0;
 i10 = HEAP32[i16 >> 2] | 0;
 i11 = i9 << 3;
 do if ((i11 | 0) != 0 & (i10 | 0) != 0) {
  if (!i7) {
   _memset(i15 | 0, 0, i10 << 2 | 0) | 0;
   break;
  } else {
   i13 = 0;
   i14 = 0;
  }
  do {
   i12 = i15 + (i13 << 2) | 0;
   i1 = i14 >>> 3;
   if (i1 >>> 0 < i9 >>> 0) {
    i6 = i7;
    i2 = i14 - (i1 << 3) | 0;
    i5 = i1;
    i1 = 0;
    while (1) {
     i3 = 8 - i2 | 0;
     i20 = i6 >>> 0 < i3 >>> 0 ? i6 : i3;
     i1 = 255 >>> (8 - i20 | 0) & 255 & (HEAPU8[i8 + i5 >> 0] | 0) >>> (i3 - i20 | 0) | i1 << i20;
     i3 = i20 + i2 | 0;
     i4 = i3 >>> 0 > 7;
     i5 = (i4 & 1) + i5 | 0;
     i2 = i6 - i20 | 0;
     if (!((i6 | 0) != (i20 | 0) & i5 >>> 0 < i9 >>> 0)) break; else {
      i6 = i2;
      i2 = i4 ? i3 & 7 : i3;
     }
    }
   } else {
    i2 = i7;
    i1 = 0;
   }
   HEAP32[i12 >> 2] = i1 << i2;
   i13 = i13 + 1 | 0;
   i14 = i14 + i7 | 0;
  } while (i14 >>> 0 < i11 >>> 0 & i13 >>> 0 < i10 >>> 0);
 } while (0);
 if (!(HEAP32[i16 >> 2] | 0)) return;
 i1 = 0;
 do {
  _modem_modulate(HEAP32[i19 >> 2] | 0, HEAP32[(HEAP32[i17 >> 2] | 0) + (i1 << 2) >> 2] | 0, i18 + (i1 << 3) | 0);
  i1 = i1 + 1 | 0;
 } while (i1 >>> 0 < (HEAP32[i16 >> 2] | 0) >>> 0);
 return;
}

function _cexpf(i4, d5, d6) {
 i4 = i4 | 0;
 d5 = +d5;
 d6 = +d6;
 var i1 = 0, i2 = 0, i3 = 0, d7 = 0.0, d8 = 0.0, d9 = 0.0;
 d7 = +Math_abs(+d6);
 i1 = (HEAPF32[tempDoublePtr >> 2] = d7, HEAP32[tempDoublePtr >> 2] | 0);
 do if (i1) {
  i2 = (HEAPF32[tempDoublePtr >> 2] = d5, HEAP32[tempDoublePtr >> 2] | 0);
  d7 = +Math_abs(+d5);
  i3 = (HEAPF32[tempDoublePtr >> 2] = d7, HEAP32[tempDoublePtr >> 2] | 0);
  if (!i3) {
   d7 = +Math_sin(+d6);
   HEAPF32[i4 >> 2] = +Math_cos(+d6);
   HEAPF32[i4 + 4 >> 2] = d7;
   break;
  }
  if (i1 >>> 0 <= 2139095039) if ((i2 + -1118925336 | 0) >>> 0 < 9342557) {
   d9 = +Math_exp(+(d5 + -162.88958740234375));
   i2 = (HEAPF32[tempDoublePtr >> 2] = d9, HEAP32[tempDoublePtr >> 2] | 0);
   d9 = (HEAP32[tempDoublePtr >> 2] = i2 & 8388607 | 2130706432, +HEAPF32[tempDoublePtr >> 2]);
   i2 = (i2 >>> 23) + -19 | 0;
   i3 = (i2 | 0) / 2 | 0;
   d8 = (HEAP32[tempDoublePtr >> 2] = (i3 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
   d5 = (HEAP32[tempDoublePtr >> 2] = (i2 - i3 << 23) + 1065353216, +HEAPF32[tempDoublePtr >> 2]);
   d7 = +Math_sin(+d6) * d9 * d8 * d5;
   HEAPF32[i4 >> 2] = +Math_cos(+d6) * d9 * d8 * d5;
   HEAPF32[i4 + 4 >> 2] = d7;
   break;
  } else {
   d8 = +Math_exp(+d5);
   d9 = d8 * +Math_sin(+d6);
   HEAPF32[i4 >> 2] = d8 * +Math_cos(+d6);
   HEAPF32[i4 + 4 >> 2] = d9;
   break;
  }
  if ((i3 | 0) != 2139095040) {
   d9 = d6 - d6;
   HEAPF32[i4 >> 2] = d9;
   HEAPF32[i4 + 4 >> 2] = d9;
   break;
  }
  if ((i2 | 0) < 0) {
   HEAPF32[i4 >> 2] = 0.0;
   HEAPF32[i4 + 4 >> 2] = 0.0;
   break;
  } else {
   HEAPF32[i4 >> 2] = d5;
   HEAPF32[i4 + 4 >> 2] = d6 - d6;
   break;
  }
 } else {
  HEAPF32[i4 >> 2] = +Math_exp(+d5);
  HEAPF32[i4 + 4 >> 2] = d6;
 } while (0);
 return;
}

function _error_set(i12, i8, i7, i2) {
 i12 = i12 | 0;
 i8 = i8 | 0;
 i7 = i7 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0, i15 = 0;
 i14 = STACKTOP;
 STACKTOP = STACKTOP + 480 | 0;
 i13 = i14 + 16 | 0;
 i10 = i14 + 8 | 0;
 i9 = i14;
 i6 = i14 + 40 | 0;
 i5 = i14 + 24 | 0;
 i1 = i14 + 312 | 0;
 i11 = i14 + 152 | 0;
 if (!i12) {
  STACKTOP = i14;
  return;
 }
 HEAP32[i5 >> 2] = i2;
 i2 = i6;
 i3 = gb + 8956 | 0;
 i4 = i2 + 112 | 0;
 do {
  HEAP32[i2 >> 2] = HEAP32[i3 >> 2];
  i2 = i2 + 4 | 0;
  i3 = i3 + 4 | 0;
 } while ((i2 | 0) < (i4 | 0));
 i4 = -2 - i1 | 0;
 i4 = i4 >>> 0 < 160 ? i4 : 160;
 HEAP32[i6 + 48 >> 2] = i4;
 i2 = i6 + 20 | 0;
 HEAP32[i2 >> 2] = i1;
 HEAP32[i6 + 44 >> 2] = i1;
 i15 = i1 + i4 | 0;
 i3 = i6 + 16 | 0;
 HEAP32[i3 >> 2] = i15;
 HEAP32[i6 + 28 >> 2] = i15;
 _vfprintf(i6, i7, i5) | 0;
 if (i4 | 0) {
  i15 = HEAP32[i2 >> 2] | 0;
  HEAP8[i15 + (((i15 | 0) == (HEAP32[i3 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
 }
 HEAP8[i1 + 159 >> 0] = 0;
 do if (i8) {
  i5 = HEAP32[i8 + 40 >> 2] | 0;
  i3 = HEAP32[i8 + 24 >> 2] | 0;
  i4 = HEAP32[i8 + 28 >> 2] | 0;
  i2 = HEAP32[i8 + 36 >> 2] | 0;
  if (i5 | 0 ? HEAP8[i5 >> 0] | 0 : 0) {
   if ((HEAP32[i8 + 44 >> 2] | 0) >>> 0 >= 21) break;
   HEAP32[i9 >> 2] = i1;
   HEAP32[i9 + 4 >> 2] = i5;
   _snprintf(i11, 160, gb + 37699 | 0, i9);
   HEAP8[i11 + 159 >> 0] = 0;
   i1 = i11;
   break;
  }
  if ((HEAP32[i8 + 20 >> 2] | 0) != -2) {
   HEAP32[i10 >> 2] = i1;
   _snprintf(i11, 160, gb + 37712 | 0, i10);
   HEAP8[i11 + 159 >> 0] = 0;
   i1 = i11;
  }
 } else {
  i4 = -1;
  i3 = -1;
  i2 = 0;
 } while (0);
 HEAP32[i13 >> 2] = i1;
 _jsonp_error_set(i12, i3, i4, i2, 0, i13);
 STACKTOP = i14;
 return;
}

function _ofdmframesync_estimate_gain_S0(i17, i1, i16) {
 i17 = i17 | 0;
 i1 = i1 | 0;
 i16 = i16 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i18 = 0;
 i18 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i15 = i18;
 _memmove(HEAP32[i17 + 56 >> 2] | 0, i1 | 0, HEAP32[i17 >> 2] << 3 | 0) | 0;
 i14 = HEAP32[i17 + 48 >> 2] | 0;
 mftCall_vi(HEAP32[i14 + 28 >> 2] | 0, i14 | 0);
 d9 = +Math_sqrt(+(+((HEAP32[i17 + 28 >> 2] | 0) >>> 0)));
 i14 = HEAP32[i17 >> 2] | 0;
 d9 = d9 / +(i14 >>> 0);
 if (!i14) {
  STACKTOP = i18;
  return;
 }
 i10 = i17 + 12 | 0;
 i11 = i17 + 52 | 0;
 i12 = i17 + 64 | 0;
 i13 = i15 + 4 | 0;
 i14 = 0;
 do {
  if ((i14 & 1 | 0) == 0 ? (HEAP8[(HEAP32[i10 >> 2] | 0) + i14 >> 0] | 0) != 0 : 0) {
   i4 = HEAP32[i11 >> 2] | 0;
   d5 = +HEAPF32[i4 + (i14 << 3) >> 2];
   d6 = +HEAPF32[i4 + (i14 << 3) + 4 >> 2];
   i4 = HEAP32[i12 >> 2] | 0;
   d7 = +HEAPF32[i4 + (i14 << 3) >> 2];
   d8 = -+HEAPF32[i4 + (i14 << 3) + 4 >> 2];
   d3 = d5 * d7 - d6 * d8;
   d2 = d6 * d7 + d5 * d8;
   if ((d3 != d3 | 0.0 != 0.0) & (d2 != d2 | 0.0 != 0.0)) {
    ___mulsc3(i15, d5, d6, d7, d8);
    d3 = +HEAPF32[i15 >> 2];
    d2 = +HEAPF32[i13 >> 2];
   }
   i4 = i16 + (i14 << 3) | 0;
   i1 = i16 + (i14 << 3) + 4 | 0;
   HEAPF32[i4 >> 2] = d3;
   HEAPF32[i1 >> 2] = d2;
  } else {
   i4 = i16 + (i14 << 3) | 0;
   i1 = i16 + (i14 << 3) + 4 | 0;
   HEAPF32[i4 >> 2] = 0.0;
   HEAPF32[i1 >> 2] = 0.0;
   d3 = 0.0;
   d2 = 0.0;
  }
  HEAPF32[i4 >> 2] = d9 * d3;
  HEAPF32[i1 >> 2] = d9 * d2;
  i14 = i14 + 1 | 0;
 } while (i14 >>> 0 < (HEAP32[i17 >> 2] | 0) >>> 0);
 STACKTOP = i18;
 return;
}

function _flexframegen_reconfigure(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 i8 = i2 + 92 | 0;
 _qpacketmodem_configure(HEAP32[i8 >> 2] | 0, HEAP32[i2 + 88 >> 2] | 0, HEAP32[i2 + 32 >> 2] | 0, HEAP32[i2 + 36 >> 2] | 0, HEAP32[i2 + 40 >> 2] | 0, HEAP32[i2 + 44 >> 2] | 0);
 i8 = HEAP32[(HEAP32[i8 >> 2] | 0) + 32 >> 2] | 0;
 HEAP32[i2 + 96 >> 2] = i8;
 i7 = i2 + 100 | 0;
 i2 = _realloc(HEAP32[i7 >> 2] | 0, i8 << 3) | 0;
 HEAP32[i7 >> 2] = i2;
 if (i2 | 0) return;
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 71) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23289 | 0, 71) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23289 | 0, 71) | 0) >>> 0 < 71) _exit(1); else {
  i4 = 0;
  i5 = gb + 23289 + 71 | 0;
  i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i4 = 71;
  i5 = gb + 23289 | 0;
  i6 = i1;
 } while (0);
 _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
 _exit(1);
}

function _fft_execute_dft(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, d3 = 0.0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i21 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i17 = i21;
 i18 = HEAP32[i1 >> 2] | 0;
 if (!i18) {
  STACKTOP = i21;
  return;
 }
 i19 = i1 + 44 | 0;
 i20 = i1 + 4 | 0;
 i14 = i1 + 8 | 0;
 i15 = i17 + 4 | 0;
 i16 = 0;
 do {
  i11 = HEAP32[(HEAP32[i19 >> 2] | 0) + (i16 << 2) >> 2] | 0;
  i1 = (HEAP32[i20 >> 2] | 0) + 8 | 0;
  i13 = HEAP32[i14 >> 2] | 0;
  i10 = HEAP32[i11 >> 2] | 0;
  i11 = HEAP32[i11 + 4 >> 2] | 0;
  if (!i11) {
   d3 = 0.0;
   d2 = 0.0;
  } else {
   i12 = 0;
   d3 = 0.0;
   d2 = 0.0;
   do {
    d6 = +HEAPF32[i10 + (i12 << 3) >> 2];
    d7 = +HEAPF32[i10 + (i12 << 3) + 4 >> 2];
    d8 = +HEAPF32[i1 + (i12 << 3) >> 2];
    d9 = +HEAPF32[i1 + (i12 << 3) + 4 >> 2];
    d4 = d6 * d8 - d7 * d9;
    d5 = d7 * d8 + d6 * d9;
    if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
     ___mulsc3(i17, d6, d7, d8, d9);
     d4 = +HEAPF32[i17 >> 2];
     d5 = +HEAPF32[i15 >> 2];
    }
    d3 = d3 + d4;
    d2 = d2 + d5;
    i12 = i12 + 1 | 0;
   } while ((i12 | 0) != (i11 | 0));
  }
  HEAPF32[i13 + (i16 << 3) >> 2] = d3;
  HEAPF32[i13 + (i16 << 3) + 4 >> 2] = d2;
  i11 = HEAP32[i20 >> 2] | 0;
  i13 = HEAP32[i14 >> 2] | 0;
  i12 = i13 + (i16 << 3) | 0;
  i13 = i13 + (i16 << 3) + 4 | 0;
  d9 = +HEAPF32[i11 + 4 >> 2] + +HEAPF32[i13 >> 2];
  HEAPF32[i12 >> 2] = +HEAPF32[i11 >> 2] + +HEAPF32[i12 >> 2];
  HEAPF32[i13 >> 2] = d9;
  i16 = i16 + 1 | 0;
 } while ((i16 | 0) != (i18 | 0));
 STACKTOP = i21;
 return;
}

function _msequence_create_default(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 if ((i2 + -2 | 0) >>> 0 <= 13) {
  i6 = _malloc(24) | 0;
  i5 = gb + 6864 + (i2 * 24 | 0) | 0;
  HEAP32[i6 >> 2] = HEAP32[i5 >> 2];
  HEAP32[i6 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
  HEAP32[i6 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
  HEAP32[i6 + 12 >> 2] = HEAP32[i5 + 12 >> 2];
  HEAP32[i6 + 16 >> 2] = HEAP32[i5 + 16 >> 2];
  HEAP32[i6 + 20 >> 2] = HEAP32[i5 + 20 >> 2];
  return i6 | 0;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 42) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36192 | 0, 42) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 36192 | 0, 42) | 0) >>> 0 < 42) _exit(1); else {
  i4 = 0;
  i5 = gb + 36192 + 42 | 0;
  i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i4 = 42;
  i5 = gb + 36192 | 0;
  i6 = i1;
 } while (0);
 _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
 _exit(1);
 return 0;
}

function _hashtable_get(i4, i8) {
 i4 = i4 | 0;
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0;
 i3 = i8;
 L1 : do if (!(i3 & 3)) {
  i1 = i8;
  i9 = 4;
 } else {
  i1 = i8;
  i2 = i3;
  while (1) {
   if (!(HEAP8[i1 >> 0] | 0)) {
    i1 = i2;
    break L1;
   }
   i1 = i1 + 1 | 0;
   i2 = i1;
   if (!(i2 & 3)) {
    i9 = 4;
    break;
   }
  }
 } while (0);
 if ((i9 | 0) == 4) {
  while (1) {
   i2 = HEAP32[i1 >> 2] | 0;
   if (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009)) i1 = i1 + 4 | 0; else break;
  }
  if ((i2 & 255) << 24 >> 24) do i1 = i1 + 1 | 0; while ((HEAP8[i1 >> 0] | 0) != 0);
 }
 i6 = _hashlittle(i8, i1 - i3 | 0, HEAP32[gb + 41356 >> 2] | 0) | 0;
 i7 = (1 << HEAP32[i4 + 8 >> 2]) + -1 & i6;
 i5 = HEAP32[i4 + 4 >> 2] | 0;
 i1 = HEAP32[i5 + (i7 << 3) >> 2] | 0;
 i7 = i5 + (i7 << 3) + 4 | 0;
 if ((i1 | 0) == (i4 + 12 | 0) ? (i1 | 0) == (HEAP32[i7 >> 2] | 0) : 0) {
  i9 = 0;
  return i9 | 0;
 }
 while (1) {
  if ((HEAP32[i1 + 8 >> 2] | 0) == (i6 | 0)) {
   i3 = i1 + 20 | 0;
   i4 = HEAP8[i3 >> 0] | 0;
   i2 = HEAP8[i8 >> 0] | 0;
   if (!(i4 << 24 >> 24 == 0 ? 1 : i4 << 24 >> 24 != i2 << 24 >> 24)) {
    i5 = i8;
    do {
     i3 = i3 + 1 | 0;
     i5 = i5 + 1 | 0;
     i4 = HEAP8[i3 >> 0] | 0;
     i2 = HEAP8[i5 >> 0] | 0;
    } while (!(i4 << 24 >> 24 == 0 ? 1 : i4 << 24 >> 24 != i2 << 24 >> 24));
   }
   if (i4 << 24 >> 24 == i2 << 24 >> 24) break;
  }
  if ((i1 | 0) == (HEAP32[i7 >> 2] | 0)) {
   i1 = 0;
   i9 = 19;
   break;
  }
  i1 = HEAP32[i1 + 4 >> 2] | 0;
 }
 if ((i9 | 0) == 19) return i1 | 0;
 if (!i1) {
  i9 = 0;
  return i9 | 0;
 }
 i9 = HEAP32[i1 + 12 >> 2] | 0;
 return i9 | 0;
}

function _fec_secded2216_estimate_ehat(i1, i6) {
 i1 = i1 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0;
 HEAP8[i6 >> 0] = 0;
 HEAP8[i6 + 1 >> 0] = 0;
 HEAP8[i6 + 2 >> 0] = 0;
 i3 = HEAPU8[i1 >> 0] | 0;
 i4 = HEAP8[i1 + 1 >> 0] | 0;
 i1 = HEAP8[i1 + 2 >> 0] | 0;
 i2 = 0;
 i5 = 0;
 do {
  i7 = i2 << 1;
  i5 = ((1 << 5 - i2 & i3 | 0) != 0 & 1) + (HEAPU8[(HEAP8[gb + 17802 + i7 >> 0] & i4 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i7 | 1) + (gb + 17802) >> 0] & i1 & 255) + (gb + 36235) >> 0] | 0) & 1 | i5 << 1 & 510;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 6);
 i1 = i5 & 255;
 if (!(i5 & 255)) return;
 do if (i1 << 24 >> 24 != 7) if (i1 << 24 >> 24 != 19) if (i1 << 24 >> 24 != 35) if (i1 << 24 >> 24 != 49) if (i1 << 24 >> 24 != 37) if (i1 << 24 >> 24 != 41) if (i1 << 24 >> 24 != 14) if (i1 << 24 >> 24 != 22) if (i1 << 24 >> 24 != 38) if (i1 << 24 >> 24 != 26) if (i1 << 24 >> 24 != 25) if (i1 << 24 >> 24 != 56) if (i1 << 24 >> 24 != 50) if (i1 << 24 >> 24 != 28) if (i1 << 24 >> 24 != 13) if (i1 << 24 >> 24 != 44) if (i1 << 24 >> 24 != 1) if (i1 << 24 >> 24 == 2) i1 = 17; else {
  if (i1 << 24 >> 24 == 4) {
   i1 = 18;
   break;
  }
  if (i1 << 24 >> 24 == 8) {
   i1 = 19;
   break;
  }
  if (i1 << 24 >> 24 == 16) {
   i1 = 20;
   break;
  }
  if (i1 << 24 >> 24 == 32) {
   i1 = 21;
   break;
  }
  return;
 } else i1 = 16; else i1 = 15; else i1 = 14; else i1 = 13; else i1 = 12; else i1 = 11; else i1 = 10; else i1 = 9; else i1 = 8; else i1 = 7; else i1 = 6; else i1 = 5; else i1 = 4; else i1 = 3; else i1 = 2; else i1 = 1; else i1 = 0; while (0);
 HEAP8[i6 + (2 - (i1 >>> 3)) >> 0] = 1 << (i1 & 7);
 return;
}

function _modem_modulate(i2, i3, i4) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 if ((HEAP32[i2 + 8 >> 2] | 0) >>> 0 > i3 >>> 0) if (!(HEAP32[i2 + 80 >> 2] | 0)) {
  mftCall_viii(HEAP32[i2 + 236 >> 2] | 0, i2 | 0, i3 | 0, i4 | 0);
  return;
 } else {
  i7 = HEAP32[i2 + 76 >> 2] | 0;
  i8 = HEAP32[i7 + (i3 << 3) + 4 >> 2] | 0;
  HEAP32[i4 >> 2] = HEAP32[i7 + (i3 << 3) >> 2];
  HEAP32[i4 + 4 >> 2] = i8;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i5 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i5;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i5 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i5 - i1 | 0) >>> 0 < 65) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28660 | 0, 65) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 28660 | 0, 65) | 0) >>> 0 < 65) _exit(1); else {
  i6 = 0;
  i7 = gb + 28660 + 65 | 0;
  i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i6 = 65;
  i7 = gb + 28660 | 0;
  i8 = i1;
 } while (0);
 _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
 _exit(1);
}

function _ofdmflexframegen_reconfigure(i8) {
 i8 = i8 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i7 = i8 + 88 | 0;
 i1 = HEAP32[i7 >> 2] | 0;
 i3 = HEAP32[i8 + 92 >> 2] | 0;
 i4 = HEAP32[i8 + 140 >> 2] | 0;
 i5 = HEAP32[i8 + 144 >> 2] | 0;
 i6 = HEAP32[i8 + 148 >> 2] | 0;
 do if (!i1) i1 = _packetizer_create(i3, i4, i5, i6) | 0; else {
  if ((((HEAP32[i1 >> 2] | 0) == (i3 | 0) ? (HEAP32[i1 + 8 >> 2] | 0) == (i4 | 0) : 0) ? (i2 = HEAP32[i1 + 16 >> 2] | 0, (HEAP32[i2 + 8 >> 2] | 0) == (i5 | 0)) : 0) ? (HEAP32[i2 + 28 >> 2] | 0) == (i6 | 0) : 0) break;
  _packetizer_destroy(i1);
  i1 = _packetizer_create(i3, i4, i5, i6) | 0;
 } while (0);
 HEAP32[i7 >> 2] = i1;
 i2 = HEAP32[i1 + 4 >> 2] | 0;
 i4 = i8 + 108 | 0;
 HEAP32[i4 >> 2] = i2;
 i5 = i8 + 100 | 0;
 HEAP32[i5 >> 2] = _realloc(HEAP32[i5 >> 2] | 0, i2) | 0;
 i5 = i8 + 96 | 0;
 i2 = HEAP32[i5 >> 2] | 0;
 i3 = i8 + 152 | 0;
 i1 = HEAP32[i3 >> 2] | 0;
 if ((HEAP32[i2 >> 2] | 0) != (i1 | 0)) {
  _modem_destroy(i2);
  i2 = _modem_create(i1) | 0;
  i1 = HEAP32[i3 >> 2] | 0;
 }
 HEAP32[i5 >> 2] = i2;
 i5 = HEAP32[gb + 508 + (i1 << 4) + 12 >> 2] | 0;
 i6 = HEAP32[i4 >> 2] << 3;
 i5 = (((i6 | 0) % (i5 | 0) | 0 | 0) != 0 & 1) + ((i6 | 0) / (i5 | 0) | 0) | 0;
 i6 = i8 + 112 | 0;
 HEAP32[i6 >> 2] = i5;
 i7 = i8 + 104 | 0;
 HEAP32[i7 >> 2] = _realloc(HEAP32[i7 >> 2] | 0, i5 << 2) | 0;
 i6 = HEAP32[i6 >> 2] | 0;
 i7 = HEAP32[i8 + 24 >> 2] | 0;
 i5 = (i6 | 0) % (i7 | 0) | 0;
 HEAP32[i8 + 48 >> 2] = ((i5 >>> 0 > 0 | (i5 | 0) == 0 & 0 > 4294967295) & 1) + ((i6 | 0) / (i7 | 0) | 0);
 return;
}

function _fec_secded7264_encode(i1, i9, i5, i6) {
 i1 = i1 | 0;
 i9 = i9 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i8;
 i7 = i9 & 7;
 i3 = i9 - i7 | 0;
 if ((i7 | 0) == (i9 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i11 = i5 + i2 | 0;
   i10 = i6 + i1 | 0;
   HEAP8[i10 >> 0] = _fec_secded7264_compute_parity(i11) | 0;
   HEAP8[i10 + 1 >> 0] = HEAP8[i11 >> 0] | 0;
   HEAP8[i10 + 2 >> 0] = HEAP8[i11 + 1 >> 0] | 0;
   HEAP8[i10 + 3 >> 0] = HEAP8[i11 + 2 >> 0] | 0;
   HEAP8[i10 + 4 >> 0] = HEAP8[i11 + 3 >> 0] | 0;
   HEAP8[i10 + 5 >> 0] = HEAP8[i11 + 4 >> 0] | 0;
   HEAP8[i10 + 6 >> 0] = HEAP8[i11 + 5 >> 0] | 0;
   HEAP8[i10 + 7 >> 0] = HEAP8[i11 + 6 >> 0] | 0;
   HEAP8[i10 + 8 >> 0] = HEAP8[i11 + 7 >> 0] | 0;
   i1 = i1 + 9 | 0;
   i2 = i2 + 8 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i7) {
  i3 = i4;
  HEAP32[i3 >> 2] = 0;
  HEAP32[i3 + 4 >> 2] = 0;
  _memcpy(i4 | 0, i5 + i2 | 0, i7 | 0) | 0;
  HEAP8[i6 + i1 >> 0] = _fec_secded7264_compute_parity(i4) | 0;
  i3 = i1 + 1 | 0;
  i4 = 0;
  do {
   HEAP8[i6 + (i3 + i4) >> 0] = HEAP8[i5 + (i4 + i2) >> 0] | 0;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i7 | 0));
  i2 = i2 | i7;
  i1 = i7 + 1 + i1 | 0;
 }
 if ((i1 | 0) != ((i9 >>> 3) + i9 + ((i7 | 0) != 0 & 1) | 0)) ___assert_fail(gb + 18291 | 0, gb + 18355 | 0, 286, gb + 18384 | 0);
 if ((i2 | 0) == (i9 | 0)) {
  STACKTOP = i8;
  return;
 } else ___assert_fail(gb + 18406 | 0, gb + 18355 | 0, 287, gb + 18384 | 0);
}

function _modem_modulate_arb(i2, i3, i4) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 if ((HEAP32[i2 + 8 >> 2] | 0) >>> 0 > i3 >>> 0) {
  i7 = HEAP32[i2 + 76 >> 2] | 0;
  i8 = HEAP32[i7 + (i3 << 3) + 4 >> 2] | 0;
  HEAP32[i4 >> 2] = HEAP32[i7 + (i3 << 3) >> 2];
  HEAP32[i4 + 4 >> 2] = i8;
  return;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i5 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i5;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i5 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i5 - i1 | 0) >>> 0 < 52) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29323 | 0, 52) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 29323 | 0, 52) | 0) >>> 0 < 52) _exit(1); else {
  i6 = 0;
  i7 = gb + 29323 + 52 | 0;
  i8 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i6 = 52;
  i7 = gb + 29323 | 0;
  i8 = i1;
 } while (0);
 _memcpy(i8 | 0, i7 | 0, i6 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i6;
 _exit(1);
}

function _liquid_lngammaf(d3) {
 d3 = +d3;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 if (!(d3 < 0.0)) if (d3 < 10.0) return +(+_liquid_lngammaf(d3 + 1.0) - +Math_log(+d3)); else return +((1.8378770351409912 - +Math_log(+d3)) * .5 + (+Math_log(+(1.0 / (d3 * 12.0 - .10000000149011612 / d3) + d3)) + -1.0) * d3);
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i4 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i4;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i4 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i4 - i1 | 0) >>> 0 < 47) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27919 | 0, 47) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27919 | 0, 47) | 0) >>> 0 < 47) _exit(1); else {
  i5 = 0;
  i6 = gb + 27919 + 47 | 0;
  i7 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i5 = 47;
  i6 = gb + 27919 | 0;
  i7 = i1;
 } while (0);
 _memcpy(i7 | 0, i6 | 0, i5 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i5;
 _exit(1);
 return +(0.0);
}

function _firdecim_crcf_create_kaiser(i6, i3) {
 i6 = i6 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i4 = i9 + 16 | 0;
 i2 = i9 + 8 | 0;
 i1 = i9;
 if (i6 >>> 0 < 2) {
  HEAP32[i1 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18523 | 0, i1);
  _exit(1);
 }
 if (!i3) {
  HEAP32[i2 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18593 | 0, i2);
  _exit(1);
 }
 i7 = Math_imul(i6 << 1, i3) | 0;
 i2 = i7 | 1;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i2 << 2) | 0) + 15 & -16) | 0;
 _liquid_firdes_kaiser(i2, .5 / +(i6 >>> 0), 60.0, i5);
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i2 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i8 | 0, i5 | 0, Math_imul(i6 << 3, i3) | 0 | 4 | 0) | 0;
 if (!i7) {
  HEAP32[i4 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18456 | 0, i4);
  _exit(1);
 }
 i5 = _malloc(20) | 0;
 HEAP32[i5 + 4 >> 2] = i7;
 HEAP32[i5 + 8 >> 2] = i6;
 i1 = i7 << 2;
 i2 = _malloc(i1) | 0;
 HEAP32[i5 >> 2] = i2;
 i3 = i7 + -1 | 0;
 i4 = 0;
 do {
  HEAP32[i2 + (i4 << 2) >> 2] = HEAP32[i8 + (i3 - i4 << 2) >> 2];
  i4 = i4 + 1 | 0;
 } while ((i4 | 0) != (i7 | 0));
 i8 = _windowcf_create(i7) | 0;
 HEAP32[i5 + 12 >> 2] = i8;
 i6 = _malloc(8) | 0;
 HEAP32[i6 + 4 >> 2] = i7;
 i7 = _malloc(i1) | 0;
 HEAP32[i6 >> 2] = i7;
 _memcpy(i7 | 0, i2 | 0, i1 | 0) | 0;
 HEAP32[i5 + 16 >> 2] = i6;
 HEAP32[i8 + 24 >> 2] = 0;
 _memset(HEAP32[i8 >> 2] | 0, 0, HEAP32[i8 + 20 >> 2] << 3 | 0) | 0;
 STACKTOP = i9;
 return i5 | 0;
}

function _flexframegen_getframelen(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 if (HEAP32[i1 + 112 >> 2] | 0) {
  i3 = Math_imul((HEAP32[i1 + 80 >> 2] | 0) + 64 + (HEAP32[i1 + 96 >> 2] | 0) + (HEAP32[i1 + 4 >> 2] << 1) | 0, HEAP32[i1 >> 2] | 0) | 0;
  return i3 | 0;
 }
 i1 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i1) {
  i1 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i1 + 255 | i1;
  i1 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i2 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i2;
   HEAP32[gb + 8728 + 20 >> 2] = i2;
   i1 = i2 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i1;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i1 | 32;
  i3 = 0;
  return i3 | 0;
 } else i2 = HEAP32[gb + 8728 + 20 >> 2] | 0; while (0);
 if ((i1 - i2 | 0) >>> 0 < 58) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23361 | 0, 58) | 0;
  i3 = 0;
  return i3 | 0;
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 23361 | 0, 58) | 0) >>> 0 < 58) {
  i3 = 0;
  return i3 | 0;
 } else {
  i1 = 0;
  i3 = gb + 23361 + 58 | 0;
  i2 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i1 = 58;
  i3 = gb + 23361 | 0;
 } while (0);
 _memcpy(i2 | 0, i3 | 0, i1 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i1;
 i3 = 0;
 return i3 | 0;
}

function _liquid_nextpow2(i2) {
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 if (i2 | 0) {
  i1 = i2 + -1 | 0;
  if (!i1) {
   i6 = 0;
   return i6 | 0;
  } else i2 = 0;
  do {
   i1 = i1 >>> 1;
   i2 = i2 + 1 | 0;
  } while ((i1 | 0) != 0);
  i1 = i2;
  return i1 | 0;
 }
 i2 = HEAP32[gb + 8728 + 16 >> 2] | 0;
 do if (!i2) {
  i2 = HEAP8[gb + 8728 + 74 >> 0] | 0;
  HEAP8[gb + 8728 + 74 >> 0] = i2 + 255 | i2;
  i2 = HEAP32[gb + 8728 >> 2] | 0;
  if (!(i2 & 8)) {
   HEAP32[gb + 8728 + 8 >> 2] = 0;
   HEAP32[gb + 8728 + 4 >> 2] = 0;
   i1 = HEAP32[gb + 8728 + 44 >> 2] | 0;
   HEAP32[gb + 8728 + 28 >> 2] = i1;
   HEAP32[gb + 8728 + 20 >> 2] = i1;
   i3 = i1 + (HEAP32[gb + 8728 + 48 >> 2] | 0) | 0;
   HEAP32[gb + 8728 + 16 >> 2] = i3;
   break;
  }
  HEAP32[gb + 8728 >> 2] = i2 | 32;
  _exit(1);
 } else {
  i3 = i2;
  i1 = HEAP32[gb + 8728 + 20 >> 2] | 0;
 } while (0);
 if ((i3 - i1 | 0) >>> 0 < 58) {
  mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27738 | 0, 58) | 0;
  _exit(1);
 }
 do if ((HEAP8[gb + 8728 + 75 >> 0] | 0) > -1) if ((mftCall_iiii(HEAP32[gb + 8728 + 36 >> 2] | 0, gb + 8728 | 0, gb + 27738 | 0, 58) | 0) >>> 0 < 58) _exit(1); else {
  i4 = 0;
  i5 = gb + 27738 + 58 | 0;
  i6 = HEAP32[gb + 8728 + 20 >> 2] | 0;
  break;
 } else {
  i4 = 58;
  i5 = gb + 27738 | 0;
  i6 = i1;
 } while (0);
 _memcpy(i6 | 0, i5 | 0, i4 | 0) | 0;
 HEAP32[gb + 8728 + 20 >> 2] = (HEAP32[gb + 8728 + 20 >> 2] | 0) + i4;
 _exit(1);
 return 0;
}

function _decode_unicode_escape(i5) {
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0;
 if ((HEAP8[i5 >> 0] | 0) != 117) ___assert_fail(gb + 37968 | 0, gb + 37743 | 0, 299, gb + 37982 | 0);
 i1 = HEAP8[i5 + 1 >> 0] | 0;
 i2 = i1 << 24 >> 24;
 do if ((i1 + -48 & 255) >= 10) {
  if ((i1 + -97 & 255) < 26) {
   i1 = i2 + -87 | 0;
   break;
  }
  if ((i1 + -65 & 255) < 26) {
   i1 = i2 + -55 | 0;
   break;
  } else {
   i5 = -1;
   return i5 | 0;
  }
 } else i1 = i2 + -48 | 0; while (0);
 i2 = HEAP8[i5 + 2 >> 0] | 0;
 i3 = i1 << 4;
 i1 = i2 << 24 >> 24;
 do if ((i2 + -48 & 255) >= 10) {
  if ((i2 + -97 & 255) < 26) {
   i1 = i1 + -87 | 0;
   break;
  }
  if ((i2 + -65 & 255) < 26) {
   i1 = i1 + -55 | 0;
   break;
  } else {
   i5 = -1;
   return i5 | 0;
  }
 } else i1 = i1 + -48 | 0; while (0);
 i2 = HEAP8[i5 + 3 >> 0] | 0;
 i4 = i1 + i3 << 4;
 i1 = i2 << 24 >> 24;
 do if ((i2 + -48 & 255) >= 10) {
  if ((i2 + -97 & 255) < 26) {
   i1 = i1 + -87 | 0;
   break;
  }
  if ((i2 + -65 & 255) < 26) {
   i1 = i1 + -55 | 0;
   break;
  } else {
   i5 = -1;
   return i5 | 0;
  }
 } else i1 = i1 + -48 | 0; while (0);
 i3 = HEAP8[i5 + 4 >> 0] | 0;
 i2 = i1 + i4 << 4;
 i1 = i3 << 24 >> 24;
 do if ((i3 + -48 & 255) >= 10) {
  if ((i3 + -97 & 255) < 26) {
   i1 = i1 + -87 | 0;
   break;
  }
  if ((i3 + -65 & 255) < 26) {
   i1 = i1 + -55 | 0;
   break;
  } else {
   i5 = -1;
   return i5 | 0;
  }
 } else i1 = i1 + -48 | 0; while (0);
 i5 = i1 + i2 | 0;
 return i5 | 0;
}

function _ofdmflexframegen_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i5 = 0;
 HEAP32[i4 + 72 >> 2] = i1;
 i3 = i1 + 6 | 0;
 i1 = i4 + 76 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 60 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i4 + 56 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _packetizer_destroy(i3);
 i3 = _packetizer_create(HEAP32[i1 >> 2] | 0, 6, 7, 1) | 0;
 HEAP32[i2 >> 2] = i3;
 i2 = HEAP32[i3 + 4 >> 2] | 0;
 i3 = i4 + 80 | 0;
 HEAP32[i3 >> 2] = i2;
 i1 = i4 + 64 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i2) | 0;
 i3 = HEAP32[i3 >> 2] << 3;
 i1 = i4 + 84 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 68 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i4 + 52 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _modem_destroy(i3);
 i3 = _malloc(252) | 0;
 HEAP32[i3 >> 2] = 47;
 HEAP32[i3 + 76 >> 2] = 0;
 HEAP32[i3 + 80 >> 2] = 0;
 HEAP32[i3 + 4 >> 2] = 1;
 HEAP32[i3 + 8 >> 2] = 2;
 i5 = i3 + 236 | 0;
 HEAP32[i5 >> 2] = 0;
 HEAP32[i5 + 4 >> 2] = 0;
 HEAP32[i5 + 8 >> 2] = 0;
 HEAP32[i5 + 12 >> 2] = 0;
 HEAP32[i5 >> 2] = fb + 3;
 HEAP32[i3 + 240 >> 2] = fb + 4;
 HEAPF32[i3 + 84 >> 2] = 1.0;
 HEAPF32[i3 + 88 >> 2] = 0.0;
 HEAP32[i3 + 92 >> 2] = 1065353216;
 HEAPF32[i3 + 96 >> 2] = 0.0;
 HEAP32[i2 >> 2] = i3;
 i2 = HEAP32[i1 >> 2] | 0;
 i3 = HEAP32[i4 + 24 >> 2] | 0;
 HEAP32[i4 + 44 >> 2] = (((i2 | 0) % (i3 | 0) | 0 | 0) != 0 & 1) + ((i2 | 0) / (i3 | 0) | 0);
 return;
}

function _vfprintf(i14, i10, i1) {
 i14 = i14 | 0;
 i10 = i10 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i12 = 0, i13 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 i9 = i15 + 120 | 0;
 i13 = i15 + 80 | 0;
 i12 = i15;
 i11 = i15 + 136 | 0;
 i2 = i13;
 i3 = i2 + 40 | 0;
 do {
  HEAP32[i2 >> 2] = 0;
  i2 = i2 + 4 | 0;
 } while ((i2 | 0) < (i3 | 0));
 HEAP32[i9 >> 2] = HEAP32[i1 >> 2];
 if ((_printf_core(0, i10, i9, i12, i13) | 0) < 0) i1 = -1; else {
  i1 = HEAP32[i14 >> 2] | 0;
  i8 = i1 & 32;
  if ((HEAP8[i14 + 74 >> 0] | 0) < 1) HEAP32[i14 >> 2] = i1 & -33;
  i7 = i14 + 48 | 0;
  if (!(HEAP32[i7 >> 2] | 0)) {
   i2 = i14 + 44 | 0;
   i3 = HEAP32[i2 >> 2] | 0;
   HEAP32[i2 >> 2] = i11;
   i4 = i14 + 28 | 0;
   HEAP32[i4 >> 2] = i11;
   i5 = i14 + 20 | 0;
   HEAP32[i5 >> 2] = i11;
   HEAP32[i7 >> 2] = 80;
   i6 = i14 + 16 | 0;
   HEAP32[i6 >> 2] = i11 + 80;
   i1 = _printf_core(i14, i10, i9, i12, i13) | 0;
   if (i3) {
    mftCall_iiii(HEAP32[i14 + 36 >> 2] | 0, i14 | 0, 0, 0) | 0;
    i1 = (HEAP32[i5 >> 2] | 0) == 0 ? -1 : i1;
    HEAP32[i2 >> 2] = i3;
    HEAP32[i7 >> 2] = 0;
    HEAP32[i6 >> 2] = 0;
    HEAP32[i4 >> 2] = 0;
    HEAP32[i5 >> 2] = 0;
   }
  } else i1 = _printf_core(i14, i10, i9, i12, i13) | 0;
  i13 = HEAP32[i14 >> 2] | 0;
  HEAP32[i14 >> 2] = i13 | i8;
  i1 = (i13 & 32 | 0) == 0 ? i1 : -1;
 }
 STACKTOP = i15;
 return i1 | 0;
}

function _fec_golay2412_decode(i1, i7, i6, i5) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0;
 i4 = (i7 >>> 0) % 3 | 0;
 i2 = i7 - i4 | 0;
 if ((i4 | 0) == (i7 | 0)) i1 = 0; else {
  i3 = 0;
  i1 = 0;
  do {
   i8 = (HEAPU8[i6 + (i1 + 4) >> 0] | 0) << 8 | (HEAPU8[i6 + (i1 + 3) >> 0] | 0) << 16 | (HEAPU8[i6 + (i1 + 5) >> 0] | 0);
   i9 = _fec_golay2412_decode_symbol((HEAPU8[i6 + (i1 | 1) >> 0] | 0) << 8 | (HEAPU8[i6 + i1 >> 0] | 0) << 16 | (HEAPU8[i6 + (i1 + 2) >> 0] | 0)) | 0;
   i8 = _fec_golay2412_decode_symbol(i8) | 0;
   HEAP8[i5 + i3 >> 0] = i9 >>> 4;
   HEAP8[i5 + (i3 + 1) >> 0] = i8 >>> 8 & 15 | i9 << 4;
   HEAP8[i5 + (i3 + 2) >> 0] = i8;
   i1 = i1 + 6 | 0;
   i3 = i3 + 3 | 0;
  } while (i3 >>> 0 < i2 >>> 0);
 }
 if (i2 >>> 0 < i7 >>> 0) {
  i3 = i1;
  while (1) {
   HEAP8[i5 + i2 >> 0] = _fec_golay2412_decode_symbol((HEAPU8[i6 + (i3 + 1) >> 0] | 0) << 8 | (HEAPU8[i6 + i3 >> 0] | 0) << 16 | (HEAPU8[i6 + (i3 + 2) >> 0] | 0)) | 0;
   i2 = i2 + 1 | 0;
   if ((i2 | 0) == (i7 | 0)) break; else i3 = i3 + 3 | 0;
  }
  i2 = i7;
  i1 = i1 + (i4 * 3 | 0) | 0;
 }
 i9 = i7 << 3;
 if ((i1 | 0) != ((((((i9 >>> 0) % 12 | 0 | 0) != 0 & 1) + ((i9 >>> 0) / 12 | 0) | 0) * 24 | 0) >>> 3 | 0)) ___assert_fail(gb + 12464 | 0, gb + 12415 | 0, 396, gb + 12526 | 0);
 if ((i2 | 0) == (i7 | 0)) return; else ___assert_fail(gb + 18406 | 0, gb + 12415 | 0, 397, gb + 12526 | 0);
}

function _fec_secded2216_decode(i1, i12, i9, i8) {
 i1 = i1 | 0;
 i12 = i12 | 0;
 i9 = i9 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0;
 i11 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i11 + 3 | 0;
 i7 = i11;
 i10 = i12 & 1;
 i3 = i12 - i10 | 0;
 if ((i10 | 0) == (i12 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i4 = i6 + 1 | 0;
  i5 = i6 + 2 | 0;
  i2 = 0;
  i1 = 0;
  do {
   i14 = i9 + i1 | 0;
   i13 = i8 + i2 | 0;
   HEAP8[i6 >> 0] = 0;
   HEAP8[i6 + 1 >> 0] = 0;
   HEAP8[i6 + 2 >> 0] = 0;
   _fec_secded2216_estimate_ehat(i14, i6);
   HEAP8[i13 >> 0] = HEAP8[i4 >> 0] ^ HEAP8[i14 + 1 >> 0];
   HEAP8[i13 + 1 >> 0] = HEAP8[i5 >> 0] ^ HEAP8[i14 + 2 >> 0];
   i1 = i1 + 3 | 0;
   i2 = i2 + 2 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i10) {
  HEAP8[i7 >> 0] = HEAP8[i9 + i1 >> 0] | 0;
  i14 = HEAP8[i9 + (i1 + 1) >> 0] | 0;
  HEAP8[i7 + 1 >> 0] = i14;
  HEAP8[i7 + 2 >> 0] = 0;
  HEAP8[i6 >> 0] = 0;
  HEAP8[i6 + 1 >> 0] = 0;
  HEAP8[i6 + 2 >> 0] = 0;
  _fec_secded2216_estimate_ehat(i7, i6);
  HEAP8[i8 + i2 >> 0] = HEAP8[i6 + 1 >> 0] ^ i14;
  i2 = i2 | i10;
  i1 = i10 + 1 + i1 | 0;
 }
 if ((i1 | 0) != ((i12 >>> 1) + i12 + i10 | 0)) ___assert_fail(gb + 17814 | 0, gb + 17878 | 0, 323, gb + 17929 | 0);
 if ((i2 | 0) == (i12 | 0)) {
  STACKTOP = i11;
  return;
 } else ___assert_fail(gb + 18406 | 0, gb + 17878 | 0, 324, gb + 17929 | 0);
}

function ___fwritex(i2, i3, i8) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i8 = i8 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i4 = i8 + 16 | 0;
 i1 = HEAP32[i4 >> 2] | 0;
 do if (!i1) {
  i1 = i8 + 74 | 0;
  i7 = HEAP8[i1 >> 0] | 0;
  HEAP8[i1 >> 0] = i7 + 255 | i7;
  i1 = HEAP32[i8 >> 2] | 0;
  if (!(i1 & 8)) {
   HEAP32[i8 + 8 >> 2] = 0;
   HEAP32[i8 + 4 >> 2] = 0;
   i5 = HEAP32[i8 + 44 >> 2] | 0;
   HEAP32[i8 + 28 >> 2] = i5;
   i7 = i8 + 20 | 0;
   HEAP32[i7 >> 2] = i5;
   i6 = i5 + (HEAP32[i8 + 48 >> 2] | 0) | 0;
   HEAP32[i4 >> 2] = i6;
   i4 = i6;
   i6 = 6;
   break;
  } else {
   HEAP32[i8 >> 2] = i1 | 32;
   break;
  }
 } else {
  i5 = i8 + 20 | 0;
  i4 = i1;
  i7 = i5;
  i5 = HEAP32[i5 >> 2] | 0;
  i6 = 6;
 } while (0);
 L7 : do if ((i6 | 0) == 6) {
  i1 = i5;
  if ((i4 - i5 | 0) >>> 0 < i3 >>> 0) {
   mftCall_iiii(HEAP32[i8 + 36 >> 2] | 0, i8 | 0, i2 | 0, i3 | 0) | 0;
   break;
  }
  L12 : do if ((HEAP8[i8 + 75 >> 0] | 0) > -1) {
   i5 = i3;
   while (1) {
    if (!i5) break L12;
    i4 = i5 + -1 | 0;
    if ((HEAP8[i2 + i4 >> 0] | 0) == 10) break; else i5 = i4;
   }
   if ((mftCall_iiii(HEAP32[i8 + 36 >> 2] | 0, i8 | 0, i2 | 0, i5 | 0) | 0) >>> 0 < i5 >>> 0) break L7;
   i3 = i3 - i5 | 0;
   i2 = i2 + i5 | 0;
   i1 = HEAP32[i7 >> 2] | 0;
  } while (0);
  _memcpy(i1 | 0, i2 | 0, i3 | 0) | 0;
  HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + i3;
 } while (0);
 return;
}

function _json_delete(i9) {
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 if (!i9) return;
 switch (HEAP32[i9 >> 2] | 0) {
 case 0:
  {
   i4 = i9 + 20 | 0;
   i1 = HEAP32[i9 + 24 >> 2] | 0;
   if ((i1 | 0) != (i4 | 0)) do {
    i3 = i1;
    i1 = HEAP32[i1 + 4 >> 2] | 0;
    i2 = HEAP32[i3 + 12 >> 2] | 0;
    if ((i2 | 0 ? (i7 = i2 + 4 | 0, i8 = HEAP32[i7 >> 2] | 0, (i8 | 0) != -1) : 0) ? (i6 = i8 + -1 | 0, HEAP32[i7 >> 2] = i6, (i6 | 0) == 0) : 0) _json_delete(i2);
    if (i3 | 0) _free(i3);
   } while ((i1 | 0) != (i4 | 0));
   i1 = HEAP32[i9 + 12 >> 2] | 0;
   if (i1 | 0) _free(i1);
   _free(i9);
   return;
  }
 case 1:
  {
   i1 = i9 + 12 | 0;
   i3 = i9 + 16 | 0;
   if (HEAP32[i1 >> 2] | 0) {
    i4 = 0;
    do {
     i2 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i4 << 2) >> 2] | 0;
     if ((i2 | 0 ? (i5 = i2 + 4 | 0, i6 = HEAP32[i5 >> 2] | 0, (i6 | 0) != -1) : 0) ? (i8 = i6 + -1 | 0, HEAP32[i5 >> 2] = i8, (i8 | 0) == 0) : 0) _json_delete(i2);
     i4 = i4 + 1 | 0;
    } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
   }
   i1 = HEAP32[i3 >> 2] | 0;
   if (i1 | 0) _free(i1);
   _free(i9);
   return;
  }
 case 2:
  {
   i1 = HEAP32[i9 + 8 >> 2] | 0;
   if (i1 | 0) _free(i1);
   _free(i9);
   return;
  }
 case 3:
  {
   _free(i9);
   return;
  }
 case 4:
  {
   _free(i9);
   return;
  }
 default:
  return;
 }
}

function _modem_demodulate_qam(i13, i8, i14) {
 i13 = i13 | 0;
 i8 = i8 | 0;
 i14 = i14 | 0;
 var i1 = 0, d2 = 0.0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, d9 = 0.0, i10 = 0, d11 = 0.0, d12 = 0.0;
 d12 = +HEAPF32[i8 >> 2];
 i5 = HEAP32[i13 + 100 >> 2] | 0;
 if (!i5) {
  d11 = d12;
  i10 = 0;
 } else {
  i6 = i5 + -1 | 0;
  d2 = d12;
  i4 = 0;
  i7 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i13 + 12 + (i4 + i6 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i13 + 12 + (i4 + i6 << 2) >> 2];
   i3 = i7 + 1 | 0;
   if ((i3 | 0) == (i5 | 0)) {
    d11 = d2;
    i10 = i1;
    break;
   } else {
    i4 = ~i7;
    i7 = i3;
   }
  }
 }
 d9 = +HEAPF32[i8 + 4 >> 2];
 i7 = HEAP32[i13 + 104 >> 2] | 0;
 if (!i7) {
  d2 = d9;
  i1 = 0;
 } else {
  i5 = i7 + -1 | 0;
  d2 = d9;
  i4 = 0;
  i6 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i13 + 12 + (i4 + i5 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i13 + 12 + (i4 + i5 << 2) >> 2];
   i3 = i6 + 1 | 0;
   if ((i3 | 0) == (i7 | 0)) break; else {
    i4 = ~i6;
    i6 = i3;
   }
  }
 }
 HEAP32[i14 >> 2] = ((i10 >>> 1 ^ i10) << i7) + (i1 >>> 1 ^ i1);
 HEAPF32[i13 + 92 >> 2] = d12 - (d11 + d2 * 0.0);
 HEAPF32[i13 + 96 >> 2] = d9 - d2;
 HEAPF32[i13 + 84 >> 2] = d12;
 HEAPF32[i13 + 88 >> 2] = d9;
 return;
}

function _modem_demodulate_psk(i11, i1, i12) {
 i11 = i11 | 0;
 i1 = i1 | 0;
 i12 = i12 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = HEAP32[i1 >> 2] | 0;
 i9 = HEAP32[i1 + 4 >> 2] | 0;
 d2 = (HEAP32[tempDoublePtr >> 2] = i9, +HEAPF32[tempDoublePtr >> 2]);
 d2 = +Math_atan2(+d2, +(HEAP32[tempDoublePtr >> 2] = i10, +HEAPF32[tempDoublePtr >> 2]));
 d2 = d2 - +HEAPF32[i11 + 100 >> 2];
 d3 = d2;
 i7 = HEAP32[i11 + 4 >> 2] | 0;
 if (!i7) i1 = 0; else {
  i8 = i7 + -1 | 0;
  d2 = d3 < -3.141592653589793 ? d3 + 6.283185307179586 : d2;
  i5 = 0;
  i6 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i11 + 12 + (i5 + i8 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i11 + 12 + (i5 + i8 << 2) >> 2];
   i4 = i6 + 1 | 0;
   if ((i4 | 0) == (i7 | 0)) break; else {
    i5 = ~i6;
    i6 = i4;
   }
  }
 }
 i8 = i1 >>> 1 ^ i1;
 HEAP32[i12 >> 2] = i8;
 d2 = +HEAPF32[i11 + 104 >> 2] * +((i8 >>> 1 ^ i8 ^ i8 >>> 2 ^ i8 >>> 3 ^ i8 >>> 4 ^ i8 >>> 5 ^ i8 >>> 6 ^ i8 >>> 7 ^ i8 >>> 8 ^ i8 >>> 9 ^ i8 >>> 10 ^ i8 >>> 11 ^ i8 >>> 12 ^ i8 >>> 13 ^ i8 >>> 14 ^ i8 >>> 15 ^ i8 >>> 16) << 1 >>> 0);
 d3 = +Math_sin(+d2);
 HEAPF32[i11 + 92 >> 2] = +Math_cos(+d2) + d3 * 0.0;
 HEAPF32[i11 + 96 >> 2] = d3;
 HEAP32[i11 + 84 >> 2] = i10;
 HEAP32[i11 + 88 >> 2] = i9;
 return;
}

function _qpacketmodem_configure(i9, i4, i6, i7, i8, i2) {
 i9 = i9 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i5 = 0;
 i3 = i9 + 12 | 0;
 HEAP32[i3 >> 2] = i4;
 i1 = HEAP32[i9 >> 2] | 0;
 if ((HEAP32[i1 >> 2] | 0) == (i2 | 0)) i2 = i4; else {
  _modem_destroy(i1);
  i1 = _modem_create(i2) | 0;
  i2 = HEAP32[i3 >> 2] | 0;
 }
 HEAP32[i9 >> 2] = i1;
 i4 = i9 + 8 | 0;
 HEAP32[i4 >> 2] = HEAP32[i1 + 4 >> 2];
 i3 = i9 + 4 | 0;
 i1 = HEAP32[i3 >> 2] | 0;
 do if (!i1) i1 = _packetizer_create(i2, i6, i7, i8) | 0; else {
  if ((((HEAP32[i1 >> 2] | 0) == (i2 | 0) ? (HEAP32[i1 + 8 >> 2] | 0) == (i6 | 0) : 0) ? (i5 = HEAP32[i1 + 16 >> 2] | 0, (HEAP32[i5 + 8 >> 2] | 0) == (i7 | 0)) : 0) ? (HEAP32[i5 + 28 >> 2] | 0) == (i8 | 0) : 0) break;
  _packetizer_destroy(i1);
  i1 = _packetizer_create(i2, i6, i7, i8) | 0;
 } while (0);
 HEAP32[i3 >> 2] = i1;
 i6 = HEAP32[i1 + 4 >> 2] | 0;
 HEAP32[i9 + 24 >> 2] = i6;
 i6 = i6 << 3;
 HEAP32[i9 + 28 >> 2] = i6;
 i5 = HEAP32[i4 >> 2] | 0;
 i6 = (((i6 | 0) % (i5 | 0) | 0 | 0) != 0 & 1) + ((i6 | 0) / (i5 | 0) | 0) | 0;
 i8 = i9 + 32 | 0;
 HEAP32[i8 >> 2] = i6;
 i7 = i9 + 16 | 0;
 HEAP32[i7 >> 2] = _realloc(HEAP32[i7 >> 2] | 0, Math_imul(i5, i6) | 0) | 0;
 i9 = i9 + 20 | 0;
 HEAP32[i9 >> 2] = _realloc(HEAP32[i9 >> 2] | 0, HEAP32[i8 >> 2] << 2) | 0;
 return;
}

function _polyf_fit(i8, i9, i6, i7, i5) {
 i8 = i8 | 0;
 i9 = i9 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, i10 = 0, i11 = 0, d12 = 0.0, i13 = 0;
 i13 = STACKTOP;
 i1 = Math_imul(i5, i6) | 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 if (!((i6 | 0) == 0 | (i5 | 0) == 0)) {
  i11 = 0;
  do {
   i3 = Math_imul(i11, i5) | 0;
   d4 = +HEAPF32[i8 + (i11 << 2) >> 2];
   i10 = 0;
   d12 = 1.0;
   while (1) {
    HEAPF32[i2 + (i10 + i3 << 2) >> 2] = d12;
    i10 = i10 + 1 | 0;
    if ((i10 | 0) == (i5 | 0)) break; else d12 = d4 * d12;
   }
   i11 = i11 + 1 | 0;
  } while ((i11 | 0) != (i6 | 0));
 }
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i10 | 0, i2 | 0, i1 << 2 | 0) | 0;
 _matrixf_hermitian(i10, i6, i5);
 i11 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i5 << 2) | 0) + 15 & -16) | 0;
 _matrixf_mul(i10, i5, i6, i9, i6, 1, i11, i5, 1);
 i9 = Math_imul(i5, i5) | 0;
 i8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 _matrixf_mul(i10, i5, i6, i2, i6, i5, i8, i5, i5);
 i10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i9 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i10 | 0, i8 | 0, i9 << 2 | 0) | 0;
 _matrixf_inv(i10, i5, i5);
 _matrixf_mul(i10, i5, i5, i11, i5, 1, i7, i5, 1);
 STACKTOP = i13;
 return;
}

function runPostSets2() {
 HEAP32[gb + 1740 >> 2] = (HEAP32[gb + 1740 >> 2] | 0) + (gb + 32048 | 0);
 HEAP32[gb + 1808 >> 2] = (HEAP32[gb + 1808 >> 2] | 0) + (gb + 1744 | 0);
 HEAP32[gb + 1812 >> 2] = (HEAP32[gb + 1812 >> 2] | 0) + (gb + 1764 | 0);
 HEAP32[gb + 1816 >> 2] = (HEAP32[gb + 1816 >> 2] | 0) + (gb + 41308 | 0);
 HEAP32[gb + 1820 >> 2] = (HEAP32[gb + 1820 >> 2] | 0) + (gb + 1784 | 0);
 HEAP32[gb + 1824 >> 2] = (HEAP32[gb + 1824 >> 2] | 0) + (gb + 32112 | 0);
 HEAP32[gb + 1916 >> 2] = (HEAP32[gb + 1916 >> 2] | 0) + (gb + 1828 | 0);
 HEAP32[gb + 1920 >> 2] = (HEAP32[gb + 1920 >> 2] | 0) + (gb + 1856 | 0);
 HEAP32[gb + 1924 >> 2] = (HEAP32[gb + 1924 >> 2] | 0) + (gb + 41328 | 0);
 HEAP32[gb + 1928 >> 2] = (HEAP32[gb + 1928 >> 2] | 0) + (gb + 1884 | 0);
 HEAP32[gb + 1932 >> 2] = (HEAP32[gb + 1932 >> 2] | 0) + (gb + 32240 | 0);
 HEAP32[gb + 8740 >> 2] = fb + 1;
 HEAP32[gb + 8764 >> 2] = fb + 1;
 HEAP32[gb + 8768 >> 2] = fb + 2;
 HEAP32[gb + 8772 >> 2] = (HEAP32[gb + 8772 >> 2] | 0) + (gb + 41905 | 0);
 HEAP32[gb + 8852 >> 2] = fb + 1;
 HEAP32[gb + 8876 >> 2] = fb + 3;
 HEAP32[gb + 8880 >> 2] = fb + 2;
 HEAP32[gb + 8884 >> 2] = (HEAP32[gb + 8884 >> 2] | 0) + (gb + 41913 | 0);
 HEAP32[gb + 8952 >> 2] = (HEAP32[gb + 8952 >> 2] | 0) + (gb + 8840 | 0);
 HEAP32[gb + 8992 >> 2] = fb + 4;
}

function _ofdmflexframesync_set_header_len(i4, i1) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 HEAP32[i4 + 56 >> 2] = i1;
 i3 = i1 + 6 | 0;
 i1 = i4 + 60 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = i4 + 44 | 0;
 HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, i3) | 0;
 i2 = i4 + 40 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if (i3 | 0) _packetizer_destroy(i3);
 i3 = _packetizer_create(HEAP32[i1 >> 2] | 0, 6, 7, 1) | 0;
 HEAP32[i2 >> 2] = i3;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 i2 = i4 + 64 | 0;
 HEAP32[i2 >> 2] = i3;
 i1 = i4 + 48 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i3) | 0;
 i2 = HEAP32[i2 >> 2] << 3;
 HEAP32[i4 + 68 >> 2] = i2;
 i1 = i4 + 52 | 0;
 HEAP32[i1 >> 2] = _realloc(HEAP32[i1 >> 2] | 0, i2) | 0;
 i1 = i4 + 36 | 0;
 i2 = HEAP32[i1 >> 2] | 0;
 if (i2 | 0) _modem_destroy(i2);
 i4 = _malloc(252) | 0;
 HEAP32[i4 >> 2] = 47;
 HEAP32[i4 + 76 >> 2] = 0;
 HEAP32[i4 + 80 >> 2] = 0;
 HEAP32[i4 + 4 >> 2] = 1;
 HEAP32[i4 + 8 >> 2] = 2;
 i3 = i4 + 236 | 0;
 HEAP32[i3 >> 2] = 0;
 HEAP32[i3 + 4 >> 2] = 0;
 HEAP32[i3 + 8 >> 2] = 0;
 HEAP32[i3 + 12 >> 2] = 0;
 HEAP32[i3 >> 2] = fb + 3;
 HEAP32[i4 + 240 >> 2] = fb + 4;
 HEAPF32[i4 + 84 >> 2] = 1.0;
 HEAPF32[i4 + 88 >> 2] = 0.0;
 HEAP32[i4 + 92 >> 2] = 1065353216;
 HEAPF32[i4 + 96 >> 2] = 0.0;
 HEAP32[i1 >> 2] = i4;
 return;
}

function _modem_demodulate_dpsk(i12, i1, i13) {
 i12 = i12 | 0;
 i1 = i1 | 0;
 i13 = i13 | 0;
 var d2 = 0.0, d3 = 0.0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, d10 = 0.0, i11 = 0;
 i11 = HEAP32[i1 >> 2] | 0;
 i9 = HEAP32[i1 + 4 >> 2] | 0;
 d10 = (HEAP32[tempDoublePtr >> 2] = i9, +HEAPF32[tempDoublePtr >> 2]);
 d10 = +Math_atan2(+d10, +(HEAP32[tempDoublePtr >> 2] = i11, +HEAPF32[tempDoublePtr >> 2]));
 i8 = i12 + 104 | 0;
 d2 = d10 - +HEAPF32[i8 >> 2];
 HEAPF32[i8 >> 2] = d10;
 d2 = d2 - +HEAPF32[i12 + 100 >> 2];
 d3 = d2;
 if (!(d3 > 3.141592653589793)) {
  if (d3 < -3.141592653589793) d2 = d3 + 6.283185307179586;
 } else d2 = d3 + -6.283185307179586;
 i7 = HEAP32[i12 + 4 >> 2] | 0;
 if (!i7) i1 = 0; else {
  i8 = i7 + -1 | 0;
  i5 = 0;
  i6 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d2 > 0.0) {
    d2 = d2 - +HEAPF32[i12 + 12 + (i5 + i8 << 2) >> 2];
    i1 = i1 | 1;
   } else d2 = d2 + +HEAPF32[i12 + 12 + (i5 + i8 << 2) >> 2];
   i4 = i6 + 1 | 0;
   if ((i4 | 0) == (i7 | 0)) break; else {
    i5 = ~i6;
    i6 = i4;
   }
  }
 }
 HEAP32[i13 >> 2] = i1 >>> 1 ^ i1;
 d3 = d10 - d2;
 d10 = +Math_sin(+d3);
 HEAPF32[i12 + 92 >> 2] = +Math_cos(+d3) + d10 * 0.0;
 HEAPF32[i12 + 96 >> 2] = d10;
 HEAP32[i12 + 84 >> 2] = i11;
 HEAP32[i12 + 88 >> 2] = i9;
 return;
}

function _fec_secded7264_compute_syndrome(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 i4 = HEAPU8[i1 >> 0] | 0;
 i8 = HEAP8[i1 + 1 >> 0] | 0;
 i9 = HEAP8[i1 + 2 >> 0] | 0;
 i10 = HEAP8[i1 + 3 >> 0] | 0;
 i11 = HEAP8[i1 + 4 >> 0] | 0;
 i5 = HEAP8[i1 + 5 >> 0] | 0;
 i6 = HEAP8[i1 + 6 >> 0] | 0;
 i7 = HEAP8[i1 + 7 >> 0] | 0;
 i1 = HEAP8[i1 + 8 >> 0] | 0;
 i2 = 0;
 i3 = 0;
 do {
  i12 = i2 << 3;
  i3 = ((1 << 7 - i2 & i4 | 0) != 0 & 1) + (HEAPU8[(HEAP8[gb + 18155 + i12 >> 0] & i8 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 1) + (gb + 18155) >> 0] & i9 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 2) + (gb + 18155) >> 0] & i10 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 3) + (gb + 18155) >> 0] & i11 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 4) + (gb + 18155) >> 0] & i5 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 5) + (gb + 18155) >> 0] & i6 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 6) + (gb + 18155) >> 0] & i7 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i12 | 7) + (gb + 18155) >> 0] & i1 & 255) + (gb + 36235) >> 0] | 0) & 1 | i3 << 1 & 510;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 8);
 return i3 & 255 | 0;
}

function _ofdmframesync_S0_metrics(i15, i13, i16) {
 i15 = i15 | 0;
 i13 = i13 | 0;
 i16 = i16 | 0;
 var d1 = 0.0, d2 = 0.0, i3 = 0, d4 = 0.0, d5 = 0.0, d6 = 0.0, d7 = 0.0, d8 = 0.0, d9 = 0.0, i10 = 0, i11 = 0, i12 = 0, i14 = 0, i17 = 0, i18 = 0, i19 = 0;
 i17 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i11 = i17 + 8 | 0;
 i14 = i17;
 i3 = HEAP32[i15 >> 2] | 0;
 if (!i3) {
  d2 = 0.0;
  d1 = 0.0;
 } else {
  i12 = i11 + 4 | 0;
  i10 = 0;
  d2 = 0.0;
  d1 = 0.0;
  do {
   i18 = i10;
   i10 = i10 + 2 | 0;
   i19 = (i10 >>> 0) % (i3 >>> 0) | 0;
   d9 = +HEAPF32[i13 + (i19 << 3) >> 2];
   d6 = +HEAPF32[i13 + (i19 << 3) + 4 >> 2];
   d7 = +HEAPF32[i13 + (i18 << 3) >> 2];
   d8 = -+HEAPF32[i13 + (i18 << 3) + 4 >> 2];
   d4 = d9 * d7 - d6 * d8;
   d5 = d6 * d7 + d9 * d8;
   if ((d4 != d4 | 0.0 != 0.0) & (d5 != d5 | 0.0 != 0.0)) {
    ___mulsc3(i11, d9, d6, d7, d8);
    d4 = +HEAPF32[i11 >> 2];
    d5 = +HEAPF32[i12 >> 2];
    i3 = HEAP32[i15 >> 2] | 0;
   }
   d2 = d2 + d4;
   d1 = d1 + d5;
  } while (i10 >>> 0 < i3 >>> 0);
 }
 ___divsc3(i14, d2, d1, +((HEAP32[i15 + 28 >> 2] | 0) >>> 0), 0.0);
 i19 = HEAP32[i14 + 4 >> 2] | 0;
 HEAP32[i16 >> 2] = HEAP32[i14 >> 2];
 HEAP32[i16 + 4 >> 2] = i19;
 STACKTOP = i17;
 return;
}

function _fec_conv_decode_soft(i7, i1, i6, i5) {
 i7 = i7 | 0;
 i1 = i1 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i4 = i7 + 8 | 0;
 if ((HEAP32[i4 >> 2] | 0) == (i1 | 0)) {
  i1 = i7 + 12 | 0;
  i2 = i7 + 16 | 0;
 } else {
  HEAP32[i4 >> 2] = i1;
  i3 = i7 + 12 | 0;
  HEAP32[i3 >> 2] = _fec_get_enc_msg_length(HEAP32[i7 >> 2] | 0, i1) | 0;
  i1 = i7 + 20 | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  if (i2 | 0) mftCall_vi(HEAP32[i7 + 60 >> 2] | 0, i2 | 0);
  HEAP32[i1 >> 2] = mftCall_ii(HEAP32[i7 + 44 >> 2] | 0, HEAP32[i4 >> 2] << 3 | 0) | 0;
  i2 = i7 + 16 | 0;
  HEAP32[i2 >> 2] = _realloc(HEAP32[i2 >> 2] | 0, HEAP32[i3 >> 2] << 3) | 0;
  i1 = i3;
 }
 if (HEAP32[i1 >> 2] & 536870911 | 0) {
  i3 = 0;
  do {
   HEAP8[(HEAP32[i2 >> 2] | 0) + i3 >> 0] = HEAP8[i6 + i3 >> 0] | 0;
   i3 = i3 + 1 | 0;
  } while (i3 >>> 0 < HEAP32[i1 >> 2] << 3 >>> 0);
 }
 i6 = i7 + 20 | 0;
 mftCall_iii(HEAP32[i7 + 48 >> 2] | 0, HEAP32[i6 >> 2] | 0, 0) | 0;
 mftCall_iiii(HEAP32[i7 + 52 >> 2] | 0, HEAP32[i6 >> 2] | 0, HEAP32[i2 >> 2] | 0, (HEAP32[i7 + 32 >> 2] | 0) + -1 + (HEAP32[i4 >> 2] << 3) | 0) | 0;
 mftCall_iiiii(HEAP32[i7 + 56 >> 2] | 0, HEAP32[i6 >> 2] | 0, i5 | 0, HEAP32[i4 >> 2] << 3 | 0, 0) | 0;
 return;
}

function _firinterp_crcf_create(i8, i6, i7) {
 i8 = i8 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, d4 = 0.0, i5 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i9 + 8 | 0;
 i1 = i9;
 if (i8 >>> 0 < 2) {
  HEAP32[i1 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18663 | 0, i1);
  _exit(1);
 }
 if (i7 >>> 0 < i8 >>> 0) {
  HEAP32[i2 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18731 | 0, i2);
  _exit(1);
 }
 i5 = _malloc(20) | 0;
 HEAP32[i5 + 12 >> 2] = i8;
 i2 = i5 + 4 | 0;
 HEAP32[i2 >> 2] = i7;
 i3 = 0;
 while (1) {
  i1 = Math_imul(i3, i8) | 0;
  if (i1 >>> 0 < i7 >>> 0) i3 = i3 + 1 | 0; else break;
 }
 HEAP32[i5 + 8 >> 2] = i3;
 HEAP32[i2 >> 2] = i1;
 i3 = _malloc(i1 << 2) | 0;
 HEAP32[i5 >> 2] = i3;
 if (!i1) {
  i7 = 0;
  i7 = _firpfb_crcf_create(i8, i3, i7) | 0;
  i8 = i5 + 16 | 0;
  HEAP32[i8 >> 2] = i7;
  STACKTOP = i9;
  return i5 | 0;
 } else i2 = 0;
 do {
  if (i2 >>> 0 < i7 >>> 0) d4 = +HEAPF32[i6 + (i2 << 2) >> 2]; else d4 = 0.0;
  HEAPF32[i3 + (i2 << 2) >> 2] = d4;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i1 | 0));
 i7 = _firpfb_crcf_create(i8, i3, i1) | 0;
 i8 = i5 + 16 | 0;
 HEAP32[i8 >> 2] = i7;
 STACKTOP = i9;
 return i5 | 0;
}

function _fec_secded3932_estimate_ehat(i1, i8) {
 i1 = i1 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0;
 HEAP8[i8 >> 0] = 0;
 HEAP8[i8 + 1 >> 0] = 0;
 HEAP8[i8 + 2 >> 0] = 0;
 HEAP8[i8 + 3 >> 0] = 0;
 HEAP8[i8 + 4 >> 0] = 0;
 i3 = HEAPU8[i1 >> 0] | 0;
 i4 = HEAP8[i1 + 1 >> 0] | 0;
 i5 = HEAP8[i1 + 2 >> 0] | 0;
 i6 = HEAP8[i1 + 3 >> 0] | 0;
 i1 = HEAP8[i1 + 4 >> 0] | 0;
 i2 = 0;
 i7 = 0;
 do {
  i10 = i2 << 2;
  i7 = ((1 << 6 - i2 & i3 | 0) != 0 & 1) + (HEAPU8[(HEAP8[gb + 17951 + i10 >> 0] & i4 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i10 | 1) + (gb + 17951) >> 0] & i5 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i10 | 2) + (gb + 17951) >> 0] & i6 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i10 | 3) + (gb + 17951) >> 0] & i1 & 255) + (gb + 36235) >> 0] | 0) & 1 | i7 << 1 & 510;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 7);
 i2 = i7 & 255;
 if (!(i7 & 255)) return; else i1 = 0;
 while (1) {
  if (i2 << 24 >> 24 == (HEAP8[gb + 17979 + i1 >> 0] | 0)) break;
  i1 = i1 + 1 | 0;
  if (i1 >>> 0 >= 39) {
   i9 = 7;
   break;
  }
 }
 if ((i9 | 0) == 7) return;
 HEAP8[i8 + (4 - ((i1 | 0) / 8 | 0)) >> 0] = 1 << (i1 & 7);
 return;
}

function _fec_secded7264_compute_parity(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i4 = HEAP8[i1 >> 0] | 0;
 i7 = HEAP8[i1 + 1 >> 0] | 0;
 i8 = HEAP8[i1 + 2 >> 0] | 0;
 i9 = HEAP8[i1 + 3 >> 0] | 0;
 i10 = HEAP8[i1 + 4 >> 0] | 0;
 i5 = HEAP8[i1 + 5 >> 0] | 0;
 i6 = HEAP8[i1 + 6 >> 0] | 0;
 i1 = HEAP8[i1 + 7 >> 0] | 0;
 i2 = 0;
 i3 = 0;
 do {
  i11 = i2 << 3;
  i3 = (HEAPU8[(HEAP8[(i11 | 1) + (gb + 18155) >> 0] & i7 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[gb + 18155 + i11 >> 0] & i4 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i11 | 2) + (gb + 18155) >> 0] & i8 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i11 | 3) + (gb + 18155) >> 0] & i9 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i11 | 4) + (gb + 18155) >> 0] & i10 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i11 | 5) + (gb + 18155) >> 0] & i5 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i11 | 6) + (gb + 18155) >> 0] & i6 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(HEAP8[(i11 | 7) + (gb + 18155) >> 0] & i1 & 255) + (gb + 36235) >> 0] | 0) & 1 | i3 << 1 & 510;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != 8);
 return i3 & 255 | 0;
}

function _vsnprintf(i3, i2, i13, i11) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i13 = i13 | 0;
 i11 = i11 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i14 = 0, i15 = 0;
 i15 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i1 = i15 + 112 | 0;
 i12 = i15;
 i4 = i12;
 i5 = gb + 8956 | 0;
 i6 = i4 + 112 | 0;
 do {
  HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
  i4 = i4 + 4 | 0;
  i5 = i5 + 4 | 0;
 } while ((i4 | 0) < (i6 | 0));
 if ((i2 + -1 | 0) >>> 0 > 2147483646) if (!i2) {
  i7 = i1;
  i8 = 1;
  i14 = 6;
 } else {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i1 >> 2] = 75;
 } else {
  i7 = i3;
  i8 = i2;
  i14 = 6;
 }
 if ((i14 | 0) == 6 ? (i14 = -2 - i7 | 0, i14 = i8 >>> 0 > i14 >>> 0 ? i14 : i8, HEAP32[i12 + 48 >> 2] = i14, i9 = i12 + 20 | 0, HEAP32[i9 >> 2] = i7, HEAP32[i12 + 44 >> 2] = i7, i8 = i7 + i14 | 0, i10 = i12 + 16 | 0, HEAP32[i10 >> 2] = i8, HEAP32[i12 + 28 >> 2] = i8, _vfprintf(i12, i13, i11) | 0, i14 | 0) : 0) {
  i14 = HEAP32[i9 >> 2] | 0;
  HEAP8[i14 + (((i14 | 0) == (HEAP32[i10 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
 }
 STACKTOP = i15;
 return;
}

function _modem_demodulate_ask(i9, i11, i10) {
 i9 = i9 | 0;
 i11 = i11 | 0;
 i10 = i10 | 0;
 var i1 = 0, i2 = 0, d3 = 0.0, i4 = 0, i5 = 0, d6 = 0.0, i7 = 0, i8 = 0;
 i5 = HEAP32[i9 + 4 >> 2] | 0;
 if (!i5) {
  i2 = HEAP32[i11 >> 2] | 0;
  i1 = 0;
 } else {
  d6 = +HEAPF32[i11 >> 2];
  i7 = i5 + -1 | 0;
  d3 = d6;
  i4 = 0;
  i8 = 0;
  i1 = 0;
  while (1) {
   i1 = i1 << 1;
   if (d3 > 0.0) {
    d3 = d3 - +HEAPF32[i9 + 12 + (i4 + i7 << 2) >> 2];
    i1 = i1 | 1;
   } else d3 = d3 + +HEAPF32[i9 + 12 + (i4 + i7 << 2) >> 2];
   i2 = i8 + 1 | 0;
   if ((i2 | 0) == (i5 | 0)) break; else {
    i4 = ~i8;
    i8 = i2;
   }
  }
  i2 = (HEAPF32[tempDoublePtr >> 2] = d6, HEAP32[tempDoublePtr >> 2] | 0);
 }
 i8 = i1 >>> 1 ^ i1;
 HEAP32[i10 >> 2] = i8;
 HEAPF32[i9 + 92 >> 2] = +HEAPF32[i9 + 100 >> 2] * +(1 - (HEAP32[i9 + 8 >> 2] | 0) + ((i8 >>> 1 ^ i8 ^ i8 >>> 2 ^ i8 >>> 3 ^ i8 >>> 4 ^ i8 >>> 5 ^ i8 >>> 6 ^ i8 >>> 7 ^ i8 >>> 8 ^ i8 >>> 9 ^ i8 >>> 10 ^ i8 >>> 11 ^ i8 >>> 12 ^ i8 >>> 13 ^ i8 >>> 14 ^ i8 >>> 15 ^ i8 >>> 16) << 1) | 0);
 HEAPF32[i9 + 96 >> 2] = 0.0;
 i11 = HEAP32[i11 + 4 >> 2] | 0;
 HEAP32[i9 + 84 >> 2] = i2;
 HEAP32[i9 + 88 >> 2] = i11;
 return;
}

function _memchr(i1, i5, i2) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i6 = 0, i7 = 0;
 i6 = i5 & 255;
 i3 = (i2 | 0) != 0;
 L1 : do if (i3 & (i1 & 3 | 0) != 0) {
  i4 = i5 & 255;
  while (1) {
   if ((HEAP8[i1 >> 0] | 0) == i4 << 24 >> 24) break L1;
   i1 = i1 + 1 | 0;
   i2 = i2 + -1 | 0;
   i3 = (i2 | 0) != 0;
   if (!(i3 & (i1 & 3 | 0) != 0)) {
    i7 = 5;
    break;
   }
  }
 } else i7 = 5; while (0);
 L6 : do if ((i7 | 0) == 5) if (i3) {
  i4 = i5 & 255;
  if ((HEAP8[i1 >> 0] | 0) != i4 << 24 >> 24) {
   i3 = Math_imul(i6, 16843009) | 0;
   L10 : do if (i2 >>> 0 > 3) while (1) {
    i6 = HEAP32[i1 >> 2] ^ i3;
    if ((i6 & -2139062144 ^ -2139062144) & i6 + -16843009 | 0) break;
    i1 = i1 + 4 | 0;
    i2 = i2 + -4 | 0;
    if (i2 >>> 0 <= 3) {
     i7 = 11;
     break L10;
    }
   } else i7 = 11; while (0);
   if ((i7 | 0) == 11) if (!i2) {
    i2 = 0;
    break;
   }
   while (1) {
    if ((HEAP8[i1 >> 0] | 0) == i4 << 24 >> 24) break L6;
    i1 = i1 + 1 | 0;
    i2 = i2 + -1 | 0;
    if (!i2) {
     i2 = 0;
     break;
    }
   }
  }
 } else i2 = 0; while (0);
 return (i2 | 0 ? i1 : 0) | 0;
}

function _jsonp_error_set(i10, i4, i3, i5, i1, i2) {
 i10 = i10 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 i9 = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 i8 = i9 + 16 | 0;
 i7 = i9;
 HEAP32[i7 >> 2] = i2;
 if (!i10) {
  STACKTOP = i9;
  return;
 }
 i6 = i10 + 92 | 0;
 if (HEAP8[i6 >> 0] | 0) {
  STACKTOP = i9;
  return;
 }
 HEAP32[i10 >> 2] = i4;
 HEAP32[i10 + 4 >> 2] = i3;
 HEAP32[i10 + 8 >> 2] = i5;
 i1 = i8;
 i2 = gb + 8956 | 0;
 i3 = i1 + 112 | 0;
 do {
  HEAP32[i1 >> 2] = HEAP32[i2 >> 2];
  i1 = i1 + 4 | 0;
  i2 = i2 + 4 | 0;
 } while ((i1 | 0) < (i3 | 0));
 i5 = -2 - i6 | 0;
 i5 = i5 >>> 0 < 160 ? i5 : 160;
 HEAP32[i8 + 48 >> 2] = i5;
 i2 = i8 + 20 | 0;
 HEAP32[i2 >> 2] = i6;
 HEAP32[i8 + 44 >> 2] = i6;
 i6 = i10 + 92 + i5 | 0;
 i1 = i8 + 16 | 0;
 HEAP32[i1 >> 2] = i6;
 HEAP32[i8 + 28 >> 2] = i6;
 _vfprintf(i8, gb + 41233 | 0, i7) | 0;
 if (i5 | 0) {
  i8 = HEAP32[i2 >> 2] | 0;
  HEAP8[i8 + (((i8 | 0) == (HEAP32[i1 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
 }
 HEAP8[i10 + 251 >> 0] = 0;
 STACKTOP = i9;
 return;
}

function _fecsoft_hamming84_decode(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i8 = HEAPU8[i1 >> 0] | 0;
 i14 = i8 ^ 255;
 i19 = HEAPU8[i1 + 1 >> 0] | 0;
 i20 = i19 ^ 255;
 i21 = HEAPU8[i1 + 2 >> 0] | 0;
 i9 = i21 ^ 255;
 i10 = HEAPU8[i1 + 3 >> 0] | 0;
 i11 = i10 ^ 255;
 i12 = HEAPU8[i1 + 4 >> 0] | 0;
 i13 = i12 ^ 255;
 i15 = HEAPU8[i1 + 5 >> 0] | 0;
 i16 = i15 ^ 255;
 i17 = HEAPU8[i1 + 6 >> 0] | 0;
 i18 = i17 ^ 255;
 i1 = HEAPU8[i1 + 7 >> 0] | 0;
 i2 = i1 ^ 255;
 i4 = 0;
 i5 = 0;
 i7 = 0;
 while (1) {
  i3 = HEAPU8[gb + 12745 + i5 >> 0] | 0;
  i3 = (i3 & 64 | 0 ? i20 : i19) + (i3 & 128 | 0 ? i14 : i8) + (i3 & 32 | 0 ? i9 : i21) + (i3 & 16 | 0 ? i11 : i10) + (i3 & 8 | 0 ? i13 : i12) + (i3 & 4 | 0 ? i16 : i15) + (i3 & 2 | 0 ? i18 : i17) + (i3 & 1 | 0 ? i2 : i1) | 0;
  i6 = (i5 | 0) == 0 | i3 >>> 0 < i4 >>> 0;
  i7 = i6 ? i5 & 255 : i7;
  i5 = i5 + 1 | 0;
  if ((i5 | 0) == 16) break; else i4 = i6 ? i3 : i4;
 }
 return i7 | 0;
}

function _fclose(i5) {
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0;
 i4 = (HEAP32[i5 >> 2] & 1 | 0) != 0;
 if (!i4) {
  ___lock(gb + 41360 + 28 | 0);
  i2 = HEAP32[i5 + 52 >> 2] | 0;
  i1 = i5 + 56 | 0;
  if (i2 | 0) HEAP32[i2 + 56 >> 2] = HEAP32[i1 >> 2];
  i1 = HEAP32[i1 >> 2] | 0;
  if (i1 | 0) HEAP32[i1 + 52 >> 2] = i2;
  if ((HEAP32[gb + 41360 + 24 >> 2] | 0) == (i5 | 0)) HEAP32[gb + 41360 + 24 >> 2] = i1;
  ___unlock(gb + 41360 + 28 | 0);
  if (!i5) {
   if (HEAP32[gb + 8952 >> 2] | 0) _fflush(HEAP32[gb + 8952 >> 2] | 0) | 0;
   ___lock(gb + 41360 + 28 | 0);
   i1 = HEAP32[gb + 41360 + 24 >> 2] | 0;
   if (i1 | 0) do {
    if ((HEAP32[i1 + 20 >> 2] | 0) >>> 0 > (HEAP32[i1 + 28 >> 2] | 0) >>> 0) ___fflush_unlocked(i1) | 0;
    i1 = HEAP32[i1 + 56 >> 2] | 0;
   } while ((i1 | 0) != 0);
   ___unlock(gb + 41360 + 28 | 0);
  } else i3 = 9;
 } else i3 = 9;
 if ((i3 | 0) == 9) ___fflush_unlocked(i5) | 0;
 mftCall_ii(HEAP32[i5 + 12 >> 2] | 0, i5 | 0) | 0;
 i1 = HEAP32[i5 + 92 >> 2] | 0;
 if (i1 | 0) _free(i1);
 if (!i4) _free(i5);
 return;
}

function _fec_hamming128_encode(i1, i7, i5, i6) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0;
 i4 = i7 & 1;
 i2 = i7 - i4 | 0;
 if ((i4 | 0) == (i7 | 0)) i1 = 0; else {
  i3 = 0;
  i1 = 0;
  do {
   i9 = HEAP16[gb + 9100 + ((HEAPU8[i5 + i3 >> 0] | 0) << 1) >> 1] | 0;
   i8 = HEAP16[gb + 9100 + ((HEAPU8[i5 + (i3 | 1) >> 0] | 0) << 1) >> 1] | 0;
   HEAP8[i6 + i1 >> 0] = (i9 & 65535) >>> 4;
   HEAP8[i6 + (i1 + 1) >> 0] = (i8 & 65535) >>> 8 & 15 | (i9 & 65535) << 4;
   HEAP8[i6 + (i1 + 2) >> 0] = i8;
   i1 = i1 + 3 | 0;
   i3 = i3 + 2 | 0;
  } while (i3 >>> 0 < i2 >>> 0);
 }
 if (i4) {
  i9 = HEAP16[gb + 9100 + ((HEAPU8[i5 + (i7 + -1) >> 0] | 0) << 1) >> 1] | 0;
  HEAP8[i6 + i1 >> 0] = (i9 & 65535) >>> 4;
  HEAP8[i6 + (i1 + 1) >> 0] = (i9 & 65535) << 4;
  i1 = i1 + 2 | 0;
 }
 i9 = (i7 & 536870911) * 12 | 0;
 if ((i1 | 0) == ((i9 >>> 2 & 1) + (i9 >>> 3) | 0)) return; else ___assert_fail(gb + 13073 | 0, gb + 13136 | 0, 226, gb + 13165 | 0);
}

function _fecsoft_hamming74_decode(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0;
 i8 = HEAPU8[i1 >> 0] | 0;
 i14 = i8 ^ 255;
 i17 = HEAPU8[i1 + 1 >> 0] | 0;
 i18 = i17 ^ 255;
 i19 = HEAPU8[i1 + 2 >> 0] | 0;
 i9 = i19 ^ 255;
 i10 = HEAPU8[i1 + 3 >> 0] | 0;
 i11 = i10 ^ 255;
 i12 = HEAPU8[i1 + 4 >> 0] | 0;
 i13 = i12 ^ 255;
 i15 = HEAPU8[i1 + 5 >> 0] | 0;
 i16 = i15 ^ 255;
 i1 = HEAPU8[i1 + 6 >> 0] | 0;
 i2 = i1 ^ 255;
 i4 = 0;
 i5 = 0;
 i7 = 0;
 while (1) {
  i3 = HEAPU8[gb + 12547 + i5 >> 0] | 0;
  i3 = (i3 & 32 | 0 ? i18 : i17) + (i3 & 64 | 0 ? i14 : i8) + (i3 & 16 | 0 ? i9 : i19) + (i3 & 8 | 0 ? i11 : i10) + (i3 & 4 | 0 ? i13 : i12) + (i3 & 2 | 0 ? i16 : i15) + (i3 & 1 | 0 ? i2 : i1) | 0;
  i6 = (i5 | 0) == 0 | i3 >>> 0 < i4 >>> 0;
  i7 = i6 ? i5 & 255 : i7;
  i5 = i5 + 1 | 0;
  if ((i5 | 0) == 16) break; else i4 = i6 ? i3 : i4;
 }
 return i7 | 0;
}

function _windowcf_create(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i1 = i6;
 if (!i4) {
  HEAP32[i1 >> 2] = gb + 37013;
  _fprintf(gb + 8728 | 0, gb + 37016 | 0, i1);
  _exit(1);
 }
 i3 = _malloc(28) | 0;
 HEAP32[i3 + 4 >> 2] = i4;
 i1 = i4 >>> 24;
 if (!i1) {
  i1 = i4 >>> 16 & 255;
  if (!i1) {
   i1 = i4 >>> 8 & 255;
   if (!i1) {
    i1 = i4 & 255;
    if (!i1) i1 = 0; else {
     i2 = 8;
     i5 = 4;
    }
   } else {
    i2 = 16;
    i5 = 4;
   }
  } else {
   i2 = 24;
   i5 = 4;
  }
 } else {
  i2 = 32;
  i5 = 4;
 }
 if ((i5 | 0) == 4) i1 = i2 - (HEAP32[gb + 7248 + (i1 << 2) >> 2] | 0) | 0;
 HEAP32[i3 + 8 >> 2] = i1;
 i5 = 1 << i1;
 HEAP32[i3 + 12 >> 2] = i5;
 i5 = i5 + -1 | 0;
 HEAP32[i3 + 16 >> 2] = i5;
 i5 = i5 + i4 | 0;
 HEAP32[i3 + 20 >> 2] = i5;
 i5 = i5 << 3;
 i4 = _malloc(i5) | 0;
 HEAP32[i3 >> 2] = i4;
 HEAP32[i3 + 24 >> 2] = 0;
 _memset(i4 | 0, 0, i5 | 0) | 0;
 STACKTOP = i6;
 return i3 | 0;
}

function _fec_secded2216_encode(i1, i7, i4, i5) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i6 = 0, i8 = 0;
 i6 = i7 & 1;
 i3 = i7 - i6 | 0;
 if ((i6 | 0) == (i7 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i8 = i4 + i2 | 0;
   HEAP8[i5 + i1 >> 0] = _fec_secded2216_compute_parity(HEAP8[i8 >> 0] | 0, HEAP8[i8 + 1 >> 0] | 0) | 0;
   HEAP8[i5 + (i1 + 1) >> 0] = HEAP8[i8 >> 0] | 0;
   HEAP8[i5 + (i1 + 2) >> 0] = HEAP8[i4 + (i2 | 1) >> 0] | 0;
   i1 = i1 + 3 | 0;
   i2 = i2 + 2 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i6) {
  i8 = HEAP8[i4 + i2 >> 0] | 0;
  HEAP8[i5 + i1 >> 0] = _fec_secded2216_compute_parity(i8, 0) | 0;
  HEAP8[i5 + (i1 + 1) >> 0] = i8;
  i2 = i2 | i6;
  i1 = i6 + 1 + i1 | 0;
 }
 if ((i1 | 0) != ((i7 >>> 1) + i7 + i6 | 0)) ___assert_fail(gb + 17814 | 0, gb + 17878 | 0, 274, gb + 17907 | 0);
 if ((i2 | 0) == (i7 | 0)) return; else ___assert_fail(gb + 18406 | 0, gb + 17878 | 0, 275, gb + 17907 | 0);
}

function _firpfb_rrrf_create_rnyquist(i2, i3, d1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 d1 = +d1;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i6 = i7 + 16 | 0;
 i5 = i7 + 8 | 0;
 i4 = i7;
 if (i2 >>> 0 < 2) {
  HEAP32[i4 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19412 | 0, i4);
  _exit(1);
 }
 if (!i3) {
  HEAP32[i5 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19494 | 0, i5);
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  HEAP32[i6 >> 2] = gb + 18446;
  _fprintf(gb + 8728 | 0, gb + 19567 | 0, i6);
  _exit(1);
 } else {
  i6 = Math_imul(i2 << 6, i3) | 0 | 1;
  i4 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i6 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(12, i2 << 5, i3, d1, i4);
  i5 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i6 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i5 | 0, i4 | 0, Math_imul(i2 << 8, i3) | 0 | 4 | 0) | 0;
  i6 = _firpfb_rrrf_create(32, i5, i6) | 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 return 0;
}

function _quiet_encoder_clamp_frame_len(i6, i1) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, d7 = 0.0, i8 = 0;
 HEAP8[i6 + 92 >> 0] = 1;
 d7 = +HEAPF32[i6 + 148 >> 2];
 i2 = ~~(+Math_ceil(+(+(i1 >>> 0) / d7)) + +Math_ceil(+d7)) >>> 0;
 i1 = HEAP32[i6 + 104 >> 2] | 0;
 if (!i1) i1 = 0; else i1 = Math_imul(HEAP32[i1 >> 2] << 1, HEAP32[i1 + 4 >> 2] | 0) | 0;
 i1 = i2 - i1 | 0;
 if (HEAP32[i6 + 152 >> 2] | 0) i1 = i1 - (HEAP32[i6 + 44 >> 2] | 0) | 0;
 i5 = i6 + 80 | 0;
 i4 = (_quiet_encoder_sample_len(i6, HEAP32[i5 >> 2] | 0) | 0) >>> 0 > i1 >>> 0;
 i3 = HEAP32[i5 >> 2] | 0;
 if (!i4) {
  i6 = i3;
  return i6 | 0;
 }
 i2 = i3 >>> 1;
 if (i3 >>> 0 > 1) {
  i4 = 0;
  do {
   i8 = (_quiet_encoder_sample_len(i6, i2) | 0) >>> 0 > i1 >>> 0;
   i3 = i8 ? i2 : i3;
   i4 = i8 ? i4 : i2;
   i8 = i3 - i4 | 0;
   i2 = (i8 >>> 1) + i4 | 0;
  } while (i8 >>> 0 > 1);
  i1 = i2;
 } else i1 = i2;
 HEAP32[i5 >> 2] = i1;
 i8 = i1;
 return i8 | 0;
}

function _fec_hamming128_decode(i1, i7, i6, i5) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0;
 i4 = i7 & 1;
 i3 = i7 - i4 | 0;
 if ((i4 | 0) == (i7 | 0)) {
  i2 = 0;
  i1 = 0;
 } else {
  i2 = 0;
  i1 = 0;
  do {
   i9 = HEAPU8[i6 + (i1 + 1) >> 0] | 0;
   i8 = i9 << 8 & 3840 | (HEAPU8[i6 + (i1 + 2) >> 0] | 0);
   HEAP8[i5 + i2 >> 0] = _fec_hamming128_decode_symbol(i9 >>> 4 | (HEAPU8[i6 + i1 >> 0] | 0) << 4) | 0;
   HEAP8[i5 + (i2 | 1) >> 0] = _fec_hamming128_decode_symbol(i8) | 0;
   i1 = i1 + 3 | 0;
   i2 = i2 + 2 | 0;
  } while (i2 >>> 0 < i3 >>> 0);
 }
 if (i4) {
  HEAP8[i5 + i2 >> 0] = _fec_hamming128_decode_symbol((HEAPU8[i6 + (i1 + 1) >> 0] | 0) >>> 4 | (HEAPU8[i6 + i1 >> 0] | 0) << 4) | 0;
  i1 = i1 + 2 | 0;
 }
 i9 = (i7 & 536870911) * 12 | 0;
 if ((i1 | 0) == ((i9 >>> 2 & 1) + (i9 >>> 3) | 0)) return; else ___assert_fail(gb + 13073 | 0, gb + 13136 | 0, 280, gb + 13187 | 0);
}

function _scramble_data(i4, i3) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i5 = 0;
 i1 = i3 & -4;
 if (!i1) i1 = 0; else {
  i2 = 0;
  do {
   i5 = i4 + i2 | 0;
   HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 180;
   i5 = i4 + (i2 | 1) | 0;
   HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 106;
   i5 = i4 + (i2 | 2) | 0;
   HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 139;
   i5 = i4 + (i2 | 3) | 0;
   HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 197;
   i2 = i2 + 4 | 0;
  } while (i2 >>> 0 < i1 >>> 0);
 }
 if (i1 >>> 0 < i3 >>> 0) {
  i5 = i4 + i1 | 0;
  HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 180;
 }
 i2 = i1 | 1;
 if (i2 >>> 0 < i3 >>> 0) {
  i5 = i4 + i2 | 0;
  HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 106;
 }
 i2 = i1 | 2;
 if (i2 >>> 0 < i3 >>> 0) {
  i5 = i4 + i2 | 0;
  HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 139;
 }
 i1 = i1 | 3;
 if (i1 >>> 0 >= i3 >>> 0) return;
 i5 = i4 + i1 | 0;
 HEAP8[i5 >> 0] = (HEAPU8[i5 >> 0] | 0) ^ 197;
 return;
}

function _decoder_on_decode(i1, i2, i8, i9, i3, i4, i5) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i8 = i8 | 0;
 i9 = i9 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i6 = 0, i7 = 0;
 if (!i2) {
  i9 = 1;
  return i9 | 0;
 }
 if (!i5) {
  i9 = 0;
  return i9 | 0;
 }
 if (!i3) {
  i9 = i5 + 108 | 0;
  HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + 1;
  i9 = 1;
  return i9 | 0;
 }
 i6 = i5 + 72 | 0;
 i7 = i5 + 76 | 0;
 i4 = i5 + 68 | 0;
 while (1) {
  i1 = HEAP32[i6 >> 2] | 0;
  i2 = HEAP32[i7 >> 2] | 0;
  if ((i1 - i2 | 0) >>> 0 >= i9 >>> 0) {
   i3 = 9;
   break;
  }
  i1 = i1 << 1;
  i2 = _realloc(HEAP32[i4 >> 2] | 0, i1) | 0;
  if (i2 | 0) {
   i3 = 8;
   break;
  }
 }
 if ((i3 | 0) == 8) {
  HEAP32[i4 >> 2] = i2;
  HEAP32[i6 >> 2] = i1;
  i9 = 1;
  return i9 | 0;
 } else if ((i3 | 0) == 9) {
  _memmove((HEAP32[i4 >> 2] | 0) + i2 | 0, i8 | 0, i9 | 0) | 0;
  HEAP32[i7 >> 2] = (HEAP32[i7 >> 2] | 0) + i9;
  i9 = 0;
  return i9 | 0;
 }
 return 0;
}

function ___strchrnul(i1, i4) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 var i2 = 0, i3 = 0, i5 = 0;
 i3 = i4 & 255;
 L1 : do if (!i3) i1 = i1 + (_strlen(i1) | 0) | 0; else {
  if (i1 & 3) {
   i2 = i4 & 255;
   do {
    i5 = HEAP8[i1 >> 0] | 0;
    if (i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 == i2 << 24 >> 24) break L1;
    i1 = i1 + 1 | 0;
   } while ((i1 & 3 | 0) != 0);
  }
  i3 = Math_imul(i3, 16843009) | 0;
  i2 = HEAP32[i1 >> 2] | 0;
  L10 : do if (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009)) do {
   i5 = i2 ^ i3;
   if ((i5 & -2139062144 ^ -2139062144) & i5 + -16843009 | 0) break L10;
   i1 = i1 + 4 | 0;
   i2 = HEAP32[i1 >> 2] | 0;
  } while (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009 | 0)); while (0);
  i2 = i4 & 255;
  while (1) {
   i5 = HEAP8[i1 >> 0] | 0;
   if (i5 << 24 >> 24 == 0 ? 1 : i5 << 24 >> 24 == i2 << 24 >> 24) break; else i1 = i1 + 1 | 0;
  }
 } while (0);
 return i1 | 0;
}

function _wcrtomb(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 do if (!i1) i1 = 1; else {
  if (i2 >>> 0 < 128) {
   HEAP8[i1 >> 0] = i2;
   i1 = 1;
   break;
  }
  if (i2 >>> 0 < 2048) {
   HEAP8[i1 >> 0] = i2 >>> 6 | 192;
   HEAP8[i1 + 1 >> 0] = i2 & 63 | 128;
   i1 = 2;
   break;
  }
  if (i2 >>> 0 < 55296 | (i2 & -8192 | 0) == 57344) {
   HEAP8[i1 >> 0] = i2 >>> 12 | 224;
   HEAP8[i1 + 1 >> 0] = i2 >>> 6 & 63 | 128;
   HEAP8[i1 + 2 >> 0] = i2 & 63 | 128;
   i1 = 3;
   break;
  }
  if ((i2 + -65536 | 0) >>> 0 < 1048576) {
   HEAP8[i1 >> 0] = i2 >>> 18 | 240;
   HEAP8[i1 + 1 >> 0] = i2 >>> 12 & 63 | 128;
   HEAP8[i1 + 2 >> 0] = i2 >>> 6 & 63 | 128;
   HEAP8[i1 + 3 >> 0] = i2 & 63 | 128;
   i1 = 4;
   break;
  }
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i1 >> 2] = 84;
  i1 = -1;
 } while (0);
 return i1 | 0;
}

function _fec_rep5_decode_soft(i1, i13, i15, i14) {
 i1 = i1 | 0;
 i13 = i13 | 0;
 i15 = i15 | 0;
 i14 = i14 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0;
 if (!i13) return;
 i1 = i13 << 1;
 i4 = i13 * 3 | 0;
 i5 = i13 << 2;
 i11 = 0;
 do {
  i6 = i14 + i11 | 0;
  HEAP8[i6 >> 0] = 0;
  i8 = i11 << 3;
  i9 = i11 + i13 << 3;
  i10 = i11 + i1 << 3;
  i2 = i11 + i4 << 3;
  i3 = i11 + i5 << 3;
  i7 = 0;
  i12 = 0;
  do {
   i7 = (((HEAPU8[i15 + (i12 + i9) >> 0] | 0) + (HEAPU8[i15 + (i12 + i8) >> 0] | 0) + (HEAPU8[i15 + (i12 + i10) >> 0] | 0) + (HEAPU8[i15 + (i12 + i2) >> 0] | 0) + (HEAPU8[i15 + (i12 + i3) >> 0] | 0) | 0) >>> 0 > 639 ? 1 << 7 - i12 : 0) | i7 & 255;
   HEAP8[i6 >> 0] = i7;
   i12 = i12 + 1 | 0;
  } while ((i12 | 0) != 8);
  i11 = i11 + 1 | 0;
 } while ((i11 | 0) != (i13 | 0));
 return;
}

function _firinterp_crcf_create_kaiser(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5 + 8 | 0;
 i3 = i5;
 if (i1 >>> 0 < 2) {
  HEAP32[i3 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 18950 | 0, i3);
  _exit(1);
 }
 if (!i2) {
  HEAP32[i4 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 19025 | 0, i4);
  _exit(1);
 } else {
  i4 = Math_imul(i1 << 1, i2) | 0;
  i7 = i4 | 1;
  i6 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i7 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_kaiser(i7, .5 / +(i1 >>> 0), 60.0, i6);
  i3 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i7 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i3 | 0, i6 | 0, Math_imul(i1 << 3, i2) | 0 | 4 | 0) | 0;
  i4 = _firinterp_crcf_create(i1, i3, i4) | 0;
  STACKTOP = i5;
  return i4 | 0;
 }
 return 0;
}

function ___remdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i8 = i5 | 0;
 i7 = i2 >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i6 = ((i2 | 0) < 0 ? -1 : 0) >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i10 = i4 >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i9 = ((i4 | 0) < 0 ? -1 : 0) >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i1 = _i64Subtract(i7 ^ i1 | 0, i6 ^ i2 | 0, i7 | 0, i6 | 0) | 0;
 i2 = getTempRet0() | 0;
 ___udivmoddi4(i1, i2, _i64Subtract(i10 ^ i3 | 0, i9 ^ i4 | 0, i10 | 0, i9 | 0) | 0, getTempRet0() | 0, i8) | 0;
 i4 = _i64Subtract(HEAP32[i8 >> 2] ^ i7 | 0, HEAP32[i8 + 4 >> 2] ^ i6 | 0, i7 | 0, i6 | 0) | 0;
 i3 = getTempRet0() | 0;
 STACKTOP = i5;
 return (setTempRet0(i3 | 0), i4) | 0;
}

function _modem_modulate_qam(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var d4 = 0.0, i5 = 0, d6 = 0.0, i7 = 0;
 i7 = HEAP32[i1 + 104 >> 2] | 0;
 i5 = i2 >>> i7;
 i2 = (1 << i7) + -1 & i2;
 d6 = +HEAPF32[i1 + 116 >> 2];
 d4 = d6 * +(((i2 >>> 1 ^ i2 ^ i2 >>> 2 ^ i2 >>> 3 ^ i2 >>> 4 ^ i2 >>> 5 ^ i2 >>> 6 ^ i2 >>> 7 ^ i2 >>> 8 ^ i2 >>> 9 ^ i2 >>> 10 ^ i2 >>> 11 ^ i2 >>> 12 ^ i2 >>> 13 ^ i2 >>> 14 ^ i2 >>> 15 ^ i2 >>> 16) << 1 | 1) - (HEAP32[i1 + 112 >> 2] | 0) | 0);
 HEAPF32[i3 >> 2] = d6 * +(((i5 >>> 1 ^ i5 ^ i5 >>> 2 ^ i5 >>> 3 ^ i5 >>> 4 ^ i5 >>> 5 ^ i5 >>> 6 ^ i5 >>> 7 ^ i5 >>> 8 ^ i5 >>> 9 ^ i5 >>> 10 ^ i5 >>> 11 ^ i5 >>> 12 ^ i5 >>> 13 ^ i5 >>> 14 ^ i5 >>> 15 ^ i5 >>> 16) << 1 | 1) - (HEAP32[i1 + 108 >> 2] | 0) | 0) + d4 * 0.0;
 HEAPF32[i3 + 4 >> 2] = d4;
 return;
}

function _firinterp_crcf_create_prototype(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5 + 8 | 0;
 i3 = i5;
 if (!i2) {
  HEAP32[i3 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 19177 | 0, i3);
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  HEAP32[i4 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 19254 | 0, i4);
  _exit(1);
 } else {
  i4 = i2 << 2 | 1;
  i6 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(7, 2, i2, d1, i6);
  i3 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i3 | 0, i6 | 0, i2 << 4 | 4 | 0) | 0;
  i4 = _firinterp_crcf_create(2, i3, i4) | 0;
  STACKTOP = i5;
  return i4 | 0;
 }
 return 0;
}

function _firpfb_crcf_create_rnyquist(i2, d1) {
 i2 = i2 | 0;
 d1 = +d1;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5 + 8 | 0;
 i3 = i5;
 if (!i2) {
  HEAP32[i3 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 19494 | 0, i3);
  _exit(1);
 }
 if (d1 < 0.0 | d1 > 1.0) {
  HEAP32[i4 >> 2] = gb + 18451;
  _fprintf(gb + 8728 | 0, gb + 19567 | 0, i4);
  _exit(1);
 } else {
  i4 = i2 << 7 | 1;
  i6 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _liquid_firdes_prototype(7, 64, i2, d1, i6);
  i3 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (i4 << 2) | 0) + 15 & -16) | 0;
  _memcpy(i3 | 0, i6 | 0, i2 << 9 | 4 | 0) | 0;
  i4 = _firpfb_crcf_create(32, i3, i4) | 0;
  STACKTOP = i5;
  return i4 | 0;
 }
 return 0;
}

function _fec_secded2216_compute_parity(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 return ((HEAPU8[(i1 & 63) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & 68) + (gb + 36235) >> 0] | 0) & 1 | ((HEAPU8[(i1 & -57 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & 19) + (gb + 36235) >> 0] | 0) & 1 | ((HEAPU8[(i1 & -47 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & -31 & 255) + (gb + 36235) >> 0] | 0) & 1 | ((HEAPU8[(i1 & 96) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & -18 & 255) + (gb + 36235) >> 0] | 0) & 1 | ((HEAPU8[(i1 & -118 & 255) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & 62) + (gb + 36235) >> 0] | 0) & 1 | (HEAPU8[(i1 & 60) + (gb + 36235) >> 0] | 0) + (HEAPU8[(i2 & -103 & 255) + (gb + 36235) >> 0] | 0) << 1 & 2) << 1 & 6) << 1 & 14) << 1 & 30) << 1 & 62) & 255 | 0;
}

function _fec_hamming74_decode(i1, i7, i9, i8) {
 i1 = i1 | 0;
 i7 = i7 | 0;
 i9 = i9 | 0;
 i8 = i8 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i6 + 4 | 0;
 i5 = i6;
 i1 = (i7 << 1 & 1073741822) * 7 | 0;
 i1 = ((i1 & 6 | 0) != 0 & 1) + (i1 >>> 3) | 0;
 if (!i7) {
  STACKTOP = i6;
  return;
 } else {
  i2 = 0;
  i3 = 0;
 }
 while (1) {
  _liquid_unpack_array(i9, i1, i3, i4);
  _liquid_unpack_array(i9, i1, i3 + 7 | 0, i5);
  HEAP8[i8 + i2 >> 0] = HEAPU8[(HEAP32[i5 >> 2] | 0) + (gb + 12563) >> 0] | 0 | (HEAPU8[(HEAP32[i4 >> 2] | 0) + (gb + 12563) >> 0] | 0) << 4;
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i7 | 0)) break; else i3 = i3 + 14 | 0;
 }
 STACKTOP = i6;
 return;
}

function ___stdio_seek(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i7 = i6;
 i4 = i6 + 20 | 0;
 HEAP32[i7 >> 2] = HEAP32[i1 + 60 >> 2];
 HEAP32[i7 + 4 >> 2] = 0;
 HEAP32[i7 + 8 >> 2] = i2;
 HEAP32[i7 + 12 >> 2] = i4;
 HEAP32[i7 + 16 >> 2] = i3;
 i2 = ___syscall140(140, i7 | 0) | 0;
 if (i2 >>> 0 <= 4294963200) if ((i2 | 0) < 0) i5 = 7; else i1 = HEAP32[i4 >> 2] | 0; else {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i1 >> 2] = 0 - i2;
  i5 = 7;
 }
 if ((i5 | 0) == 7) {
  HEAP32[i4 >> 2] = -1;
  i1 = -1;
 }
 STACKTOP = i6;
 return i1 | 0;
}

function _pad(i5, i4, i3, i2, i1) {
 i5 = i5 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i6 = 0, i7 = 0;
 i7 = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 i6 = i7;
 do if ((i3 | 0) > (i2 | 0) & (i1 & 73728 | 0) == 0) {
  i1 = i3 - i2 | 0;
  _memset(i6 | 0, i4 | 0, (i1 >>> 0 > 256 ? 256 : i1) | 0) | 0;
  i2 = HEAP32[i5 >> 2] | 0;
  i3 = (i2 & 32 | 0) == 0;
  if (i1 >>> 0 > 255) {
   i4 = i1;
   do {
    if (i3) {
     ___fwritex(i6, 256, i5);
     i2 = HEAP32[i5 >> 2] | 0;
    }
    i4 = i4 + -256 | 0;
    i3 = (i2 & 32 | 0) == 0;
   } while (i4 >>> 0 > 255);
   if (i3) i1 = i1 & 255; else break;
  } else if (!i3) break;
  ___fwritex(i6, i1, i5);
 } while (0);
 STACKTOP = i7;
 return;
}

function _frexp(d1, i5) {
 d1 = +d1;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 HEAPF64[tempDoublePtr >> 3] = d1;
 i2 = HEAP32[tempDoublePtr >> 2] | 0;
 i3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 i4 = _bitshift64Lshr(i2 | 0, i3 | 0, 52) | 0;
 getTempRet0() | 0;
 i4 = i4 & 2047;
 switch (i4 | 0) {
 case 0:
  {
   if (d1 != 0.0) {
    d1 = +_frexp(d1 * 18446744073709551616.0, i5);
    i2 = (HEAP32[i5 >> 2] | 0) + -64 | 0;
   } else i2 = 0;
   HEAP32[i5 >> 2] = i2;
   break;
  }
 case 2047:
  break;
 default:
  {
   HEAP32[i5 >> 2] = i4 + -1022;
   HEAP32[tempDoublePtr >> 2] = i2;
   HEAP32[tempDoublePtr + 4 >> 2] = i3 & -2146435073 | 1071644672;
   d1 = +HEAPF64[tempDoublePtr >> 3];
  }
 }
 return +d1;
}

function _fec_rep5_decode(i1, i5, i7, i6) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 if (!i5) return;
 i1 = i5 << 1;
 i2 = i5 * 3 | 0;
 i3 = i5 << 2;
 i4 = 0;
 do {
  i11 = HEAP8[i7 + i4 >> 0] | 0;
  i12 = HEAP8[i7 + (i4 + i5) >> 0] | 0;
  i9 = HEAP8[i7 + (i4 + i1) >> 0] | 0;
  i10 = HEAP8[i7 + (i4 + i2) >> 0] | 0;
  i8 = HEAP8[i7 + (i4 + i3) >> 0] | 0;
  i14 = i9 & i11;
  i13 = i9 & i12;
  HEAP8[i6 + i4 >> 0] = (i13 | i14) & i10 | i8 & i14 | i10 & i11 & i8 | i8 & i13 | i10 & i12 & i8 | i10 & i9 & i8 | i12 & i11 & (i10 | i9 | i8);
  i4 = i4 + 1 | 0;
 } while ((i4 | 0) != (i5 | 0));
 return;
}

function ___divdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i10 = i2 >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i9 = ((i2 | 0) < 0 ? -1 : 0) >> 31 | ((i2 | 0) < 0 ? -1 : 0) << 1;
 i6 = i4 >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i5 = ((i4 | 0) < 0 ? -1 : 0) >> 31 | ((i4 | 0) < 0 ? -1 : 0) << 1;
 i8 = _i64Subtract(i10 ^ i1 | 0, i9 ^ i2 | 0, i10 | 0, i9 | 0) | 0;
 i7 = getTempRet0() | 0;
 i1 = i6 ^ i10;
 i2 = i5 ^ i9;
 return _i64Subtract((___udivmoddi4(i8, i7, _i64Subtract(i6 ^ i3 | 0, i5 ^ i4 | 0, i6 | 0, i5 | 0) | 0, getTempRet0() | 0, 0) | 0) ^ i1 | 0, (getTempRet0() | 0) ^ i2 | 0, i1 | 0, i2 | 0) | 0;
}

function _modulator_flush(i5, i6) {
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i7 = 0;
 i7 = STACKTOP;
 if (!i5) {
  i6 = 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 i1 = HEAP32[i5 + 4 >> 2] | 0;
 if (!i1) {
  i6 = 0;
  STACKTOP = i7;
  return i6 | 0;
 }
 i1 = i1 << 1;
 i2 = _llvm_stacksave() | 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i1 << 3) | 0) + 15 & -16) | 0;
 if (i1 | 0) {
  i4 = 0;
  do {
   HEAPF32[i3 + (i4 << 3) >> 2] = 0.0;
   HEAPF32[i3 + (i4 << 3) + 4 >> 2] = 0.0;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i1 | 0));
 }
 i6 = _modulator_emit(i5, i3, i1, i6) | 0;
 _llvm_stackrestore(i2 | 0);
 STACKTOP = i7;
 return i6 | 0;
}

function _fec_hamming74_decode_soft(i1, i5, i7, i6) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i7 = i7 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i8 = 0;
 i3 = (i5 << 1 & 1073741822) * 7 | 0;
 i4 = (i3 & 6 | 0) != 0 & 1;
 if (!i5) i1 = 0; else {
  i1 = 0;
  i2 = 0;
  while (1) {
   i8 = _fecsoft_hamming74_decode(i7 + i2 | 0) | 0;
   HEAP8[i6 + i1 >> 0] = (i8 & 255) << 4 | (_fecsoft_hamming74_decode(i7 + (i2 + 7) | 0) | 0) & 255;
   i1 = i1 + 1 | 0;
   if ((i1 | 0) == (i5 | 0)) break; else i2 = i2 + 14 | 0;
  }
  i1 = i5 * 14 | 0;
 }
 if ((i1 | 0) == ((i4 << 3) + i3 & -8 | 0)) return; else ___assert_fail(gb + 13209 | 0, gb + 12691 | 0, 193, gb + 12719 | 0);
}

function _modem_modulate_dpsk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var d4 = 0.0, d5 = 0.0, i6 = 0;
 i6 = i1 + 104 | 0;
 d5 = +HEAPF32[i6 >> 2] + +((i2 >>> 1 ^ i2 ^ i2 >>> 2 ^ i2 >>> 3 ^ i2 >>> 4 ^ i2 >>> 5 ^ i2 >>> 6 ^ i2 >>> 7 ^ i2 >>> 8 ^ i2 >>> 9 ^ i2 >>> 10 ^ i2 >>> 11 ^ i2 >>> 12 ^ i2 >>> 13 ^ i2 >>> 14 ^ i2 >>> 15 ^ i2 >>> 16) << 1 >>> 0) * +HEAPF32[i1 + 108 >> 2];
 d5 = d5 - (d5 > 6.283185307179586 ? 6.283185307179586 : 0.0);
 HEAPF32[i6 >> 2] = d5;
 d4 = +Math_sin(+d5);
 d5 = +Math_cos(+d5) + d4 * 0.0;
 HEAPF32[i3 >> 2] = d5;
 HEAPF32[i3 + 4 >> 2] = d4;
 HEAPF32[i1 + 84 >> 2] = d5;
 HEAPF32[i1 + 88 >> 2] = d4;
 return;
}

function _matrixf_hermitian(i3, i5, i4) {
 i3 = i3 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i6 = 0, i7 = 0, i8 = 0;
 i8 = STACKTOP;
 i7 = Math_imul(i4, i5) | 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i7 << 2) | 0) + 15 & -16) | 0;
 _memcpy(i1 | 0, i3 | 0, i7 << 2 | 0) | 0;
 if ((i5 | 0) == 0 | (i4 | 0) == 0) {
  STACKTOP = i8;
  return;
 } else i7 = 0;
 do {
  i2 = Math_imul(i7, i4) | 0;
  i6 = 0;
  do {
   HEAP32[i3 + ((Math_imul(i6, i5) | 0) + i7 << 2) >> 2] = HEAP32[i1 + (i6 + i2 << 2) >> 2];
   i6 = i6 + 1 | 0;
  } while ((i6 | 0) != (i4 | 0));
  i7 = i7 + 1 | 0;
 } while ((i7 | 0) != (i5 | 0));
 STACKTOP = i8;
 return;
}

function ___fflush_unlocked(i7) {
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i1 = i7 + 20 | 0;
 i5 = i7 + 28 | 0;
 if ((HEAP32[i1 >> 2] | 0) >>> 0 > (HEAP32[i5 >> 2] | 0) >>> 0 ? (mftCall_iiii(HEAP32[i7 + 36 >> 2] | 0, i7 | 0, 0, 0) | 0, (HEAP32[i1 >> 2] | 0) == 0) : 0) i1 = -1; else {
  i6 = i7 + 4 | 0;
  i2 = HEAP32[i6 >> 2] | 0;
  i3 = i7 + 8 | 0;
  i4 = HEAP32[i3 >> 2] | 0;
  if (i2 >>> 0 < i4 >>> 0) mftCall_iiii(HEAP32[i7 + 40 >> 2] | 0, i7 | 0, i2 - i4 | 0, 1) | 0;
  HEAP32[i7 + 16 >> 2] = 0;
  HEAP32[i5 >> 2] = 0;
  HEAP32[i1 >> 2] = 0;
  HEAP32[i3 >> 2] = 0;
  HEAP32[i6 >> 2] = 0;
  i1 = 0;
 }
 return i1 | 0;
}

function _open(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0, i6 = 0, i7 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i5 = i4;
 i6 = i4 + 16 | 0;
 HEAP32[i6 >> 2] = i3;
 i7 = (HEAP32[i6 >> 2] | 0) + (4 - 1) & ~(4 - 1);
 i3 = HEAP32[i7 >> 2] | 0;
 HEAP32[i6 >> 2] = i7 + 4;
 HEAP32[i5 >> 2] = i1;
 HEAP32[i5 + 4 >> 2] = i2 | 32768;
 HEAP32[i5 + 8 >> 2] = i3;
 i1 = ___syscall5(5, i5 | 0) | 0;
 if (i1 >>> 0 > 4294963200) {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i2 = gb + 41404 | 0; else i2 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i2 >> 2] = 0 - i1;
  i1 = -1;
 }
 STACKTOP = i4;
 return i1 | 0;
}

function _fec_rep3_decode_soft(i1, i9, i11, i10) {
 i1 = i1 | 0;
 i9 = i9 | 0;
 i11 = i11 | 0;
 i10 = i10 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;
 if (!i9) return;
 i1 = i9 << 1;
 i7 = 0;
 do {
  i2 = i10 + i7 | 0;
  HEAP8[i2 >> 0] = 0;
  i4 = i7 << 3;
  i5 = i7 + i9 << 3;
  i6 = i7 + i1 << 3;
  i3 = 0;
  i8 = 0;
  do {
   i3 = (((HEAPU8[i11 + (i8 + i5) >> 0] | 0) + (HEAPU8[i11 + (i8 + i4) >> 0] | 0) + (HEAPU8[i11 + (i8 + i6) >> 0] | 0) | 0) >>> 0 > 383 ? 1 << 7 - i8 : 0) | i3 & 255;
   HEAP8[i2 >> 0] = i3;
   i8 = i8 + 1 | 0;
  } while ((i8 | 0) != 8);
  i7 = i7 + 1 | 0;
 } while ((i7 | 0) != (i9 | 0));
 return;
}

function _modem_modulate_sqam128(i1, i4, i5) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var d2 = 0.0, d3 = 0.0, i6 = 0;
 i6 = i4 & 31;
 i1 = HEAP32[i1 + 100 >> 2] | 0;
 d2 = +HEAPF32[i1 + (i6 << 3) >> 2];
 d3 = +HEAPF32[i1 + (i6 << 3) + 4 >> 2];
 switch (i4 >>> 5 & 3 | 0) {
 case 0:
  {
   HEAPF32[i5 >> 2] = d2;
   HEAPF32[i5 + 4 >> 2] = d3;
   return;
  }
 case 1:
  {
   HEAPF32[i5 >> 2] = d2;
   HEAPF32[i5 + 4 >> 2] = -d3;
   return;
  }
 case 2:
  {
   HEAPF32[i5 >> 2] = -d2;
   HEAPF32[i5 + 4 >> 2] = d3;
   return;
  }
 case 3:
  {
   HEAPF32[i5 >> 2] = -d2;
   HEAPF32[i5 + 4 >> 2] = -d3;
   return;
  }
 default:
  {}
 }
}

function _modem_modulate_sqam32(i1, i4, i5) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var d2 = 0.0, d3 = 0.0, i6 = 0;
 i6 = i4 & 7;
 i1 = HEAP32[i1 + 100 >> 2] | 0;
 d2 = +HEAPF32[i1 + (i6 << 3) >> 2];
 d3 = +HEAPF32[i1 + (i6 << 3) + 4 >> 2];
 switch (i4 >>> 3 & 3 | 0) {
 case 0:
  {
   HEAPF32[i5 >> 2] = d2;
   HEAPF32[i5 + 4 >> 2] = d3;
   return;
  }
 case 1:
  {
   HEAPF32[i5 >> 2] = d2;
   HEAPF32[i5 + 4 >> 2] = -d3;
   return;
  }
 case 2:
  {
   HEAPF32[i5 >> 2] = -d2;
   HEAPF32[i5 + 4 >> 2] = d3;
   return;
  }
 case 3:
  {
   HEAPF32[i5 >> 2] = -d2;
   HEAPF32[i5 + 4 >> 2] = -d3;
   return;
  }
 default:
  {}
 }
}

function _memcpy(i1, i4, i2) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i3 = 0;
 if ((i2 | 0) >= 4096) return _emscripten_memcpy_big(i1 | 0, i4 | 0, i2 | 0) | 0;
 i3 = i1 | 0;
 if ((i1 & 3) == (i4 & 3)) {
  while (i1 & 3) {
   if (!i2) return i3 | 0;
   HEAP8[i1 >> 0] = HEAP8[i4 >> 0] | 0;
   i1 = i1 + 1 | 0;
   i4 = i4 + 1 | 0;
   i2 = i2 - 1 | 0;
  }
  while ((i2 | 0) >= 4) {
   HEAP32[i1 >> 2] = HEAP32[i4 >> 2];
   i1 = i1 + 4 | 0;
   i4 = i4 + 4 | 0;
   i2 = i2 - 4 | 0;
  }
 }
 while ((i2 | 0) > 0) {
  HEAP8[i1 >> 0] = HEAP8[i4 >> 0] | 0;
  i1 = i1 + 1 | 0;
  i4 = i4 + 1 | 0;
  i2 = i2 - 1 | 0;
 }
 return i3 | 0;
}

function _fec_hamming74_encode(i1, i4, i5, i6) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i7 = 0, i8 = 0;
 i1 = (i4 << 1 & 1073741822) * 7 | 0;
 i1 = ((i1 & 6 | 0) != 0 & 1) + (i1 >>> 3) | 0;
 if (!i4) return; else {
  i2 = 0;
  i3 = 0;
 }
 while (1) {
  i8 = HEAP8[i5 + i2 >> 0] | 0;
  i7 = HEAPU8[(i8 & 15) + (gb + 12547) >> 0] | 0;
  _liquid_pack_array(i6, i1, i3, 7, HEAPU8[((i8 & 255) >>> 4 & 255) + (gb + 12547) >> 0] | 0);
  _liquid_pack_array(i6, i1, i3 + 7 | 0, 7, i7);
  i2 = i2 + 1 | 0;
  if ((i2 | 0) == (i4 | 0)) break; else i3 = i3 + 14 | 0;
 }
 return;
}

function _fmt_u(i2, i3, i1) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = i1 | 0;
 var i4 = 0, i5 = 0;
 if (i3 >>> 0 > 0 | (i3 | 0) == 0 & i2 >>> 0 > 4294967295) do {
  i4 = ___uremdi3(i2 | 0, i3 | 0, 10, 0) | 0;
  getTempRet0() | 0;
  i1 = i1 + -1 | 0;
  HEAP8[i1 >> 0] = i4 | 48;
  i4 = i2;
  i2 = ___udivdi3(i2 | 0, i3 | 0, 10, 0) | 0;
  i5 = i3;
  i3 = getTempRet0() | 0;
 } while (i5 >>> 0 > 9 | (i5 | 0) == 9 & i4 >>> 0 > 4294967295);
 if (i2) while (1) {
  i1 = i1 + -1 | 0;
  HEAP8[i1 >> 0] = (i2 >>> 0) % 10 | 0 | 48;
  if (i2 >>> 0 < 10) break; else i2 = (i2 >>> 0) / 10 | 0;
 }
 return i1 | 0;
}

function _strlen(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i4 = i1;
 L1 : do if (!(i4 & 3)) i3 = 4; else {
  i2 = i1;
  i1 = i4;
  while (1) {
   if (!(HEAP8[i2 >> 0] | 0)) break L1;
   i2 = i2 + 1 | 0;
   i1 = i2;
   if (!(i1 & 3)) {
    i1 = i2;
    i3 = 4;
    break;
   }
  }
 } while (0);
 if ((i3 | 0) == 4) {
  while (1) {
   i2 = HEAP32[i1 >> 2] | 0;
   if (!((i2 & -2139062144 ^ -2139062144) & i2 + -16843009)) i1 = i1 + 4 | 0; else break;
  }
  if ((i2 & 255) << 24 >> 24) do i1 = i1 + 1 | 0; while ((HEAP8[i1 >> 0] | 0) != 0);
 }
 return i1 - i4 | 0;
}

function _demodulator_flush(i6, i7) {
 i6 = i6 | 0;
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0;
 i8 = STACKTOP;
 if (!i6) {
  i7 = 0;
  STACKTOP = i8;
  return i7 | 0;
 }
 i1 = HEAP32[i6 >> 2] | 0;
 i2 = HEAP32[i6 + 4 >> 2] | 0;
 i3 = Math_imul(i2 << 1, i1) | 0;
 i4 = _llvm_stacksave() | 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (i3 << 2) | 0) + 15 & -16) | 0;
 if (i3 | 0) _memset(i5 | 0, 0, Math_imul(i1 << 3, i2) | 0) | 0;
 i7 = _demodulator_recv(i6, i5, i3, i7) | 0;
 _llvm_stackrestore(i4 | 0);
 STACKTOP = i8;
 return i7 | 0;
}

function _firinterp_rrrf_destroy(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i1 = HEAP32[i4 + 16 >> 2] | 0;
 i2 = i1 + 12 | 0;
 i3 = i1 + 20 | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i5 = 0;
  do {
   i6 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0;
   _free(HEAP32[i6 >> 2] | 0);
   _free(i6);
   i5 = i5 + 1 | 0;
  } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i3 >> 2] | 0);
 i6 = HEAP32[i1 + 16 >> 2] | 0;
 _free(HEAP32[i6 >> 2] | 0);
 _free(i6);
 _free(i1);
 _free(HEAP32[i4 >> 2] | 0);
 _free(i4);
 return;
}

function _firinterp_crcf_destroy(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i1 = HEAP32[i4 + 16 >> 2] | 0;
 i2 = i1 + 12 | 0;
 i3 = i1 + 20 | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i5 = 0;
  do {
   i6 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0;
   _free(HEAP32[i6 >> 2] | 0);
   _free(i6);
   i5 = i5 + 1 | 0;
  } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i3 >> 2] | 0);
 i6 = HEAP32[i1 + 16 >> 2] | 0;
 _free(HEAP32[i6 >> 2] | 0);
 _free(i6);
 _free(i1);
 _free(HEAP32[i4 >> 2] | 0);
 _free(i4);
 return;
}

function _memset(i2, i6, i1) {
 i2 = i2 | 0;
 i6 = i6 | 0;
 i1 = i1 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i7 = 0;
 i3 = i2 + i1 | 0;
 if ((i1 | 0) >= 20) {
  i6 = i6 & 255;
  i5 = i2 & 3;
  i7 = i6 | i6 << 8 | i6 << 16 | i6 << 24;
  i4 = i3 & ~3;
  if (i5) {
   i5 = i2 + 4 - i5 | 0;
   while ((i2 | 0) < (i5 | 0)) {
    HEAP8[i2 >> 0] = i6;
    i2 = i2 + 1 | 0;
   }
  }
  while ((i2 | 0) < (i4 | 0)) {
   HEAP32[i2 >> 2] = i7;
   i2 = i2 + 4 | 0;
  }
 }
 while ((i2 | 0) < (i3 | 0)) {
  HEAP8[i2 >> 0] = i6;
  i2 = i2 + 1 | 0;
 }
 return i2 - i1 | 0;
}

function _fft_execute_dft_2(i1) {
 i1 = i1 | 0;
 var d2 = 0.0, i3 = 0, i4 = 0, i5 = 0;
 i3 = i1 + 4 | 0;
 i5 = HEAP32[i3 >> 2] | 0;
 d2 = +HEAPF32[i5 + 4 >> 2] + +HEAPF32[i5 + 12 >> 2];
 i1 = i1 + 8 | 0;
 i4 = HEAP32[i1 >> 2] | 0;
 HEAPF32[i4 >> 2] = +HEAPF32[i5 >> 2] + +HEAPF32[i5 + 8 >> 2];
 HEAPF32[i4 + 4 >> 2] = d2;
 i3 = HEAP32[i3 >> 2] | 0;
 d2 = +HEAPF32[i3 + 4 >> 2] - +HEAPF32[i3 + 12 >> 2];
 i1 = HEAP32[i1 >> 2] | 0;
 HEAPF32[i1 + 8 >> 2] = +HEAPF32[i3 >> 2] - +HEAPF32[i3 + 8 >> 2];
 HEAPF32[i1 + 12 >> 2] = d2;
 return;
}

function _modem_destroy(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP32[i2 + 76 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 + 244 >> 2] | 0;
 if (i1 | 0) _free(i1);
 i1 = HEAP32[i2 >> 2] | 0;
 switch (i1 | 0) {
 case 50:
  {
   _free(HEAP32[i2 + 100 >> 2] | 0);
   _free(i2);
   return;
  }
 case 51:
  {
   _free(HEAP32[i2 + 100 >> 2] | 0);
   _free(i2);
   return;
  }
 default:
  {
   if ((i1 + -40 | 0) >>> 0 >= 7) {
    _free(i2);
    return;
   }
   _free(HEAP32[i2 + 232 >> 2] | 0);
   _free(i2);
   return;
  }
 }
}

function _resamp_rrrf_destroy(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0;
 i1 = HEAP32[i4 + 48 >> 2] | 0;
 i2 = i1 + 12 | 0;
 i3 = i1 + 20 | 0;
 if (HEAP32[i2 >> 2] | 0) {
  i5 = 0;
  do {
   i6 = HEAP32[(HEAP32[i3 >> 2] | 0) + (i5 << 2) >> 2] | 0;
   _free(HEAP32[i6 >> 2] | 0);
   _free(i6);
   i5 = i5 + 1 | 0;
  } while (i5 >>> 0 < (HEAP32[i2 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i3 >> 2] | 0);
 i6 = HEAP32[i1 + 16 >> 2] | 0;
 _free(HEAP32[i6 >> 2] | 0);
 _free(i6);
 _free(i1);
 _free(i4);
 return;
}

function _iirfilt_crcf_destroy(i3) {
 i3 = i3 | 0;
 var i1 = 0, i2 = 0, i4 = 0;
 _free(HEAP32[i3 >> 2] | 0);
 _free(HEAP32[i3 + 4 >> 2] | 0);
 if ((HEAP32[i3 + 24 >> 2] | 0) != 1) {
  _free(HEAP32[i3 + 8 >> 2] | 0);
  _free(i3);
  return;
 }
 i1 = i3 + 32 | 0;
 i2 = i3 + 28 | 0;
 if (HEAP32[i1 >> 2] | 0) {
  i4 = 0;
  do {
   _free(HEAP32[(HEAP32[i2 >> 2] | 0) + (i4 << 2) >> 2] | 0);
   i4 = i4 + 1 | 0;
  } while (i4 >>> 0 < (HEAP32[i1 >> 2] | 0) >>> 0);
 }
 _free(HEAP32[i2 >> 2] | 0);
 _free(i3);
 return;
}

function _fflush(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 if (i1 | 0) return ___fflush_unlocked(i1) | 0;
 if (!(HEAP32[gb + 8952 >> 2] | 0)) i1 = 0; else i1 = _fflush(HEAP32[gb + 8952 >> 2] | 0) | 0;
 ___lock(gb + 41360 + 28 | 0);
 i2 = HEAP32[gb + 41360 + 24 >> 2] | 0;
 if (i2) do {
  if ((HEAP32[i2 + 20 >> 2] | 0) >>> 0 > (HEAP32[i2 + 28 >> 2] | 0) >>> 0) i1 = ___fflush_unlocked(i2) | 0 | i1;
  i2 = HEAP32[i2 + 56 >> 2] | 0;
 } while ((i2 | 0) != 0);
 ___unlock(gb + 41360 + 28 | 0);
 return i1 | 0;
}

function _modem_demodulate_qpsk(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, d5 = 0.0, i6 = 0;
 d5 = +HEAPF32[i3 >> 2];
 i6 = !(d5 > 0.0);
 d4 = +HEAPF32[i3 + 4 >> 2];
 i3 = d4 > 0.0;
 HEAP32[i2 >> 2] = (i3 ? 0 : 2) | i6 & 1;
 HEAPF32[i1 + 92 >> 2] = (i6 ? -.7071067811865476 : .7071067811865476) + (i3 ? 0.0 : -0.0);
 HEAPF32[i1 + 96 >> 2] = i3 ? .7071067690849304 : -.7071067690849304;
 HEAPF32[i1 + 84 >> 2] = d5;
 HEAPF32[i1 + 88 >> 2] = d4;
 return;
}

function _firdespm_destroy(i1) {
 i1 = i1 | 0;
 _free(HEAP32[i1 + 88 >> 2] | 0);
 _free(HEAP32[i1 + 64 >> 2] | 0);
 _free(HEAP32[i1 + 68 >> 2] | 0);
 _free(HEAP32[i1 + 72 >> 2] | 0);
 _free(HEAP32[i1 + 48 >> 2] | 0);
 _free(HEAP32[i1 + 52 >> 2] | 0);
 _free(HEAP32[i1 + 56 >> 2] | 0);
 _free(HEAP32[i1 + 60 >> 2] | 0);
 _free(HEAP32[i1 + 32 >> 2] | 0);
 _free(HEAP32[i1 + 36 >> 2] | 0);
 _free(HEAP32[i1 + 40 >> 2] | 0);
 _free(HEAP32[i1 + 44 >> 2] | 0);
 _free(i1);
 return;
}

function ___stdout_write(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 i4 = i5;
 HEAP32[i2 + 36 >> 2] = fb + 1;
 if ((HEAP32[i2 >> 2] & 64 | 0) == 0 ? (HEAP32[i4 >> 2] = HEAP32[i2 + 60 >> 2], HEAP32[i4 + 4 >> 2] = 21505, HEAP32[i4 + 8 >> 2] = i5 + 12, ___syscall54(54, i4 | 0) | 0) : 0) HEAP8[i2 + 75 >> 0] = -1;
 i4 = ___stdio_write(i2, i1, i3) | 0;
 STACKTOP = i5;
 return i4 | 0;
}

function copyTempDouble(i1) {
 i1 = i1 | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[i1 >> 0];
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[i1 + 1 >> 0];
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[i1 + 2 >> 0];
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[i1 + 3 >> 0];
 HEAP8[tempDoublePtr + 4 >> 0] = HEAP8[i1 + 4 >> 0];
 HEAP8[tempDoublePtr + 5 >> 0] = HEAP8[i1 + 5 >> 0];
 HEAP8[tempDoublePtr + 6 >> 0] = HEAP8[i1 + 6 >> 0];
 HEAP8[tempDoublePtr + 7 >> 0] = HEAP8[i1 + 7 >> 0];
}

function _fec_hamming84_encode(i1, i3, i4, i5) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i2 = 0, i6 = 0;
 if (!i3) return; else {
  i1 = 0;
  i2 = 0;
 }
 while (1) {
  i6 = HEAP8[i4 + i1 >> 0] | 0;
  HEAP8[i5 + i2 >> 0] = HEAP8[((i6 & 255) >>> 4 & 255) + (gb + 12745) >> 0] | 0;
  HEAP8[i5 + (i2 | 1) >> 0] = HEAP8[(i6 & 15) + (gb + 12745) >> 0] | 0;
  i1 = i1 + 1 | 0;
  if ((i1 | 0) == (i3 | 0)) break; else i2 = i2 + 2 | 0;
 }
 return;
}

function _quiet_decoder_readbuf(i2, i3, i4) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i1 = 0;
 if (!i2) {
  i4 = 0;
  return i4 | 0;
 }
 i1 = i2 + 76 | 0;
 if ((HEAP32[i1 >> 2] | 0) >>> 0 < i4 >>> 0) {
  i4 = 0;
  return i4 | 0;
 }
 i2 = i2 + 68 | 0;
 _memmove(i3 | 0, HEAP32[i2 >> 2] | 0, i4 | 0) | 0;
 i3 = (HEAP32[i1 >> 2] | 0) - i4 | 0;
 HEAP32[i1 >> 2] = i3;
 i2 = HEAP32[i2 >> 2] | 0;
 _memmove(i2 | 0, i2 + i4 | 0, i3 | 0) | 0;
 return i4 | 0;
}

function _modem_modulate_psk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var d4 = 0.0, d5 = 0.0;
 d5 = +((i2 >>> 1 ^ i2 ^ i2 >>> 2 ^ i2 >>> 3 ^ i2 >>> 4 ^ i2 >>> 5 ^ i2 >>> 6 ^ i2 >>> 7 ^ i2 >>> 8 ^ i2 >>> 9 ^ i2 >>> 10 ^ i2 >>> 11 ^ i2 >>> 12 ^ i2 >>> 13 ^ i2 >>> 14 ^ i2 >>> 15 ^ i2 >>> 16) << 1 >>> 0) * +HEAPF32[i1 + 104 >> 2];
 d4 = +Math_sin(+d5);
 HEAPF32[i3 >> 2] = +Math_cos(+d5) + d4 * 0.0;
 HEAPF32[i3 + 4 >> 2] = d4;
 return;
}

function _fec_hamming84_decode_soft(i1, i3, i5, i4) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i2 = 0, i6 = 0;
 if (!i3) return; else {
  i1 = 0;
  i2 = 0;
 }
 while (1) {
  i6 = _fecsoft_hamming84_decode(i5 + i2 | 0) | 0;
  HEAP8[i4 + i1 >> 0] = (i6 & 255) << 4 | (_fecsoft_hamming84_decode(i5 + (i2 | 8) | 0) | 0) & 255;
  i1 = i1 + 1 | 0;
  if ((i1 | 0) == (i3 | 0)) break; else i2 = i2 + 16 | 0;
 }
 return;
}

function mftCall_iiiiiiii(i8, i1, i2, i3, i4, i5, i6, i7) {
 i8 = i8 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 if ((i8 | 0) >= (fb | 0) & (i8 | 0) < (fb + 1 | 0)) return FUNCTION_TABLE_iiiiiiii[i8 - fb & 1](i1 | 0, i2 | 0, i3 | 0, i4 | 0, i5 | 0, i6 | 0, i7 | 0) | 0;
 return ftCall_iiiiiiii(i8 | 0, i1 | 0, i2 | 0, i3 | 0, i4 | 0, i5 | 0, i6 | 0, i7 | 0) | 0;
}

function ___stdio_close(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3;
 HEAP32[i2 >> 2] = HEAP32[i1 + 60 >> 2];
 i1 = ___syscall6(6, i2 | 0) | 0;
 if (i1 >>> 0 > 4294963200) {
  if (!(HEAP32[gb + 41360 >> 2] | 0)) i2 = gb + 41404 | 0; else i2 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
  HEAP32[i2 >> 2] = 0 - i1;
  i1 = -1;
 }
 STACKTOP = i3;
 return i1 | 0;
}

function ___muldsi3(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0, i5 = 0, i6 = 0;
 i6 = i1 & 65535;
 i5 = i2 & 65535;
 i3 = Math_imul(i5, i6) | 0;
 i4 = i1 >>> 16;
 i1 = (i3 >>> 16) + (Math_imul(i5, i4) | 0) | 0;
 i5 = i2 >>> 16;
 i2 = Math_imul(i5, i6) | 0;
 return (setTempRet0((i1 >>> 16) + (Math_imul(i5, i4) | 0) + (((i1 & 65535) + i2 | 0) >>> 16) | 0), i1 + i2 << 16 | i3 & 65535 | 0) | 0;
}

function _modem_modulate_ask(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 HEAPF32[i3 >> 2] = +HEAPF32[i1 + 100 >> 2] * +(((i2 >>> 1 ^ i2 ^ i2 >>> 2 ^ i2 >>> 3 ^ i2 >>> 4 ^ i2 >>> 5 ^ i2 >>> 6 ^ i2 >>> 7 ^ i2 >>> 8 ^ i2 >>> 9 ^ i2 >>> 10 ^ i2 >>> 11 ^ i2 >>> 12 ^ i2 >>> 13 ^ i2 >>> 14 ^ i2 >>> 15 ^ i2 >>> 16) << 1 | 1) - (HEAP32[i1 + 8 >> 2] | 0) | 0);
 HEAPF32[i3 + 4 >> 2] = 0.0;
 return;
}

function _fec_hamming84_decode(i1, i2, i4, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i5 = 0;
 if (!i2) return; else i1 = 0;
 do {
  i5 = i1 << 1;
  HEAP8[i3 + i1 >> 0] = (HEAPU8[(HEAPU8[i4 + i5 >> 0] | 0) + (gb + 12761) >> 0] | 0) << 4 | (HEAPU8[(HEAPU8[i4 + (i5 | 1) >> 0] | 0) + (gb + 12761) >> 0] | 0);
  i1 = i1 + 1 | 0;
 } while ((i1 | 0) != (i2 | 0));
 return;
}

function _fec_rep3_decode(i1, i3, i5, i4) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i5 = i5 | 0;
 i4 = i4 | 0;
 var i2 = 0, i6 = 0, i7 = 0;
 if (!i3) return;
 i1 = i3 << 1;
 i2 = 0;
 do {
  i6 = HEAP8[i5 + (i2 + i3) >> 0] | 0;
  i7 = HEAP8[i5 + (i2 + i1) >> 0] | 0;
  HEAP8[i4 + i2 >> 0] = (i7 | i6) & HEAP8[i5 + i2 >> 0] | i7 & i6;
  i2 = i2 + 1 | 0;
 } while ((i2 | 0) != (i3 | 0));
 return;
}

function _memmove(i1, i4, i2) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i3 = 0;
 if ((i4 | 0) < (i1 | 0) & (i1 | 0) < (i4 + i2 | 0)) {
  i3 = i1;
  i4 = i4 + i2 | 0;
  i1 = i1 + i2 | 0;
  while ((i2 | 0) > 0) {
   i1 = i1 - 1 | 0;
   i4 = i4 - 1 | 0;
   i2 = i2 - 1 | 0;
   HEAP8[i1 >> 0] = HEAP8[i4 >> 0] | 0;
  }
  i1 = i3;
 } else _memcpy(i1, i4, i2) | 0;
 return i1 | 0;
}

function _modem_demodulate_ook(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, i5 = 0;
 d4 = +HEAPF32[i3 >> 2];
 i5 = !(d4 > .7071067811865476);
 HEAP32[i2 >> 2] = i5 & 1;
 HEAPF32[i1 + 92 >> 2] = i5 ? 0.0 : 1.4142135381698608;
 HEAPF32[i1 + 96 >> 2] = 0.0;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 HEAPF32[i1 + 84 >> 2] = d4;
 HEAP32[i1 + 88 >> 2] = i3;
 return;
}

function _llvm_cttz_i32(i2) {
 i2 = i2 | 0;
 var i1 = 0;
 i1 = HEAP8[cttz_i8 + (i2 & 255) >> 0] | 0;
 if ((i1 | 0) < 8) return i1 | 0;
 i1 = HEAP8[cttz_i8 + (i2 >> 8 & 255) >> 0] | 0;
 if ((i1 | 0) < 8) return i1 + 8 | 0;
 i1 = HEAP8[cttz_i8 + (i2 >> 16 & 255) >> 0] | 0;
 if ((i1 | 0) < 8) return i1 + 16 | 0;
 return (HEAP8[cttz_i8 + (i2 >>> 24) >> 0] | 0) + 24 | 0;
}

function _modem_demodulate_bpsk(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var d4 = 0.0, i5 = 0;
 d4 = +HEAPF32[i3 >> 2];
 i5 = !(d4 > 0.0);
 HEAP32[i2 >> 2] = i5 & 1;
 HEAPF32[i1 + 92 >> 2] = i5 ? -1.0 : 1.0;
 HEAPF32[i1 + 96 >> 2] = 0.0;
 i3 = HEAP32[i3 + 4 >> 2] | 0;
 HEAPF32[i1 + 84 >> 2] = d4;
 HEAP32[i1 + 88 >> 2] = i3;
 return;
}

function _fec_rep5_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 _memcpy(i3 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + i1 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 << 1) | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 * 3 | 0) | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 << 2) | 0, i2 | 0, i1 | 0) | 0;
 return;
}

function _nco_crcf_compute_sincos_nco(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = ~~(+HEAPF32[i1 + 4 >> 2] * 40.7436637878418 + 512.0 + .5) >>> 0;
 i3 = i2 & 255;
 HEAP32[i1 + 1036 >> 2] = i3;
 HEAP32[i1 + 1040 >> 2] = HEAP32[i1 + 12 + (i3 << 2) >> 2];
 HEAP32[i1 + 1044 >> 2] = HEAP32[i1 + 12 + ((i2 + 64 & 255) << 2) >> 2];
 return;
}

function _sn_write(i1, i3, i2) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 var i4 = 0, i5 = 0;
 i4 = i1 + 20 | 0;
 i5 = HEAP32[i4 >> 2] | 0;
 i1 = (HEAP32[i1 + 16 >> 2] | 0) - i5 | 0;
 i1 = i1 >>> 0 > i2 >>> 0 ? i2 : i1;
 _memcpy(i5 | 0, i3 | 0, i1 | 0) | 0;
 HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i1;
 return i2 | 0;
}

function mftCall_iiiii(i5, i1, i2, i3, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 if ((i5 | 0) >= (fb | 0) & (i5 | 0) < (fb + 7 | 0)) return FUNCTION_TABLE_iiiii[i5 - fb & 7](i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
 return ftCall_iiiii(i5 | 0, i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function mftCall_viiii(i5, i1, i2, i3, i4) {
 i5 = i5 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 if ((i5 | 0) >= (fb | 0) & (i5 | 0) < (fb + 63 | 0)) {
  FUNCTION_TABLE_viiii[i5 - fb & 63](i1 | 0, i2 | 0, i3 | 0, i4 | 0);
  return;
 }
 ftCall_viiii(i5 | 0, i1 | 0, i2 | 0, i3 | 0, i4 | 0);
}

function ___uremdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0;
 i6 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i6 | 0;
 ___udivmoddi4(i1, i2, i3, i4, i5) | 0;
 STACKTOP = i6;
 return (setTempRet0(HEAP32[i5 + 4 >> 2] | 0), HEAP32[i5 >> 2] | 0) | 0;
}

function ___muldi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0;
 i5 = i1;
 i6 = i3;
 i3 = ___muldsi3(i5, i6) | 0;
 i1 = getTempRet0() | 0;
 return (setTempRet0((Math_imul(i2, i6) | 0) + (Math_imul(i4, i5) | 0) + i1 | i1 & 0 | 0), i3 | 0 | 0) | 0;
}

function _modem_modulate_qpsk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i1 = (i2 & 2 | 0) != 0;
 HEAPF32[i3 >> 2] = (i2 & 1 | 0 ? -.7071067811865476 : .7071067811865476) + (i1 ? -0.0 : 0.0);
 HEAPF32[i3 + 4 >> 2] = i1 ? -.7071067690849304 : .7071067690849304;
 return;
}

function mftCall_iiii(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 if ((i4 | 0) >= (fb | 0) & (i4 | 0) < (fb + 15 | 0)) return FUNCTION_TABLE_iiii[i4 - fb & 15](i1 | 0, i2 | 0, i3 | 0) | 0;
 return ftCall_iiii(i4 | 0, i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _string_get(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = i1 + 4 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 i1 = HEAP8[(HEAP32[i1 >> 2] | 0) + i3 >> 0] | 0;
 if (!(i1 << 24 >> 24)) {
  i3 = -1;
  return i3 | 0;
 }
 HEAP32[i2 >> 2] = i3 + 1;
 i3 = i1 & 255;
 return i3 | 0;
}

function mftCall_viii(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 if ((i4 | 0) >= (fb | 0) & (i4 | 0) < (fb + 31 | 0)) {
  FUNCTION_TABLE_viii[i4 - fb & 31](i1 | 0, i2 | 0, i3 | 0);
  return;
 }
 ftCall_viii(i4 | 0, i1 | 0, i2 | 0, i3 | 0);
}

function _bitshift64Ashr(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i1 | 0) < 32) {
  setTempRet0(i2 >> i1 | 0);
  return i3 >>> i1 | (i2 & (1 << i1) - 1) << 32 - i1;
 }
 setTempRet0(((i2 | 0) < 0 ? -1 : 0) | 0);
 return i2 >> i1 - 32 | 0;
}

function _snprintf(i3, i2, i1, i4) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i4 = i4 | 0;
 var i5 = 0, i6 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i6 = i5;
 HEAP32[i6 >> 2] = i4;
 _vsnprintf(i3, i2, i1, i6);
 STACKTOP = i5;
 return;
}

function copyTempFloat(i1) {
 i1 = i1 | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[i1 >> 0];
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[i1 + 1 >> 0];
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[i1 + 2 >> 0];
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[i1 + 3 >> 0];
}

function _bitshift64Shl(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i1 | 0) < 32) {
  setTempRet0(i2 << i1 | (i3 & (1 << i1) - 1 << 32 - i1) >>> 32 - i1 | 0);
  return i3 << i1;
 }
 setTempRet0(i3 << i1 - 32 | 0);
 return 0;
}

function _fec_rep3_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 _memcpy(i3 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + i1 | 0, i2 | 0, i1 | 0) | 0;
 _memcpy(i3 + (i1 << 1) | 0, i2 | 0, i1 | 0) | 0;
 return;
}

function mftCall_iii(i3, i1, i2) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 if ((i3 | 0) >= (fb | 0) & (i3 | 0) < (fb + 7 | 0)) return FUNCTION_TABLE_iii[i3 - fb & 7](i1 | 0, i2 | 0) | 0;
 return ftCall_iii(i3 | 0, i1 | 0, i2 | 0) | 0;
}

function _sprintf(i2, i1, i3) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4;
 HEAP32[i5 >> 2] = i3;
 _vsnprintf(i2, 2147483647, i1, i5);
 STACKTOP = i4;
 return;
}

function _bitshift64Lshr(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i1 | 0) < 32) {
  setTempRet0(i2 >>> i1 | 0);
  return i3 >>> i1 | (i2 & (1 << i1) - 1) << 32 - i1;
 }
 setTempRet0(0);
 return i2 >>> i1 - 32 | 0;
}

function _fprintf(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i4 = 0, i5 = 0;
 i4 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i5 = i4;
 HEAP32[i5 >> 2] = i3;
 _vfprintf(i1, i2, i5) | 0;
 STACKTOP = i4;
 return;
}

function _printf(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i3 = 0, i4 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i3;
 HEAP32[i4 >> 2] = i2;
 _vfprintf(gb + 8840 | 0, i1, i4) | 0;
 STACKTOP = i3;
 return;
}

function mftCall_ii(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i2 | 0) >= (fb | 0) & (i2 | 0) < (fb + 7 | 0)) return FUNCTION_TABLE_ii[i2 - fb & 7](i1 | 0) | 0;
 return ftCall_ii(i2 | 0, i1 | 0) | 0;
}

function _i64Subtract(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i4 = i2 - i4 - (i3 >>> 0 > i1 >>> 0 | 0) >>> 0;
 return (setTempRet0(i4 | 0), i1 - i3 >>> 0 | 0) | 0;
}

function mftCall_vi(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 if ((i2 | 0) >= (fb | 0) & (i2 | 0) < (fb + 31 | 0)) {
  FUNCTION_TABLE_vi[i2 - fb & 31](i1 | 0);
  return;
 }
 ftCall_vi(i2 | 0, i1 | 0);
}

function _nco_crcf_compute_sincos_vco(i1) {
 i1 = i1 | 0;
 var d2 = 0.0;
 d2 = +HEAPF32[i1 + 4 >> 2];
 HEAPF32[i1 + 1040 >> 2] = +Math_sin(+d2);
 HEAPF32[i1 + 1044 >> 2] = +Math_cos(+d2);
 return;
}

function _i64Add(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i3 = i1 + i3 >>> 0;
 return (setTempRet0(i2 + i4 + (i3 >>> 0 < i1 >>> 0 | 0) >>> 0 | 0), i3 | 0) | 0;
}

function _chainback_viterbi615__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi615(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _chainback_viterbi39__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi39(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _chainback_viterbi29__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi29(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _chainback_viterbi27__wrapper(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return _chainback_viterbi27(i1 | 0, i2 | 0, i3 | 0, i4 | 0) | 0;
}

function _modem_modulate_ook(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 HEAPF32[i3 >> 2] = i2 | 0 ? 0.0 : 1.4142135381698608;
 HEAPF32[i3 + 4 >> 2] = 0.0;
 return;
}

function ___errno_location() {
 var i1 = 0;
 if (!(HEAP32[gb + 41360 >> 2] | 0)) i1 = gb + 41404 | 0; else i1 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
 return i1 | 0;
}

function _modem_modulate_bpsk(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 HEAPF32[i3 >> 2] = i2 | 0 ? -1.0 : 1.0;
 HEAPF32[i3 + 4 >> 2] = 0.0;
 return;
}

function b0(i1, i2, i3, i4, i5, i6, i7) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 i7 = i7 | 0;
 abort(0);
 return 0;
}

function _update_viterbi615_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi615_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _update_viterbi39_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi39_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _update_viterbi29_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi29_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}

function _update_viterbi27_blk__wrapper(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 return _update_viterbi27_blk(i1 | 0, i2 | 0, i3 | 0) | 0;
}
function stackAlloc(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + i1 | 0;
 STACKTOP = STACKTOP + 15 & -16;
 return i2 | 0;
}

function _fec_pass_encode(i4, i1, i2, i3) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 _memmove(i3 | 0, i2 | 0, i1 | 0) | 0;
 return;
}

function _fec_pass_decode(i4, i1, i3, i2) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 _memmove(i2 | 0, i3 | 0, i1 | 0) | 0;
 return;
}

function ___udivdi3(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 return ___udivmoddi4(i1, i2, i3, i4, 0) | 0;
}

function _init_viterbi615__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi615(i1 | 0, i2 | 0) | 0;
}

function _init_viterbi39__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi39(i1 | 0, i2 | 0) | 0;
}

function _init_viterbi29__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi29(i1 | 0, i2 | 0) | 0;
}

function _init_viterbi27__wrapper(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 return _init_viterbi27(i1 | 0, i2 | 0) | 0;
}

function setThrew(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if (!__THREW__) {
  __THREW__ = i1;
  threwValue = i2;
 }
}

function b5(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 abort(5);
 return 0;
}

function establishStackSpace(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 STACKTOP = i1;
 STACK_MAX = i2;
}

function _roundf(d1) {
 d1 = +d1;
 return d1 >= 0.0 ? +Math_floor(d1 + .5) : +Math_ceil(d1 - .5);
}

function b7(i1, i2, i3, i4) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 abort(7);
}

function _create_viterbi615__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi615(i1 | 0) | 0;
}

function _create_viterbi39__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi39(i1 | 0) | 0;
}

function _create_viterbi29__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi29(i1 | 0) | 0;
}

function _create_viterbi27__wrapper(i1) {
 i1 = i1 | 0;
 return _create_viterbi27(i1 | 0) | 0;
}

function _quiet_decoder_checksum_fails(i1) {
 i1 = i1 | 0;
 return HEAP32[i1 + 108 >> 2] | 0;
}

function b1(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 abort(1);
 return 0;
}

function _delete_viterbi615__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi615(i1 | 0);
}

function _delete_viterbi39__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi39(i1 | 0);
}

function _delete_viterbi29__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi29(i1 | 0);
}

function _delete_viterbi27__wrapper(i1) {
 i1 = i1 | 0;
 _delete_viterbi27(i1 | 0);
}

function b4(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 abort(4);
}

function b6(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 abort(6);
 return 0;
}

function stackRestore(i1) {
 i1 = i1 | 0;
 STACKTOP = i1;
}

function b3(i1) {
 i1 = i1 | 0;
 abort(3);
 return 0;
}

function _cleanup_387(i1) {
 i1 = i1 | 0;
 return;
}

function _cleanup_382(i1) {
 i1 = i1 | 0;
 return;
}

function stackSave() {
 return STACKTOP | 0;
}

function b2(i1) {
 i1 = i1 | 0;
 abort(2);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_iiiiiiii = [b0,_decoder_on_decode];
var FUNCTION_TABLE_iiii = [b1,___stdio_write,___stdio_seek,___stdout_write,_sn_write,_update_viterbi27_blk__wrapper,_update_viterbi29_blk__wrapper,_update_viterbi39_blk__wrapper,_update_viterbi615_blk__wrapper,___stdio_read,b1,b1,b1,b1,b1,b1];
var FUNCTION_TABLE_vi = [b2,_nco_crcf_compute_sincos_nco,_nco_crcf_compute_sincos_vco,_delete_viterbi27__wrapper,_delete_viterbi29__wrapper,_delete_viterbi39__wrapper,_delete_viterbi615__wrapper,_fft_execute_mixed_radix,_fft_execute_rader,_fft_execute_rader2,_fft_execute_dft_2,_fft_execute_dft_3,_fft_execute_dft_4,_fft_execute_dft_5,_fft_execute_dft_6,_fft_execute_dft_7,_fft_execute_dft_8,_fft_execute_dft_16,_fft_execute_dft,_cleanup_387,_cleanup_382,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2];
var FUNCTION_TABLE_ii = [b3,___stdio_close,_create_viterbi27__wrapper,_create_viterbi29__wrapper,_create_viterbi39__wrapper,_create_viterbi615__wrapper,_string_get,b3];
var FUNCTION_TABLE_viii = [b4,_modem_modulate_qpsk,_modem_demodulate_qpsk,_modem_modulate_bpsk,_modem_demodulate_bpsk,_modem_modulate_dpsk,_modem_demodulate_dpsk,_modem_modulate_ask,_modem_demodulate_ask,_modem_modulate_ook,_modem_demodulate_ook,_modem_modulate_sqam32,_modem_demodulate_sqam32,_modem_modulate_sqam128,_modem_demodulate_sqam128,_modem_modulate_arb,_modem_demodulate_arb,_modem_modulate_psk,_modem_demodulate_psk,_modem_modulate_qam,_modem_demodulate_qam,_modem_modulate_apsk,_modem_demodulate_apsk,b4,b4,b4,b4,b4,b4
,b4,b4,b4];
var FUNCTION_TABLE_iiiii = [b5,_ofdmflexframesync_internal_callback,_chainback_viterbi27__wrapper,_chainback_viterbi29__wrapper,_chainback_viterbi39__wrapper,_chainback_viterbi615__wrapper,b5,b5];
var FUNCTION_TABLE_iii = [b6,_init_viterbi27__wrapper,_init_viterbi29__wrapper,_init_viterbi39__wrapper,_init_viterbi615__wrapper,b6,b6,b6];
var FUNCTION_TABLE_viiii = [b7,_fec_pass_encode,_fec_pass_decode,_fec_rep3_encode,_fec_rep3_decode,_fec_rep3_decode_soft,_fec_rep5_encode,_fec_rep5_decode,_fec_rep5_decode_soft,_fec_hamming74_encode,_fec_hamming74_decode,_fec_hamming74_decode_soft,_fec_hamming84_encode,_fec_hamming84_decode,_fec_hamming84_decode_soft,_fec_hamming128_encode,_fec_hamming128_decode,_fec_hamming128_decode_soft,_fec_golay2412_encode,_fec_golay2412_decode,_fec_secded2216_encode,_fec_secded2216_decode,_fec_secded3932_encode,_fec_secded3932_decode,_fec_secded7264_encode,_fec_secded7264_decode,_fec_conv_encode,_fec_conv_decode_hard,_fec_conv_decode_soft
,_fec_conv_punctured_encode,_fec_conv_punctured_decode_hard,_fec_conv_punctured_decode_soft,_fec_rs_encode,_fec_rs_decode,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7];

  return { _fec_hamming84_decode_soft: _fec_hamming84_decode_soft, _strlen: _strlen, _detector_cccf_create: _detector_cccf_create, _crc_generate_key: _crc_generate_key, _gmskframesync_update_symsync: _gmskframesync_update_symsync, _memchr: _memchr, _pad: _pad, _fec_conv_encode: _fec_conv_encode, _flexframegen_setprops: _flexframegen_setprops, _fec_secded7264_encode: _fec_secded7264_encode, _fec_get_enc_msg_length: _fec_get_enc_msg_length, _fec_hamming84_encode: _fec_hamming84_encode, _firdespm_execute: _firdespm_execute, _resamp_rrrf_execute_output_block: _resamp_rrrf_execute_output_block, _bitshift64Ashr: _bitshift64Ashr, _firpfb_rrrf_create_drnyquist: _firpfb_rrrf_create_drnyquist, ___stdio_write: ___stdio_write, _ofdmflexframegen_assemble: _ofdmflexframegen_assemble, _modem_modulate_apsk: _modem_modulate_apsk, _packetizer_create: _packetizer_create, _modem_modulate_psk: _modem_modulate_psk, _liquid_firdes_hM3: _liquid_firdes_hM3, ___stdio_close: ___stdio_close, _liquid_firdes_fnyquist: _liquid_firdes_fnyquist, _fmt_u: _fmt_u, _modem_modulate_ook: _modem_modulate_ook, _quiet_encoder_create: _quiet_encoder_create, _polyf_fit: _polyf_fit, _flexframegen_reconfigure: _flexframegen_reconfigure, stackSave: stackSave, _matrixf_inv: _matrixf_inv, ___shgetc: ___shgetc, _liquid_firdes_gmskrx: _liquid_firdes_gmskrx, _gmskframesync_execute: _gmskframesync_execute, _modem_modulate_qam: _modem_modulate_qam, _fec_hamming128_encode: _fec_hamming128_encode, _fft_execute_dft_5: _fft_execute_dft_5, _fft_execute_dft_4: _fft_execute_dft_4, _fft_execute_dft_7: _fft_execute_dft_7, _fft_execute_dft_6: _fft_execute_dft_6, _fft_execute_dft_3: _fft_execute_dft_3, _nco_crcf_compute_sincos_nco: _nco_crcf_compute_sincos_nco, _fft_execute_dft_8: _fft_execute_dft_8, _quiet_decoder_checksum_fails: _quiet_decoder_checksum_fails, _resamp_rrrf_destroy: _resamp_rrrf_destroy, _fec_secded7264_compute_syndrome: _fec_secded7264_compute_syndrome, _firinterp_crcf_execute: _firinterp_crcf_execute, _fft_execute_rader2: _fft_execute_rader2, _modem_modulate_ask: _modem_modulate_ask, setThrew: setThrew, _iirfilt_crcf_execute: _iirfilt_crcf_execute, _dispose_chunk: _dispose_chunk, _firdespm_create: _firdespm_create, _fec_secded2216_estimate_ehat: _fec_secded2216_estimate_ehat, _firinterp_rrrf_create_prototype: _firinterp_rrrf_create_prototype, _fec_secded3932_decode: _fec_secded3932_decode, _ofdmframesync_execute: _ofdmframesync_execute, _firinterp_crcf_create_kaiser: _firinterp_crcf_create_kaiser, _modem_arb_init: _modem_arb_init, _liquid_nextpow2: _liquid_nextpow2, _flexframegen_assemble: _flexframegen_assemble, _firpfb_crcf_create_rnyquist: _firpfb_crcf_create_rnyquist, _matrixf_mul: _matrixf_mul, _packetizer_destroy: _packetizer_destroy, _fecsoft_hamming84_decode: _fecsoft_hamming84_decode, ___strchrnul: ___strchrnul, _flexframegen_getframelen: _flexframegen_getframelen, _modem_demodulate_apsk: _modem_demodulate_apsk, _windowcf_create: _windowcf_create, _cleanup_382: _cleanup_382, _fft_create_plan: _fft_create_plan, _gmskframegen_assemble: _gmskframegen_assemble, _sprintf: _sprintf, _firinterp_crcf_create: _firinterp_crcf_create, _vsnprintf: _vsnprintf, _firinterp_crcf_create_prototype: _firinterp_crcf_create_prototype, _firpfb_rrrf_create_rnyquist: _firpfb_rrrf_create_rnyquist, _fec_conv_punctured_encode: _fec_conv_punctured_encode, _rkaiser_approximate_rho: _rkaiser_approximate_rho, _fprintf: _fprintf, _modem_demodulate_dpsk: _modem_demodulate_dpsk, _packetizer_decode: _packetizer_decode, _fec_rep3_decode: _fec_rep3_decode, _fmod: _fmod, _jsonp_error_set: _jsonp_error_set, _modulator_emit: _modulator_emit, _fec_secded7264_decode: _fec_secded7264_decode, _fec_secded2216_decode: _fec_secded2216_decode, _liquid_Qf: _liquid_Qf, _demodulator_recv: _demodulator_recv, _matrixf_hermitian: _matrixf_hermitian, _stream_get: _stream_get, _fec_hamming128_decode_symbol: _fec_hamming128_decode_symbol, _fclose: _fclose, _parse_value: _parse_value, _modem_demodulate_arb: _modem_demodulate_arb, ___stdio_seek: ___stdio_seek, _scramble_data: _scramble_data, _quiet_encoder_profile_str: _quiet_encoder_profile_str, _pop_arg: _pop_arg, _malloc: _malloc, _decode_unicode_escape: _decode_unicode_escape, _fopen: _fopen, ___mulsc3: ___mulsc3, _quiet_decoder_recv: _quiet_decoder_recv, _ofdmframesync_estimate_gain_S0: _ofdmframesync_estimate_gain_S0, _modem_destroy: _modem_destroy, _fec_secded7264_compute_parity: _fec_secded7264_compute_parity, _gmskmod_modulate: _gmskmod_modulate, _gmskframesync_execute_rxpreamble: _gmskframesync_execute_rxpreamble, _ofdmframesync_rxsymbol: _ofdmframesync_rxsymbol, _fec_secded3932_estimate_ehat: _fec_secded3932_estimate_ehat, _modem_init_map: _modem_init_map, _modem_demodulate_sqam128: _modem_demodulate_sqam128, _qpacketmodem_encode: _qpacketmodem_encode, _fec_hamming74_decode: _fec_hamming74_decode, _log10: _log10, _liquid_iirdes: _liquid_iirdes, _fec_conv_decode_hard: _fec_conv_decode_hard, _fec_conv_decode_soft: _fec_conv_decode_soft, _cexpf: _cexpf, _modem_demodulate_sqam32: _modem_demodulate_sqam32, _fec_conv_punctured_decode_soft: _fec_conv_punctured_decode_soft, _i64Add: _i64Add, _ofdmflexframegen_reconfigure: _ofdmflexframegen_reconfigure, _demodulator_flush: _demodulator_flush, stackRestore: stackRestore, _quiet_encoder_emit: _quiet_encoder_emit, _wcrtomb: _wcrtomb, _fec_rep3_encode: _fec_rep3_encode, _frexp: _frexp, _hashlittle: _hashlittle, _gmskframegen_set_header_len: _gmskframegen_set_header_len, _ofdmframegen_writesymbol: _ofdmframegen_writesymbol, _modem_modulate_dpsk: _modem_modulate_dpsk, _modem_modulate_sqam128: _modem_modulate_sqam128, _firdespm_compute_interp: _firdespm_compute_interp, ___muldc3: ___muldc3, _liquid_firdes_gmsktx: _liquid_firdes_gmsktx, _bitshift64Lshr: _bitshift64Lshr, _quiet_decoder_destroy: _quiet_decoder_destroy, _modem_demodulate_psk: _modem_demodulate_psk, _fec_create: _fec_create, _modem_modulate_bpsk: _modem_modulate_bpsk, _fec_hamming128_decode: _fec_hamming128_decode, _cleanup_387: _cleanup_387, _firdespm_destroy: _firdespm_destroy, ___divdc3: ___divdc3, _nco_crcf_compute_sincos_vco: _nco_crcf_compute_sincos_vco, _memcpy: _memcpy, _ofdmframe_init_default_sctype: _ofdmframe_init_default_sctype, _ofdmframesync_S0_metrics: _ofdmframesync_S0_metrics, _qpacketmodem_configure: _qpacketmodem_configure, ___stdout_write: ___stdout_write, _quiet_decoder_readbuf: _quiet_decoder_readbuf, _sn_write: _sn_write, ___stdio_read: ___stdio_read, _free: _free, runPostSets: runPostSets, _iirfilt_crcf_destroy: _iirfilt_crcf_destroy, _fec_secded2216_compute_parity: _fec_secded2216_compute_parity, _firdespm_compute_taps: _firdespm_compute_taps, _error_set: _error_set, _quiet_encoder_destroy: _quiet_encoder_destroy, _liquid_firdes_kaiser: _liquid_firdes_kaiser, ___divsc3: ___divsc3, _fec_golay2412_decode: _fec_golay2412_decode, _fecsoft_hamming74_decode: _fecsoft_hamming74_decode, _modem_modulate_qpsk: _modem_modulate_qpsk, _json_delete: _json_delete, _liquid_pack_array: _liquid_pack_array, _fft_execute_dft_16: _fft_execute_dft_16, _quiet_decoder_create: _quiet_decoder_create, _liquid_unpack_array: _liquid_unpack_array, _llvm_cttz_i32: _llvm_cttz_i32, _quiet_decoder_flush: _quiet_decoder_flush, _liquid_firdes_prototype: _liquid_firdes_prototype, _modulator_flush: _modulator_flush, _quiet_encoder_clamp_frame_len: _quiet_encoder_clamp_frame_len, _fft_execute_dft: _fft_execute_dft, _fft_execute_dft_2: _fft_execute_dft_2, _ofdmframesync_estimate_eqgain_poly: _ofdmframesync_estimate_eqgain_poly, _printf: _printf, _liquid_repack_bytes: _liquid_repack_bytes, _json_loads: _json_loads, _msequence_create_default: _msequence_create_default, _modem_demodulate_ook: _modem_demodulate_ook, _fec_golay2412_encode: _fec_golay2412_encode, _liquid_firdes_rkaiser_internal_isi: _liquid_firdes_rkaiser_internal_isi, _firpfb_crcf_create: _firpfb_crcf_create, establishStackSpace: establishStackSpace, _liquid_cplxpair: _liquid_cplxpair, _string_get: _string_get, _fec_rs_encode: _fec_rs_encode, _modem_create: _modem_create, _fec_rs_decode: _fec_rs_decode, _roundf: _roundf, _fec_rep5_decode_soft: _fec_rep5_decode_soft, _modem_demodsoft_gentab: _modem_demodsoft_gentab, _ofdmframesync_debug_print: _ofdmframesync_debug_print, _modem_demodulate_qpsk: _modem_demodulate_qpsk, _fec_hamming74_decode_soft: _fec_hamming74_decode_soft, _vfprintf: _vfprintf, _quiet_encoder_sample_len: _quiet_encoder_sample_len, _modem_demodulate_ask: _modem_demodulate_ask, _fec_pass_decode: _fec_pass_decode, _fec_hamming128_decode_soft: _fec_hamming128_decode_soft, _firinterp_crcf_destroy: _firinterp_crcf_destroy, _fec_golay2412_decode_symbol: _fec_golay2412_decode_symbol, _fec_conv_punctured_decode_hard: _fec_conv_punctured_decode_hard, _memset: _memset, _open: _open, _snprintf: _snprintf, _ofdmflexframesync_set_header_len: _ofdmflexframesync_set_header_len, _modem_modulate_sqam32: _modem_modulate_sqam32, _hashtable_get: _hashtable_get, _lex_scan: _lex_scan, _i64Subtract: _i64Subtract, _firdecim_crcf_create_kaiser: _firdecim_crcf_create_kaiser, ___fflush_unlocked: ___fflush_unlocked, _modem_modulate_arb: _modem_modulate_arb, _fec_rep5_decode: _fec_rep5_decode, _modem_create_qam: _modem_create_qam, _modem_demodulate_qam: _modem_demodulate_qam, _modem_modulate: _modem_modulate, _fec_hamming74_encode: _fec_hamming74_encode, _modem_demodulate_bpsk: _modem_demodulate_bpsk, _fec_rep5_encode: _fec_rep5_encode, _ofdmflexframesync_internal_callback: _ofdmflexframesync_internal_callback, _firinterp_rrrf_destroy: _firinterp_rrrf_destroy, _decoder_on_decode: _decoder_on_decode, _modem_create_psk: _modem_create_psk, _fec_rep3_decode_soft: _fec_rep3_decode_soft, _modem_create_apsk: _modem_create_apsk, _fec_pass_encode: _fec_pass_encode, _firpfb_rrrf_create: _firpfb_rrrf_create, _scanexp: _scanexp, _bitshift64Shl: _bitshift64Shl, _fflush: _fflush, _ofdmframe_init_S1: _ofdmframe_init_S1, _ofdmframe_init_S0: _ofdmframe_init_S0, _quiet_decoder_profile_str: _quiet_decoder_profile_str, _fft_execute_mixed_radix: _fft_execute_mixed_radix, _packetizer_encode: _packetizer_encode, _firdespm_iext_search: _firdespm_iext_search, stackAlloc: stackAlloc, _expm1f: _expm1f, _realloc: _realloc, _flexframesync_set_header_len: _flexframesync_set_header_len, _fft_destroy_plan: _fft_destroy_plan, _flexframesync_execute: _flexframesync_execute, _resamp_rrrf_create: _resamp_rrrf_create, ___errno_location: ___errno_location, _flexframegen_set_header_len: _flexframegen_set_header_len, _fec_hamming84_decode: _fec_hamming84_decode, _fec_secded2216_encode: _fec_secded2216_encode, _fec_secded3932_encode: _fec_secded3932_encode, _printf_core: _printf_core, _memmove: _memmove, _liquid_lngammaf: _liquid_lngammaf, _gmskframesync_create: _gmskframesync_create, _fft_execute_rader: _fft_execute_rader, ___fwritex: ___fwritex, _quiet_encoder_set_payload: _quiet_encoder_set_payload, _ofdmflexframegen_set_header_len: _ofdmflexframegen_set_header_len };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
var _fec_hamming84_decode_soft = Module["_fec_hamming84_decode_soft"] = asm["_fec_hamming84_decode_soft"];
var _frexp = Module["_frexp"] = asm["_frexp"];
var _hashlittle = Module["_hashlittle"] = asm["_hashlittle"];
var _gmskframegen_set_header_len = Module["_gmskframegen_set_header_len"] = asm["_gmskframegen_set_header_len"];
var _ofdmframegen_writesymbol = Module["_ofdmframegen_writesymbol"] = asm["_ofdmframegen_writesymbol"];
var _modem_modulate_dpsk = Module["_modem_modulate_dpsk"] = asm["_modem_modulate_dpsk"];
var _modem_modulate_apsk = Module["_modem_modulate_apsk"] = asm["_modem_modulate_apsk"];
var _modem_demodulate_bpsk = Module["_modem_demodulate_bpsk"] = asm["_modem_demodulate_bpsk"];
var _modem_modulate_sqam128 = Module["_modem_modulate_sqam128"] = asm["_modem_modulate_sqam128"];
var _detector_cccf_create = Module["_detector_cccf_create"] = asm["_detector_cccf_create"];
var _crc_generate_key = Module["_crc_generate_key"] = asm["_crc_generate_key"];
var _gmskframesync_update_symsync = Module["_gmskframesync_update_symsync"] = asm["_gmskframesync_update_symsync"];
var ___muldc3 = Module["___muldc3"] = asm["___muldc3"];
var _pad = Module["_pad"] = asm["_pad"];
var _liquid_firdes_gmsktx = Module["_liquid_firdes_gmsktx"] = asm["_liquid_firdes_gmsktx"];
var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
var _quiet_decoder_destroy = Module["_quiet_decoder_destroy"] = asm["_quiet_decoder_destroy"];
var _liquid_firdes_gmskrx = Module["_liquid_firdes_gmskrx"] = asm["_liquid_firdes_gmskrx"];
var _flexframegen_setprops = Module["_flexframegen_setprops"] = asm["_flexframegen_setprops"];
var _fec_create = Module["_fec_create"] = asm["_fec_create"];
var _modem_modulate_bpsk = Module["_modem_modulate_bpsk"] = asm["_modem_modulate_bpsk"];
var _fec_secded7264_encode = Module["_fec_secded7264_encode"] = asm["_fec_secded7264_encode"];
var _fec_hamming128_decode = Module["_fec_hamming128_decode"] = asm["_fec_hamming128_decode"];
var _fec_get_enc_msg_length = Module["_fec_get_enc_msg_length"] = asm["_fec_get_enc_msg_length"];
var _cleanup_387 = Module["_cleanup_387"] = asm["_cleanup_387"];
var _fec_hamming84_encode = Module["_fec_hamming84_encode"] = asm["_fec_hamming84_encode"];
var _firdespm_execute = Module["_firdespm_execute"] = asm["_firdespm_execute"];
var _resamp_rrrf_execute_output_block = Module["_resamp_rrrf_execute_output_block"] = asm["_resamp_rrrf_execute_output_block"];
var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
var _firpfb_rrrf_create_drnyquist = Module["_firpfb_rrrf_create_drnyquist"] = asm["_firpfb_rrrf_create_drnyquist"];
var ___stdio_write = Module["___stdio_write"] = asm["___stdio_write"];
var _nco_crcf_compute_sincos_vco = Module["_nco_crcf_compute_sincos_vco"] = asm["_nco_crcf_compute_sincos_vco"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _ofdmframe_init_default_sctype = Module["_ofdmframe_init_default_sctype"] = asm["_ofdmframe_init_default_sctype"];
var _ofdmflexframegen_assemble = Module["_ofdmflexframegen_assemble"] = asm["_ofdmflexframegen_assemble"];
var _ofdmframesync_S0_metrics = Module["_ofdmframesync_S0_metrics"] = asm["_ofdmframesync_S0_metrics"];
var _matrixf_mul = Module["_matrixf_mul"] = asm["_matrixf_mul"];
var _qpacketmodem_configure = Module["_qpacketmodem_configure"] = asm["_qpacketmodem_configure"];
var ___stdout_write = Module["___stdout_write"] = asm["___stdout_write"];
var _quiet_decoder_readbuf = Module["_quiet_decoder_readbuf"] = asm["_quiet_decoder_readbuf"];
var _sn_write = Module["_sn_write"] = asm["_sn_write"];
var _modem_modulate_psk = Module["_modem_modulate_psk"] = asm["_modem_modulate_psk"];
var _liquid_firdes_prototype = Module["_liquid_firdes_prototype"] = asm["_liquid_firdes_prototype"];
var ___stdio_close = Module["___stdio_close"] = asm["___stdio_close"];
var _liquid_firdes_fnyquist = Module["_liquid_firdes_fnyquist"] = asm["_liquid_firdes_fnyquist"];
var _firdespm_compute_interp = Module["_firdespm_compute_interp"] = asm["_firdespm_compute_interp"];
var _fec_conv_decode_soft = Module["_fec_conv_decode_soft"] = asm["_fec_conv_decode_soft"];
var _modem_modulate_ook = Module["_modem_modulate_ook"] = asm["_modem_modulate_ook"];
var _quiet_encoder_profile_str = Module["_quiet_encoder_profile_str"] = asm["_quiet_encoder_profile_str"];
var _quiet_encoder_create = Module["_quiet_encoder_create"] = asm["_quiet_encoder_create"];
var _polyf_fit = Module["_polyf_fit"] = asm["_polyf_fit"];
var _flexframegen_reconfigure = Module["_flexframegen_reconfigure"] = asm["_flexframegen_reconfigure"];
var _memchr = Module["_memchr"] = asm["_memchr"];
var _matrixf_inv = Module["_matrixf_inv"] = asm["_matrixf_inv"];
var _free = Module["_free"] = asm["_free"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var ___shgetc = Module["___shgetc"] = asm["___shgetc"];
var _iirfilt_crcf_destroy = Module["_iirfilt_crcf_destroy"] = asm["_iirfilt_crcf_destroy"];
var _gmskframesync_execute = Module["_gmskframesync_execute"] = asm["_gmskframesync_execute"];
var _modem_modulate_qam = Module["_modem_modulate_qam"] = asm["_modem_modulate_qam"];
var _modulator_flush = Module["_modulator_flush"] = asm["_modulator_flush"];
var _fft_execute_dft_5 = Module["_fft_execute_dft_5"] = asm["_fft_execute_dft_5"];
var _fft_execute_dft_4 = Module["_fft_execute_dft_4"] = asm["_fft_execute_dft_4"];
var _fft_execute_dft_7 = Module["_fft_execute_dft_7"] = asm["_fft_execute_dft_7"];
var _fec_secded2216_compute_parity = Module["_fec_secded2216_compute_parity"] = asm["_fec_secded2216_compute_parity"];
var _firdespm_compute_taps = Module["_firdespm_compute_taps"] = asm["_firdespm_compute_taps"];
var _fft_execute_dft_3 = Module["_fft_execute_dft_3"] = asm["_fft_execute_dft_3"];
var _nco_crcf_compute_sincos_nco = Module["_nco_crcf_compute_sincos_nco"] = asm["_nco_crcf_compute_sincos_nco"];
var _error_set = Module["_error_set"] = asm["_error_set"];
var _fft_execute_dft_8 = Module["_fft_execute_dft_8"] = asm["_fft_execute_dft_8"];
var _quiet_encoder_destroy = Module["_quiet_encoder_destroy"] = asm["_quiet_encoder_destroy"];
var _liquid_firdes_kaiser = Module["_liquid_firdes_kaiser"] = asm["_liquid_firdes_kaiser"];
var _quiet_decoder_checksum_fails = Module["_quiet_decoder_checksum_fails"] = asm["_quiet_decoder_checksum_fails"];
var ___divsc3 = Module["___divsc3"] = asm["___divsc3"];
var _resamp_rrrf_destroy = Module["_resamp_rrrf_destroy"] = asm["_resamp_rrrf_destroy"];
var _vfprintf = Module["_vfprintf"] = asm["_vfprintf"];
var _firinterp_crcf_execute = Module["_firinterp_crcf_execute"] = asm["_firinterp_crcf_execute"];
var _fft_execute_rader2 = Module["_fft_execute_rader2"] = asm["_fft_execute_rader2"];
var _fecsoft_hamming74_decode = Module["_fecsoft_hamming74_decode"] = asm["_fecsoft_hamming74_decode"];
var _modem_modulate_qpsk = Module["_modem_modulate_qpsk"] = asm["_modem_modulate_qpsk"];
var _json_delete = Module["_json_delete"] = asm["_json_delete"];
var _fec_rep3_decode = Module["_fec_rep3_decode"] = asm["_fec_rep3_decode"];
var _iirfilt_crcf_execute = Module["_iirfilt_crcf_execute"] = asm["_iirfilt_crcf_execute"];
var _liquid_pack_array = Module["_liquid_pack_array"] = asm["_liquid_pack_array"];
var _firdespm_create = Module["_firdespm_create"] = asm["_firdespm_create"];
var _fec_conv_encode = Module["_fec_conv_encode"] = asm["_fec_conv_encode"];
var _fec_secded2216_estimate_ehat = Module["_fec_secded2216_estimate_ehat"] = asm["_fec_secded2216_estimate_ehat"];
var _modem_create_apsk = Module["_modem_create_apsk"] = asm["_modem_create_apsk"];
var _firinterp_rrrf_create_prototype = Module["_firinterp_rrrf_create_prototype"] = asm["_firinterp_rrrf_create_prototype"];
var _quiet_decoder_create = Module["_quiet_decoder_create"] = asm["_quiet_decoder_create"];
var _liquid_unpack_array = Module["_liquid_unpack_array"] = asm["_liquid_unpack_array"];
var _ofdmframesync_execute = Module["_ofdmframesync_execute"] = asm["_ofdmframesync_execute"];
var _firinterp_crcf_create_kaiser = Module["_firinterp_crcf_create_kaiser"] = asm["_firinterp_crcf_create_kaiser"];
var _modem_arb_init = Module["_modem_arb_init"] = asm["_modem_arb_init"];
var _llvm_cttz_i32 = Module["_llvm_cttz_i32"] = asm["_llvm_cttz_i32"];
var _flexframegen_assemble = Module["_flexframegen_assemble"] = asm["_flexframegen_assemble"];
var _firpfb_crcf_create_rnyquist = Module["_firpfb_crcf_create_rnyquist"] = asm["_firpfb_crcf_create_rnyquist"];
var _quiet_decoder_flush = Module["_quiet_decoder_flush"] = asm["_quiet_decoder_flush"];
var _fec_secded3932_decode = Module["_fec_secded3932_decode"] = asm["_fec_secded3932_decode"];
var _modem_demodulate_dpsk = Module["_modem_demodulate_dpsk"] = asm["_modem_demodulate_dpsk"];
var _packetizer_destroy = Module["_packetizer_destroy"] = asm["_packetizer_destroy"];
var _liquid_firdes_hM3 = Module["_liquid_firdes_hM3"] = asm["_liquid_firdes_hM3"];
var _firinterp_crcf_destroy = Module["_firinterp_crcf_destroy"] = asm["_firinterp_crcf_destroy"];
var _liquid_lngammaf = Module["_liquid_lngammaf"] = asm["_liquid_lngammaf"];
var _fec_hamming128_encode = Module["_fec_hamming128_encode"] = asm["_fec_hamming128_encode"];
var ___strchrnul = Module["___strchrnul"] = asm["___strchrnul"];
var _flexframegen_getframelen = Module["_flexframegen_getframelen"] = asm["_flexframegen_getframelen"];
var _modem_demodulate_apsk = Module["_modem_demodulate_apsk"] = asm["_modem_demodulate_apsk"];
var _windowcf_create = Module["_windowcf_create"] = asm["_windowcf_create"];
var _quiet_encoder_clamp_frame_len = Module["_quiet_encoder_clamp_frame_len"] = asm["_quiet_encoder_clamp_frame_len"];
var _fft_execute_dft = Module["_fft_execute_dft"] = asm["_fft_execute_dft"];
var _cleanup_382 = Module["_cleanup_382"] = asm["_cleanup_382"];
var _fft_execute_dft_2 = Module["_fft_execute_dft_2"] = asm["_fft_execute_dft_2"];
var _fft_create_plan = Module["_fft_create_plan"] = asm["_fft_create_plan"];
var _gmskframegen_assemble = Module["_gmskframegen_assemble"] = asm["_gmskframegen_assemble"];
var _ofdmframesync_estimate_eqgain_poly = Module["_ofdmframesync_estimate_eqgain_poly"] = asm["_ofdmframesync_estimate_eqgain_poly"];
var _printf = Module["_printf"] = asm["_printf"];
var _sprintf = Module["_sprintf"] = asm["_sprintf"];
var _firinterp_crcf_create = Module["_firinterp_crcf_create"] = asm["_firinterp_crcf_create"];
var _liquid_repack_bytes = Module["_liquid_repack_bytes"] = asm["_liquid_repack_bytes"];
var _json_loads = Module["_json_loads"] = asm["_json_loads"];
var _msequence_create_default = Module["_msequence_create_default"] = asm["_msequence_create_default"];
var _modem_demodulate_ook = Module["_modem_demodulate_ook"] = asm["_modem_demodulate_ook"];
var _fec_golay2412_encode = Module["_fec_golay2412_encode"] = asm["_fec_golay2412_encode"];
var _vsnprintf = Module["_vsnprintf"] = asm["_vsnprintf"];
var _liquid_firdes_rkaiser_internal_isi = Module["_liquid_firdes_rkaiser_internal_isi"] = asm["_liquid_firdes_rkaiser_internal_isi"];
var _firinterp_crcf_create_prototype = Module["_firinterp_crcf_create_prototype"] = asm["_firinterp_crcf_create_prototype"];
var _firpfb_rrrf_create_rnyquist = Module["_firpfb_rrrf_create_rnyquist"] = asm["_firpfb_rrrf_create_rnyquist"];
var _firpfb_crcf_create = Module["_firpfb_crcf_create"] = asm["_firpfb_crcf_create"];
var _fec_conv_punctured_encode = Module["_fec_conv_punctured_encode"] = asm["_fec_conv_punctured_encode"];
var _fec_conv_punctured_decode_hard = Module["_fec_conv_punctured_decode_hard"] = asm["_fec_conv_punctured_decode_hard"];
var _rkaiser_approximate_rho = Module["_rkaiser_approximate_rho"] = asm["_rkaiser_approximate_rho"];
var _string_get = Module["_string_get"] = asm["_string_get"];
var _fec_rs_encode = Module["_fec_rs_encode"] = asm["_fec_rs_encode"];
var _modem_create = Module["_modem_create"] = asm["_modem_create"];
var _firdespm_destroy = Module["_firdespm_destroy"] = asm["_firdespm_destroy"];
var _fec_rs_decode = Module["_fec_rs_decode"] = asm["_fec_rs_decode"];
var _roundf = Module["_roundf"] = asm["_roundf"];
var _fec_rep5_decode_soft = Module["_fec_rep5_decode_soft"] = asm["_fec_rep5_decode_soft"];
var _modem_demodsoft_gentab = Module["_modem_demodsoft_gentab"] = asm["_modem_demodsoft_gentab"];
var _ofdmframesync_debug_print = Module["_ofdmframesync_debug_print"] = asm["_ofdmframesync_debug_print"];
var _packetizer_decode = Module["_packetizer_decode"] = asm["_packetizer_decode"];
var ___divdc3 = Module["___divdc3"] = asm["___divdc3"];
var _fmod = Module["_fmod"] = asm["_fmod"];
var _modem_demodulate_qpsk = Module["_modem_demodulate_qpsk"] = asm["_modem_demodulate_qpsk"];
var _fec_hamming74_decode_soft = Module["_fec_hamming74_decode_soft"] = asm["_fec_hamming74_decode_soft"];
var _jsonp_error_set = Module["_jsonp_error_set"] = asm["_jsonp_error_set"];
var _modulator_emit = Module["_modulator_emit"] = asm["_modulator_emit"];
var _quiet_encoder_sample_len = Module["_quiet_encoder_sample_len"] = asm["_quiet_encoder_sample_len"];
var _modem_demodulate_ask = Module["_modem_demodulate_ask"] = asm["_modem_demodulate_ask"];
var _fec_pass_decode = Module["_fec_pass_decode"] = asm["_fec_pass_decode"];
var _fec_hamming128_decode_soft = Module["_fec_hamming128_decode_soft"] = asm["_fec_hamming128_decode_soft"];
var _fft_execute_dft_6 = Module["_fft_execute_dft_6"] = asm["_fft_execute_dft_6"];
var _fec_golay2412_decode_symbol = Module["_fec_golay2412_decode_symbol"] = asm["_fec_golay2412_decode_symbol"];
var _liquid_cplxpair = Module["_liquid_cplxpair"] = asm["_liquid_cplxpair"];
var _fec_secded7264_decode = Module["_fec_secded7264_decode"] = asm["_fec_secded7264_decode"];
var _fec_secded2216_decode = Module["_fec_secded2216_decode"] = asm["_fec_secded2216_decode"];
var _memset = Module["_memset"] = asm["_memset"];
var _open = Module["_open"] = asm["_open"];
var _liquid_Qf = Module["_liquid_Qf"] = asm["_liquid_Qf"];
var _snprintf = Module["_snprintf"] = asm["_snprintf"];
var _ofdmflexframesync_set_header_len = Module["_ofdmflexframesync_set_header_len"] = asm["_ofdmflexframesync_set_header_len"];
var _demodulator_recv = Module["_demodulator_recv"] = asm["_demodulator_recv"];
var _matrixf_hermitian = Module["_matrixf_hermitian"] = asm["_matrixf_hermitian"];
var _modem_modulate_sqam32 = Module["_modem_modulate_sqam32"] = asm["_modem_modulate_sqam32"];
var _modem_demodulate_psk = Module["_modem_demodulate_psk"] = asm["_modem_demodulate_psk"];
var _lex_scan = Module["_lex_scan"] = asm["_lex_scan"];
var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
var _fec_secded7264_compute_syndrome = Module["_fec_secded7264_compute_syndrome"] = asm["_fec_secded7264_compute_syndrome"];
var _firdecim_crcf_create_kaiser = Module["_firdecim_crcf_create_kaiser"] = asm["_firdecim_crcf_create_kaiser"];
var _fec_hamming84_decode = Module["_fec_hamming84_decode"] = asm["_fec_hamming84_decode"];
var _modem_modulate_arb = Module["_modem_modulate_arb"] = asm["_modem_modulate_arb"];
var _fec_rep5_decode = Module["_fec_rep5_decode"] = asm["_fec_rep5_decode"];
var _modem_create_qam = Module["_modem_create_qam"] = asm["_modem_create_qam"];
var _fec_hamming128_decode_symbol = Module["_fec_hamming128_decode_symbol"] = asm["_fec_hamming128_decode_symbol"];
var _modem_demodulate_qam = Module["_modem_demodulate_qam"] = asm["_modem_demodulate_qam"];
var _fclose = Module["_fclose"] = asm["_fclose"];
var _modem_modulate = Module["_modem_modulate"] = asm["_modem_modulate"];
var _modem_modulate_ask = Module["_modem_modulate_ask"] = asm["_modem_modulate_ask"];
var _parse_value = Module["_parse_value"] = asm["_parse_value"];
var _modem_demodulate_arb = Module["_modem_demodulate_arb"] = asm["_modem_demodulate_arb"];
var _liquid_nextpow2 = Module["_liquid_nextpow2"] = asm["_liquid_nextpow2"];
var ___stdio_seek = Module["___stdio_seek"] = asm["___stdio_seek"];
var _scramble_data = Module["_scramble_data"] = asm["_scramble_data"];
var _fec_rep5_encode = Module["_fec_rep5_encode"] = asm["_fec_rep5_encode"];
var _strlen = Module["_strlen"] = asm["_strlen"];
var _ofdmflexframesync_internal_callback = Module["_ofdmflexframesync_internal_callback"] = asm["_ofdmflexframesync_internal_callback"];
var _pop_arg = Module["_pop_arg"] = asm["_pop_arg"];
var _firinterp_rrrf_destroy = Module["_firinterp_rrrf_destroy"] = asm["_firinterp_rrrf_destroy"];
var _decoder_on_decode = Module["_decoder_on_decode"] = asm["_decoder_on_decode"];
var _stream_get = Module["_stream_get"] = asm["_stream_get"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _decode_unicode_escape = Module["_decode_unicode_escape"] = asm["_decode_unicode_escape"];
var _hashtable_get = Module["_hashtable_get"] = asm["_hashtable_get"];
var _fopen = Module["_fopen"] = asm["_fopen"];
var ___mulsc3 = Module["___mulsc3"] = asm["___mulsc3"];
var _packetizer_create = Module["_packetizer_create"] = asm["_packetizer_create"];
var _fec_rep3_decode_soft = Module["_fec_rep3_decode_soft"] = asm["_fec_rep3_decode_soft"];
var _quiet_decoder_recv = Module["_quiet_decoder_recv"] = asm["_quiet_decoder_recv"];
var _ofdmframesync_estimate_gain_S0 = Module["_ofdmframesync_estimate_gain_S0"] = asm["_ofdmframesync_estimate_gain_S0"];
var _fft_execute_dft_16 = Module["_fft_execute_dft_16"] = asm["_fft_execute_dft_16"];
var _modem_destroy = Module["_modem_destroy"] = asm["_modem_destroy"];
var _fec_secded7264_compute_parity = Module["_fec_secded7264_compute_parity"] = asm["_fec_secded7264_compute_parity"];
var _log10 = Module["_log10"] = asm["_log10"];
var _fecsoft_hamming84_decode = Module["_fecsoft_hamming84_decode"] = asm["_fecsoft_hamming84_decode"];
var _gmskmod_modulate = Module["_gmskmod_modulate"] = asm["_gmskmod_modulate"];
var _gmskframesync_execute_rxpreamble = Module["_gmskframesync_execute_rxpreamble"] = asm["_gmskframesync_execute_rxpreamble"];
var _ofdmframesync_rxsymbol = Module["_ofdmframesync_rxsymbol"] = asm["_ofdmframesync_rxsymbol"];
var _fec_pass_encode = Module["_fec_pass_encode"] = asm["_fec_pass_encode"];
var _firpfb_rrrf_create = Module["_firpfb_rrrf_create"] = asm["_firpfb_rrrf_create"];
var _scanexp = Module["_scanexp"] = asm["_scanexp"];
var _fec_secded3932_estimate_ehat = Module["_fec_secded3932_estimate_ehat"] = asm["_fec_secded3932_estimate_ehat"];
var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
var _modem_init_map = Module["_modem_init_map"] = asm["_modem_init_map"];
var _modem_demodulate_sqam128 = Module["_modem_demodulate_sqam128"] = asm["_modem_demodulate_sqam128"];
var _fflush = Module["_fflush"] = asm["_fflush"];
var _dispose_chunk = Module["_dispose_chunk"] = asm["_dispose_chunk"];
var _ofdmframe_init_S1 = Module["_ofdmframe_init_S1"] = asm["_ofdmframe_init_S1"];
var _qpacketmodem_encode = Module["_qpacketmodem_encode"] = asm["_qpacketmodem_encode"];
var _quiet_decoder_profile_str = Module["_quiet_decoder_profile_str"] = asm["_quiet_decoder_profile_str"];
var _fprintf = Module["_fprintf"] = asm["_fprintf"];
var ___stdio_read = Module["___stdio_read"] = asm["___stdio_read"];
var _fec_hamming74_encode = Module["_fec_hamming74_encode"] = asm["_fec_hamming74_encode"];
var _liquid_iirdes = Module["_liquid_iirdes"] = asm["_liquid_iirdes"];
var _fft_execute_mixed_radix = Module["_fft_execute_mixed_radix"] = asm["_fft_execute_mixed_radix"];
var _fec_conv_decode_hard = Module["_fec_conv_decode_hard"] = asm["_fec_conv_decode_hard"];
var _fec_hamming74_decode = Module["_fec_hamming74_decode"] = asm["_fec_hamming74_decode"];
var _packetizer_encode = Module["_packetizer_encode"] = asm["_packetizer_encode"];
var _cexpf = Module["_cexpf"] = asm["_cexpf"];
var _firdespm_iext_search = Module["_firdespm_iext_search"] = asm["_firdespm_iext_search"];
var _fec_golay2412_decode = Module["_fec_golay2412_decode"] = asm["_fec_golay2412_decode"];
var _modem_create_psk = Module["_modem_create_psk"] = asm["_modem_create_psk"];
var _expm1f = Module["_expm1f"] = asm["_expm1f"];
var _fec_conv_punctured_decode_soft = Module["_fec_conv_punctured_decode_soft"] = asm["_fec_conv_punctured_decode_soft"];
var _realloc = Module["_realloc"] = asm["_realloc"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _flexframesync_set_header_len = Module["_flexframesync_set_header_len"] = asm["_flexframesync_set_header_len"];
var _fft_destroy_plan = Module["_fft_destroy_plan"] = asm["_fft_destroy_plan"];
var _ofdmflexframegen_reconfigure = Module["_ofdmflexframegen_reconfigure"] = asm["_ofdmflexframegen_reconfigure"];
var _demodulator_flush = Module["_demodulator_flush"] = asm["_demodulator_flush"];
var _flexframesync_execute = Module["_flexframesync_execute"] = asm["_flexframesync_execute"];
var _resamp_rrrf_create = Module["_resamp_rrrf_create"] = asm["_resamp_rrrf_create"];
var _fmt_u = Module["_fmt_u"] = asm["_fmt_u"];
var _quiet_encoder_emit = Module["_quiet_encoder_emit"] = asm["_quiet_encoder_emit"];
var ___errno_location = Module["___errno_location"] = asm["___errno_location"];
var _flexframegen_set_header_len = Module["_flexframegen_set_header_len"] = asm["_flexframegen_set_header_len"];
var ___fflush_unlocked = Module["___fflush_unlocked"] = asm["___fflush_unlocked"];
var _fec_secded2216_encode = Module["_fec_secded2216_encode"] = asm["_fec_secded2216_encode"];
var _fec_secded3932_encode = Module["_fec_secded3932_encode"] = asm["_fec_secded3932_encode"];
var _printf_core = Module["_printf_core"] = asm["_printf_core"];
var _memmove = Module["_memmove"] = asm["_memmove"];
var _ofdmframe_init_S0 = Module["_ofdmframe_init_S0"] = asm["_ofdmframe_init_S0"];
var _modem_demodulate_sqam32 = Module["_modem_demodulate_sqam32"] = asm["_modem_demodulate_sqam32"];
var _wcrtomb = Module["_wcrtomb"] = asm["_wcrtomb"];
var _gmskframesync_create = Module["_gmskframesync_create"] = asm["_gmskframesync_create"];
var _fec_rep3_encode = Module["_fec_rep3_encode"] = asm["_fec_rep3_encode"];
var _fft_execute_rader = Module["_fft_execute_rader"] = asm["_fft_execute_rader"];
var ___fwritex = Module["___fwritex"] = asm["___fwritex"];
var _quiet_encoder_set_payload = Module["_quiet_encoder_set_payload"] = asm["_quiet_encoder_set_payload"];
var _ofdmflexframegen_set_header_len = Module["_ofdmflexframegen_set_header_len"] = asm["_ofdmflexframegen_set_header_len"];
function b0(p0, p1, p2, p3, p4, p5, p6) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 p6 = p6 | 0;
 abort(0);
 return 0;
}
function b1(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(1);
 return 0;
}
function _update_viterbi27_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi27_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function _update_viterbi29_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi29_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function _update_viterbi39_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi39_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function _update_viterbi615_blk__wrapper(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 return _update_viterbi615_blk(p0 | 0, p1 | 0, p2 | 0) | 0;
}
function b2(p0) {
 p0 = p0 | 0;
 abort(2);
}
function _delete_viterbi27__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi27(p0 | 0);
}
function _delete_viterbi29__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi29(p0 | 0);
}
function _delete_viterbi39__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi39(p0 | 0);
}
function _delete_viterbi615__wrapper(p0) {
 p0 = p0 | 0;
 _delete_viterbi615(p0 | 0);
}
function b3(p0) {
 p0 = p0 | 0;
 abort(3);
 return 0;
}
function _create_viterbi27__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi27(p0 | 0) | 0;
}
function _create_viterbi29__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi29(p0 | 0) | 0;
}
function _create_viterbi39__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi39(p0 | 0) | 0;
}
function _create_viterbi615__wrapper(p0) {
 p0 = p0 | 0;
 return _create_viterbi615(p0 | 0) | 0;
}
function b4(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(4);
}
function b5(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(5);
 return 0;
}
function _chainback_viterbi27__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi27(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function _chainback_viterbi29__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi29(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function _chainback_viterbi39__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi39(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function _chainback_viterbi615__wrapper(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 return _chainback_viterbi615(p0 | 0, p1 | 0, p2 | 0, p3 | 0) | 0;
}
function b6(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(6);
 return 0;
}
function _init_viterbi27__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi27(p0 | 0, p1 | 0) | 0;
}
function _init_viterbi29__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi29(p0 | 0, p1 | 0) | 0;
}
function _init_viterbi39__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi39(p0 | 0, p1 | 0) | 0;
}
function _init_viterbi615__wrapper(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 return _init_viterbi615(p0 | 0, p1 | 0) | 0;
}
function b7(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(7);
}
var FUNCTION_TABLE_iiiiiiii = [ b0, asm["_decoder_on_decode"] ];
var FUNCTION_TABLE_iiii = [ b1, asm["___stdio_write"], asm["___stdio_seek"], asm["___stdout_write"], asm["_sn_write"], _update_viterbi27_blk__wrapper, _update_viterbi29_blk__wrapper, _update_viterbi39_blk__wrapper, _update_viterbi615_blk__wrapper, asm["___stdio_read"], b1, b1, b1, b1, b1, b1 ];
var FUNCTION_TABLE_vi = [ b2, asm["_nco_crcf_compute_sincos_nco"], asm["_nco_crcf_compute_sincos_vco"], _delete_viterbi27__wrapper, _delete_viterbi29__wrapper, _delete_viterbi39__wrapper, _delete_viterbi615__wrapper, asm["_fft_execute_mixed_radix"], asm["_fft_execute_rader"], asm["_fft_execute_rader2"], asm["_fft_execute_dft_2"], asm["_fft_execute_dft_3"], asm["_fft_execute_dft_4"], asm["_fft_execute_dft_5"], asm["_fft_execute_dft_6"], asm["_fft_execute_dft_7"], asm["_fft_execute_dft_8"], asm["_fft_execute_dft_16"], asm["_fft_execute_dft"], asm["_cleanup_387"], asm["_cleanup_382"], b2, b2, b2, b2, b2, b2, b2, b2, b2, b2, b2 ];
var FUNCTION_TABLE_ii = [ b3, asm["___stdio_close"], _create_viterbi27__wrapper, _create_viterbi29__wrapper, _create_viterbi39__wrapper, _create_viterbi615__wrapper, asm["_string_get"], b3 ];
var FUNCTION_TABLE_viii = [ b4, asm["_modem_modulate_qpsk"], asm["_modem_demodulate_qpsk"], asm["_modem_modulate_bpsk"], asm["_modem_demodulate_bpsk"], asm["_modem_modulate_dpsk"], asm["_modem_demodulate_dpsk"], asm["_modem_modulate_ask"], asm["_modem_demodulate_ask"], asm["_modem_modulate_ook"], asm["_modem_demodulate_ook"], asm["_modem_modulate_sqam32"], asm["_modem_demodulate_sqam32"], asm["_modem_modulate_sqam128"], asm["_modem_demodulate_sqam128"], asm["_modem_modulate_arb"], asm["_modem_demodulate_arb"], asm["_modem_modulate_psk"], asm["_modem_demodulate_psk"], asm["_modem_modulate_qam"], asm["_modem_demodulate_qam"], asm["_modem_modulate_apsk"], asm["_modem_demodulate_apsk"], b4, b4, b4, b4, b4, b4, b4, b4, b4 ];
var FUNCTION_TABLE_iiiii = [ b5, asm["_ofdmflexframesync_internal_callback"], _chainback_viterbi27__wrapper, _chainback_viterbi29__wrapper, _chainback_viterbi39__wrapper, _chainback_viterbi615__wrapper, b5, b5 ];
var FUNCTION_TABLE_iii = [ b6, _init_viterbi27__wrapper, _init_viterbi29__wrapper, _init_viterbi39__wrapper, _init_viterbi615__wrapper, b6, b6, b6 ];
var FUNCTION_TABLE_viiii = [ b7, asm["_fec_pass_encode"], asm["_fec_pass_decode"], asm["_fec_rep3_encode"], asm["_fec_rep3_decode"], asm["_fec_rep3_decode_soft"], asm["_fec_rep5_encode"], asm["_fec_rep5_decode"], asm["_fec_rep5_decode_soft"], asm["_fec_hamming74_encode"], asm["_fec_hamming74_decode"], asm["_fec_hamming74_decode_soft"], asm["_fec_hamming84_encode"], asm["_fec_hamming84_decode"], asm["_fec_hamming84_decode_soft"], asm["_fec_hamming128_encode"], asm["_fec_hamming128_decode"], asm["_fec_hamming128_decode_soft"], asm["_fec_golay2412_encode"], asm["_fec_golay2412_decode"], asm["_fec_secded2216_encode"], asm["_fec_secded2216_decode"], asm["_fec_secded3932_encode"], asm["_fec_secded3932_decode"], asm["_fec_secded7264_encode"], asm["_fec_secded7264_decode"], asm["_fec_conv_encode"], asm["_fec_conv_decode_hard"], asm["_fec_conv_decode_soft"], asm["_fec_conv_punctured_encode"], asm["_fec_conv_punctured_decode_hard"], asm["_fec_conv_punctured_decode_soft"], asm["_fec_rs_encode"], asm["_fec_rs_decode"], b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7, b7 ];
Module["dynCall_iiiiiiii"] = dynCall_iiiiiiii;
Module["dynCall_iiii"] = dynCall_iiii;
Module["dynCall_vi"] = dynCall_vi;
Module["dynCall_ii"] = dynCall_ii;
Module["dynCall_viii"] = dynCall_viii;
Module["dynCall_iiiii"] = dynCall_iiiii;
Module["dynCall_iii"] = dynCall_iii;
Module["dynCall_viiii"] = dynCall_viiii;
Module["FUNCTION_TABLE_iiiiiiii"] = FUNCTION_TABLE_iiiiiiii;
Module["FUNCTION_TABLE_iiii"] = FUNCTION_TABLE_iiii;
Module["FUNCTION_TABLE_vi"] = FUNCTION_TABLE_vi;
Module["FUNCTION_TABLE_ii"] = FUNCTION_TABLE_ii;
Module["FUNCTION_TABLE_viii"] = FUNCTION_TABLE_viii;
Module["FUNCTION_TABLE_iiiii"] = FUNCTION_TABLE_iiiii;
Module["FUNCTION_TABLE_iii"] = FUNCTION_TABLE_iii;
Module["FUNCTION_TABLE_viiii"] = FUNCTION_TABLE_viiii;
var NAMED_GLOBALS = {
 "str": 9878
};
for (var named in NAMED_GLOBALS) {
 Module["_" + named] = gb + NAMED_GLOBALS[named];
}
Module["NAMED_GLOBALS"] = NAMED_GLOBALS;
Runtime.stackAlloc = asm["stackAlloc"];
Runtime.stackSave = asm["stackSave"];
Runtime.stackRestore = asm["stackRestore"];
Runtime.establishStackSpace = asm["establishStackSpace"];
if (memoryInitializer) {
 if (typeof Module["locateFile"] === "function") {
  memoryInitializer = Module["locateFile"](memoryInitializer);
 } else if (Module["memoryInitializerPrefixURL"]) {
  memoryInitializer = Module["memoryInitializerPrefixURL"] + memoryInitializer;
 }
 if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
  var data = Module["readBinary"](memoryInitializer);
  HEAPU8.set(data, Runtime.GLOBAL_BASE);
 } else {
  addRunDependency("memory initializer");
  var applyMemoryInitializer = (function(data) {
   if (data.byteLength) data = new Uint8Array(data);
   HEAPU8.set(data, Runtime.GLOBAL_BASE);
   if (Module["memoryInitializerRequest"]) delete Module["memoryInitializerRequest"].response;
   removeRunDependency("memory initializer");
  });
  function doBrowserLoad() {
   Module["readAsync"](memoryInitializer, applyMemoryInitializer, (function() {
    throw "could not load memory initializer " + memoryInitializer;
   }));
  }
  if (Module["memoryInitializerRequest"]) {
   function useRequest() {
    var request = Module["memoryInitializerRequest"];
    if (request.status !== 200 && request.status !== 0) {
     console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
     doBrowserLoad();
     return;
    }
    applyMemoryInitializer(request.response);
   }
   if (Module["memoryInitializerRequest"].response) {
    setTimeout(useRequest, 0);
   } else {
    Module["memoryInitializerRequest"].addEventListener("load", useRequest);
   }
  } else {
   doBrowserLoad();
  }
 }
}
function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}
ExitStatus.prototype = new Error;
ExitStatus.prototype.constructor = ExitStatus;
var initialStackTop;
var preloadStartTime = null;
var calledMain = false;
dependenciesFulfilled = function runCaller() {
 if (!Module["calledRun"]) run();
 if (!Module["calledRun"]) dependenciesFulfilled = runCaller;
};
Module["callMain"] = Module.callMain = function callMain(args) {
 args = args || [];
 ensureInitRuntime();
 var argc = args.length + 1;
 function pad() {
  for (var i = 0; i < 4 - 1; i++) {
   argv.push(0);
  }
 }
 var argv = [ allocate(intArrayFromString(Module["thisProgram"]), "i8", ALLOC_NORMAL) ];
 pad();
 for (var i = 0; i < argc - 1; i = i + 1) {
  argv.push(allocate(intArrayFromString(args[i]), "i8", ALLOC_NORMAL));
  pad();
 }
 argv.push(0);
 argv = allocate(argv, "i32", ALLOC_NORMAL);
 try {
  var ret = Module["_main"](argc, argv, 0);
  exit(ret, true);
 } catch (e) {
  if (e instanceof ExitStatus) {
   return;
  } else if (e == "SimulateInfiniteLoop") {
   Module["noExitRuntime"] = true;
   return;
  } else {
   if (e && typeof e === "object" && e.stack) Module.printErr("exception thrown: " + [ e, e.stack ]);
   throw e;
  }
 } finally {
  calledMain = true;
 }
};
function run(args) {
 args = args || Module["arguments"];
 if (preloadStartTime === null) preloadStartTime = Date.now();
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) return;
 if (Module["calledRun"]) return;
 function doRun() {
  if (Module["calledRun"]) return;
  Module["calledRun"] = true;
  if (ABORT) return;
  ensureInitRuntime();
  preMain();
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  if (Module["_main"] && shouldRunNow) Module["callMain"](args);
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout((function() {
   setTimeout((function() {
    Module["setStatus"]("");
   }), 1);
   doRun();
  }), 1);
 } else {
  doRun();
 }
}
Module["run"] = Module.run = run;
function exit(status, implicit) {
 if (implicit && Module["noExitRuntime"]) {
  return;
 }
 if (Module["noExitRuntime"]) {} else {
  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;
  exitRuntime();
  if (Module["onExit"]) Module["onExit"](status);
 }
 if (ENVIRONMENT_IS_NODE) {
  process["exit"](status);
 } else if (ENVIRONMENT_IS_SHELL && typeof quit === "function") {
  quit(status);
 }
 throw new ExitStatus(status);
}
Module["exit"] = Module.exit = exit;
var abortDecorators = [];
function abort(what) {
 if (what !== undefined) {
  Module.print(what);
  Module.printErr(what);
  what = JSON.stringify(what);
 } else {
  what = "";
 }
 ABORT = true;
 EXITSTATUS = 1;
 var extra = "\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";
 var output = "abort(" + what + ") at " + stackTrace() + extra;
 if (abortDecorators) {
  abortDecorators.forEach((function(decorator) {
   output = decorator(output, what);
  }));
 }
 throw output;
}
Module["abort"] = Module.abort = abort;
if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}
var shouldRunNow = true;
if (Module["noInitialRun"]) {
 shouldRunNow = false;
}
run();




